diff --git a/services/camera_service/include/camera_buffer_manager/photo_buffer_consumer.h b/services/camera_service/include/camera_buffer_manager/photo_buffer_consumer.h
new file mode 100644
index 000000000..c3da7da9e
--- /dev/null
+++ b/services/camera_service/include/camera_buffer_manager/photo_buffer_consumer.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_PHOTO_BUFFER_CONSUMER_H
+#define OHOS_CAMERA_PHOTO_BUFFER_CONSUMER_H
+
+#include "ibuffer_consumer_listener.h"
+
+namespace OHOS {
+namespace CameraStandard {
+class HStreamCapture;
+
+class PhotoBufferConsumer : public IBufferConsumerListener {
+public:
+    explicit PhotoBufferConsumer(wptr<HStreamCapture> streamCapture, bool isRaw);
+    ~PhotoBufferConsumer() override;
+    void OnBufferAvailable() override;
+
+private:
+    void ExecuteOnBufferAvailable();
+
+    wptr<HStreamCapture> streamCapture_ = nullptr;
+    bool isRaw_ = false;
+};
+
+}  // namespace CameraStandard
+}  // namespace OHOS
+#endif
\ No newline at end of file
diff --git a/services/camera_service/include/camera_buffer_manager/picture_assembler.h b/services/camera_service/include/camera_buffer_manager/picture_assembler.h
new file mode 100644
index 000000000..c6ba056f1
--- /dev/null
+++ b/services/camera_service/include/camera_buffer_manager/picture_assembler.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_PICTURE_ASSEMBLER_H
+#define OHOS_CAMERA_PICTURE_ASSEMBLER_H
+
+#include <mutex>
+#include <refbase.h>
+
+namespace OHOS {
+namespace CameraStandard {
+class HStreamCapture;
+// class AuxiliaryBufferConsumer;
+class PictureAssembler : public RefBase {
+public:
+    explicit PictureAssembler(wptr<HStreamCapture> streamCapture);
+    ~PictureAssembler();
+    void RegisterAuxiliaryConsumers();
+private:
+    wptr<HStreamCapture> streamCapture_ = nullptr;
+};
+
+}  // namespace CameraStandard
+}  // namespace OHOS
+#endif
\ No newline at end of file
diff --git a/services/camera_service/include/camera_buffer_manager/thumbnail_buffer_consumer.h b/services/camera_service/include/camera_buffer_manager/thumbnail_buffer_consumer.h
new file mode 100644
index 000000000..2b415b487
--- /dev/null
+++ b/services/camera_service/include/camera_buffer_manager/thumbnail_buffer_consumer.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_THUMBNAIL_BUFFER_CONSUMER_H
+#define OHOS_CAMERA_THUMBNAIL_BUFFER_CONSUMER_H
+
+#include "ibuffer_consumer_listener.h"
+
+namespace OHOS {
+namespace CameraStandard {
+class HStreamCapture;
+namespace DeferredProcessing {
+class TaskManager;
+}
+class ThumbnailBufferConsumer : public IBufferConsumerListener {
+public:
+    explicit ThumbnailBufferConsumer(wptr<HStreamCapture> streamCapture);
+    ~ThumbnailBufferConsumer() override;
+    void OnBufferAvailable() override;
+
+private:
+    void ExecuteOnBufferAvailable();
+
+    wptr<HStreamCapture> streamCapture_ = nullptr;
+};
+
+}  // namespace CameraStandard
+}  // namespace OHOS
+#endif
\ No newline at end of file
diff --git a/services/camera_service/include/hcamera_service.h b/services/camera_service/include/hcamera_service.h
index aae748104..28357a766 100644
--- a/services/camera_service/include/hcamera_service.h
+++ b/services/camera_service/include/hcamera_service.h
@@ -115,6 +115,8 @@ public:
     int32_t IsMechSupported(bool &isMechSupported) override;
     int32_t CreatePhotoOutput(const sptr<OHOS::IBufferProducer>& producer, int32_t format, int32_t width,
         int32_t height, sptr<IStreamCapture>& photoOutput) override;
+    int32_t CreatePhotoOutput(
+        int32_t format, int32_t width, int32_t height, sptr<IStreamCapture> &photoOutput) override;
     int32_t CreateDeferredPreviewOutput(
         int32_t format, int32_t width, int32_t height, sptr<IStreamRepeat>& previewOutput) override;
     int32_t CreatePreviewOutput(const sptr<OHOS::IBufferProducer>& producer, int32_t format, int32_t width,
diff --git a/services/camera_service/include/hcapture_session.h b/services/camera_service/include/hcapture_session.h
index 3baef046b..863a29314 100644
--- a/services/camera_service/include/hcapture_session.h
+++ b/services/camera_service/include/hcapture_session.h
@@ -229,7 +229,7 @@ private:
         std::lock_guard<std::mutex> lock(cameraDeviceLock_);
         return cameraDevice_;
     }
-    string CreateDisplayName();
+    string CreateDisplayName(const std::string& suffix);
     string CreateBurstDisplayName(int32_t imageSeqId, int32_t seqId);
     int32_t ValidateSessionInputs();
     int32_t ValidateSessionOutputs();
diff --git a/services/camera_service/include/hstream_capture.h b/services/camera_service/include/hstream_capture.h
index 52bfe027e..785aed6bb 100644
--- a/services/camera_service/include/hstream_capture.h
+++ b/services/camera_service/include/hstream_capture.h
@@ -39,33 +39,38 @@ class PhotoAssetIntf;
 class PictureIntf;
 class CameraServerPhotoProxy;
 class HStreamOperator;
+class PictureAssembler;
+namespace DeferredProcessing {
+class TaskManager;
+}
 class ConcurrentMap {
 public:
     void Insert(const int32_t& key, const std::shared_ptr<PhotoAssetIntf>& value);
     std::shared_ptr<PhotoAssetIntf> Get(const int32_t& key);
     void Release();
     void Erase(const int32_t& key);
-    std::mutex& GetMutex(const int32_t& key);
-    std::condition_variable& GetCv(const int32_t& key);
     bool ReadyToUnlock(const int32_t& key, const int32_t& step, const int32_t& mode);
+    bool WaitForUnlock(const int32_t& key, const int32_t& step, const int32_t& mode,
+                    const std::chrono::seconds& timeout);
     void IncreaseCaptureStep(const int32_t& key);
 private:
     std::map<int32_t, std::shared_ptr<PhotoAssetIntf>> map_;
-    std::map<int32_t, std::mutex> mutexes_;
+    std::map<int32_t, std::shared_ptr<std::mutex>> mutexes_;
     std::map<int32_t, int32_t> step_;
-    std::map<int32_t, std::condition_variable> cv_;
+    std::map<int32_t, std::shared_ptr<std::condition_variable>> cv_;
     std::mutex map_mutex_;
 };
 constexpr const char* BURST_UUID_UNSET = "";
 class EXPORT_API HStreamCapture : public StreamCaptureStub, public HStreamCommon, public ICameraIpcChecker {
 public:
     HStreamCapture(sptr<OHOS::IBufferProducer> producer, int32_t format, int32_t width, int32_t height);
+    HStreamCapture(int32_t format, int32_t width, int32_t height);
     ~HStreamCapture();
 
     int32_t LinkInput(wptr<OHOS::HDI::Camera::V1_0::IStreamOperator> streamOperator,
         std::shared_ptr<OHOS::Camera::CameraMetadata> cameraAbility) override;
     void SetStreamInfo(StreamInfo_V1_1 &streamInfo) override;
-    int32_t SetThumbnail(bool isEnabled, const sptr<OHOS::IBufferProducer> &producer) override;
+    int32_t SetThumbnail(bool isEnabled) override;
     int32_t EnableRawDelivery(bool enabled) override;
     int32_t EnableMovingPhoto(bool enabled) override;
     int32_t SetBufferProducerInfo(const std::string& bufName, const sptr<OHOS::IBufferProducer> &producer) override;
@@ -76,6 +81,9 @@ public:
     int32_t ReleaseStream(bool isDelay) override;
     int32_t Release() override;
     int32_t SetCallback(const sptr<IStreamCaptureCallback> &callback) override;
+    int32_t SetPhotoAvailableCallback(const sptr<IStreamCapturePhotoCallback> &callback) override;
+    int32_t SetPhotoAssetAvailableCallback(const sptr<IStreamCapturePhotoAssetCallback> &callback) override;
+    int32_t SetThumbnailCallback(const sptr<IStreamCaptureThumbnailCallback> &callback) override;
     int32_t UnSetCallback() override;
     int32_t OnCaptureStarted(int32_t captureId);
     int32_t OnCaptureStarted(int32_t captureId, uint32_t exposureTime);
@@ -85,6 +93,10 @@ public:
     int32_t OnFrameShutterEnd(int32_t captureId, uint64_t timestamp);
     int32_t OnCaptureReady(int32_t captureId, uint64_t timestamp);
     int32_t OnOfflineDeliveryFinished(int32_t captureId);
+    int32_t OnPhotoAvailable(sptr<SurfaceBuffer> surfaceBuffer, const int64_t timestamp, bool isRaw);
+    int32_t OnPhotoAssetAvailable(
+        const int32_t captureId, const std::string &uri, int32_t cameraShotType, const std::string &burstKey);
+    int32_t OnThumbnailAvailable(sptr<SurfaceBuffer> surfaceBuffer, const int64_t timestamp);
     void DumpStreamInfo(CameraInfoDumper& infoDumper) override;
     void SetRotation(const std::shared_ptr<OHOS::Camera::CameraMetadata> &captureMetadataSetting_, int32_t captureId);
     void SetMode(int32_t modeName);
@@ -105,25 +117,48 @@ public:
     void CheckResetBurstKey(int32_t captureId);
     int32_t SetCameraPhotoRotation(bool isEnable) override;
     int32_t CreateMediaLibraryPhotoAssetProxy(int32_t captureId);
-    int32_t UpdateMediaLibraryPhotoAssetProxy(const sptr<CameraPhotoProxy>& photoProxy) override;
+    int32_t UpdateMediaLibraryPhotoAssetProxy(sptr<CameraServerPhotoProxy> photoProxy);
     std::shared_ptr<PhotoAssetIntf> GetPhotoAssetInstance(int32_t captureId);
     bool GetAddPhotoProxyEnabled();
-    int32_t AcquireBufferToPrepareProxy(int32_t captureId) override;
+    int32_t AcquireBufferToPrepareProxy(int32_t captureId);
     int32_t EnableOfflinePhoto(bool isEnable) override;
     bool IsHasEnableOfflinePhoto();
     void SwitchToOffline();
     bool IsHasSwitchToOffline();
     void SetStreamOperator(wptr<HStreamOperator> hStreamOperator);
-    int32_t CreateMediaLibrary(const sptr<CameraPhotoProxy>& photoProxy, std::string& uri, int32_t& cameraShotType,
-        std::string& burstKey, int64_t timestamp) override;
-    int32_t CreateMediaLibrary(const std::shared_ptr<PictureIntf>& picture, const sptr<CameraPhotoProxy> &photoProxy,
-        std::string &uri, int32_t &cameraShotType, std::string& burstKey, int64_t timestamp) override;
+    int32_t CreateMediaLibrary(sptr<CameraServerPhotoProxy>& photoProxy, std::string& uri, int32_t& cameraShotType,
+        std::string& burstKey, int64_t timestamp);
+    int32_t CreateMediaLibrary(std::shared_ptr<PictureIntf> picture, sptr<CameraServerPhotoProxy> &photoProxy,
+        std::string &uri, int32_t &cameraShotType, std::string& burstKey, int64_t timestamp);
+    int32_t RequireMemorySize(int32_t memSize);
 
-    int32_t CallbackParcel(
-        [[maybe_unused]] uint32_t code,
-        [[maybe_unused]] MessageParcel& data,
-        [[maybe_unused]] MessageParcel& reply,
-        [[maybe_unused]] MessageOption& option) override;
+    bool isYuvCapture_ = false;
+    sptr<Surface> gainmapSurface_;
+    sptr<Surface> deepSurface_;
+    sptr<Surface> exifSurface_;
+    sptr<Surface> debugSurface_;
+    sptr<Surface> rawSurface_;
+    sptr<Surface> thumbnailSurface_;
+    sptr<IBufferConsumerListener> gainmapListener_ = nullptr;
+    sptr<IBufferConsumerListener> deepListener_ = nullptr;
+    sptr<IBufferConsumerListener> exifListener_ = nullptr;
+    sptr<IBufferConsumerListener> debugListener_ = nullptr;
+    sptr<PictureAssembler> pictureAssembler_;
+    std::map<int32_t, std::shared_ptr<PictureIntf>> captureIdPictureMap_;
+    std::shared_ptr<DeferredProcessing::TaskManager> photoTask_ = nullptr;
+    std::shared_ptr<DeferredProcessing::TaskManager> photoSubTask_ = nullptr;
+
+    std::mutex g_photoImageMutex;
+    std::mutex g_assembleImageMutex;
+    std::map<int32_t, int32_t> captureIdAuxiliaryCountMap_;
+    std::map<int32_t, int32_t> captureIdCountMap_;
+    std::map<int32_t, uint32_t> captureIdHandleMap_;
+
+    std::map<int32_t, sptr<CameraServerPhotoProxy>> photoProxyMap_;
+    std::map<int32_t, sptr<SurfaceBuffer>> captureIdGainmapMap_;
+    SafeMap<int32_t, sptr<SurfaceBuffer>> captureIdDepthMap_ = {};
+    std::map<int32_t, sptr<SurfaceBuffer>> captureIdExifMap_;
+    std::map<int32_t, sptr<SurfaceBuffer>> captureIdDebugMap_;
 
 private:
     int32_t CheckBurstCapture(const std::shared_ptr<OHOS::Camera::CameraMetadata>& captureSettings,
@@ -136,10 +171,19 @@ private:
         const std::shared_ptr<OHOS::Camera::CameraMetadata>& captureSettings, int32_t captureId);
     void SetCameraPhotoProxyInfo(sptr<CameraServerPhotoProxy> cameraPhotoProxy);
     sptr<IStreamCaptureCallback> streamCaptureCallback_;
+    sptr<IStreamCapturePhotoCallback> photoAvaiableCallback_;
+    sptr<IStreamCapturePhotoAssetCallback> photoAssetAvaiableCallback_;
+    sptr<IStreamCaptureThumbnailCallback> thumbnailAvaiableCallback_;
     void FillingPictureExtendStreamInfos(StreamInfo_V1_1 &streamInfo, int32_t format);
     void FillingRawAndThumbnailStreamInfo(StreamInfo_V1_1 &streamInfo);
     void UpdateJpegBasicInfo(const std::shared_ptr<OHOS::Camera::CameraMetadata> &captureMetadataSetting,
         int32_t& rotation);
+    void RegisterAuxiliaryConsumers();
+    void CreateCaptureSurface();
+    void CreateAuxiliarySurfaces();
+    void InitCaptureThread();
+    void SetRawCallback();
+    void GetLocation(const std::shared_ptr<OHOS::Camera::CameraMetadata> &captureMetadataSetting);
     std::mutex callbackLock_;
     int32_t thumbnailSwitch_;
     int32_t rawDeliverySwitch_;
@@ -172,6 +216,15 @@ private:
     int32_t mlastCaptureId = 0;
     wptr<HStreamOperator> hStreamOperator_;
     std::map<int32_t, std::unique_ptr<std::mutex>> mutexMap;
+    std::mutex photoCallbackLock_;
+    std::mutex assetCallbackLock_;
+    std::mutex thumbnailCallbackLock_;
+    sptr<IBufferConsumerListener> photoListener_ = nullptr;
+    sptr<IBufferConsumerListener> photoAssetListener_ = nullptr;
+    sptr<IBufferConsumerListener> thumbnailListener_ = nullptr;
+    double latitude_ = 0.0;
+    double longitude_ = 0.0;
+    double altitude_ = 0.0;
 };
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/services/camera_service/include/hstream_common.h b/services/camera_service/include/hstream_common.h
index de6d67094..ca6d74656 100644
--- a/services/camera_service/include/hstream_common.h
+++ b/services/camera_service/include/hstream_common.h
@@ -44,6 +44,8 @@ class HStreamCommon : virtual public RefBase {
 public:
     explicit HStreamCommon(
         StreamType streamType, sptr<OHOS::IBufferProducer> producer, int32_t format, int32_t width, int32_t height);
+    explicit HStreamCommon(
+        StreamType streamType, int32_t format, int32_t width, int32_t height);    
     virtual ~HStreamCommon();
     virtual int32_t LinkInput(wptr<OHOS::HDI::Camera::V1_0::IStreamOperator> streamOperator,
         std::shared_ptr<OHOS::Camera::CameraMetadata> cameraAbility);
@@ -53,6 +55,7 @@ public:
     virtual void DumpStreamInfo(CameraInfoDumper& infoDumper) = 0;
 
     virtual void SetColorSpace(ColorSpace colorSpace) final;
+    virtual ColorSpace GetColorSpace() final;
     virtual int32_t StopStream() final;
 
     virtual int32_t GetPreparedCaptureId() final;
@@ -98,7 +101,8 @@ public:
     int32_t dataSpace_ = 0;
     std::map<int32_t, std::string> param;
     sptr<OHOS::IBufferProducer> producer_;
-
+    std::string surfaceId_= "";
+    sptr<Surface> surface_;
     std::shared_ptr<OHOS::Camera::CameraMetadata> cameraAbility_ = nullptr;
 
 protected:
diff --git a/services/camera_service/include/hstream_operator.h b/services/camera_service/include/hstream_operator.h
index 630d6ee87..db6af79da 100644
--- a/services/camera_service/include/hstream_operator.h
+++ b/services/camera_service/include/hstream_operator.h
@@ -166,9 +166,9 @@ public:
     int32_t GetCurrentStreamInfos(std::vector<StreamInfo_V1_1>& streamInfos);
     std::list<sptr<HStreamCommon>> GetAllStreams();
     int32_t EnableMovingPhotoMirror(bool isMirror, bool isConfig);
-    int32_t CreateMediaLibrary(const sptr<CameraPhotoProxy>& photoProxy, std::string& uri, int32_t& cameraShotType,
+    int32_t CreateMediaLibrary(const sptr<CameraServerPhotoProxy>& photoProxy, std::string& uri, int32_t& cameraShotType,
         std::string& burstKey, int64_t timestamp);
-    int32_t CreateMediaLibrary(std::shared_ptr<PictureIntf> picture, const sptr<CameraPhotoProxy> &photoProxy,
+    int32_t CreateMediaLibrary(std::shared_ptr<PictureIntf> picture, const sptr<CameraServerPhotoProxy> &photoProxy,
         std::string &uri, int32_t &cameraShotType, std::string& burstKey, int64_t timestamp);
     void SetCameraPhotoProxyInfo(sptr<CameraServerPhotoProxy> cameraPhotoProxy, int32_t &cameraShotType,
         bool &isBursting, std::string &burstKey);
@@ -307,7 +307,7 @@ private:
         return hdiStreamIdGenerator_.fetch_add(1);
     }
 
-    string CreateDisplayName();
+    string CreateDisplayName(const std::string& suffix);
     string CreateBurstDisplayName(int32_t imageSeqId, int32_t seqId);
     int32_t AddOutputStream(sptr<HStreamCommon> stream);
     
diff --git a/services/camera_service/src/avcodec/camera_server_photo_proxy.cpp b/services/camera_service/src/avcodec/camera_server_photo_proxy.cpp
index 69933d044..2e462c023 100644
--- a/services/camera_service/src/avcodec/camera_server_photo_proxy.cpp
+++ b/services/camera_service/src/avcodec/camera_server_photo_proxy.cpp
@@ -21,6 +21,8 @@
 #include "camera_log.h"
 #include "datetime_ex.h"
 #include "camera_server_photo_proxy.h"
+#include "camera_surface_buffer_util.h"
+#include "format.h"
 #include "photo_proxy.h"
 
 namespace OHOS {
@@ -42,8 +44,8 @@ CameraServerPhotoProxy::CameraServerPhotoProxy()
     isDeferredPhoto_ = 0;
     isHighQuality_ = false;
     mode_ = 0;
-    longitude_ = -1.0;
-    latitude_ = -1.0;
+    longitude_ = 0.0;
+    latitude_ = 0.0;
     captureId_ = 0;
     burstSeqId_ = -1;
     burstKey_ = "";
@@ -57,15 +59,13 @@ CameraServerPhotoProxy::~CameraServerPhotoProxy()
 {
     std::lock_guard<std::mutex> lock(mutex_);
     MEDIA_INFO_LOG("~CameraServerPhotoProxy");
-    CameraFreeBufferHandle(const_cast<BufferHandle*>(bufferHandle_));
     fileDataAddr_ = nullptr;
     fileSize_ = 0;
 }
 
 int32_t CameraServerPhotoProxy::CameraFreeBufferHandle(BufferHandle *handle)
 {
-    CHECK_ERROR_RETURN_RET_LOG(handle == nullptr, 0,
-        "CameraServerPhotoProxy::CameraFreeBufferHandle with nullptr handle");
+    CHECK_ERROR_RETURN_RET_LOG(handle == nullptr, 0, "CameraFreeBufferHandle with nullptr handle");
     if (handle->fd >= 0) {
         close(handle->fd);
         handle->fd = -1;
@@ -81,7 +81,7 @@ int32_t CameraServerPhotoProxy::CameraFreeBufferHandle(BufferHandle *handle)
     return 0;
 }
 
-std::string CreateDisplayName()
+std::string CreateDisplayName(const std::string& suffix)
 {
     struct tm currentTime;
     std::string formattedTime = "";
@@ -109,6 +109,34 @@ std::string CreateDisplayName()
     return formattedTime;
 }
 
+std::string CreateVideoDisplayName()
+{
+    struct tm currentTime;
+    std::string formattedTime = "";
+    if (GetSystemCurrentTime(&currentTime)) {
+        std::stringstream ss;
+        ss << videoPrefix << std::setw(yearWidth) << std::setfill(placeholder) << currentTime.tm_year + startYear
+           << std::setw(otherWidth) << std::setfill(placeholder) << (currentTime.tm_mon + 1)
+           << std::setw(otherWidth) << std::setfill(placeholder) << currentTime.tm_mday
+           << connector << std::setw(otherWidth) << std::setfill(placeholder) << currentTime.tm_hour
+           << std::setw(otherWidth) << std::setfill(placeholder) << currentTime.tm_min
+           << std::setw(otherWidth) << std::setfill(placeholder) << currentTime.tm_sec;
+        formattedTime = ss.str();
+    } else {
+        MEDIA_ERR_LOG("Failed to get current time.");
+    }
+    if (g_lastDisplayName == formattedTime) {
+        g_saveIndex++;
+        formattedTime = formattedTime + connector + std::to_string(g_saveIndex);
+        MEDIA_INFO_LOG("CreateVideoDisplayName is %{private}s", formattedTime.c_str());
+        return formattedTime;
+    }
+    g_lastDisplayName = formattedTime;
+    g_saveIndex = 0;
+    MEDIA_INFO_LOG("CreateVideoDisplayName is %{private}s", formattedTime.c_str());
+    return formattedTime;
+}
+
 void CameraServerPhotoProxy::SetDisplayName(std::string displayName)
 {
     displayName_ = displayName;
@@ -135,6 +163,48 @@ void CameraServerPhotoProxy::ReadFromParcel(MessageParcel &parcel)
     MEDIA_INFO_LOG("CameraServerPhotoProxy::ReadFromParcel");
 }
 
+void CameraServerPhotoProxy::GetServerPhotoProxyInfo(sptr<SurfaceBuffer>& surfaceBuffer)
+{
+    MEDIA_INFO_LOG("GetServerPhotoProxyInfo E");
+    CHECK_ERROR_RETURN_LOG(surfaceBuffer == nullptr, "surfaceBuffer is null");
+    std::lock_guard<std::mutex> lock(mutex_);
+    captureId_ = CameraSurfaceBufferUtil::GetCaptureId(surfaceBuffer);
+    BufferHandle *bufferHandle = surfaceBuffer->GetBufferHandle();
+    bufferHandle_ = bufferHandle;
+    CHECK_ERROR_PRINT_LOG(bufferHandle == nullptr, "invalid bufferHandle");
+    format_ = bufferHandle->format;
+    std::string imageIdStr = std::to_string(CameraSurfaceBufferUtil::GetImageId(surfaceBuffer));
+    photoId_ = imageIdStr;
+    photoWidth_ = CameraSurfaceBufferUtil::GetDataWidth(surfaceBuffer);
+    photoHeight_ = CameraSurfaceBufferUtil::GetDataHeight(surfaceBuffer);
+    deferredProcType_ = CameraSurfaceBufferUtil::GetDeferredProcessingType(surfaceBuffer);
+    isDeferredPhoto_ = 1;
+    bool isHighQuality = (CameraSurfaceBufferUtil::GetIsDegradedImage(surfaceBuffer) == 0);
+    isHighQuality_ = isHighQuality;
+    if (isHighQuality) { // get cloudImageEnhanceFlag for 100 picture
+        cloudImageEnhanceFlag_ = CameraSurfaceBufferUtil::GetCloudImageEnhanceFlag(surfaceBuffer);
+    }
+    uint64_t size = static_cast<uint64_t>(surfaceBuffer->GetSize());
+    int32_t extraDataSize = CameraSurfaceBufferUtil::GetDataSize(surfaceBuffer);
+    if (extraDataSize <= 0) {
+        MEDIA_INFO_LOG("ExtraGet dataSize Ok, but size <= 0");
+    } else if (static_cast<uint64_t>(extraDataSize) > size) {
+        MEDIA_INFO_LOG("ExtraGet dataSize Ok,but dataSize %{public}d is bigger than bufferSize %{public}" PRIu64,
+            extraDataSize, size);
+    } else {
+        MEDIA_INFO_LOG("ExtraGet dataSize %{public}d", extraDataSize);
+        size = static_cast<uint64_t>(extraDataSize);
+    }
+    fileSize_ = size;
+    burstSeqId_ = CameraSurfaceBufferUtil::GetBurstSequenceId(surfaceBuffer);
+    imageFormat_ = CameraSurfaceBufferUtil::GetDeferredImageFormat(surfaceBuffer);
+    latitude_ = 0.0;
+    longitude_ = 0.0;
+    MEDIA_INFO_LOG("GetServerPhotoProxyInfo X,cId:%{public}d pId:%{public}s w:%{public}d h:%{public}d f:%{public}d "
+                   "s:%{public}zu dT:%{public}d iH:%{public}d",
+        captureId_, photoId_.c_str(), photoWidth_, photoHeight_, format_, fileSize_, deferredProcType_, isHighQuality_);
+}
+
 int32_t CameraServerPhotoProxy::GetCaptureId()
 {
     MEDIA_INFO_LOG("CameraServerPhotoProxy::GetCaptureId captureId:%{public}d", captureId_);
@@ -205,8 +275,7 @@ int32_t CameraServerPhotoProxy::GetHeight()
 PhotoFormat CameraServerPhotoProxy::GetFormat()
 {
     auto iter = formatMap.find(imageFormat_);
-    CHECK_ERROR_RETURN_RET(iter != formatMap.end(), iter->second);
-    return Media::PhotoFormat::RGBA;
+    return iter != formatMap.end() ? iter->second : Media::PhotoFormat::RGBA;
 }
 
 PhotoQuality CameraServerPhotoProxy::GetPhotoQuality()
@@ -217,10 +286,11 @@ PhotoQuality CameraServerPhotoProxy::GetPhotoQuality()
 void CameraServerPhotoProxy::Release()
 {
     MEDIA_INFO_LOG("CameraServerPhotoProxy release enter");
-    if (isMmaped_ && bufferHandle_ != nullptr) {
+    bool isMmappedAndBufferValid = isMmaped_ && bufferHandle_ != nullptr;
+    if (isMmappedAndBufferValid) {
         munmap(fileDataAddr_, bufferHandle_->size);
     } else {
-        MEDIA_ERR_LOG("~CameraServerPhotoProxy munmap failed");
+        MEDIA_ERR_LOG("CameraServerPhotoProxy munmap failed");
     }
 }
 
@@ -232,6 +302,10 @@ std::string CameraServerPhotoProxy::GetTitle()
 std::string CameraServerPhotoProxy::GetExtension()
 {
     std::string suffix = suffixJpeg;
+    if (isVideo_) {
+        suffix = suffixMp4;
+        return suffix;
+    }
     switch (GetFormat()) {
         case PhotoFormat::HEIF : {
             suffix = suffixHeif;
@@ -249,6 +323,15 @@ std::string CameraServerPhotoProxy::GetExtension()
     return suffix;
 }
 
+void CameraServerPhotoProxy::SetLatitude(double latitude)
+{
+    latitude_ = latitude;
+}
+void CameraServerPhotoProxy::SetLongitude(double longitude)
+{
+    longitude_ = longitude;
+}
+
 double CameraServerPhotoProxy::GetLatitude()
 {
     return latitude_;
@@ -260,8 +343,7 @@ double CameraServerPhotoProxy::GetLongitude()
 int32_t CameraServerPhotoProxy::GetShootingMode()
 {
     auto iter = modeMap.find(mode_);
-    CHECK_ERROR_RETURN_RET(iter != modeMap.end(), iter->second);
-    return 0;
+    return iter != modeMap.end() ? iter->second : 0;
 }
 void CameraServerPhotoProxy::SetShootingMode(int32_t mode)
 {
@@ -294,6 +376,11 @@ uint32_t CameraServerPhotoProxy::GetCloudImageEnhanceFlag()
     return cloudImageEnhanceFlag_;
 }
 
+void CameraServerPhotoProxy::SetIsVideo(bool isVideo)
+{
+    isVideo_ = isVideo;
+}
+
 void CameraServerPhotoProxy::SetStageVideoTaskStatus(uint8_t status)
 {
     stageVideoTaskStatus_ = static_cast<int32_t>(status);
@@ -302,8 +389,18 @@ void CameraServerPhotoProxy::SetStageVideoTaskStatus(uint8_t status)
 
 int32_t CameraServerPhotoProxy::GetStageVideoTaskStatus()
 {
-    MEDIA_DEBUG_LOG("%{public}s get value: %{public}u", __FUNCTION__, stageVideoTaskStatus_);
+    MEDIA_DEBUG_LOG("%{public}s get value: %{public}d", __FUNCTION__, stageVideoTaskStatus_);
     return stageVideoTaskStatus_;
 }
+
+void CameraServerPhotoProxy::SetFormat(int32_t format)
+{
+    format_ = format;
+}
+
+void CameraServerPhotoProxy::SetImageFormat(int32_t imageFormat)
+{
+    imageFormat_ = imageFormat;
+}
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/services/camera_service/src/camera_buffer_manager/photo_asset_auxiliary_consumer.cpp b/services/camera_service/src/camera_buffer_manager/photo_asset_auxiliary_consumer.cpp
new file mode 100644
index 000000000..d125dffa9
--- /dev/null
+++ b/services/camera_service/src/camera_buffer_manager/photo_asset_auxiliary_consumer.cpp
@@ -0,0 +1,139 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+// LCOV_EXCL_START
+#include "photo_asset_auxiliary_consumer.h"
+
+#include "camera_log.h"
+#include "hstream_capture.h"
+#include "task_manager.h"
+#include "camera_surface_buffer_util.h"
+#include "dp_utils.h"
+#include "buffer_extra_data_impl.h"
+
+namespace OHOS {
+namespace CameraStandard {
+
+AuxiliaryBufferConsumer::AuxiliaryBufferConsumer(const std::string surfaceName, wptr<HStreamCapture> streamCapture)
+    : surfaceName_(surfaceName), streamCapture_(streamCapture)
+{
+    MEDIA_INFO_LOG("AuxiliaryBufferConsumer new E, surfaceName:%{public}s", surfaceName_.c_str());
+}
+
+AuxiliaryBufferConsumer::~AuxiliaryBufferConsumer()
+{
+    MEDIA_INFO_LOG("AuxiliaryBufferConsumer ~ E, surfaceName:%{public}s", surfaceName_.c_str());
+}
+
+void AuxiliaryBufferConsumer::OnBufferAvailable()
+{
+    MEDIA_INFO_LOG("OnBufferAvailable E, surfaceName:%{public}s", surfaceName_.c_str());
+    sptr<HStreamCapture> streamCapture = streamCapture_.promote();
+    CHECK_ERROR_RETURN_LOG(streamCapture == nullptr, "streamCapture is null");
+    CHECK_ERROR_RETURN_LOG(streamCapture->photoSubTask_ == nullptr, "photoSubTask is null");
+    wptr<AuxiliaryBufferConsumer> thisPtr(this);
+    streamCapture->photoSubTask_->SubmitTask([thisPtr]() {
+        auto listener = thisPtr.promote();
+        CHECK_EXECUTE(listener, listener->ExecuteOnBufferAvailable());
+    });
+
+    MEDIA_INFO_LOG("OnBufferAvailable X");
+}
+
+void AuxiliaryBufferConsumer::ExecuteOnBufferAvailable()
+{
+    MEDIA_INFO_LOG("ExecuteOnBufferAvailable E, surfaceName:%{public}s", surfaceName_.c_str());
+    CAMERA_SYNC_TRACE;
+    sptr<HStreamCapture> streamCapture = streamCapture_.promote();
+    CHECK_ERROR_RETURN_LOG(streamCapture == nullptr, "streamCapture is null");
+    sptr<Surface> surface;
+    if (surfaceName_ == S_GAINMAP) {
+        surface = streamCapture->gainmapSurface_;
+    } else if (surfaceName_ == S_DEEP) {
+        surface = streamCapture->deepSurface_;
+    } else if (surfaceName_ == S_EXIF) {
+        surface = streamCapture->exifSurface_;
+    } else if (surfaceName_ == S_DEBUG) {
+        surface = streamCapture->debugSurface_;
+    }
+    // acquire copy release buffer
+    sptr<SurfaceBuffer> surfaceBuffer = nullptr;
+    int32_t fence = -1;
+    int64_t timestamp;
+    OHOS::Rect damage;
+    SurfaceError surfaceRet = surface->AcquireBuffer(surfaceBuffer, fence, timestamp, damage);
+    MEDIA_INFO_LOG("AuxiliaryBufferConsumer surfaceName = %{public}s AcquireBuffer end", surfaceName_.c_str());
+    if (surfaceRet != SURFACE_ERROR_OK) {
+        MEDIA_ERR_LOG("AuxiliaryBufferConsumer Failed to acquire surface buffer");
+    }
+    sptr<SurfaceBuffer> newSurfaceBuffer = CameraSurfaceBufferUtil::DeepCopyBuffer(surfaceBuffer);
+    surface->ReleaseBuffer(surfaceBuffer, -1);
+    CHECK_ERROR_RETURN_LOG(newSurfaceBuffer == nullptr, "newSurfaceBuffer is null");
+    if (surfaceName_ == S_EXIF) {
+        int32_t dataSize = CameraSurfaceBufferUtil::GetDataSize(newSurfaceBuffer);
+        sptr<BufferExtraData> extraData = newSurfaceBuffer->GetExtraData();
+        extraData->ExtraSet("exifDataSize", dataSize);
+        newSurfaceBuffer->SetExtraData(extraData);
+        MEDIA_INFO_LOG("AuxiliaryBufferConsumer exifDataSize = %{public}d", dataSize);
+    }
+
+    int32_t captureId = CameraSurfaceBufferUtil::GetMaskCaptureId(newSurfaceBuffer);
+    MEDIA_INFO_LOG("AuxiliaryBufferConsumer captureId:%{public}d", captureId);
+    {
+        std::lock_guard<std::mutex> lock(streamCapture->g_photoImageMutex);
+        if (streamCapture->captureIdAuxiliaryCountMap_.count(captureId)) {
+            int32_t auxiliaryCount = streamCapture->captureIdAuxiliaryCountMap_[captureId];
+            int32_t expectCount = streamCapture->captureIdCountMap_[captureId];
+            // AuxiliaryBuffer unexpected
+            if (auxiliaryCount == -1 || (expectCount != 0 && auxiliaryCount == expectCount)) {
+                MEDIA_INFO_LOG("AuxiliaryBufferConsumer ReleaseBuffer, captureId=%{public}d", captureId);
+                return;
+            }
+        }
+        // cache buffer and check assemble
+        streamCapture->captureIdAuxiliaryCountMap_[captureId]++;
+        if (surfaceName_ == S_GAINMAP) {
+            streamCapture->captureIdGainmapMap_[captureId] = newSurfaceBuffer;
+            MEDIA_INFO_LOG("AuxiliaryBufferConsumer gainmapSurfaceBuffer_, captureId=%{public}d", captureId);
+        } else if (surfaceName_ == S_DEEP) {
+            streamCapture->captureIdDepthMap_.EnsureInsert(captureId, newSurfaceBuffer);
+            MEDIA_INFO_LOG("AuxiliaryBufferConsumer deepSurfaceBuffer_, captureId=%{public}d", captureId);
+        } else if (surfaceName_ == S_EXIF) {
+            streamCapture->captureIdExifMap_[captureId] = newSurfaceBuffer;
+            MEDIA_INFO_LOG("AuxiliaryBufferConsumer exifSurfaceBuffer_, captureId=%{public}d", captureId);
+        } else if (surfaceName_ == S_DEBUG) {
+            streamCapture->captureIdDebugMap_[captureId] = newSurfaceBuffer;
+            MEDIA_INFO_LOG("AuxiliaryBufferConsumer debugSurfaceBuffer_, captureId=%{public}d", captureId);
+        }
+        MEDIA_INFO_LOG("AuxiliaryBufferConsumer auxiliaryPhotoCount = %{public}d, captureCount = %{public}d, "
+                       "surfaceName=%{public}s, captureId=%{public}d",
+            streamCapture->captureIdAuxiliaryCountMap_[captureId], streamCapture->captureIdCountMap_[captureId],
+            surfaceName_.c_str(), captureId);
+        if (streamCapture->captureIdCountMap_[captureId] != 0 &&
+            streamCapture->captureIdAuxiliaryCountMap_[captureId] == streamCapture->captureIdCountMap_[captureId]) {
+            uint32_t pictureHandle = streamCapture->captureIdHandleMap_[captureId];
+            MEDIA_INFO_LOG("AuxiliaryBufferConsumer StopMonitor, surfaceName=%{public}s, pictureHandle = %{public}d, "
+                           "captureId = %{public}d",
+                surfaceName_.c_str(), pictureHandle, captureId);
+            DeferredProcessing::GetGlobalWatchdog().DoTimeout(pictureHandle);
+            DeferredProcessing::GetGlobalWatchdog().StopMonitor(pictureHandle);
+            streamCapture->captureIdAuxiliaryCountMap_[captureId] = -1;
+            MEDIA_INFO_LOG("AuxiliaryBufferConsumer captureIdAuxiliaryCountMap_ = -1");
+        }
+    }
+    MEDIA_INFO_LOG("ExecuteOnBufferAvailable X");
+}
+}  // namespace CameraStandard
+}  // namespace OHOS
+// LCOV_EXCL_STOP
\ No newline at end of file
diff --git a/services/camera_service/src/camera_buffer_manager/photo_asset_buffer_consumer.cpp b/services/camera_service/src/camera_buffer_manager/photo_asset_buffer_consumer.cpp
new file mode 100644
index 000000000..183f249f0
--- /dev/null
+++ b/services/camera_service/src/camera_buffer_manager/photo_asset_buffer_consumer.cpp
@@ -0,0 +1,248 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+// LCOV_EXCL_START
+#include "photo_asset_buffer_consumer.h"
+
+#include "camera_log.h"
+#include "video_key_info.h"
+#include "camera_surface_buffer_util.h"
+#include "hstream_capture.h"
+#include "task_manager.h"
+#include "picture_assembler.h"
+#include "dp_utils.h"
+#include "camera_server_photo_proxy.h"
+#include "picture_proxy.h"
+#include "camera_report_dfx_uitls.h"
+
+namespace OHOS {
+namespace CameraStandard {
+
+PhotoAssetBufferConsumer::PhotoAssetBufferConsumer(wptr<HStreamCapture> streamCapture) : streamCapture_(streamCapture)
+{
+    MEDIA_INFO_LOG("PhotoAssetBufferConsumer new E");
+}
+
+PhotoAssetBufferConsumer::~PhotoAssetBufferConsumer()
+{
+    MEDIA_INFO_LOG("PhotoAssetBufferConsumer ~ E");
+}
+
+void PhotoAssetBufferConsumer::OnBufferAvailable()
+{
+    MEDIA_INFO_LOG("OnBufferAvailable E");
+    CAMERA_SYNC_TRACE;
+    sptr<HStreamCapture> streamCapture = streamCapture_.promote();
+    CHECK_ERROR_RETURN_LOG(streamCapture == nullptr, "streamCapture is null");
+    CHECK_ERROR_RETURN_LOG(streamCapture->photoTask_ == nullptr, "photoTask is null");
+    wptr<PhotoAssetBufferConsumer> thisPtr(this);
+    streamCapture->photoTask_->SubmitTask([thisPtr]() {
+        auto listener = thisPtr.promote();
+        CHECK_EXECUTE(listener, listener->ExecuteOnBufferAvailable());
+    });
+
+    MEDIA_INFO_LOG("OnBufferAvailable X");
+}
+
+void PhotoAssetBufferConsumer::ExecuteOnBufferAvailable()
+{
+    MEDIA_INFO_LOG("ExecuteOnBufferAvailable E");
+    CAMERA_SYNC_TRACE;
+    sptr<HStreamCapture> streamCapture = streamCapture_.promote();
+    CHECK_ERROR_RETURN_LOG(streamCapture == nullptr, "streamCapture is null");
+    CHECK_ERROR_RETURN_LOG(streamCapture->surface_ == nullptr, "surface is null");
+    sptr<SurfaceBuffer> surfaceBuffer = nullptr;
+    int32_t fence = -1;
+    int64_t timestamp;
+    OHOS::Rect damage;
+    SurfaceError surfaceRet = streamCapture->surface_->AcquireBuffer(surfaceBuffer, fence, timestamp, damage);
+    CHECK_ERROR_RETURN_LOG(surfaceRet != SURFACE_ERROR_OK, "Failed to acquire surface buffer");
+    CameraSurfaceBufferUtil::DumpSurfaceBuffer(surfaceBuffer);
+    // deep copy surfaceBuffer
+    sptr<SurfaceBuffer> newSurfaceBuffer = CameraSurfaceBufferUtil::DeepCopyBuffer(surfaceBuffer);
+    // release surfaceBuffer to bufferQueue
+    streamCapture->surface_->ReleaseBuffer(surfaceBuffer, -1);
+    CHECK_ERROR_RETURN_LOG(newSurfaceBuffer == nullptr, "DeepCopyBuffer faild");
+    int32_t captureId = CameraSurfaceBufferUtil::GetMaskCaptureId(newSurfaceBuffer);
+    CameraReportDfxUtils::GetInstance()->SetFirstBufferEndInfo(captureId);
+    CameraReportDfxUtils::GetInstance()->SetPrepareProxyStartInfo(captureId);
+    int32_t auxiliaryCount = CameraSurfaceBufferUtil::GetImageCount(newSurfaceBuffer);
+    MEDIA_INFO_LOG("OnBufferAvailable captureId:%{public}d auxiliaryCount:%{public}d", captureId, auxiliaryCount);
+    // create photoProxy
+    sptr<CameraServerPhotoProxy> cameraPhotoProxy = new CameraServerPhotoProxy();
+    cameraPhotoProxy->GetServerPhotoProxyInfo(newSurfaceBuffer);
+
+    std::string uri;
+    int32_t cameraShotType = 0;
+    std::string burstKey;
+    bool isYuv = streamCapture->isYuvCapture_;
+    MEDIA_INFO_LOG("CreateMediaLibrary captureId:%{public}d isYuv::%{public}d", captureId, isYuv);
+    if (isYuv) {
+        StartWaitAuxiliaryTask(captureId, auxiliaryCount, timestamp, newSurfaceBuffer);
+    } else {
+        streamCapture->CreateMediaLibrary(cameraPhotoProxy, uri, cameraShotType, burstKey, timestamp);
+        MEDIA_INFO_LOG("CreateMediaLibrary uri:%{public}s", uri.c_str());
+        streamCapture->OnPhotoAssetAvailable(captureId, uri, cameraShotType, burstKey);
+    }
+
+    MEDIA_INFO_LOG("ExecuteOnBufferAvailable X");
+}
+
+void PhotoAssetBufferConsumer::StartWaitAuxiliaryTask(
+    const int32_t captureId, const int32_t auxiliaryCount, int64_t timestamp, sptr<SurfaceBuffer> &newSurfaceBuffer)
+{
+    CAMERA_SYNC_TRACE;
+    MEDIA_INFO_LOG("StartWaitAuxiliaryTask E, captureId:%{public}d", captureId);
+    sptr<HStreamCapture> streamCapture = streamCapture_.promote();
+    CHECK_ERROR_RETURN_LOG(streamCapture == nullptr, "streamCapture is null");
+    {
+        std::lock_guard<std::mutex> lock(streamCapture->g_photoImageMutex);
+        // create and save photoProxy
+        streamCapture->captureIdCountMap_[captureId] = auxiliaryCount;
+        streamCapture->captureIdAuxiliaryCountMap_[captureId]++;
+        MEDIA_INFO_LOG("PhotoAssetBufferConsumer StartWaitAuxiliaryTask 4 captureId = %{public}d", captureId);
+        sptr<CameraServerPhotoProxy> photoProxy = new CameraServerPhotoProxy();
+        photoProxy->GetServerPhotoProxyInfo(newSurfaceBuffer);
+        photoProxy->SetDisplayName(CreateDisplayName(suffixJpeg));
+        streamCapture->photoProxyMap_[captureId] = photoProxy;
+        MEDIA_INFO_LOG("PhotoAssetBufferConsumer StartWaitAuxiliaryTask 5");
+
+        // create and save pictureProxy
+        std::shared_ptr<PictureIntf> pictureProxy = PictureProxy::CreatePictureProxy();
+        CHECK_ERROR_RETURN_LOG(pictureProxy == nullptr, "pictureProxy is nullptr");
+        pictureProxy->Create(newSurfaceBuffer);
+        MEDIA_INFO_LOG(
+            "PhotoAssetBufferConsumer StartWaitAuxiliaryTask MainSurface w=%{public}d, h=%{public}d, f=%{public}d",
+            newSurfaceBuffer->GetWidth(), newSurfaceBuffer->GetHeight(), newSurfaceBuffer->GetFormat());
+        streamCapture->captureIdPictureMap_[captureId] = pictureProxy;
+
+        // all AuxiliaryBuffer ready, do assamble
+        if (streamCapture->captureIdCountMap_[captureId] != 0 &&
+            streamCapture->captureIdAuxiliaryCountMap_[captureId] == streamCapture->captureIdCountMap_[captureId]) {
+            MEDIA_INFO_LOG(
+                "PhotoAssetBufferConsumer StartWaitAuxiliaryTask auxiliaryCount is complete, StopMonitor DoTimeout "
+                "captureId = %{public}d",  captureId);
+            AssembleDeferredPicture(timestamp, captureId);
+        } else {
+            // start timeer to do assamble
+            uint32_t pictureHandle;
+            constexpr uint32_t delayMilli = 1 * 1000;
+            MEDIA_INFO_LOG(
+                "PhotoAssetBufferConsumer StartWaitAuxiliaryTask GetGlobalWatchdog StartMonitor, captureId=%{public}d",
+                captureId);
+            DeferredProcessing::GetGlobalWatchdog().StartMonitor(
+                pictureHandle, delayMilli, [this, captureId, timestamp](uint32_t handle) {
+                    MEDIA_INFO_LOG(
+                        "PhotoAssetBufferConsumer PhotoAssetBufferConsumer-Watchdog executed, handle: %{public}d, "
+                        "captureId=%{public}d", static_cast<int>(handle), captureId);
+                    AssembleDeferredPicture(timestamp, captureId);
+                    auto streamCapture = streamCapture_.promote();
+                    if (streamCapture && streamCapture->captureIdAuxiliaryCountMap_.count(captureId)) {
+                        streamCapture->captureIdAuxiliaryCountMap_[captureId] = -1;
+                        MEDIA_INFO_LOG(
+                            "PhotoAssetBufferConsumer StartWaitAuxiliaryTask captureIdAuxiliaryCountMap_ = -1, "
+                            "captureId=%{public}d", captureId);
+                    }
+                });
+            streamCapture->captureIdHandleMap_[captureId] = pictureHandle;
+            MEDIA_INFO_LOG(
+                "PhotoAssetBufferConsumer StartWaitAuxiliaryTask, pictureHandle: %{public}d, captureId=%{public}d "
+                "captureIdCountMap = %{public}d, captureIdAuxiliaryCountMap = %{public}d",
+                pictureHandle, captureId, streamCapture->captureIdCountMap_[captureId],
+                streamCapture->captureIdAuxiliaryCountMap_[captureId]);
+        }
+    }
+    MEDIA_INFO_LOG("StartWaitAuxiliaryTask X");
+}
+
+inline void LoggingSurfaceBufferInfo(sptr<SurfaceBuffer> buffer, std::string bufName)
+{
+    if (buffer) {
+        MEDIA_INFO_LOG("LoggingSurfaceBufferInfo %{public}s w=%{public}d, h=%{public}d, f=%{public}d",
+            bufName.c_str(), buffer->GetWidth(), buffer->GetHeight(), buffer->GetFormat());
+    }
+};
+
+void PhotoAssetBufferConsumer::CleanAfterTransPicture(int32_t captureId)
+{
+    MEDIA_INFO_LOG("CleanAfterTransPicture E, captureId:%{public}d", captureId);
+    sptr<HStreamCapture> streamCapture = streamCapture_.promote();
+    CHECK_ERROR_RETURN_LOG(streamCapture == nullptr, "streamCapture is null");
+
+    streamCapture->photoProxyMap_.erase(captureId);
+    streamCapture->captureIdPictureMap_.erase(captureId);
+    streamCapture->captureIdGainmapMap_.erase(captureId);
+    streamCapture->captureIdDepthMap_.Erase(captureId);
+    streamCapture->captureIdExifMap_.erase(captureId);
+    streamCapture->captureIdDebugMap_.erase(captureId);
+    streamCapture->captureIdAuxiliaryCountMap_.erase(captureId);
+    streamCapture->captureIdCountMap_.erase(captureId);
+    streamCapture->captureIdHandleMap_.erase(captureId);
+}
+
+void PhotoAssetBufferConsumer::AssembleDeferredPicture(int64_t timestamp, int32_t captureId)
+{
+    CAMERA_SYNC_TRACE;
+    MEDIA_INFO_LOG("AssembleDeferredPicture E, captureId:%{public}d", captureId);
+    sptr<HStreamCapture> streamCapture = streamCapture_.promote();
+    CHECK_ERROR_RETURN_LOG(streamCapture == nullptr, "streamCapture is null");
+    std::lock_guard<std::mutex> lock(streamCapture->g_assembleImageMutex);
+    std::shared_ptr<PictureIntf> picture = streamCapture->captureIdPictureMap_[captureId];
+    if (streamCapture->captureIdExifMap_[captureId] && picture) {
+        MEDIA_ERR_LOG("AssembleDeferredPicture exifSurfaceBuffer");
+        auto buffer = streamCapture->captureIdExifMap_[captureId];
+        LoggingSurfaceBufferInfo(buffer, "exifSurfaceBuffer");
+        picture->SetExifMetadata(buffer);
+        streamCapture->captureIdExifMap_[captureId] = nullptr;
+    }
+    if (streamCapture->captureIdGainmapMap_[captureId] && picture) {
+        MEDIA_ERR_LOG("AssembleDeferredPicture exifSurfaceBuffer");
+        LoggingSurfaceBufferInfo(streamCapture->captureIdGainmapMap_[captureId], "gainmapSurfaceBuffer");
+        picture->SetAuxiliaryPicture(
+            streamCapture->captureIdGainmapMap_[captureId], CameraAuxiliaryPictureType::GAINMAP);
+        streamCapture->captureIdGainmapMap_[captureId] = nullptr;
+    }
+    sptr<SurfaceBuffer> depthBuffer = nullptr;
+    streamCapture->captureIdDepthMap_.FindOldAndSetNew(captureId, depthBuffer, nullptr);
+    if (depthBuffer && picture) {
+        MEDIA_ERR_LOG("AssembleDeferredPicture deepSurfaceBuffer");
+        LoggingSurfaceBufferInfo(depthBuffer, "deepSurfaceBuffer");
+        picture->SetAuxiliaryPicture(depthBuffer, CameraAuxiliaryPictureType::DEPTH_MAP);
+    }
+    if (streamCapture->captureIdDebugMap_[captureId] && picture) {
+        MEDIA_ERR_LOG("AssembleDeferredPicture debugSurfaceBuffer");
+        auto buffer = streamCapture->captureIdDebugMap_[captureId];
+        LoggingSurfaceBufferInfo(buffer, "debugSurfaceBuffer");
+        picture->SetMaintenanceData(buffer);
+        streamCapture->captureIdDebugMap_[captureId] = nullptr;
+    }
+    if (!picture) {
+        MEDIA_ERR_LOG("CreateMediaLibrary picture is nullptr");
+        return;
+    }
+    std::string uri;
+    int32_t cameraShotType;
+    std::string burstKey = "";
+    MEDIA_DEBUG_LOG("AssembleDeferredPicture CreateMediaLibrary E");
+    streamCapture->CreateMediaLibrary(
+        picture, streamCapture->photoProxyMap_[captureId], uri, cameraShotType, burstKey, timestamp);
+    MEDIA_DEBUG_LOG("AssembleDeferredPicture CreateMediaLibrary X");
+    MEDIA_INFO_LOG("CreateMediaLibrary result %{public}s, type %{public}d", uri.c_str(), cameraShotType);
+    streamCapture->OnPhotoAssetAvailable(captureId, uri, cameraShotType, burstKey);
+    CleanAfterTransPicture(captureId);
+    MEDIA_INFO_LOG("AssembleDeferredPicture X, captureId:%{public}d", captureId);
+}
+}  // namespace CameraStandard
+}  // namespace OHOS
+// LCOV_EXCL_STOP
\ No newline at end of file
diff --git a/services/camera_service/src/camera_buffer_manager/photo_buffer_consumer.cpp b/services/camera_service/src/camera_buffer_manager/photo_buffer_consumer.cpp
new file mode 100644
index 000000000..c8b719dc1
--- /dev/null
+++ b/services/camera_service/src/camera_buffer_manager/photo_buffer_consumer.cpp
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "photo_buffer_consumer.h"
+
+#include "camera_log.h"
+#include "task_manager.h"
+#include "camera_surface_buffer_util.h"
+#include "camera_report_dfx_uitls.h"
+#include "hstream_capture.h"
+
+namespace OHOS {
+namespace CameraStandard {
+
+PhotoBufferConsumer::PhotoBufferConsumer(wptr<HStreamCapture> streamCapture, bool isRaw)
+    : streamCapture_(streamCapture), isRaw_(isRaw)
+{
+    MEDIA_INFO_LOG("PhotoBufferConsumer new E, isRaw:%{public}d", isRaw);
+}
+
+PhotoBufferConsumer::~PhotoBufferConsumer()
+{
+    MEDIA_INFO_LOG("PhotoBufferConsumer ~ E");
+}
+
+void PhotoBufferConsumer::OnBufferAvailable()
+{
+    MEDIA_INFO_LOG("PhotoBufferConsumer OnBufferAvailable E");
+    sptr<HStreamCapture> streamCapture = streamCapture_.promote();
+    CHECK_ERROR_RETURN_LOG(streamCapture == nullptr, "streamCapture is null");
+    CHECK_ERROR_RETURN_LOG(streamCapture->photoTask_ == nullptr, "photoTask is null");
+    wptr<PhotoBufferConsumer> thisPtr(this);
+    streamCapture->photoTask_->SubmitTask([thisPtr]() {
+        auto listener = thisPtr.promote();
+        CHECK_EXECUTE(listener, listener->ExecuteOnBufferAvailable());
+    });
+    MEDIA_INFO_LOG("PhotoBufferConsumer OnBufferAvailable X");
+}
+
+void PhotoBufferConsumer::ExecuteOnBufferAvailable()
+{
+
+    MEDIA_INFO_LOG("PhotoBufferConsumer ExecuteOnBufferAvailable E");
+    CAMERA_SYNC_TRACE;
+    sptr<HStreamCapture> streamCapture = streamCapture_.promote();
+    CHECK_ERROR_RETURN_LOG(streamCapture == nullptr, "streamCapture is null");
+    sptr<Surface> surface;
+    if (isRaw_) {
+        surface = streamCapture->rawSurface_;
+    } else {
+        surface = streamCapture->surface_;
+    }
+    CHECK_ERROR_RETURN_LOG(surface == nullptr, "surface is null");
+    sptr<SurfaceBuffer> surfaceBuffer = nullptr;
+    int32_t fence = -1;
+    int64_t timestamp;
+    OHOS::Rect damage;
+    SurfaceError surfaceRet = surface->AcquireBuffer(surfaceBuffer, fence, timestamp, damage);
+    CHECK_ERROR_RETURN_LOG(surfaceRet != SURFACE_ERROR_OK, "PhotoBufferConsumer Failed to acquire surface buffer");
+    int32_t isDegradedImage = CameraSurfaceBufferUtil::GetIsDegradedImage(surfaceBuffer);
+    MEDIA_INFO_LOG("PhotoBufferConsumer ts isDegradedImage:%{public}d", isDegradedImage);
+    MEDIA_INFO_LOG("PhotoBufferConsumer ts is:%{public}" PRId64, timestamp);
+    // deep copy surfaceBuffer
+    sptr<SurfaceBuffer> newSurfaceBuffer = CameraSurfaceBufferUtil::DeepCopyBuffer(surfaceBuffer);
+    // release surfaceBuffer to bufferQueue
+    surface->ReleaseBuffer(surfaceBuffer, -1);
+    CHECK_ERROR_RETURN_LOG(newSurfaceBuffer == nullptr, "newSurfaceBuffer is null");
+    int32_t captureId = CameraSurfaceBufferUtil::GetCaptureId(newSurfaceBuffer);
+    CameraReportDfxUtils::GetInstance()->SetFirstBufferEndInfo(captureId);
+    CameraReportDfxUtils::GetInstance()->SetPrepareProxyStartInfo(captureId);
+    streamCapture->OnPhotoAvailable(newSurfaceBuffer, timestamp, isRaw_);
+    MEDIA_INFO_LOG("PhotoBufferConsumer ExecuteOnBufferAvailable X");
+}
+}  // namespace CameraStandard
+}  // namespace OHOS
\ No newline at end of file