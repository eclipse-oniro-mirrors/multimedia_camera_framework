-void PhotoListener::UpdateJSCallback(sptr<Surface> photoSurface) const
-{
-    CAMERA_SYNC_TRACE;
-    MEDIA_DEBUG_LOG("PhotoListener UpdateJSCallback enter");
-    sptr<SurfaceBuffer> surfaceBuffer = nullptr;
-    int32_t fence = -1;
-    int64_t timestamp;
-    OHOS::Rect damage;
-    SurfaceError surfaceRet = photoSurface->AcquireBuffer(surfaceBuffer, fence, timestamp, damage);
-    CHECK_ERROR_RETURN_LOG(surfaceRet != SURFACE_ERROR_OK, "PhotoListener Failed to acquire surface buffer");
-    MEDIA_INFO_LOG("PhotoListener::UpdateJSCallback ts is:%{public}" PRId64, timestamp);
-    int32_t isDegradedImage;
-    surfaceBuffer->GetExtraData()->ExtraGet(OHOS::Camera::isDegradedImage, isDegradedImage);
-    MEDIA_INFO_LOG("PhotoListener UpdateJSCallback isDegradedImage:%{public}d", isDegradedImage);
-    if ((callbackFlag_ & CAPTURE_PHOTO_ASSET) != 0) {
-        auto photoOutput = photoOutput_.promote();
-        if (photoOutput != nullptr) {
-            int32_t currentCaptureId = GetCaptureId(surfaceBuffer);
-            photoOutput->AcquireBufferToPrepareProxy(currentCaptureId);
-        }
-        ExecutePhotoAsset(surfaceBuffer, isDegradedImage == 0, timestamp);
-    } else if (isDegradedImage == 0 && (callbackFlag_ & CAPTURE_PHOTO) != 0) {
-        ExecutePhoto(surfaceBuffer, timestamp);
-    } else if (isDegradedImage != 0 && (callbackFlag_ & CAPTURE_DEFERRED_PHOTO) != 0) {
-        ExecuteDeferredPhoto(surfaceBuffer);
-    } else {
-        MEDIA_INFO_LOG("PhotoListener on error callback");
-    }
-}
-
-void PhotoListener::UpdateJSCallbackAsync(sptr<Surface> photoSurface) const
-{
-    CAMERA_SYNC_TRACE;
-    MEDIA_DEBUG_LOG("PhotoListener UpdateJSCallbackAsync enter");
-    std::unique_ptr<PhotoListenerInfo> callbackInfo =
-        std::make_unique<PhotoListenerInfo>(photoSurface, shared_from_this());
-    PhotoListenerInfo *event = callbackInfo.get();
-    MEDIA_DEBUG_LOG("PhotoListener UpdateJSCallbackAsync uv_queue_work_with_qos start");
-    auto task = [event]() {
-        PhotoListenerInfo* callbackInfo = reinterpret_cast<PhotoListenerInfo*>(event);
-            if (callbackInfo) {
-                auto listener = callbackInfo->listener_.lock();
-                CHECK_EXECUTE(listener != nullptr, listener->UpdateJSCallback(callbackInfo->photoSurface_));
-                MEDIA_INFO_LOG("PhotoListener:UpdateJSCallbackAsync() complete");
-                callbackInfo->photoSurface_ = nullptr;
-                callbackInfo->listener_.reset();
-                delete callbackInfo;
-            }
-        };
-    if (napi_ok != napi_send_event(env_, task, napi_eprio_immediate)) {
-        MEDIA_ERR_LOG("PhotoListener:UpdateJSCallbackAsync() failed to execute work");
-    } else {
-        callbackInfo.release();
-    }
-}
-
-void PhotoListener::SaveCallback(const std::string eventName, napi_value callback)
-{
-    MEDIA_INFO_LOG("PhotoListener::SaveCallback is called eventName:%{public}s", eventName.c_str());
-    auto eventTypeEnum = PhotoOutputEventTypeHelper.ToEnum(eventName);
-    switch (eventTypeEnum) {
-        case PhotoOutputEventType::CAPTURE_PHOTO_AVAILABLE:
-            callbackFlag_ |= CAPTURE_PHOTO;
-            break;
-        case PhotoOutputEventType::CAPTURE_DEFERRED_PHOTO_AVAILABLE:
-            callbackFlag_ |= CAPTURE_DEFERRED_PHOTO;
-            break;
-        case PhotoOutputEventType::CAPTURE_PHOTO_ASSET_AVAILABLE:
-            callbackFlag_ |= CAPTURE_PHOTO_ASSET;
-            break;
-        default:
-            MEDIA_ERR_LOG("Incorrect photo callback event type received from JS");
-            return;
-    }
-    auto photoOutput = photoOutput_.promote();
-    if (photoOutput) {
-        photoOutput->SetCallbackFlag(callbackFlag_);
-    } else {
-        MEDIA_ERR_LOG("cannot get photoOutput");
-    }
-    SaveCallbackReference(eventName, callback, false);
-}
-
-void PhotoListener::RemoveCallback(const std::string eventName, napi_value callback)
-{
-    MEDIA_INFO_LOG("PhotoListener::RemoveCallback is called eventName:%{public}s", eventName.c_str());
-    if (eventName == CONST_CAPTURE_PHOTO_AVAILABLE) {
-        callbackFlag_ &= ~CAPTURE_PHOTO;
-    } else if (eventName == CONST_CAPTURE_DEFERRED_PHOTO_AVAILABLE) {
-        callbackFlag_ &= ~CAPTURE_DEFERRED_PHOTO;
-    } else if (eventName == CONST_CAPTURE_PHOTO_ASSET_AVAILABLE) {
-        auto photoOutput = photoOutput_.promote();
-        CHECK_EXECUTE(photoOutput != nullptr,
-            photoOutput->DeferImageDeliveryFor(DeferredDeliveryImageType::DELIVERY_NONE));
-        callbackFlag_ &= ~CAPTURE_PHOTO_ASSET;
-    }
-    RemoveCallbackRef(eventName, callback);
-}
-
-void RawPhotoListener::OnBufferAvailable()
-{
-    std::lock_guard<std::mutex> lock(g_photoImageMutex);
-    CAMERA_SYNC_TRACE;
-    MEDIA_INFO_LOG("RawPhotoListener::OnBufferAvailable is called");
-    CHECK_ERROR_RETURN_LOG(!rawPhotoSurface_, "RawPhotoListener napi rawPhotoSurface_ is null");
-    UpdateJSCallbackAsync(rawPhotoSurface_);
-}
-
-void RawPhotoListener::ExecuteRawPhoto(sptr<SurfaceBuffer> surfaceBuffer) const
-{
-    MEDIA_INFO_LOG("ExecuteRawPhoto");
-    napi_value result[ARGS_TWO] = { nullptr, nullptr };
-    napi_value retVal;
-    napi_value rawImage = nullptr;
-    std::shared_ptr<Media::NativeImage> image = std::make_shared<Media::NativeImage>(surfaceBuffer, bufferProcessor_);
-    napi_get_undefined(env_, &result[PARAM0]);
-    napi_get_undefined(env_, &result[PARAM1]);
-    rawImage = Media::ImageNapi::Create(env_, image);
-    if (rawImage == nullptr) {
-        MEDIA_ERR_LOG("ImageNapi Create failed");
-        napi_get_undefined(env_, &rawImage);
-    }
-    result[PARAM1] = PhotoNapi::CreateRawPhoto(env_, rawImage);
-    ExecuteCallbackNapiPara callbackNapiPara { .recv = nullptr, .argc = ARGS_TWO, .argv = result, .result = &retVal };
-    ExecuteCallback(CONST_CAPTURE_PHOTO_AVAILABLE, callbackNapiPara);
-    rawPhotoSurface_->ReleaseBuffer(surfaceBuffer, -1);
-}
-
-void RawPhotoListener::UpdateJSCallback(sptr<Surface> rawPhotoSurface) const
+void FillPixelMapWithCaptureIdAndTimestamp(napi_env env, int32_t captureId, int64_t timestamp, napi_value pixelMapNapi)
 {
-    sptr<SurfaceBuffer> surfaceBuffer = nullptr;
-    int32_t fence = -1;
-    int64_t timestamp;
-    OHOS::Rect damage;
-    SurfaceError surfaceRet = rawPhotoSurface->AcquireBuffer(surfaceBuffer, fence, timestamp, damage);
-    CHECK_ERROR_RETURN_LOG(surfaceRet != SURFACE_ERROR_OK, "RawPhotoListener Failed to acquire surface buffer");
-
-    int32_t isDegradedImage;
-    surfaceBuffer->GetExtraData()->ExtraGet(OHOS::Camera::isDegradedImage, isDegradedImage);
-    MEDIA_INFO_LOG("RawPhotoListener UpdateJSCallback isDegradedImage:%{public}d", isDegradedImage);
-
-    if (isDegradedImage == 0) {
-        ExecuteRawPhoto(surfaceBuffer);
-    } else {
-        MEDIA_ERR_LOG("RawPhoto not support deferred photo");
+    napi_valuetype valueType = napi_undefined;
+    if (napi_typeof(env, pixelMapNapi, &valueType) != napi_ok || valueType == napi_undefined) {
+        MEDIA_ERR_LOG("FillPixelMapWithCaptureIdAndTimestamp err, pixelMapNapi is undefined = %{public}d",
+            valueType == napi_undefined);
+        return;
     }
-}
+    napi_value propertyName;
+    napi_value propertyValue;
+    napi_get_undefined(env, &propertyName);
+    napi_get_undefined(env, &propertyValue);
+    napi_create_string_utf8(env, "captureId", NAPI_AUTO_LENGTH, &propertyName);
+    napi_create_int32(env, captureId, &propertyValue);
+    napi_set_property(env, pixelMapNapi, propertyName, propertyValue);
+    MEDIA_INFO_LOG("FillPixelMapWithCaptureIdAndTimestamp captureId %{public}d", captureId);
 
-void RawPhotoListener::UpdateJSCallbackAsync(sptr<Surface> rawPhotoSurface) const
-{
-    std::unique_ptr<RawPhotoListenerInfo> callbackInfo =
-        std::make_unique<RawPhotoListenerInfo>(rawPhotoSurface, shared_from_this());
-    RawPhotoListenerInfo *event = callbackInfo.get();
-    auto task = [event]() {
-        RawPhotoListenerInfo* callbackInfo = reinterpret_cast<RawPhotoListenerInfo*>(event);
-        if (callbackInfo) {
-            auto listener = callbackInfo->listener_.lock();
-            CHECK_EXECUTE(listener != nullptr, listener->UpdateJSCallback(callbackInfo->rawPhotoSurface_));
-            MEDIA_INFO_LOG("RawPhotoListener:UpdateJSCallbackAsync() complete");
-            callbackInfo->rawPhotoSurface_ = nullptr;
-            callbackInfo->listener_.reset();
-            delete callbackInfo;
-        }
-    };
-    if (napi_ok != napi_send_event(env_, task, napi_eprio_immediate)) {
-        MEDIA_ERR_LOG("RawPhotoListener:UpdateJSCallbackAsync() failed to execute work");
-    } else {
-        callbackInfo.release();
-    }
+    napi_create_string_utf8(env, "timestamp", NAPI_AUTO_LENGTH, &propertyName);
+    napi_create_int64(env, timestamp, &propertyValue);
+    napi_set_property(env, pixelMapNapi, propertyName, propertyValue);
 }
 
 PhotoOutputCallback::PhotoOutputCallback(napi_env env) : ListenerBase(env) {}
@@ -1367,6 +376,38 @@ void PhotoOutputCallback::OnOfflineDeliveryFinished(const int32_t captureId) con
     UpdateJSCallbackAsync(PhotoOutputEventType::CAPTURE_OFFLINE_DELIVERY_FINISHED, info);
 }
 
+void PhotoOutputCallback::OnPhotoAvailable(const std::shared_ptr<Media::NativeImage> nativeImage, bool isRaw) const
+{
+    MEDIA_DEBUG_LOG("PhotoOutputCallback::OnPhotoAvailable is called!");
+    CallbackInfo info;
+    info.nativeImage = nativeImage;
+    info.isRaw = isRaw;
+    UpdateJSCallbackAsync(PhotoOutputEventType::CAPTURE_PHOTO_AVAILABLE, info);
+}
+
+void PhotoOutputCallback::OnPhotoAssetAvailable(
+    const int32_t captureId, const std::string &uri, int32_t cameraShotType, const std::string &burstKey) const
+{
+    MEDIA_DEBUG_LOG("PhotoOutputCallback::OnPhotoAssetAvailable is called!");
+    CallbackInfo info;
+    info.captureID = captureId;
+    info.uri = uri;
+    info.cameraShotType = cameraShotType;
+    info.burstKey = burstKey;
+    UpdateJSCallbackAsync(PhotoOutputEventType::CAPTURE_PHOTO_ASSET_AVAILABLE, info);
+}
+
+void PhotoOutputCallback::OnThumbnailAvailable(
+    const int32_t captureId, const int64_t timestamp, unique_ptr<Media::PixelMap> pixelMap) const
+{
+    MEDIA_DEBUG_LOG("PhotoOutputCallback::OnThumbnailAvailable is called!");
+    CallbackInfo info;
+    info.captureID = captureId;
+    info.timestamp = timestamp;
+    info.pixelMap = std::move(pixelMap);
+    UpdateJSCallbackAsync(PhotoOutputEventType::CAPTURE_THUMBNAIL_AVAILABLE, info);
+}
+
 void PhotoOutputCallback::ExecuteCaptureStartCb(const CallbackInfo& info) const
 {
     napi_value result[ARGS_TWO] = { nullptr, nullptr };
@@ -1492,6 +533,63 @@ void PhotoOutputCallback::ExecuteOfflineDeliveryFinishedCb(const CallbackInfo& i
     ExecuteCallback(CONST_CAPTURE_OFFLINE_DELIVERY_FINISHED, callbackNapiPara);
 }
 
+void PhotoOutputCallback::ExecutePhotoAvailableCb(const CallbackInfo& info) const
+{
+    MEDIA_INFO_LOG("ExecutePhotoAvailableCb");
+    napi_value result[ARGS_TWO] = {nullptr, nullptr};
+    napi_value retVal;
+    napi_value mainImage = nullptr;
+    napi_get_undefined(env_, &result[PARAM0]);
+    napi_get_undefined(env_, &result[PARAM1]);
+    mainImage = Media::ImageNapi::Create(env_, info.nativeImage);
+    if (mainImage == nullptr) {
+        MEDIA_ERR_LOG("ImageNapi Create failed");
+        napi_get_undefined(env_, &mainImage);
+    }
+    result[PARAM1] = PhotoNapi::CreatePhoto(env_, mainImage, info.isRaw);
+    ExecuteCallbackNapiPara callbackNapiPara { .recv = nullptr, .argc = ARGS_TWO, .argv = result, .result = &retVal };
+    ExecuteCallback(CONST_CAPTURE_PHOTO_AVAILABLE, callbackNapiPara);
+}
+
+void PhotoOutputCallback::ExecutePhotoAssetAvailableCb(const CallbackInfo& info) const
+{
+    MEDIA_INFO_LOG("ExecutePhotoAssetAvailableCb");
+    napi_value result[ARGS_TWO] = {nullptr, nullptr};
+    napi_value retVal;
+    napi_value photoAsset = nullptr;
+    napi_get_undefined(env_, &result[PARAM0]);
+    napi_get_undefined(env_, &result[PARAM1]);
+    photoAsset = Media::MediaLibraryCommNapi::CreatePhotoAssetNapi(env_, info.uri, info.cameraShotType, info.burstKey);
+    if (photoAsset == nullptr) {
+        napi_get_undefined(env_, &photoAsset);
+    }
+    FillNapiObjectWithCaptureId(env_, info.captureID, photoAsset);
+    result[PARAM1] = photoAsset;
+    ExecuteCallbackNapiPara callbackNapiPara { .recv = nullptr, .argc = ARGS_TWO, .argv = result, .result = &retVal };
+    ExecuteCallback(CONST_CAPTURE_PHOTO_ASSET_AVAILABLE, callbackNapiPara);
+}
+
+void PhotoOutputCallback::ExecuteThumbnailAvailableCb(const CallbackInfo& info) const
+{
+    MEDIA_INFO_LOG("ExecuteThumbnailAvailableCb E");
+    napi_value result[ARGS_TWO] = { 0 };
+    napi_get_undefined(env_, &result[0]);
+    napi_get_undefined(env_, &result[1]);
+    napi_value retVal;
+    MEDIA_INFO_LOG("enter ImageNapi::Create start");
+    napi_value valueParam = Media::PixelMapNapi::CreatePixelMap(env_, info.pixelMap);
+    if (valueParam == nullptr) {
+        MEDIA_ERR_LOG("ImageNapi Create failed");
+        napi_get_undefined(env_, &valueParam);
+    }
+    FillPixelMapWithCaptureIdAndTimestamp(env_, info.captureID, info.timestamp, valueParam);
+    MEDIA_INFO_LOG("enter ImageNapi::Create end");
+    result[1] = valueParam;
+    ExecuteCallbackNapiPara callbackNapiPara { .recv = nullptr, .argc = ARGS_TWO, .argv = result, .result = &retVal };
+    ExecuteCallback(CONST_CAPTURE_QUICK_THUMBNAIL, callbackNapiPara);
+    MEDIA_INFO_LOG("ExecuteThumbnailAvailableCb X");
+}
+
 void PhotoOutputCallback::UpdateJSCallback(PhotoOutputEventType eventType, const CallbackInfo& info) const
 {
     MEDIA_DEBUG_LOG("UpdateJSCallback is called");
@@ -1523,428 +621,24 @@ void PhotoOutputCallback::UpdateJSCallback(PhotoOutputEventType eventType, const
         case PhotoOutputEventType::CAPTURE_OFFLINE_DELIVERY_FINISHED:
             ExecuteOfflineDeliveryFinishedCb(info);
             break;
+        case PhotoOutputEventType::CAPTURE_PHOTO_AVAILABLE:
+            ExecutePhotoAvailableCb(info);
+            break;
+        case PhotoOutputEventType::CAPTURE_PHOTO_ASSET_AVAILABLE:
+            ExecutePhotoAssetAvailableCb(info);
+            break;
+        case PhotoOutputEventType::CAPTURE_THUMBNAIL_AVAILABLE:
+            ExecuteThumbnailAvailableCb(info);
+            break;
         default:
             MEDIA_ERR_LOG("Incorrect photo callback event type received from JS");
     }
 }
 
-ThumbnailListener::ThumbnailListener(napi_env env, const sptr<PhotoOutput> photoOutput)
-    : ListenerBase(env), photoOutput_(photoOutput)
-{}
-
-ThumbnailListener::~ThumbnailListener()
-{
-    MEDIA_INFO_LOG("ThumbnailListener::~ThumbnailListener");
-    ClearTaskManager();
-    auto photoOutput = photoOutput_.promote();
-    CHECK_ERROR_RETURN_LOG(photoOutput == nullptr, "~ThumbnailListener photoOutput is nullptr");
-    auto surface = photoOutput->thumbnailSurface_;
-    if (surface) {
-        surface->CleanCache(true);
-        MEDIA_INFO_LOG("~ThumbnailListener clean buffer cache!");
-    }
-}
-
-void ThumbnailListener::ClearTaskManager()
-{
-    std::lock_guard<std::mutex> lock(taskManagerMutex_);
-    if (taskManager_) {
-        taskManager_->CancelAllTasks();
-        taskManager_.reset();
-        taskManager_ = nullptr;
-    }
-}
-
-void ThumbnailListener::OnBufferAvailable()
-{
-    CAMERA_SYNC_TRACE;
-    MEDIA_INFO_LOG("ThumbnailListener::OnBufferAvailable is called");
-    recThumb_++;
-    CHECK_EXECUTE(recThumb_ >= std::numeric_limits<int32_t>::max(), recThumb_ = 0);
-    wptr<ThumbnailListener> thisPtr(this);
-    {
-        auto taskManager = GetDefaultTaskManager();
-        if (taskManager == nullptr) {
-            MEDIA_ERR_LOG("ThumbnailListener::OnBufferAvailable taskManager_ is null");
-            return;
-        }
-        taskManager->SubmitTask([thisPtr]() {
-            auto listener = thisPtr.promote();
-            if (listener) {
-                listener->ExecuteDeepCopySurfaceBuffer();
-            }
-        });
-    }
-    constexpr int32_t memSize = 20 * 1024;
-    int32_t retCode = CameraManager::GetInstance()->RequireMemorySize(memSize);
-    CHECK_ERROR_RETURN_LOG(retCode != 0, "ThumbnailListener::OnBufferAvailable RequireMemorySize failed");
-    MEDIA_DEBUG_LOG("ThumbnailListener::OnBufferAvailable is end");
-}
-
-std::shared_ptr<DeferredProcessing::TaskManager> ThumbnailListener::GetDefaultTaskManager()
-{
-    constexpr int32_t numThreads = 1;
-    std::lock_guard<std::mutex> lock(taskManagerMutex_);
-    if (taskManager_ == nullptr) {
-        taskManager_ = std::make_shared<DeferredProcessing::TaskManager>("ThumbnailListener", numThreads, false);
-    }
-    return taskManager_;
-}
-
-OHOS::ColorManager::ColorSpaceName GetColorSpace(sptr<SurfaceBuffer> surfaceBuffer)
-{
-    OHOS::ColorManager::ColorSpaceName colorSpace = OHOS::ColorManager::ColorSpaceName::NONE;
-    HDI::Display::Graphic::Common::V1_0::CM_ColorSpaceType colorSpaceType;
-    GSError gsErr = MetadataHelper::GetColorSpaceType(surfaceBuffer, colorSpaceType);
-    if (gsErr != GSERROR_OK) {
-        MEDIA_ERR_LOG("Failed to get colorSpaceType from surfaceBuffer!");
-        return colorSpace;
-    } else {
-        MEDIA_INFO_LOG("Get current colorSpaceType is : %{public}d", colorSpaceType);
-    }
-    auto it = COLORSPACE_MAP.find(colorSpaceType);
-    if (it != COLORSPACE_MAP.end()) {
-        colorSpace = it->second;
-        MEDIA_INFO_LOG("Current get colorSpaceName: %{public}d", colorSpace);
-    } else {
-        MEDIA_ERR_LOG("Current colorSpace is not supported!");
-        return colorSpace;
-    }
-    return colorSpace;
-}
-
-void ThumbnailSetColorSpaceAndRotate(std::unique_ptr<Media::PixelMap>& pixelMap, sptr<SurfaceBuffer> surfaceBuffer,
-    OHOS::ColorManager::ColorSpaceName colorSpaceName)
-{
-    int32_t thumbnailrotation = 0;
-    surfaceBuffer->GetExtraData()->ExtraGet(OHOS::Camera::dataRotation, thumbnailrotation);
-    MEDIA_DEBUG_LOG("ThumbnailListener current rotation is : %{public}d", thumbnailrotation);
-    if (!pixelMap) {
-        MEDIA_ERR_LOG("ThumbnailListener Failed to create PixelMap.");
-    } else {
-        pixelMap->InnerSetColorSpace(OHOS::ColorManager::ColorSpace(colorSpaceName));
-        pixelMap->rotate(thumbnailrotation);
-    }
-}
-
-void ThumbnailListener::ExecuteDeepCopySurfaceBuffer()
-{
-    CAMERA_SYNC_TRACE;
-    auto photoOutput = photoOutput_.promote();
-    CHECK_ERROR_RETURN_LOG(photoOutput == nullptr, "ThumbnailListener photoOutput is nullptr");
-    auto surface = photoOutput->thumbnailSurface_;
-    CHECK_ERROR_RETURN_LOG(surface == nullptr, "ThumbnailListener surface is nullptr");
-    sptr<SurfaceBuffer> surfaceBuffer = nullptr;
-    int32_t fence = -1;
-    int64_t timestamp;
-    OHOS::Rect damage;
-    MEDIA_INFO_LOG("ThumbnailListener surfaceName = Thumbnail AcquireBuffer before");
-    SurfaceError surfaceRet = surface->AcquireBuffer(surfaceBuffer, fence, timestamp, damage);
-    MEDIA_DEBUG_LOG("ThumbnailListener surfaceName = Thumbnail AcquireBuffer end");
-    CHECK_ERROR_RETURN_LOG(surfaceRet != SURFACE_ERROR_OK, "ThumbnailListener Failed to acquire surface buffer");
-    acqThumb_++;
-    CHECK_EXECUTE(acqThumb_ >= std::numeric_limits<int32_t>::max(), acqThumb_ = 0);
-    MEDIA_DEBUG_LOG("ThumbnailListener recv:%{public}d acq:%{public}d", recThumb_, acqThumb_);
-    CHECK_ERROR_PRINT_LOG(recThumb_ != acqThumb_, "exist thumb buffer not acquire!");
-    int32_t captureIdExt = GetCaptureId(surfaceBuffer);
-    int32_t captureId = -1;
-    int32_t burstSeqId = -1;
-    int32_t thumbnailWidth = 0;
-    int32_t thumbnailHeight = 0;
-    surfaceBuffer->GetExtraData()->ExtraGet(OHOS::Camera::captureId, captureId);
-    surfaceBuffer->GetExtraData()->ExtraGet(OHOS::Camera::burstSequenceId, burstSeqId);
-    surfaceBuffer->GetExtraData()->ExtraGet(OHOS::Camera::dataWidth, thumbnailWidth);
-    surfaceBuffer->GetExtraData()->ExtraGet(OHOS::Camera::dataHeight, thumbnailHeight);
-    MEDIA_INFO_LOG("ThumbnailListener tw:%{public}d th:%{public}d cId:%{public}d bsId:%{public}d",
-        thumbnailWidth,
-        thumbnailHeight,
-        captureId,
-        burstSeqId);
-    GSError res;
-    if (burstSeqId != -1) {
-        res = surface->ReleaseBuffer(surfaceBuffer, -1);
-        CHECK_ERROR_PRINT_LOG(res != GSERROR_OK, "ReleaseBuffer bsId:%{public}d err:%{public}d", burstSeqId, res);
-        MEDIA_INFO_LOG("ThumbnailListener ReleaseBuffer, cId:%{public}d bsId:%{public}d", captureId, burstSeqId);
-        return;
-    }
-    OHOS::ColorManager::ColorSpaceName colorSpace = GetColorSpace(surfaceBuffer);
-    CHECK_ERROR_RETURN_LOG(colorSpace == OHOS::ColorManager::ColorSpaceName::NONE, "Thumbnail GetcolorSpace failed!");
-    bool isHdr = colorSpace == OHOS::ColorManager::ColorSpaceName::BT2020_HLG;
-    sptr<SurfaceBuffer> newSurfaceBuffer = SurfaceBuffer::Create();
-    DeepCopyBuffer(newSurfaceBuffer, surfaceBuffer, thumbnailWidth, thumbnailHeight, isHdr);
-    std::unique_ptr<Media::PixelMap> pixelMap = CreatePixelMapFromSurfaceBuffer(newSurfaceBuffer,
-        thumbnailWidth, thumbnailHeight, isHdr);
-    CHECK_ERROR_RETURN_LOG(pixelMap == nullptr, "ThumbnailListener create pixelMap is nullptr");
-    ThumbnailSetColorSpaceAndRotate(pixelMap, surfaceBuffer, colorSpace);
-    MEDIA_DEBUG_LOG("ThumbnailListener ReleaseBuffer begin");
-    res = surface->ReleaseBuffer(surfaceBuffer, -1);
-    CHECK_ERROR_PRINT_LOG(res != GSERROR_OK, "ReleaseBuffer cId:%{public}d err:%{public}d", captureId, res);
-    MEDIA_DEBUG_LOG("ThumbnailListener ReleaseBuffer end, cId:%{public}d", captureId);
-    UpdateJSCallbackAsync(captureIdExt, timestamp, std::move(pixelMap));
-    MEDIA_INFO_LOG("ThumbnailListener ReleaseBuffer UpdateJSCallbackAsync cId:%{public}d end", captureId);
-    auto photoProxy = CreateCameraPhotoProxy(surfaceBuffer);
-    CHECK_ERROR_RETURN_LOG(photoProxy == nullptr, "photoProxy is nullptr");
-    if (photoOutput->IsYuvOrHeifPhoto()) {
-        constexpr int32_t yuvFormat = 3;
-        photoProxy->format_ = yuvFormat;
-        photoProxy->imageFormat_ = yuvFormat;
-        photoOutput->UpdateMediaLibraryPhotoAssetProxy(photoProxy);
-    }
-}
-
-void ThumbnailListener::DeepCopyBuffer(sptr<SurfaceBuffer> newSurfaceBuffer, sptr<SurfaceBuffer> surfaceBuffer,
-    int32_t thumbnailWidth, int32_t thumbnailHeight, bool isHdr) const
-{
-    CAMERA_SYNC_TRACE;
-    MEDIA_INFO_LOG("ThumbnailListener::DeepCopyBuffer w=%{public}d, h=%{public}d, f=%{public}d ",
-        thumbnailWidth, thumbnailHeight, surfaceBuffer->GetFormat());
-    int32_t thumbnailStride = 0;
-    surfaceBuffer->GetExtraData()->ExtraGet(OHOS::Camera::dataStride, thumbnailStride);
-    MEDIA_INFO_LOG("ThumbnailListener::DeepCopyBuffer current stride : %{public}d", thumbnailStride);
-    BufferRequestConfig requestConfig = {
-        .width = thumbnailStride,
-        .height = thumbnailHeight,
-        .strideAlignment = thumbnailStride,
-        .format = surfaceBuffer->GetFormat(),
-        .usage = BUFFER_USAGE_CPU_READ | BUFFER_USAGE_CPU_WRITE | BUFFER_USAGE_MEM_DMA | BUFFER_USAGE_MEM_MMZ_CACHE,
-        .timeout = 0,
-    };
-    CHECK_ERROR_RETURN_LOG(newSurfaceBuffer == nullptr, "Deep copy surfaceBuffer failed");
-    GSError allocErrorCode = newSurfaceBuffer->Alloc(requestConfig);
-    if (allocErrorCode != 0) {
-        MEDIA_ERR_LOG("Create surfaceBuffer Alloc failed");
-        return;
-    }
-    MEDIA_INFO_LOG("ThumbnailListener::DeepCopyBuffer SurfaceBuffer alloc ret : %{public}d",
-        allocErrorCode);
-    int32_t colorLength = thumbnailStride * thumbnailHeight * PIXEL_SIZE_HDR_YUV;
-    colorLength = isHdr ? colorLength : colorLength / HDR_PIXEL_SIZE;
-    if (memcpy_s(newSurfaceBuffer->GetVirAddr(), newSurfaceBuffer->GetSize(),
-        surfaceBuffer->GetVirAddr(), colorLength) != EOK) {
-        MEDIA_ERR_LOG("PhotoListener memcpy_s failed");
-        return;
-    }
-    CopyMetaData(surfaceBuffer, newSurfaceBuffer);
-    MEDIA_DEBUG_LOG("ThumbnailListener::DeepCopyBuffer SurfaceBuffer end");
-}
-
-unique_ptr<Media::PixelMap> ThumbnailListener::CreatePixelMapFromSurfaceBuffer(sptr<SurfaceBuffer> &surfaceBuffer,
-    int32_t width, int32_t height, bool isHdr)
-{
-    CHECK_ERROR_RETURN_RET_LOG(surfaceBuffer == nullptr, nullptr,
-        "ThumbnailListener::CreatePixelMapFromSurfaceBuffer surfaceBuffer is nullptr");
-    MEDIA_INFO_LOG("ThumbnailListener Width:%{public}d, height:%{public}d, isHdr:%{public}d, format:%{public}d",
-        width, height, isHdr, surfaceBuffer->GetFormat());
-    Media::InitializationOptions options {
-        .size = { .width = width, .height = height } };
-    options.srcPixelFormat = isHdr ? Media::PixelFormat::YCRCB_P010 : Media::PixelFormat::NV12;
-    options.pixelFormat = isHdr ? Media::PixelFormat::YCRCB_P010 : Media::PixelFormat::NV12;
-    options.useDMA = true;
-    options.editable = isHdr; // 10bit支持滤镜可编辑
-    int32_t colorLength = width * height * PIXEL_SIZE_HDR_YUV;
-    colorLength = isHdr ? colorLength : colorLength / HDR_PIXEL_SIZE;
-    std::unique_ptr<Media::PixelMap> pixelMap = Media::PixelMap::Create(options);
-    void* nativeBuffer = surfaceBuffer.GetRefPtr();
-    RefBase *ref = reinterpret_cast<RefBase *>(nativeBuffer);
-    ref->IncStrongRef(ref);
-    if (isHdr) {
-        pixelMap->SetHdrType(OHOS::Media::ImageHdrType::HDR_VIVID_SINGLE);
-    }
-    pixelMap->SetPixelsAddr(surfaceBuffer->GetVirAddr(), surfaceBuffer.GetRefPtr(), colorLength,
-        Media::AllocatorType::DMA_ALLOC, nullptr);
-    
-    MEDIA_DEBUG_LOG("ThumbnailListener::CreatePixelMapFromSurfaceBuffer end");
-    return SetPixelMapYuvInfo(surfaceBuffer, std::move(pixelMap), isHdr);
-}
-
-unique_ptr<Media::PixelMap> ThumbnailListener::SetPixelMapYuvInfo(sptr<SurfaceBuffer> &surfaceBuffer,
-    unique_ptr<Media::PixelMap> pixelMap, bool isHdr)
-{
-    MEDIA_INFO_LOG("ThumbnailListener::SetPixelMapYuvInf enter");
-    uint8_t ratio = isHdr ? HDR_PIXEL_SIZE : SDR_PIXEL_SIZE;
-    int32_t srcWidth = pixelMap->GetWidth();
-    int32_t srcHeight = pixelMap->GetHeight();
-    Media::YUVDataInfo yuvDataInfo = { .yWidth = srcWidth,
-                                       .yHeight = srcHeight,
-                                       .uvWidth = srcWidth / 2,
-                                       .uvHeight = srcHeight / 2,
-                                       .yStride = srcWidth,
-                                       .uvStride = srcWidth,
-                                       .uvOffset = srcWidth * srcHeight};
-    if (surfaceBuffer == nullptr) {
-        pixelMap->SetImageYUVInfo(yuvDataInfo);
-        return pixelMap;
-    }
-    OH_NativeBuffer_Planes *planes = nullptr;
-    GSError retVal = surfaceBuffer->GetPlanesInfo(reinterpret_cast<void**>(&planes));
-    if (retVal != OHOS::GSERROR_OK || planes == nullptr) {
-        pixelMap->SetImageYUVInfo(yuvDataInfo);
-        return pixelMap;
-    }
-    
-    yuvDataInfo.yStride = planes->planes[PLANE_Y].columnStride / ratio;
-    yuvDataInfo.uvStride = planes->planes[PLANE_U].columnStride / ratio;
-    yuvDataInfo.yOffset = planes->planes[PLANE_Y].offset / ratio;
-    yuvDataInfo.uvOffset = planes->planes[PLANE_U].offset / ratio;
-
-    pixelMap->SetImageYUVInfo(yuvDataInfo);
-    MEDIA_INFO_LOG("ThumbnailListener::SetPixelMapYuvInf end");
-    return pixelMap;
-}
-
-void ThumbnailListener::UpdateJSCallbackAsync(int32_t captureId, int64_t timestamp,
-    unique_ptr<Media::PixelMap> pixelMap)
-{
-    std::unique_ptr<ThumbnailListenerInfo> callbackInfo =
-        std::make_unique<ThumbnailListenerInfo>(this, captureId, timestamp, std::move(pixelMap));
-    ThumbnailListenerInfo *event = callbackInfo.get();
-    auto taskAsync = [event]() {
-        ThumbnailListenerInfo* callbackInfo = reinterpret_cast<ThumbnailListenerInfo*>(event);
-        if (callbackInfo) {
-            auto listener = callbackInfo->listener_.promote();
-            if (listener != nullptr) {
-                listener->UpdateJSCallback(callbackInfo->captureId_, callbackInfo->timestamp_,
-                    std::move(callbackInfo->pixelMap_));
-                MEDIA_INFO_LOG("ThumbnailListener:UpdateJSCallbackAsync() complete");
-            }
-            delete callbackInfo;
-        }
-    };
-    if (napi_ok != napi_send_event(env_, taskAsync, napi_eprio_immediate)) {
-        MEDIA_ERR_LOG("ThumbnailListener:UpdateJSCallbackAsync() failed to execute work");
-    } else {
-        callbackInfo.release();
-    }
-}
-
-void FillPixelMapWithCaptureIdAndTimestamp(napi_env env, int32_t captureId, int64_t timestamp, napi_value pixelMapNapi)
-{
-    napi_valuetype valueType = napi_undefined;
-    if (napi_typeof(env, pixelMapNapi, &valueType) != napi_ok || valueType == napi_undefined) {
-        MEDIA_ERR_LOG("FillPixelMapWithCaptureIdAndTimestamp err, pixelMapNapi is undefined = %{public}d",
-            valueType == napi_undefined);
-        return;
-    }
-    napi_value propertyName;
-    napi_value propertyValue;
-    napi_get_undefined(env, &propertyName);
-    napi_get_undefined(env, &propertyValue);
-    napi_create_string_utf8(env, "captureId", NAPI_AUTO_LENGTH, &propertyName);
-    napi_create_int32(env, captureId, &propertyValue);
-    napi_set_property(env, pixelMapNapi, propertyName, propertyValue);
-    MEDIA_INFO_LOG("FillPixelMapWithCaptureIdAndTimestamp captureId %{public}d", captureId);
-
-    napi_create_string_utf8(env, "timestamp", NAPI_AUTO_LENGTH, &propertyName);
-    napi_create_int64(env, timestamp, &propertyValue);
-    napi_set_property(env, pixelMapNapi, propertyName, propertyValue);
-}
-
-void ThumbnailListener::UpdateJSCallback(int32_t captureId, int64_t timestamp,
-    unique_ptr<Media::PixelMap> pixelMap) const
-{
-    CHECK_ERROR_RETURN_LOG(pixelMap == nullptr, "ThumbnailListener::UpdateJSCallback surfaceBuffer is nullptr");
-    napi_value result[ARGS_TWO] = { 0 };
-    napi_get_undefined(env_, &result[0]);
-    napi_get_undefined(env_, &result[1]);
-    napi_value retVal;
-    MEDIA_INFO_LOG("enter ImageNapi::Create start");
-    napi_value valueParam = Media::PixelMapNapi::CreatePixelMap(env_, std::move(pixelMap));
-    if (valueParam == nullptr) {
-        MEDIA_ERR_LOG("ImageNapi Create failed");
-        napi_get_undefined(env_, &valueParam);
-    }
-    FillPixelMapWithCaptureIdAndTimestamp(env_, captureId, timestamp, valueParam);
-    napi_value valueCaptureId = nullptr;
-    napi_create_int32(env_, captureId, &valueCaptureId);
-    if (valueCaptureId == nullptr) {
-        MEDIA_ERR_LOG("napi_create_int64 failed");
-        napi_get_undefined(env_, &valueCaptureId);
-    }
-    MEDIA_INFO_LOG("enter ImageNapi::Create end");
-    napi_value obj = nullptr;
-    napi_create_object(env_, &obj);
-    napi_set_named_property(env_, obj, "thumbnailImage", valueParam);
-    napi_set_named_property(env_, obj, "captureId", valueCaptureId);
-    result[1] = obj;
-    ExecuteCallbackNapiPara callbackNapiPara { .recv = nullptr, .argc = ARGS_TWO, .argv = result, .result = &retVal };
-    ExecuteCallback(CONST_CAPTURE_QUICK_THUMBNAIL, callbackNapiPara);
-}
-
-void ThumbnailListener::UpdateJSCallback() const
-{
-    auto photoOutput = photoOutput_.promote();
-    CHECK_ERROR_RETURN_LOG(photoOutput == nullptr, "ThumbnailListener::UpdateJSCallback photoOutput is nullptr");
-    napi_value result[ARGS_TWO] = { 0 };
-    napi_get_undefined(env_, &result[0]);
-    napi_get_undefined(env_, &result[1]);
-    napi_value retVal;
-    MEDIA_INFO_LOG("enter ImageNapi::Create start");
-    int32_t fence = -1;
-    int64_t timestamp;
-    OHOS::Rect damage;
-    sptr<SurfaceBuffer> thumbnailBuffer = nullptr;
-    SurfaceError surfaceRet = photoOutput->thumbnailSurface_->AcquireBuffer(thumbnailBuffer, fence, timestamp, damage);
-    CHECK_ERROR_RETURN_LOG(surfaceRet != SURFACE_ERROR_OK, "ThumbnailListener Failed to acquire surface buffer");
-    int32_t thumbnailWidth;
-    int32_t thumbnailHeight;
-    thumbnailBuffer->GetExtraData()->ExtraGet(OHOS::CameraStandard::dataWidth, thumbnailWidth);
-    thumbnailBuffer->GetExtraData()->ExtraGet(OHOS::CameraStandard::dataHeight, thumbnailHeight);
-    int32_t captureId = GetCaptureId(thumbnailBuffer);
-    Media::InitializationOptions opts;
-    opts.srcPixelFormat = Media::PixelFormat::RGBA_8888;
-    opts.pixelFormat = Media::PixelFormat::RGBA_8888;
-    opts.size = { .width = thumbnailWidth, .height = thumbnailHeight };
-    MEDIA_INFO_LOG("thumbnailWidth:%{public}d, thumbnailheight: %{public}d", thumbnailWidth, thumbnailHeight);
-    const int32_t formatSize = 4;
-    auto pixelMap = Media::PixelMap::Create(static_cast<const uint32_t*>(thumbnailBuffer->GetVirAddr()),
-        thumbnailWidth * thumbnailHeight * formatSize, 0, thumbnailWidth, opts, true);
-    napi_value valueParam = Media::PixelMapNapi::CreatePixelMap(env_, std::move(pixelMap));
-    if (valueParam == nullptr) {
-        MEDIA_ERR_LOG("ImageNapi Create failed");
-        napi_get_undefined(env_, &valueParam);
-    }
-    FillPixelMapWithCaptureIdAndTimestamp(env_, captureId, timestamp, valueParam);
-    MEDIA_INFO_LOG("enter ImageNapi::Create end");
-    result[1] = valueParam;
-
-    ExecuteCallbackNapiPara callbackNapiPara { .recv = nullptr, .argc = ARGS_TWO, .argv = result, .result = &retVal };
-    ExecuteCallback(CONST_CAPTURE_QUICK_THUMBNAIL, callbackNapiPara);
-    photoOutput->thumbnailSurface_->ReleaseBuffer(thumbnailBuffer, -1);
-}
-
-void ThumbnailListener::UpdateJSCallbackAsync()
-{
-    std::unique_ptr<ThumbnailListenerInfo> callbackInfo = std::make_unique<ThumbnailListenerInfo>(this, 0, 0, nullptr);
-    ThumbnailListenerInfo *event = callbackInfo.get();
-    auto task = [event]() {
-        ThumbnailListenerInfo* callbackInfo = reinterpret_cast<ThumbnailListenerInfo*>(event);
-        if (callbackInfo) {
-            auto listener = callbackInfo->listener_.promote();
-            if (listener != nullptr) {
-                listener->UpdateJSCallback();
-                MEDIA_INFO_LOG("ThumbnailListener:UpdateJSCallbackAsync() complete");
-            }
-            delete callbackInfo;
-        }
-    };
-    if (napi_ok != napi_send_event(env_, task, napi_eprio_immediate)) {
-        MEDIA_ERR_LOG("ThumbnailListener:UpdateJSCallbackAsync() failed to execute work");
-    } else {
-        callbackInfo.release();
-    }
-}
-
 PhotoOutputNapi::PhotoOutputNapi() {}
 
 PhotoOutputNapi::~PhotoOutputNapi()
 {
-    if (pictureListener_) {
-        pictureListener_->gainmapImageListener = nullptr;
-        pictureListener_->deepImageListener = nullptr;
-        pictureListener_->exifImageListener = nullptr;
-        pictureListener_->debugImageListener = nullptr;
-    }
-    pictureListener_ = nullptr;
     MEDIA_DEBUG_LOG("~PhotoOutputNapi is called");
 }
 
@@ -2069,85 +763,52 @@ bool PhotoOutputNapi::IsPhotoOutput(napi_env env, napi_value obj)
     return result;
 }
 
-void PhotoOutputNapi::CreateMultiChannelPictureLisenter(napi_env env)
-{
-    if (pictureListener_ == nullptr) {
-        MEDIA_INFO_LOG("new photoListener and register surface consumer listener");
-        sptr<PictureListener> pictureListener = new (std::nothrow) PictureListener();
-        CHECK_ERROR_RETURN_LOG(pictureListener == nullptr, "pictureListener is null!");
-        pictureListener->InitPictureListeners(env, photoOutput_);
-        if (photoListener_ == nullptr) {
-            sptr<PhotoListener> photoListener = new (std::nothrow)
-                PhotoListener(env, photoOutput_->GetPhotoSurface(), photoOutput_);
-            SurfaceError ret = photoOutput_->GetPhotoSurface()->RegisterConsumerListener(
-                (sptr<IBufferConsumerListener> &)photoListener);
-            CHECK_ERROR_PRINT_LOG(ret != SURFACE_ERROR_OK, "register surface consumer listener failed!");
-            photoListener_ = photoListener;
-            pictureListener_ = pictureListener;
-        }
-        auto taskManager = photoOutput_->GetDefaultTaskManager();
-        if (taskManager == nullptr) {
-            constexpr int32_t auxiliaryPictureCount = 4;
-            auto taskManager = std::make_shared<DeferredProcessing::TaskManager>("AuxilaryPictureListener",
-                auxiliaryPictureCount, false);
-            photoOutput_->SetDefaultTaskManager(taskManager);
-        }
-    }
-}
-
-void PhotoOutputNapi::CreateSingleChannelPhotoLisenter(napi_env env)
-{
-    if (photoListener_ == nullptr) {
-        MEDIA_INFO_LOG("new photoListener and register surface consumer listener");
-        sptr<PhotoListener> photoListener = new (std::nothrow)
-            PhotoListener(env, photoOutput_->GetPhotoSurface(), photoOutput_);
-        SurfaceError ret =
-            photoOutput_->GetPhotoSurface()->RegisterConsumerListener((sptr<IBufferConsumerListener> &)photoListener);
-        CHECK_ERROR_PRINT_LOG(ret != SURFACE_ERROR_OK, "register surface consumer listener failed!");
-        photoListener_ = photoListener;
-    }
-}
-
 napi_value PhotoOutputNapi::CreatePhotoOutput(napi_env env, Profile& profile, std::string surfaceId)
 {
     MEDIA_DEBUG_LOG("CreatePhotoOutput is called, profile CameraFormat= %{public}d", profile.GetCameraFormat());
     CAMERA_SYNC_TRACE;
     napi_value result = nullptr;
     napi_get_undefined(env, &result);
-    napi_value constructors;
-    napi_status status = napi_get_reference_value(env, sConstructor_, &constructors);
+    napi_value constructor;
+    napi_status status = napi_get_reference_value(env, sConstructor_, &constructor);
     if (status == napi_ok) {
         MEDIA_INFO_LOG("CreatePhotoOutput surfaceId: %{public}s", surfaceId.c_str());
-        sptr<Surface> photoSurface;
+        int retCode = SUCCESS;
         if (surfaceId == "") {
             MEDIA_INFO_LOG("create surface as consumer");
-            photoSurface = Surface::CreateSurfaceAsConsumer("photoOutput");
+            retCode = CameraManager::GetInstance()->CreatePhotoOutput(profile, &sPhotoOutput_);
         } else {
             MEDIA_INFO_LOG("get surface by surfaceId");
+            sptr<Surface> photoSurface;
             photoSurface = Media::ImageReceiver::getSurfaceById(surfaceId);
+            CHECK_ERROR_RETURN_RET_LOG(photoSurface == nullptr, result, "failed to get photoSurface");
+            photoSurface->SetUserData(CameraManager::surfaceFormat, std::to_string(profile.GetCameraFormat()));
+            sptr<IBufferProducer> producer = photoSurface->GetProducer();
+            CHECK_ERROR_RETURN_RET_LOG(producer == nullptr, result, "failed to create GetProducer");
+            MEDIA_INFO_LOG("profile width: %{public}d, height: %{public}d, format = %{public}d, "
+                           "surface width: %{public}d, height: %{public}d",
+                profile.GetSize().width,
+                profile.GetSize().height,
+                static_cast<int32_t>(profile.GetCameraFormat()),
+                photoSurface->GetDefaultWidth(),
+                photoSurface->GetDefaultHeight());
+            retCode =
+                CameraManager::GetInstance()->CreatePhotoOutput(profile, producer, &sPhotoOutput_, photoSurface);
         }
-        CHECK_ERROR_RETURN_RET_LOG(photoSurface == nullptr, result, "failed to get surface");
-        photoSurface->SetUserData(CameraManager::surfaceFormat, std::to_string(profile.GetCameraFormat()));
-        sptr<IBufferProducer> surfaceProducer = photoSurface->GetProducer();
-        MEDIA_INFO_LOG("profile width: %{public}d, height: %{public}d, format = %{public}d, "
-                       "surface width: %{public}d, height: %{public}d", profile.GetSize().width,
-                       profile.GetSize().height, static_cast<int32_t>(profile.GetCameraFormat()),
-                       photoSurface->GetDefaultWidth(), photoSurface->GetDefaultHeight());
-        int retCode =
-            CameraManager::GetInstance()->CreatePhotoOutput(profile, surfaceProducer, &sPhotoOutput_, photoSurface);
         CHECK_ERROR_RETURN_RET_LOG(!CameraNapiUtils::CheckError(env, retCode) || sPhotoOutput_ == nullptr,
             result, "failed to create CreatePhotoOutput");
         CHECK_EXECUTE(surfaceId == "", sPhotoOutput_->SetNativeSurface(true));
-        CHECK_EXECUTE(sPhotoOutput_->IsYuvOrHeifPhoto(), sPhotoOutput_->CreateMultiChannel());
-        status = napi_new_instance(env, constructors, 0, nullptr, &result);
+        status = napi_new_instance(env, constructor, 0, nullptr, &result);
         sPhotoOutput_ = nullptr;
-        CHECK_ERROR_RETURN_RET_LOG(status == napi_ok && result != nullptr, result,
-            "Success to create photo output instance");
+        if (status == napi_ok && result != nullptr) {
+            MEDIA_INFO_LOG("Success to create photo output instance");
+            return result;
+        }
     }
     MEDIA_ERR_LOG("CreatePhotoOutput call Failed!");
     return result;
 }
-
+ 
 napi_value PhotoOutputNapi::CreatePhotoOutput(napi_env env, std::string surfaceId)
 {
     MEDIA_INFO_LOG("CreatePhotoOutput with only surfaceId is called");
@@ -2159,27 +820,31 @@ napi_value PhotoOutputNapi::CreatePhotoOutput(napi_env env, std::string surfaceI
     status = napi_get_reference_value(env, sConstructor_, &constructor);
     if (status == napi_ok) {
         MEDIA_INFO_LOG("CreatePhotoOutput surfaceId: %{public}s", surfaceId.c_str());
-        sptr<Surface> photoSurface;
+        int retCode = SUCCESS;
         if (surfaceId == "") {
             MEDIA_INFO_LOG("create surface as consumer");
-            photoSurface = Surface::CreateSurfaceAsConsumer("photoOutput");
+            retCode = CameraManager::GetInstance()->CreatePhotoOutputWithoutProfile(surfaceId, &sPhotoOutput_);
         } else {
             MEDIA_INFO_LOG("get surface by surfaceId");
-            photoSurface = Media::ImageReceiver::getSurfaceById(surfaceId);
+            sptr<Surface> photoSurface = Media::ImageReceiver::getSurfaceById(surfaceId);
+            CHECK_ERROR_RETURN_RET_LOG(photoSurface == nullptr, result, "failed to get photoSurface");
+            sptr<IBufferProducer> producer = photoSurface->GetProducer();
+            CHECK_ERROR_RETURN_RET_LOG(producer == nullptr, result, "failed to create GetProducer");
+            MEDIA_INFO_LOG("surface width: %{public}d, height: %{public}d",
+                photoSurface->GetDefaultWidth(),
+                photoSurface->GetDefaultHeight());
+            retCode = CameraManager::GetInstance()->CreatePhotoOutputWithoutProfile(
+            producer, &sPhotoOutput_, photoSurface);
         }
-        CHECK_ERROR_RETURN_RET_LOG(photoSurface == nullptr, result, "failed to get surface");
-        sptr<IBufferProducer> surfaceProducer = photoSurface->GetProducer();
-        MEDIA_INFO_LOG("surface width: %{public}d, height: %{public}d", photoSurface->GetDefaultWidth(),
-            photoSurface->GetDefaultHeight());
-        int retCode = CameraManager::GetInstance()->CreatePhotoOutputWithoutProfile(
-            surfaceProducer, &sPhotoOutput_, photoSurface);
         CHECK_ERROR_RETURN_RET_LOG(!CameraNapiUtils::CheckError(env, retCode) || sPhotoOutput_ == nullptr,
             result, "failed to create CreatePhotoOutput");
         CHECK_EXECUTE(surfaceId == "", sPhotoOutput_->SetNativeSurface(true));
         status = napi_new_instance(env, constructor, 0, nullptr, &result);
         sPhotoOutput_ = nullptr;
-        CHECK_ERROR_RETURN_RET_LOG(status == napi_ok && result != nullptr, result,
-            "Success to create photo output instance");
+        if (status == napi_ok && result != nullptr) {
+            MEDIA_DEBUG_LOG("Success to create photo output instance");
+            return result;
+        }
     }
     MEDIA_ERR_LOG("CreatePhotoOutput call Failed!");
     return result;
@@ -2608,6 +1273,11 @@ napi_value PhotoOutputNapi::EnableMovingPhoto(napi_env env, napi_callback_info i
     return result;
 }
 
+enum VideoCodecType : int32_t {
+    VIDEO_ENCODE_TYPE_AVC = 0,
+    VIDEO_ENCODE_TYPE_HEVC,
+};
+
 napi_value PhotoOutputNapi::GetSupportedMovingPhotoVideoCodecTypes(napi_env env, napi_callback_info info)
 {
     MEDIA_DEBUG_LOG("PhotoOutputNapi::GetSupportedMovingPhotoVideoCodecTypes is called");
@@ -2733,18 +1403,6 @@ napi_value PhotoOutputNapi::EnableRawDelivery(napi_env env, napi_callback_info i
         int32_t retCode = photoOutputNapi->photoOutput_->EnableRawDelivery(rawDeliverySwitch);
         CHECK_ERROR_RETURN_RET(retCode != 0 && !CameraNapiUtils::CheckError(env, retCode), result);
     }
-    MEDIA_INFO_LOG("new rawPhotoListener and register surface consumer listener");
-    CHECK_ERROR_RETURN_RET_LOG(photoOutputNapi == nullptr, result, "photoOutputNapi is null!");
-    auto rawSurface = photoOutputNapi->photoOutput_->rawPhotoSurface_;
-    CHECK_ERROR_RETURN_RET_LOG(rawSurface == nullptr, result, "rawPhotoSurface_ is null!");
-    sptr<RawPhotoListener> rawPhotoListener = new (std::nothrow) RawPhotoListener(env, rawSurface);
-    CHECK_ERROR_RETURN_RET_LOG(rawPhotoListener == nullptr, result, "failed to new rawPhotoListener");
-    SurfaceError ret = rawSurface->RegisterConsumerListener((sptr<IBufferConsumerListener>&)rawPhotoListener);
-    CHECK_ERROR_PRINT_LOG(ret != SURFACE_ERROR_OK, "register surface consumer listener failed!");
-    photoOutputNapi->rawPhotoListener_ = rawPhotoListener;
-    napi_value callback;
-    napi_get_reference_value(env, rawCallback_, &callback);
-    photoOutputNapi->rawPhotoListener_->SaveCallbackReference(CONST_CAPTURE_PHOTO_AVAILABLE, callback, false);
     return result;
 }
 
@@ -2763,127 +1421,97 @@ napi_value PhotoOutputNapi::GetActiveProfile(napi_env env, napi_callback_info in
 void PhotoOutputNapi::RegisterQuickThumbnailCallbackListener(
     const std::string& eventName, napi_env env, napi_value callback, const std::vector<napi_value>& args, bool isOnce)
 {
-    CHECK_ERROR_RETURN_LOG(!CameraNapiSecurity::CheckSystemApp(env), "SystemApi quickThumbnail on is called!");
-
-    // Set callback for exposureStateChange
-    if (thumbnailListener_ == nullptr) {
-        if (!isQuickThumbnailEnabled_) {
-            MEDIA_ERR_LOG("quickThumbnail is not enabled!");
-            napi_throw_error(env, std::to_string(SESSION_NOT_RUNNING).c_str(), "");
-            return;
-        }
-        thumbnailListener_ = new ThumbnailListener(env, photoOutput_);
-        photoOutput_->SetThumbnailListener((sptr<IBufferConsumerListener>&)thumbnailListener_);
+    CHECK_ERROR_RETURN_LOG(!CameraNapiSecurity::CheckSystemApp(env), "SystemApi!");
+    MEDIA_INFO_LOG("PhotoOutputNapi RegisterQuickThumbnailCallbackListener!");
+    CHECK_ERROR_RETURN_LOG(photoOutput_ == nullptr, "PhotoOutput is null!");
+    if (photoOutputCallback_ == nullptr) {
+        photoOutputCallback_ = std::make_shared<PhotoOutputCallback>(env);
+        photoOutput_->SetCallback(photoOutputCallback_);
     }
-    thumbnailListener_->SaveCallbackReference(eventName, callback, isOnce);
+    photoOutput_->SetThumbnailCallback(photoOutputCallback_);
+    photoOutputCallback_->SaveCallbackReference(CONST_CAPTURE_QUICK_THUMBNAIL, callback, isOnce);
 }
 
 void PhotoOutputNapi::UnregisterQuickThumbnailCallbackListener(
     const std::string& eventName, napi_env env, napi_value callback, const std::vector<napi_value>& args)
 {
-    CHECK_ERROR_RETURN_LOG(!CameraNapiSecurity::CheckSystemApp(env), "SystemApi quickThumbnail off is called!");
+    CHECK_ERROR_RETURN_LOG(!CameraNapiSecurity::CheckSystemApp(env), "SystemApi!");
     if (!isQuickThumbnailEnabled_) {
         MEDIA_ERR_LOG("quickThumbnail is not enabled!");
         napi_throw_error(env, std::to_string(SESSION_NOT_RUNNING).c_str(), "");
         return;
     }
-    if (thumbnailListener_ != nullptr) {
-        thumbnailListener_->RemoveCallbackRef(eventName, callback);
-        auto taskManager = thumbnailListener_->GetDefaultTaskManager();
-        if (taskManager) {
-            thumbnailListener_->ClearTaskManager();
-        }
-    }
+
+    CHECK_ERROR_RETURN_LOG(photoOutput_ == nullptr, "PhotoOutput is null!");
+    CHECK_ERROR_RETURN_LOG(photoOutputCallback_ == nullptr, "photoOutputCallback is null!");
+    photoOutput_->UnSetThumbnailAvailableCallback();
+    photoOutputCallback_->RemoveCallbackRef(CONST_CAPTURE_QUICK_THUMBNAIL, callback);
 }
 
 void PhotoOutputNapi::RegisterPhotoAvailableCallbackListener(
     const std::string& eventName, napi_env env, napi_value callback, const std::vector<napi_value>& args, bool isOnce)
 {
-    CHECK_ERROR_RETURN_LOG(photoOutput_->GetPhotoSurface() == nullptr, "PhotoSurface_ is null!");
-    if (photoListener_ == nullptr) {
-        MEDIA_INFO_LOG("new photoListener and register surface consumer listener");
-        sptr<PhotoListener> photoListener = new (std::nothrow)
-            PhotoListener(env, photoOutput_->GetPhotoSurface(), photoOutput_);
-        CHECK_ERROR_RETURN_LOG(photoListener == nullptr, "photoListener is null!");
-        SurfaceError ret =
-            photoOutput_->GetPhotoSurface()->RegisterConsumerListener((sptr<IBufferConsumerListener> &)photoListener);
-        CHECK_ERROR_PRINT_LOG(ret != SURFACE_ERROR_OK, "register surface consumer listener failed!");
-        photoListener_ = photoListener;
-    }
-    photoListener_->SaveCallback(CONST_CAPTURE_PHOTO_AVAILABLE, callback);
-
-    // Preconfig can't support rawPhotoListener.
-    if (photoOutput_ != nullptr && profile_ != nullptr) {
-        napi_ref rawCallback;
-        napi_create_reference(env, callback, 1, &rawCallback);
-        rawCallback_ = rawCallback;
-        CHECK_EXECUTE(profile_->GetCameraFormat() == CAMERA_FORMAT_YUV_420_SP, CreateMultiChannelPictureLisenter(env));
+    MEDIA_INFO_LOG("PhotoOutputNapi RegisterPhotoAvailableCallbackListener!");
+    CHECK_ERROR_RETURN_LOG(photoOutput_ == nullptr, "PhotoOutput is null!");
+    if (photoOutputCallback_ == nullptr) {
+        photoOutputCallback_ = std::make_shared<PhotoOutputCallback>(env);
+        photoOutput_->SetCallback(photoOutputCallback_);
     }
+    photoOutput_->SetPhotoAvailableCallback(photoOutputCallback_);
+    photoOutputCallback_->SaveCallbackReference(CONST_CAPTURE_PHOTO_AVAILABLE, callback, isOnce);
+    callbackFlag_ |= CAPTURE_PHOTO;
+    photoOutput_->SetCallbackFlag(callbackFlag_);
 }
 
 void PhotoOutputNapi::UnregisterPhotoAvailableCallbackListener(
     const std::string& eventName, napi_env env, napi_value callback, const std::vector<napi_value>& args)
 {
-    if (photoListener_ != nullptr) {
-        photoListener_->RemoveCallback(CONST_CAPTURE_PHOTO_AVAILABLE, callback);
-        if (photoListener_->IsEmpty(CONST_CAPTURE_PHOTO_AVAILABLE)) {
-            photoListener_->ClearTaskManager();
-        }
-    }
-    CHECK_EXECUTE(rawPhotoListener_ != nullptr,
-        rawPhotoListener_->RemoveCallbackRef(CONST_CAPTURE_PHOTO_AVAILABLE, callback));
+    CHECK_ERROR_RETURN_LOG(photoOutput_ == nullptr, "PhotoOutput is null!");
+    CHECK_ERROR_RETURN_LOG(photoOutputCallback_ == nullptr, "photoOutputCallback is null!");
+    photoOutput_->UnSetPhotoAvailableCallback();
+    callbackFlag_ &= ~CAPTURE_PHOTO;
+    photoOutput_->SetCallbackFlag(callbackFlag_);
+    photoOutputCallback_->RemoveCallbackRef(CONST_CAPTURE_PHOTO_AVAILABLE, callback);
 }