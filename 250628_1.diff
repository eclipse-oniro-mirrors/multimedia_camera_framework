diff --git a/interfaces/inner_api/native/camera/include/output/photo_output_callback.h b/interfaces/inner_api/native/camera/include/output/photo_output_callback.h
new file mode 100644
index 000000000..1d9617c0b
--- /dev/null
+++ b/interfaces/inner_api/native/camera/include/output/photo_output_callback.h
@@ -0,0 +1,141 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_PHOTO_OUTPUT_CALLBACK_H
+#define OHOS_CAMERA_PHOTO_OUTPUT_CALLBACK_H
+
+#include "hstream_capture_photo_callback_stub.h"
+#include "hstream_capture_thumbnail_callback_stub.h"
+#include "stream_capture_photo_asset_callback_stub.h"
+#include <native_image.h>
+#include <pixel_map.h>
+
+
+namespace OHOS {
+namespace CameraStandard {
+class PhotoOutput;
+class PhotoAvailableCallback {
+public:
+    PhotoAvailableCallback() = default;
+    virtual ~PhotoAvailableCallback() = default;
+
+    virtual void OnPhotoAvailable(const std::shared_ptr<Media::NativeImage> nativeImage, bool isRaw) const = 0;
+};
+
+class PhotoAssetAvailableCallback {
+public:
+    PhotoAssetAvailableCallback() = default;
+    virtual ~PhotoAssetAvailableCallback() = default;
+
+    virtual void OnPhotoAssetAvailable(const int32_t captureId, const std::string &uri,
+        int32_t cameraShotType, const std::string &burstKey) const = 0;
+};
+
+class ThumbnailCallback {
+public:
+    ThumbnailCallback() = default;
+    virtual ~ThumbnailCallback() = default;
+
+    virtual void OnThumbnailAvailable(int32_t captureId, int64_t timestamp,
+        std::unique_ptr<Media::PixelMap> pixelMap) const = 0;
+};
+
+class CameraBufferProcessor : public Media::IBufferProcessor {
+public:
+    explicit CameraBufferProcessor(sptr<Surface> surface) : surface_(surface) {}
+    ~CameraBufferProcessor()
+    {
+        surface_ = nullptr;
+    }
+    void BufferRelease(sptr<SurfaceBuffer>& buffer) override
+    {
+        if (surface_ != nullptr) {
+            surface_->ReleaseBuffer(buffer, -1);
+        }
+    }
+
+private:
+    wptr<Surface> surface_ = nullptr;
+};
+
+class HStreamCapturePhotoCallbackImpl : public HStreamCapturePhotoCallbackStub {
+public:
+    explicit HStreamCapturePhotoCallbackImpl(PhotoOutput* photoOutput) : innerPhotoOutput_(photoOutput) {}
+
+    ~HStreamCapturePhotoCallbackImpl() = default;
+
+    int32_t OnPhotoAvailable(sptr<SurfaceBuffer> surfaceBuffer, int64_t timestamp, bool isRaw) override;
+
+    inline sptr<PhotoOutput> GetPhotoOutput()
+    {
+        if (innerPhotoOutput_ == nullptr) {
+            return nullptr;
+        }
+        return innerPhotoOutput_.promote();
+    }
+
+private:
+    wptr<PhotoOutput> innerPhotoOutput_ = nullptr;
+};
+
+class HStreamCapturePhotoAssetCallbackImpl : public StreamCapturePhotoAssetCallbackStub {
+public:
+    explicit HStreamCapturePhotoAssetCallbackImpl(PhotoOutput *photoOutput) : innerPhotoOutput_(photoOutput)
+    {}
+
+    ~HStreamCapturePhotoAssetCallbackImpl() = default;
+
+    int32_t OnPhotoAssetAvailable(
+        int32_t captureId, const std::string &uri, int32_t cameraShotType, const std::string &burstKey) override;
+
+    inline sptr<PhotoOutput> GetPhotoOutput()
+    {
+        if (innerPhotoOutput_ == nullptr) {
+            return nullptr;
+        }
+        return innerPhotoOutput_.promote();
+    }
+
+private:
+    wptr<PhotoOutput> innerPhotoOutput_ = nullptr;
+};
+
+class HStreamCaptureThumbnailCallbackImpl : public HStreamCaptureThumbnailCallbackStub {
+public:
+    explicit HStreamCaptureThumbnailCallbackImpl(PhotoOutput* photoOutput) : innerPhotoOutput_(photoOutput) {}
+
+    ~HStreamCaptureThumbnailCallbackImpl() = default;
+
+    int32_t OnThumbnailAvailable(sptr<SurfaceBuffer> surfaceBuffer, int64_t timestamp) override;
+
+    inline sptr<PhotoOutput> GetPhotoOutput()
+    {
+        if (innerPhotoOutput_ == nullptr) {
+            return nullptr;
+        }
+        return innerPhotoOutput_.promote();
+    }
+
+private:
+    std::unique_ptr<Media::PixelMap> CreatePixelMapFromSurfaceBuffer(sptr<SurfaceBuffer> &surfaceBuffer,
+        int32_t width, int32_t height, bool isHdr);
+    std::unique_ptr<Media::PixelMap> SetPixelMapYuvInfo(sptr<SurfaceBuffer> &surfaceBuffer,
+        std::unique_ptr<Media::PixelMap> pixelMap, bool isHdr);
+
+    wptr<PhotoOutput> innerPhotoOutput_ = nullptr;
+};
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_PHOTO_OUTPUT_CALLBACK_H
diff --git a/interfaces/kits/js/camera_napi/BUILD.gn b/interfaces/kits/js/camera_napi/BUILD.gn
index ff88303ad..7554d5a80 100644
--- a/interfaces/kits/js/camera_napi/BUILD.gn
+++ b/interfaces/kits/js/camera_napi/BUILD.gn
@@ -77,7 +77,6 @@ ohos_shared_library("camera_napi") {
     "${multimedia_camera_framework_path}/frameworks/js/camera_napi/src/mode/video_session_for_sys_napi.cpp",
     "${multimedia_camera_framework_path}/frameworks/js/camera_napi/src/mode/video_session_napi.cpp",
     "${multimedia_camera_framework_path}/frameworks/js/camera_napi/src/native_module_ohos_camera.cpp",
-    "${multimedia_camera_framework_path}/frameworks/js/camera_napi/src/output/deferred_photo_proxy_napi.cpp",
     "${multimedia_camera_framework_path}/frameworks/js/camera_napi/src/output/depth_data_napi.cpp",
     "${multimedia_camera_framework_path}/frameworks/js/camera_napi/src/output/depth_data_output_napi.cpp",
     "${multimedia_camera_framework_path}/frameworks/js/camera_napi/src/output/metadata_output_napi.cpp",
@@ -110,8 +109,6 @@ ohos_shared_library("camera_napi") {
     "image_framework:image",
     "image_framework:image_native",
     "ipc:ipc_core",
-    "media_library:media_library",
-    "media_library:media_library_manager",
     "media_library:medialibrary_nutils",
     "napi:ace_napi",
     "qos_manager:qos",
@@ -134,6 +131,14 @@ ohos_shared_library("camera_napi") {
     "-fPIC",
     "-DIMAGE_COLORSPACE_FLAG",
     "-Os",
+    "-fno-merge-all-constants",
+    "-flto",
+    "-ffunction-sections"
+  ]
+
+  ldflags = [
+    "-Wl,--gc-sections",
+    "-fPIE",
   ]
 
   version_script = "libcamera_napi.map"
diff --git a/interfaces/kits/js/camera_napi/include/output/photo_napi.h b/interfaces/kits/js/camera_napi/include/output/photo_napi.h
index d5423bb52..24ee4b1be 100644
--- a/interfaces/kits/js/camera_napi/include/output/photo_napi.h
+++ b/interfaces/kits/js/camera_napi/include/output/photo_napi.h
@@ -25,7 +25,7 @@ static const char PHOTO_NAPI_CLASS_NAME[] = "Photo";
 class PhotoNapi {
 public:
     static napi_value Init(napi_env env, napi_value exports);
-    static napi_value CreatePhoto(napi_env env, napi_value mainImage);
+    static napi_value CreatePhoto(napi_env env, napi_value mainImage, bool isRaw = false);
     static napi_value CreateRawPhoto(napi_env env, napi_value mainImage);
     PhotoNapi();
     ~PhotoNapi();
diff --git a/interfaces/kits/js/camera_napi/include/output/photo_output_napi.h b/interfaces/kits/js/camera_napi/include/output/photo_output_napi.h
index 3a36248d1..51d86cd73 100644
--- a/interfaces/kits/js/camera_napi/include/output/photo_output_napi.h
+++ b/interfaces/kits/js/camera_napi/include/output/photo_output_napi.h
@@ -28,6 +28,7 @@
 #include "native_image.h"
 #include "output/camera_output_capability.h"
 #include "output/photo_output.h"
+#include "output/photo_output_callback.h"
 #include "pixel_map.h"
 
 namespace OHOS::Media {
@@ -65,6 +66,12 @@ struct CallbackInfo {
     int32_t frameCount = 0;
     int32_t errorCode;
     int32_t duration;
+    std::shared_ptr<Media::NativeImage> nativeImage;
+    std::shared_ptr<Media::PixelMap> pixelMap;
+    bool isRaw = false;
+    std::string uri;
+    int32_t cameraShotType;
+    std::string burstKey;
 };
 
 enum PhotoOutputEventType {
@@ -78,6 +85,7 @@ enum PhotoOutputEventType {
     CAPTURE_PHOTO_AVAILABLE,
     CAPTURE_DEFERRED_PHOTO_AVAILABLE,
     CAPTURE_PHOTO_ASSET_AVAILABLE,
+    CAPTURE_THUMBNAIL_AVAILABLE,
     CAPTURE_ESTIMATED_CAPTURE_DURATION,
     CAPTURE_START_WITH_INFO,
     CAPTURE_OFFLINE_DELIVERY_FINISHED
@@ -89,6 +97,7 @@ static EnumHelper<PhotoOutputEventType> PhotoOutputEventTypeHelper({
         {CAPTURE_FRAME_SHUTTER, CONST_CAPTURE_FRAME_SHUTTER},
         {CAPTURE_ERROR, CONST_CAPTURE_ERROR},
         {CAPTURE_PHOTO_AVAILABLE, CONST_CAPTURE_PHOTO_AVAILABLE},
+        {CAPTURE_THUMBNAIL_AVAILABLE, CONST_CAPTURE_QUICK_THUMBNAIL},
         {CAPTURE_DEFERRED_PHOTO_AVAILABLE, CONST_CAPTURE_DEFERRED_PHOTO_AVAILABLE},
         {CAPTURE_PHOTO_ASSET_AVAILABLE, CONST_CAPTURE_PHOTO_ASSET_AVAILABLE},
         {CAPTURE_FRAME_SHUTTER_END, CONST_CAPTURE_FRAME_SHUTTER_END},
@@ -116,105 +125,10 @@ static EnumHelper<SurfaceType> SurfaceTypeHelper({
     SurfaceType::INVALID_SURFACE
 );
 
-class PhotoBufferProcessor : public Media::IBufferProcessor {
-public:
-    explicit PhotoBufferProcessor(sptr<Surface> photoSurface) : photoSurface_(photoSurface) {}
-    ~PhotoBufferProcessor()
-    {
-        photoSurface_ = nullptr;
-    }
-    void BufferRelease(sptr<SurfaceBuffer>& buffer) override
-    {
-        if (photoSurface_ != nullptr) {
-            photoSurface_->ReleaseBuffer(buffer, -1);
-        }
-    }
-
-private:
-    sptr<Surface> photoSurface_ = nullptr;
-};
-
-class PhotoListener : public IBufferConsumerListener,
-                      public ListenerBase,
-                      public std::enable_shared_from_this<PhotoListener> {
-public:
-    explicit PhotoListener(napi_env env, const sptr<Surface> photoSurface, wptr<PhotoOutput> photoOutput);
-    virtual ~PhotoListener();
-    void OnBufferAvailable() override;
-    void SaveCallback(const std::string eventName, napi_value callback);
-    void RemoveCallback(const std::string eventName, napi_value callback);
-    void ExecuteDeepCopySurfaceBuffer();
-
-    void ClearTaskManager();
-    std::shared_ptr<DeferredProcessing::TaskManager> GetDefaultTaskManager();
-
-private:
-
-    void UpdateJSCallback(sptr<Surface> photoSurface) const;
-    void UpdateJSCallbackAsync(sptr<Surface> photoSurface) const;
-    void UpdatePictureJSCallback(int32_t captureId, const string uri, int32_t cameraShotType,
-        const std::string burstKey) const;
-    void UpdateMainPictureStageOneJSCallback(sptr<SurfaceBuffer> surfaceBuffer, int64_t timestamp) const;
-    void ExecutePhoto(sptr<SurfaceBuffer> surfaceBfuffer, int64_t timestamp) const;
-    void ExecuteDeferredPhoto(sptr<SurfaceBuffer> surfaceBuffer) const;
-    void DeepCopyBuffer(sptr<SurfaceBuffer> newSurfaceBuffer, sptr<SurfaceBuffer> surfaceBuffer,
-        int32_t captureId) const;
-    void ExecutePhotoAsset(sptr<SurfaceBuffer> surfaceBuffer, bool isHighQuality, int64_t timestamp) const;
-    void CreateMediaLibrary(sptr<SurfaceBuffer> surfaceBuffer, BufferHandle* bufferHandle, bool isHighQuality,
-        std::string& uri, int32_t& cameraShotType, std::string &burstKey, int64_t timestamp) const;
-    void AssembleAuxiliaryPhoto(int64_t timestamp, int32_t captureId);
-    void ProcessAuxiliaryPhoto(int64_t timestamp, sptr<PhotoOutput> photoOutput, int32_t captureId);
-    int32_t GetAuxiliaryPhotoCount(sptr<SurfaceBuffer> surfaceBuffer);
-    sptr<Surface> photoSurface_;
-    wptr<PhotoOutput> photoOutput_;
-    shared_ptr<PhotoBufferProcessor> bufferProcessor_;
-    uint8_t callbackFlag_ = 0;
-    std::mutex taskManagerMutex_;
-    std::shared_ptr<DeferredProcessing::TaskManager> taskManager_ = nullptr;
-};
-
-class RawPhotoListener : public IBufferConsumerListener, public ListenerBase,
-    public std::enable_shared_from_this<RawPhotoListener> {
-public:
-    explicit RawPhotoListener(napi_env env, const sptr<Surface> rawPhotoSurface);
-    ~RawPhotoListener() = default;
-    void OnBufferAvailable() override;
-
-private:
-    sptr<Surface> rawPhotoSurface_;
-    shared_ptr<PhotoBufferProcessor> bufferProcessor_;
-    void UpdateJSCallback(sptr<Surface> rawPhotoSurface) const;
-    void UpdateJSCallbackAsync(sptr<Surface> rawPhotoSurface) const;
-    void ExecuteRawPhoto(sptr<SurfaceBuffer> rawPhotoSurface) const;
-};
-
-class AuxiliaryPhotoListener : public IBufferConsumerListener {
-public:
-    explicit AuxiliaryPhotoListener(const std::string surfaceName, const sptr<Surface> surface,
-        wptr<PhotoOutput> photoOutput);
-    ~AuxiliaryPhotoListener() = default;
-    void OnBufferAvailable() override;
-    void ExecuteDeepCopySurfaceBuffer();
-private:
-    void DeepCopyBuffer(sptr<SurfaceBuffer> newSurfaceBuffer, sptr<SurfaceBuffer> surfaceBuffer, int32_t) const;
-    std::string surfaceName_;
-    sptr<Surface> surface_;
-    wptr<PhotoOutput> photoOutput_;
-    shared_ptr<PhotoBufferProcessor> bufferProcessor_;
-};
-
-class PictureListener : public RefBase {
-public:
-    explicit PictureListener() = default;
-    ~PictureListener() = default;
-    void InitPictureListeners(napi_env env, wptr<PhotoOutput> photoOutput);
-    sptr<AuxiliaryPhotoListener> gainmapImageListener;
-    sptr<AuxiliaryPhotoListener> deepImageListener;
-    sptr<AuxiliaryPhotoListener> exifImageListener;
-    sptr<AuxiliaryPhotoListener> debugImageListener;
-};
-
 class PhotoOutputCallback : public PhotoStateCallback,
+                            public PhotoAvailableCallback,
+                            public PhotoAssetAvailableCallback,
+                            public ThumbnailCallback,
                             public ListenerBase,
                             public std::enable_shared_from_this<PhotoOutputCallback> {
 public:
@@ -230,6 +144,13 @@ public:
     void OnCaptureError(const int32_t captureId, const int32_t errorCode) const override;
     void OnEstimatedCaptureDuration(const int32_t duration) const override;
     void OnOfflineDeliveryFinished(const int32_t captureId) const override;
+    void OnPhotoAvailable(
+        const std::shared_ptr<Media::NativeImage> nativeImage, const bool isRaw = false) const override;
+    void OnPhotoAssetAvailable(const int32_t captureId, const std::string &uri, const int32_t cameraShotType,
+        const std::string &burstKey) const override;
+    void OnThumbnailAvailable(
+        const int32_t captureId, const int64_t timestamp, unique_ptr<Media::PixelMap> pixelMap) const override;
+ 
 
 private:
     void UpdateJSCallback(PhotoOutputEventType eventType, const CallbackInfo& info) const;
@@ -243,6 +164,9 @@ private:
     void ExecuteCaptureReadyCb(const CallbackInfo& info) const;
     void ExecuteEstimatedCaptureDurationCb(const CallbackInfo& info) const;
     void ExecuteOfflineDeliveryFinishedCb(const CallbackInfo& info) const;
+    void ExecutePhotoAvailableCb(const CallbackInfo& info) const;
+    void ExecutePhotoAssetAvailableCb(const CallbackInfo& info) const;
+    void ExecuteThumbnailAvailableCb(const CallbackInfo& info) const;
 };
 
 struct PhotoOutputCallbackInfo {
@@ -255,74 +179,6 @@ struct PhotoOutputCallbackInfo {
     {}
 };
 
-class ThumbnailListener : public IBufferConsumerListener, public ListenerBase {
-public:
-    explicit ThumbnailListener(napi_env env, const sptr<PhotoOutput> photoOutput);
-    virtual ~ThumbnailListener();
-    void OnBufferAvailable() override;
-    std::shared_ptr<DeferredProcessing::TaskManager> taskManager_ = nullptr;
-    
-    void ClearTaskManager();
-    std::shared_ptr<DeferredProcessing::TaskManager> GetDefaultTaskManager();
-private:
-    wptr<PhotoOutput> photoOutput_;
-    void UpdateJSCallback() const;
-    void UpdateJSCallbackAsync();
-    void UpdateJSCallback(int32_t captureId, int64_t timestamp, unique_ptr<Media::PixelMap>) const;
-    void UpdateJSCallbackAsync(int32_t captureId, int64_t timestamp, unique_ptr<Media::PixelMap>);
-    void ExecuteDeepCopySurfaceBuffer();
-    
-    unique_ptr<Media::PixelMap> CreatePixelMapFromSurfaceBuffer(sptr<SurfaceBuffer> &surfaceBuffer,
-        int32_t width, int32_t height, bool isHdr);
-    unique_ptr<Media::PixelMap> SetPixelMapYuvInfo(sptr<SurfaceBuffer> &surfaceBuffer,
-        unique_ptr<Media::PixelMap> pixelMap, bool isHdr);
-    void DeepCopyBuffer(sptr<SurfaceBuffer> newSurfaceBuffer, sptr<SurfaceBuffer> surfaceBuffer,
-        int32_t thumbnailWidth, int32_t thumbnailHeight, bool isHdr) const;
-
-    static constexpr int32_t PLANE_Y = 0;
-    static constexpr int32_t PLANE_U = 1;
-    static constexpr uint8_t PIXEL_SIZE_HDR_YUV = 3;
-    static constexpr uint8_t  HDR_PIXEL_SIZE = 2;
-    static constexpr uint8_t SDR_PIXEL_SIZE = 1;
-
-    std::mutex taskManagerMutex_;
-    int32_t recThumb_ = 0;
-    int32_t acqThumb_ = 0;
-};
-
-struct ThumbnailListenerInfo {
-    wptr<ThumbnailListener> listener_;
-    int32_t captureId_;
-    int64_t timestamp_;
-    unique_ptr<Media::PixelMap> pixelMap_;
-    ThumbnailListenerInfo(sptr<ThumbnailListener> listener, int32_t captureId,
-        int64_t timestamp, unique_ptr<Media::PixelMap> pixelMap)
-        : listener_(listener), captureId_(captureId), timestamp_(timestamp), pixelMap_(std::move(pixelMap))
-    {}
-};
-
-struct PhotoListenerInfo {
-    sptr<Surface> photoSurface_;
-    weak_ptr<const PhotoListener> listener_;
-    PhotoListenerInfo(sptr<Surface> photoSurface, shared_ptr<const PhotoListener> listener)
-        : photoSurface_(photoSurface), listener_(listener)
-    {}
-    int32_t captureId = 0;
-    std::string uri = "";
-    int32_t cameraShotType = 0;
-    std::string burstKey = "";
-    sptr<SurfaceBuffer> surfaceBuffer = nullptr;
-    int64_t timestamp = 0;
-};
-
-struct RawPhotoListenerInfo {
-    sptr<Surface> rawPhotoSurface_;
-    weak_ptr<const RawPhotoListener> listener_;
-    RawPhotoListenerInfo(sptr<Surface> rawPhotoSurface, shared_ptr<const RawPhotoListener> listener)
-        : rawPhotoSurface_(rawPhotoSurface), listener_(listener)
-    {}
-};
-
 struct PhotoOutputAsyncContext;
 class PhotoOutputNapi : public CameraNapiEventEmitter<PhotoOutputNapi> {
 public:
@@ -440,13 +296,10 @@ private:
     bool isQuickThumbnailEnabled_ = false;
     bool isDeferredPhotoEnabled_ = false;
     bool isMirrorEnabled_ = false;
-    sptr<ThumbnailListener> thumbnailListener_;
-    sptr<PhotoListener> photoListener_;
-    sptr<RawPhotoListener> rawPhotoListener_;
-    sptr<PictureListener> pictureListener_;
     std::shared_ptr<PhotoOutputCallback> photoOutputCallback_;
     static thread_local uint32_t photoOutputTaskId;
     static thread_local napi_ref rawCallback_;
+    uint8_t callbackFlag_ = 0;
 };
 
 struct PhotoOutputNapiCaptureSetting {
diff --git a/services/camera_service/BUILD.gn b/services/camera_service/BUILD.gn
index 1cf43ea58..4f81c355e 100644
--- a/services/camera_service/BUILD.gn
+++ b/services/camera_service/BUILD.gn
@@ -40,6 +40,11 @@ ohos_shared_library("camera_service") {
     "src/avcodec/moving_photo_video_cache.cpp",
     "src/avcodec/sample_callback.cpp",
     "src/avcodec/video_encoder.cpp",
+    "src/camera_buffer_manager/photo_asset_auxiliary_consumer.cpp",
+    "src/camera_buffer_manager/photo_asset_buffer_consumer.cpp",
+    "src/camera_buffer_manager/photo_buffer_consumer.cpp",
+    "src/camera_buffer_manager/picture_assembler.cpp",
+    "src/camera_buffer_manager/thumbnail_buffer_consumer.cpp",
     "src/camera_common_event_manager.cpp",
     "src/camera_datashare_helper.cpp",
     "src/camera_fwk_metadata_utils.cpp",
@@ -83,10 +88,14 @@ ohos_shared_library("camera_service") {
     "-Wall",
     "-Os",
     "-fstack-protector-strong",
+    "-fno-merge-all-constants",
+    "-flto",
+    "-ffunction-sections"
   ]
 
   ldflags = [
     "-Wl,-z,relro,-z,now",
+    "-Wl,--gc-sections",
     "-fPIE",
   ]
 
@@ -114,6 +123,7 @@ ohos_shared_library("camera_service") {
     "${multimedia_camera_framework_path}/services/camera_service/binder/server/include/window_manager_service_callback_stub",
     "${multimedia_camera_framework_path}/services/camera_service/include/adapter",
     "${multimedia_camera_framework_path}/services/camera_service/include/app_manager_utils",
+    "${multimedia_camera_framework_path}/services/camera_service/include/camera_buffer_manager",
     "${multimedia_camera_framework_path}/services/camera_service/include/dfx",
     "${multimedia_camera_framework_path}/services/camera_service/include/smooth_zoom",
     "${multimedia_camera_framework_path}/services/camera_service/include/avcodec",
diff --git a/services/camera_service/binder/base/include/istream_capture_photo_callback.h b/services/camera_service/binder/base/include/istream_capture_photo_callback.h
new file mode 100644
index 000000000..5598ae817
--- /dev/null
+++ b/services/camera_service/binder/base/include/istream_capture_photo_callback.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_ISTREAM_CAPTURE_PHOTO_CALLBACK_H
+#define OHOS_CAMERA_ISTREAM_CAPTURE_PHOTO_CALLBACK_H
+
+#include "iremote_broker.h"
+#include "surface_buffer.h"
+
+namespace OHOS {
+namespace CameraStandard {
+enum StreamCapturePhotoCallbackInterfaceCode {
+    CAMERA_STREAM_CAPTURE_ON_PHOTO_AVAILABLE,
+};
+
+class IStreamCapturePhotoCallback : public IRemoteBroker {
+public:
+    virtual int32_t OnPhotoAvailable(sptr<SurfaceBuffer> surfaceBuffer, int64_t timestamp, bool isRaw) = 0;
+
+    DECLARE_INTERFACE_DESCRIPTOR(u"IStreamCapturePhotoCallback");
+};
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_ISTREAM_CAPTURE_PHOTO_CALLBACK_H
diff --git a/services/camera_service/binder/base/include/istream_capture_thumbnail_callback.h b/services/camera_service/binder/base/include/istream_capture_thumbnail_callback.h
new file mode 100644
index 000000000..a7223b5a1
--- /dev/null
+++ b/services/camera_service/binder/base/include/istream_capture_thumbnail_callback.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_ISTREAM_CAPTURE_THUMBNAIL_CALLBACK_H
+#define OHOS_CAMERA_ISTREAM_CAPTURE_THUMBNAIL_CALLBACK_H
+
+#include "iremote_broker.h"
+#include "surface_buffer.h"
+
+namespace OHOS {
+namespace CameraStandard {
+enum StreamCaptureThumbnailCallbackInterfaceCode {
+    CAMERA_STREAM_CAPTURE_ON_THUMBNAIL_AVAILABLE,
+};
+
+class IStreamCaptureThumbnailCallback : public IRemoteBroker {
+public:
+    virtual int32_t OnThumbnailAvailable(sptr<SurfaceBuffer> surfaceBuffer, int64_t timestamp) = 0;
+
+    DECLARE_INTERFACE_DESCRIPTOR(u"IStreamCaptureThumbnailCallback");
+};
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_ISTREAM_CAPTURE_THUMBNAIL_CALLBACK_H
diff --git a/services/camera_service/binder/client/include/hstream_capture_photo_callback_proxy.h b/services/camera_service/binder/client/include/hstream_capture_photo_callback_proxy.h
new file mode 100644
index 000000000..4f6c8f82b
--- /dev/null
+++ b/services/camera_service/binder/client/include/hstream_capture_photo_callback_proxy.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_HSTREAM_CAPTURE_THUMBNAIL_CALLBACK_PROXY_H
+#define OHOS_CAMERA_HSTREAM_CAPTURE_THUMBNAIL_CALLBACK_PROXY_H
+#define EXPORT_API __attribute__((visibility("default")))
+
+#include "iremote_proxy.h"
+#include "istream_capture_thumbnail_callback.h"
+
+namespace OHOS {
+namespace CameraStandard {
+class EXPORT_API HStreamCaptureThumbnailCallbackProxy : public IRemoteProxy<IStreamCaptureThumbnailCallback> {
+public:
+    explicit HStreamCaptureThumbnailCallbackProxy(const sptr<IRemoteObject> &impl);
+
+    virtual ~HStreamCaptureThumbnailCallbackProxy() = default;
+
+    int32_t OnThumbnailAvailable(sptr<SurfaceBuffer> surfaceBuffer, int64_t timestamp) override;
+
+private:
+    static inline BrokerDelegator<HStreamCaptureThumbnailCallbackProxy> delegator_;
+};
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_HSTREAM_CAPTURE_THUMBNAIL_CALLBACK_PROXY_H
diff --git a/services/camera_service/binder/client/include/hstream_capture_thumbnail_callback_proxy.h b/services/camera_service/binder/client/include/hstream_capture_thumbnail_callback_proxy.h
new file mode 100644
index 000000000..4f6c8f82b
--- /dev/null
+++ b/services/camera_service/binder/client/include/hstream_capture_thumbnail_callback_proxy.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_HSTREAM_CAPTURE_THUMBNAIL_CALLBACK_PROXY_H
+#define OHOS_CAMERA_HSTREAM_CAPTURE_THUMBNAIL_CALLBACK_PROXY_H
+#define EXPORT_API __attribute__((visibility("default")))
+
+#include "iremote_proxy.h"
+#include "istream_capture_thumbnail_callback.h"
+
+namespace OHOS {
+namespace CameraStandard {
+class EXPORT_API HStreamCaptureThumbnailCallbackProxy : public IRemoteProxy<IStreamCaptureThumbnailCallback> {
+public:
+    explicit HStreamCaptureThumbnailCallbackProxy(const sptr<IRemoteObject> &impl);
+
+    virtual ~HStreamCaptureThumbnailCallbackProxy() = default;
+
+    int32_t OnThumbnailAvailable(sptr<SurfaceBuffer> surfaceBuffer, int64_t timestamp) override;
+
+private:
+    static inline BrokerDelegator<HStreamCaptureThumbnailCallbackProxy> delegator_;
+};
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_HSTREAM_CAPTURE_THUMBNAIL_CALLBACK_PROXY_H
diff --git a/services/camera_service/binder/client/src/hstream_capture_photo_callback_proxy.cpp b/services/camera_service/binder/client/src/hstream_capture_photo_callback_proxy.cpp
new file mode 100644
index 000000000..fe0df68fc
--- /dev/null
+++ b/services/camera_service/binder/client/src/hstream_capture_photo_callback_proxy.cpp
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hstream_capture_photo_callback_proxy.h"
+#include "camera_log.h"
+
+namespace OHOS {
+namespace CameraStandard {
+
+HStreamCapturePhotoCallbackProxy::HStreamCapturePhotoCallbackProxy(const sptr<IRemoteObject> &impl)
+    : IRemoteProxy<IStreamCapturePhotoCallback>(impl)
+{
+    MEDIA_INFO_LOG("HStreamCapturePhotoCallbackProxy new E");
+}
+
+int32_t HStreamCapturePhotoCallbackProxy::OnPhotoAvailable(
+    sptr<SurfaceBuffer> surfaceBuffer, int64_t timestamp, bool isRaw)
+{
+    MEDIA_INFO_LOG("HStreamCapturePhotoCallbackProxy::OnPhotoAvailable is called!");
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option;
+    option.SetFlags(option.TF_ASYNC);
+
+    data.WriteInterfaceToken(GetDescriptor());
+    surfaceBuffer->WriteToMessageParcel(data);
+    sptr<BufferExtraData> bufferExtraData = surfaceBuffer->GetExtraData();
+    bufferExtraData->WriteToParcel(data);
+    data.WriteInt64(timestamp);
+    data.WriteBool(isRaw);
+
+    int error = Remote()->SendRequest(
+        static_cast<uint32_t>(StreamCapturePhotoCallbackInterfaceCode::CAMERA_STREAM_CAPTURE_ON_PHOTO_AVAILABLE),
+        data,
+        reply,
+        option);
+    if (error != ERR_NONE) {
+        MEDIA_ERR_LOG("HStreamCapturePhotoCallbackProxy OnPhotoAvailable failed, error: %{public}d", error);
+    }
+    return error;
+}
+}  // namespace CameraStandard
+}  // namespace OHOS
\ No newline at end of file
diff --git a/services/camera_service/binder/client/src/hstream_capture_thumbnail_callback_proxy.cpp b/services/camera_service/binder/client/src/hstream_capture_thumbnail_callback_proxy.cpp
new file mode 100644
index 000000000..cf3646ca6
--- /dev/null
+++ b/services/camera_service/binder/client/src/hstream_capture_thumbnail_callback_proxy.cpp
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hstream_capture_thumbnail_callback_proxy.h"
+#include "camera_log.h"
+
+namespace OHOS {
+namespace CameraStandard {
+
+HStreamCaptureThumbnailCallbackProxy::HStreamCaptureThumbnailCallbackProxy(const sptr<IRemoteObject> &impl)
+    : IRemoteProxy<IStreamCaptureThumbnailCallback>(impl)
+{
+    MEDIA_INFO_LOG("HStreamCapturePhotoAssetCallbackProxy new E");
+}
+
+int32_t HStreamCaptureThumbnailCallbackProxy::OnThumbnailAvailable(sptr<SurfaceBuffer> surfaceBuffer, int64_t timestamp)
+{
+    MEDIA_INFO_LOG("HStreamCaptureThumbnailCallbackProxy::OnThumbnailAvailable is called!");
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option;
+    option.SetFlags(option.TF_ASYNC);
+
+    data.WriteInterfaceToken(GetDescriptor());
+    surfaceBuffer->WriteToMessageParcel(data);
+    sptr<BufferExtraData> bufferExtraData = surfaceBuffer->GetExtraData();
+    bufferExtraData->WriteToParcel(data);
+    data.WriteInt64(timestamp);
+
+    int error = Remote()->SendRequest(
+        static_cast<uint32_t>(
+            StreamCaptureThumbnailCallbackInterfaceCode::CAMERA_STREAM_CAPTURE_ON_THUMBNAIL_AVAILABLE),
+        data,
+        reply,
+        option);
+    if (error != ERR_NONE) {
+        MEDIA_ERR_LOG("HStreamCaptureThumbnailCallbackProxy OnThumbnailAvailable failed, error: %{public}d", error);
+    }
+    return error;
+}
+}  // namespace CameraStandard
+}  // namespace OHOS
\ No newline at end of file
diff --git a/services/camera_service/binder/server/include/hstream_capture_photo_callback_stub.h b/services/camera_service/binder/server/include/hstream_capture_photo_callback_stub.h
new file mode 100644
index 000000000..b7d4ef862
--- /dev/null
+++ b/services/camera_service/binder/server/include/hstream_capture_photo_callback_stub.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_HSTREAM_CAPTURE_PHOTO_CALLBACK_STUB_H
+#define OHOS_CAMERA_HSTREAM_CAPTURE_PHOTO_CALLBACK_STUB_H
+
+#include "iremote_stub.h"
+#include "istream_capture_photo_callback.h"
+
+namespace OHOS {
+namespace CameraStandard {
+
+class HStreamCapturePhotoCallbackStub : public IRemoteStub<IStreamCapturePhotoCallback> {
+public:
+    virtual int OnRemoteRequest(uint32_t code, MessageParcel &data,
+                                MessageParcel &reply, MessageOption &option) override;
+
+private:
+    int HandleOnPhotoAvailable(MessageParcel& data);
+};
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_HSTREAM_CAPTURE_PHOTO_CALLBACK_STUB_H
diff --git a/services/camera_service/binder/server/include/hstream_capture_thumbnail_callback_stub.h b/services/camera_service/binder/server/include/hstream_capture_thumbnail_callback_stub.h
new file mode 100644
index 000000000..5ad910196
--- /dev/null
+++ b/services/camera_service/binder/server/include/hstream_capture_thumbnail_callback_stub.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_HSTREAM_CAPTURE_THUMBNAIL_CALLBACK_STUB_H
+#define OHOS_CAMERA_HSTREAM_CAPTURE_THUMBNAIL_CALLBACK_STUB_H
+
+#include "iremote_stub.h"
+#include "istream_capture_thumbnail_callback.h"
+
+namespace OHOS {
+namespace CameraStandard {
+
+class HStreamCaptureThumbnailCallbackStub : public IRemoteStub<IStreamCaptureThumbnailCallback> {
+public:
+    virtual int OnRemoteRequest(uint32_t code, MessageParcel &data,
+                                MessageParcel &reply, MessageOption &option) override;
+
+private:
+    int HandleOnThumbnailAvailable(MessageParcel& data);
+};
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_HSTREAM_CAPTURE_THUMBNAIL_CALLBACK_STUB_H
diff --git a/services/camera_service/binder/server/src/hstream_capture_photo_callback_stub.cpp b/services/camera_service/binder/server/src/hstream_capture_photo_callback_stub.cpp
new file mode 100644
index 000000000..21abf8b2c
--- /dev/null
+++ b/services/camera_service/binder/server/src/hstream_capture_photo_callback_stub.cpp
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hstream_capture_photo_callback_stub.h"
+#include "camera_log.h"
+
+namespace OHOS {
+namespace CameraStandard {
+// LCOV_EXCL_START
+int HStreamCapturePhotoCallbackStub::OnRemoteRequest(
+    uint32_t code, MessageParcel &data, MessageParcel &reply, MessageOption &option)
+{
+    int errCode = -1;
+    CHECK_ERROR_RETURN_RET(data.ReadInterfaceToken() != GetDescriptor(), errCode);
+    switch (code) {
+        case static_cast<uint32_t>(StreamCapturePhotoCallbackInterfaceCode::CAMERA_STREAM_CAPTURE_ON_PHOTO_AVAILABLE):
+            errCode = HandleOnPhotoAvailable(data);
+            break;
+        default:
+            MEDIA_ERR_LOG("HStreamCaptureCallbackStub request code %{public}u not handled", code);
+            errCode = IPCObjectStub::OnRemoteRequest(code, data, reply, option);
+            break;
+    }
+    return errCode;
+}
+ 
+int HStreamCapturePhotoCallbackStub::HandleOnPhotoAvailable(MessageParcel& data)
+{
+    MEDIA_INFO_LOG("HStreamCapturePhotoCallbackStub::OnPhotoAvailable is called!");
+    sptr<SurfaceBuffer> surfaceBuffer = SurfaceBuffer::Create();
+    surfaceBuffer->ReadFromMessageParcel(data);
+    sptr<BufferExtraData> bufferExtraData = surfaceBuffer->GetExtraData();
+    bufferExtraData->ReadFromParcel(data);
+    surfaceBuffer->SetExtraData(bufferExtraData);
+    int64_t timestamp = data.ReadInt64();
+    bool isRaw = data.ReadBool();
+    return OnPhotoAvailable(surfaceBuffer, timestamp, isRaw);
+}
+// LCOV_EXCL_STOP
+}  // namespace CameraStandard
+}  // namespace OHOS
\ No newline at end of file
diff --git a/services/camera_service/binder/server/src/hstream_capture_thumbnail_callback_stub.cpp b/services/camera_service/binder/server/src/hstream_capture_thumbnail_callback_stub.cpp
new file mode 100644
index 000000000..9ff3175c9
--- /dev/null
+++ b/services/camera_service/binder/server/src/hstream_capture_thumbnail_callback_stub.cpp
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hstream_capture_thumbnail_callback_stub.h"
+#include "camera_log.h"
+
+namespace OHOS {
+namespace CameraStandard {
+// LCOV_EXCL_START
+int HStreamCaptureThumbnailCallbackStub::OnRemoteRequest(
+    uint32_t code, MessageParcel &data, MessageParcel &reply, MessageOption &option)
+{
+    int errCode = -1;
+    CHECK_ERROR_RETURN_RET(data.ReadInterfaceToken() != GetDescriptor(), errCode);
+    switch (code) {
+        case static_cast<uint32_t>(
+            StreamCaptureThumbnailCallbackInterfaceCode::CAMERA_STREAM_CAPTURE_ON_THUMBNAIL_AVAILABLE):
+            errCode = HandleOnThumbnailAvailable(data);
+            break;
+        default:
+            MEDIA_ERR_LOG("HStreamCaptureThumbnailCallbackStub request code %{public}u not handled", code);
+            errCode = IPCObjectStub::OnRemoteRequest(code, data, reply, option);
+            break;
+    }
+    return errCode;
+}
+
+int HStreamCaptureThumbnailCallbackStub::HandleOnThumbnailAvailable(MessageParcel &data)
+{
+    MEDIA_INFO_LOG("HStreamCaptureThumbnailCallbackStub::OnThumbnailAvailable is called!");
+    sptr<SurfaceBuffer> surfaceBuffer = SurfaceBuffer::Create();
+    surfaceBuffer->ReadFromMessageParcel(data);
+    sptr<BufferExtraData> bufferExtraData = surfaceBuffer->GetExtraData();
+    bufferExtraData->ReadFromParcel(data);
+    surfaceBuffer->SetExtraData(bufferExtraData);
+    int64_t timestamp = data.ReadInt64();
+    return OnThumbnailAvailable(surfaceBuffer, timestamp);
+}
+// LCOV_EXCL_STOP
+}  // namespace CameraStandard
+}  // namespace OHOS
diff --git a/services/camera_service/idls/BUILD.gn b/services/camera_service/idls/BUILD.gn
index e83886f2a..f6bdff23f 100644
--- a/services/camera_service/idls/BUILD.gn
+++ b/services/camera_service/idls/BUILD.gn
@@ -39,6 +39,7 @@ idl_gen_interface("camera_service_idl_interface") {
     "ICameraMuteServiceCallback.idl",
     "IPressureStatusCallback.idl",
     "IMechSessionCallback.idl",
+    "IStreamCapturePhotoAssetCallback.idl",
   ]
 
   sources_common = [ "CameraTypes.idl" ]
diff --git a/services/camera_service/idls/ICameraService.idl b/services/camera_service/idls/ICameraService.idl
index 6609dacd9..6a52fa6c8 100644
--- a/services/camera_service/idls/ICameraService.idl
+++ b/services/camera_service/idls/ICameraService.idl
@@ -84,6 +84,7 @@ interface ICameraService{
   [ipccode 43] void CreateMechSession([in] int userId, [out] IMechSession session);
   [ipccode 44] void IsMechSupported([out] boolean isMechSupported);
   [ipccode 45] void GetCameraStorageSize([out] long size);
+  [ipccode 46] void CreatePhotoOutput([in] int format, [in] int width, [in] int height, [out] IStreamCapture photoOutput);
   [ipccode 101] void AllowOpenByOHSide([in] String cameraId, [in] int state, [inout] boolean canOpenCamera);
   [ipccode 102, oneway] void NotifyCameraState([in] String cameraId, [in] int state);
   [ipccode 104] void SetPeerCallback([in] ICameraBroker callbackFunc);
diff --git a/services/camera_service/idls/IStreamCapture.idl b/services/camera_service/idls/IStreamCapture.idl
index c38b5c34c..83b64cc01 100644
--- a/services/camera_service/idls/IStreamCapture.idl
+++ b/services/camera_service/idls/IStreamCapture.idl
@@ -16,21 +16,24 @@
 package OHOS.CameraStandard;
 import CameraTypes;
 import IStreamCaptureCallback;
+import IStreamCapturePhotoAssetCallback;
 
 interface IStreamCommon;
 interface OHOS.IBufferProducer;
+interface OHOS.CameraStandard.IStreamCapturePhotoCallback;
+interface OHOS.CameraStandard.IStreamCaptureThumbnailCallback;
+
 sequenceable CameraMetadataInfo..OHOS.Camera.CameraMetadata;
 sequenceable CameraPhotoProxy..OHOS.CameraStandard.CameraPhotoProxy;
 sequenceable PictureInterface..OHOS.CameraStandard.PictureIntf;
 option_stub_hooks on;
-option_parcel_hooks on;
 
 interface IStreamCapture extends IStreamCommon {
   [ipccode 0] void Capture([in] sharedptr<CameraMetadata> captureSettings);
   [ipccode 1] void CancelCapture();
   [ipccode 2] void SetCallback([in] IStreamCaptureCallback callbackFunc);
   [ipccode 3] void Release();
-  [ipccode 4] void SetThumbnail([in] boolean isEnabled, [in] IBufferProducer producer);
+  [ipccode 4] void SetThumbnail([in] boolean isEnabled);
   [ipccode 5] void ConfirmCapture();
   [ipccode 6] void DeferImageDeliveryFor([in] int type);
   [ipccode 7] void IsDeferredPhotoEnabled();
@@ -40,10 +43,9 @@ interface IStreamCapture extends IStreamCommon {
   [ipccode 11] void EnableRawDelivery([in] boolean enabled);
   [ipccode 12] void SetCameraPhotoRotation([in] boolean isEnable);
   [ipccode 13] void EnableMovingPhoto([in] boolean enabled);
-  [ipccode 14] void AcquireBufferToPrepareProxy([in] int captureId);
-  [ipccode 15] void UpdateMediaLibraryPhotoAssetProxy([in] sptr<CameraPhotoProxy> photoProxy);
   [ipccode 16] void UnSetCallback();
   [ipccode 17] void EnableOfflinePhoto([in] boolean isEnable);
-  [ipccode 18] void CreateMediaLibrary([in] sptr<CameraPhotoProxy> photoProxy, [out] String uri, [out] int cameraShotType, [out] String burstKey, [in] long timestamp);
-  [ipccode 19] void CreateMediaLibrary([in] sharedptr<PictureIntf> pictureExt, [in] sptr<CameraPhotoProxy> photoProxy, [out] String uri, [out] int cameraShotType, [out] String burstKey, [in] long timestamp);
+  [ipccode 18] void SetPhotoAvailableCallback([in] IStreamCapturePhotoCallback callbackFunc);
+  [ipccode 19] void SetPhotoAssetAvailableCallback([in] IStreamCapturePhotoAssetCallback callbackFunc);
+  [ipccode 20] void SetThumbnailCallback([in] IStreamCaptureThumbnailCallback callbackFunc);
 }
\ No newline at end of file
diff --git a/services/camera_service/idls/IStreamCapturePhotoAssetCallback.idl b/services/camera_service/idls/IStreamCapturePhotoAssetCallback.idl
new file mode 100644
index 000000000..df44efd13
--- /dev/null
+++ b/services/camera_service/idls/IStreamCapturePhotoAssetCallback.idl
@@ -0,0 +1,20 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package OHOS.CameraStandard;
+
+interface IStreamCapturePhotoAssetCallback {
+  [ipccode 0, oneway] void OnPhotoAssetAvailable([in] int captureId, [in] String uri, [in] int cameraShotType, [in] String burstKey);
+}
\ No newline at end of file
diff --git a/services/camera_service/include/avcodec/camera_server_photo_proxy.h b/services/camera_service/include/avcodec/camera_server_photo_proxy.h
index ef3790358..79c8a3200 100644
--- a/services/camera_service/include/avcodec/camera_server_photo_proxy.h
+++ b/services/camera_service/include/avcodec/camera_server_photo_proxy.h
@@ -24,18 +24,20 @@
 namespace OHOS {
 namespace CameraStandard {
 using namespace Media;
-constexpr const char* prefix = "IMG_";
-constexpr const char* suffixJpeg = "jpg";
-constexpr const char* suffixHeif = "heic";
-constexpr const char* suffixDng = "dng";
-constexpr const char* connector = "_";
-constexpr const char* burstTag = "BURST";
-constexpr const char* coverTag = "_COVER";
-constexpr const char placeholder = '0';
-constexpr const int8_t yearWidth = 4;
-constexpr const int8_t otherWidth = 2;
-constexpr const int8_t burstWidth = 3;
-constexpr const int16_t startYear = 1900;
+static const std::string prefix = "IMG_";
+static const std::string videoPrefix = "VID_";
+static const std::string suffixJpeg = "jpg";
+static const std::string suffixHeif = "heic";
+static const std::string suffixDng = "dng";
+static const std::string suffixMp4 = "mp4";
+static const std::string connector = "_";
+static const std::string burstTag = "BURST";
+static const std::string coverTag = "_COVER";
+static const char placeholder = '0';
+static const int yearWidth = 4;
+static const int otherWidth = 2;
+static const int burstWidth = 3;
+static const int startYear = 1900;
 
 static const std::map<int32_t, int32_t> modeMap = {
     { 3, 23},
@@ -57,11 +59,13 @@ static const std::map<int32_t, PhotoFormat> formatMap = {
     {4, PhotoFormat::DNG},
 };
 
-std::string CreateDisplayName();
+std::string CreateDisplayName(const std::string& suffix);
+std::string CreateVideoDisplayName();
 class CameraServerPhotoProxy : public PhotoProxy {
 public:
     CameraServerPhotoProxy();
     virtual ~CameraServerPhotoProxy();
+    void GetServerPhotoProxyInfo(sptr<SurfaceBuffer>& surfaceBuffer);
     void ReadFromParcel(MessageParcel &parcel);
     std::string GetTitle() override;
     std::string GetExtension() override;
@@ -87,6 +91,11 @@ public:
     uint32_t GetCloudImageEnhanceFlag() override;
     void SetStageVideoTaskStatus(uint8_t status);
     int32_t GetStageVideoTaskStatus() override;
+    void SetFormat(int32_t format);
+    void SetImageFormat(int32_t imageFormat);
+    void SetIsVideo(bool isVideo);
+    void SetLatitude(double latitude);
+    void SetLongitude(double longitude);
 
 private:
     uint32_t cloudImageEnhanceFlag_;
@@ -113,6 +122,7 @@ private:
     bool isCoverPhoto_;
     int32_t imageFormat_;
     uint8_t stageVideoTaskStatus_;
+    bool isVideo_ = false;
     int32_t CameraFreeBufferHandle(BufferHandle *handle);
 };
 } // namespace CameraStandard
diff --git a/services/camera_service/include/camera_buffer_manager/camera_surface_buffer_util.h b/services/camera_service/include/camera_buffer_manager/camera_surface_buffer_util.h
new file mode 100644
index 000000000..4aa454868
--- /dev/null
+++ b/services/camera_service/include/camera_buffer_manager/camera_surface_buffer_util.h
@@ -0,0 +1,282 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_SURFACE_BUFFER_UTIL_H
+#define OHOS_CAMERA_SURFACE_BUFFER_UTIL_H
+
+#include "surface.h"
+#include "video_key_info.h"
+#include "metadata_helper.h"
+
+namespace OHOS {
+namespace CameraStandard {
+
+class CameraSurfaceBufferUtil {
+static constexpr uint8_t PIXEL_SIZE_HDR_YUV = 3;
+static constexpr uint8_t HDR_PIXEL_SIZE = 2;
+
+public:
+    static sptr<SurfaceBuffer> DeepCopyBuffer(sptr<SurfaceBuffer> surfaceBuffer)
+    {
+        CAMERA_SYNC_TRACE;
+        CHECK_ERROR_RETURN_RET_LOG(surfaceBuffer == nullptr, nullptr, "DeepCopyBuffer surfaceBuffer is null");
+        uint32_t bufferSeqNum = surfaceBuffer->GetSeqNum();
+        MEDIA_DEBUG_LOG("DeepCopyBuffer E bufferSeqNum:%{public}u", bufferSeqNum);
+        DumpSurfaceBuffer(surfaceBuffer);
+        int32_t dataStride = GetDataStride(surfaceBuffer) == -1 ? 0x8 : GetDataStride(surfaceBuffer);
+        MEDIA_DEBUG_LOG("DeepCopyBuffer dataStride:%{public}d", dataStride);
+        // deep copy buffer
+        BufferRequestConfig requestConfig = {
+                .width = surfaceBuffer->GetWidth(),
+                .height = surfaceBuffer->GetHeight(),
+                .strideAlignment = 0x8,  // default stride is 8 Bytes.
+                .format = surfaceBuffer->GetFormat(),
+                .usage = surfaceBuffer->GetUsage(),
+                .timeout = 0,
+                .colorGamut = surfaceBuffer->GetSurfaceBufferColorGamut(),
+                .transform = surfaceBuffer->GetSurfaceBufferTransform(),
+        };
+        sptr<SurfaceBuffer> newSurfaceBuffer = SurfaceBuffer::Create();
+        auto allocErrorCode = newSurfaceBuffer->Alloc(requestConfig);
+        MEDIA_DEBUG_LOG("DeepCopyBuffer alloc ret: %{public}d", allocErrorCode);
+        if (memcpy_s(newSurfaceBuffer->GetVirAddr(), newSurfaceBuffer->GetSize(),
+            surfaceBuffer->GetVirAddr(), surfaceBuffer->GetSize()) != EOK) {
+            MEDIA_ERR_LOG("DeepCopyBuffer memcpy_s failed");
+        }
+
+        // deep copy buffer extData
+        MessageParcel extParcl;
+        sptr<BufferExtraData> bufferExtraData = surfaceBuffer->GetExtraData();
+        GSError gsErr = bufferExtraData->WriteToParcel(extParcl);
+        MEDIA_DEBUG_LOG("DeepCopyBuffer WriteToParcel gsErr=%{public}d", gsErr);
+        sptr<BufferExtraData> newBufferExtraData = newSurfaceBuffer->GetExtraData();
+        gsErr = newBufferExtraData->ReadFromParcel(extParcl);
+        MEDIA_DEBUG_LOG("DeepCopyBuffer ReadFromParcel gsErr=%{public}d", gsErr);
+
+        // deep metaData
+        CopyMetaData(surfaceBuffer, newSurfaceBuffer);
+        DumpSurfaceBuffer(newSurfaceBuffer);
+        MEDIA_DEBUG_LOG("DeepCopyBuffer X bufferSeqNum:%{public}u", bufferSeqNum);
+        return newSurfaceBuffer;
+    }
+
+    static sptr<SurfaceBuffer> DeepCopyThumbnailBuffer(sptr<SurfaceBuffer> surfaceBuffer)
+    {
+        CAMERA_SYNC_TRACE;
+        CHECK_ERROR_RETURN_RET_LOG(surfaceBuffer == nullptr, nullptr, "DeepCopyThumbnailBuffer surfaceBuffer is null");
+        uint32_t bufferSeqNum = surfaceBuffer->GetSeqNum();
+        MEDIA_DEBUG_LOG("DeepCopyThumbnailBuffer E bufferSeqNum:%{public}u", bufferSeqNum);
+        DumpSurfaceBuffer(surfaceBuffer);
+        int32_t thumbnailStride = GetDataStride(surfaceBuffer);
+        int32_t thumbnailHeight = GetDataHeight(surfaceBuffer);
+        MEDIA_DEBUG_LOG("DeepCopyThumbnailBuffer thumbnailStride:%{public}d", thumbnailStride);
+        // deep copy buffer
+        BufferRequestConfig requestConfig = {
+                .width = thumbnailStride,
+                .height = thumbnailHeight,
+                .strideAlignment = thumbnailStride,
+                .format = surfaceBuffer->GetFormat(),
+                .usage =
+                    BUFFER_USAGE_CPU_READ | BUFFER_USAGE_CPU_WRITE | BUFFER_USAGE_MEM_DMA | BUFFER_USAGE_MEM_MMZ_CACHE,
+                .timeout = 0,
+            };
+        sptr<SurfaceBuffer> newSurfaceBuffer = SurfaceBuffer::Create();
+        auto allocRet = newSurfaceBuffer->Alloc(requestConfig);
+        if (allocRet != 0) {
+            MEDIA_ERR_LOG("DeepCopyThumbnailBuffer alloc ret: %{public}d", allocRet);
+            return newSurfaceBuffer;
+        }
+        int32_t colorLength = thumbnailStride * thumbnailHeight * PIXEL_SIZE_HDR_YUV;
+        HDI::Display::Graphic::Common::V1_0::CM_ColorSpaceType colorSpaceType;
+        GSError gsErr = MetadataHelper::GetColorSpaceType(surfaceBuffer, colorSpaceType);
+        bool isHdr = colorSpaceType ==  HDI::Display::Graphic::Common::V1_0::CM_ColorSpaceType::CM_BT2020_HLG_FULL;
+        MEDIA_ERR_LOG("DeepCopyThumbnailBuffer colorSpaceType:%{public}d isHdr:%{public}d", colorSpaceType, isHdr);
+        colorLength = isHdr ? colorLength : colorLength / HDR_PIXEL_SIZE;
+        if (memcpy_s(newSurfaceBuffer->GetVirAddr(), newSurfaceBuffer->GetSize(),
+            surfaceBuffer->GetVirAddr(), colorLength) != EOK) {
+            MEDIA_ERR_LOG("DeepCopyThumbnailBuffer memcpy_s failed");
+            return newSurfaceBuffer;
+        }
+
+        // deep copy buffer extData
+        MessageParcel extParcl;
+        sptr<BufferExtraData> bufferExtraData = surfaceBuffer->GetExtraData();
+        gsErr = bufferExtraData->WriteToParcel(extParcl);
+        MEDIA_DEBUG_LOG("DeepCopyBuffer WriteToParcel gsErr=%{public}d", gsErr);
+        sptr<BufferExtraData> newBufferExtraData = newSurfaceBuffer->GetExtraData();
+        gsErr = newBufferExtraData->ReadFromParcel(extParcl);
+        MEDIA_DEBUG_LOG("DeepCopyBuffer ReadFromParcel gsErr=%{public}d", gsErr);
+
+        // deep metaData
+        CopyMetaData(surfaceBuffer, newSurfaceBuffer);
+        DumpSurfaceBuffer(newSurfaceBuffer);
+        MEDIA_DEBUG_LOG("DeepCopyBuffer X bufferSeqNum:%{public}u", bufferSeqNum);
+        return newSurfaceBuffer;
+    }
+
+    static int32_t GetDataSize(sptr<SurfaceBuffer> surfaceBuffer)
+    {
+        int32_t dataSize = 0;
+        surfaceBuffer->GetExtraData()->ExtraGet(OHOS::Camera::dataSize, dataSize);
+        MEDIA_DEBUG_LOG("GetDataSize:%{public}d", dataSize);
+        return dataSize;
+    }
+
+    static int32_t GetCaptureId(sptr<SurfaceBuffer> surfaceBuffer)
+    {
+        int32_t captureId = 0;
+        surfaceBuffer->GetExtraData()->ExtraGet(OHOS::Camera::captureId, captureId);
+        MEDIA_DEBUG_LOG("GetCaptureId:%{public}d", captureId);
+        return captureId;
+    }
+
+    static int32_t GetMaskCaptureId(sptr<SurfaceBuffer> surfaceBuffer)
+    {
+        int32_t captureId;
+        int32_t burstSeqId = -1;
+        int32_t maskBurstSeqId = 0;
+        int32_t invalidSeqenceId = -1;
+        int32_t captureIdMask = 0x0000FFFF;
+        int32_t captureIdShit = 16;
+        surfaceBuffer->GetExtraData()->ExtraGet(OHOS::Camera::burstSequenceId, burstSeqId);
+        surfaceBuffer->GetExtraData()->ExtraGet(OHOS::Camera::captureId, captureId);
+        if (burstSeqId != invalidSeqenceId && captureId >= 0) {
+            maskBurstSeqId = ((captureId & captureIdMask) << captureIdShit) | burstSeqId;
+            MEDIA_DEBUG_LOG("GetMaskCaptureId captureId:%{public}d, burstSeqId:%{public}d, maskBurstSeqId = %{public}d",
+                captureId, burstSeqId, maskBurstSeqId);
+            return maskBurstSeqId;
+        }
+        MEDIA_DEBUG_LOG("GetMaskCaptureId captureId:%{public}d, burstSeqId:%{public}d", captureId, burstSeqId);
+        return captureId;
+    }
+
+    static int32_t GetBurstSequenceId(sptr<SurfaceBuffer> surfaceBuffer)
+    {
+        int32_t burstSequenceId = 0;
+        surfaceBuffer->GetExtraData()->ExtraGet(OHOS::Camera::burstSequenceId, burstSequenceId);
+        MEDIA_DEBUG_LOG("GetBurstSequenceId:%{public}d", burstSequenceId);
+        return burstSequenceId;
+    }
+
+    static int32_t GetImageCount(sptr<SurfaceBuffer> surfaceBuffer)
+    {
+        int32_t imageCount = 0;
+        surfaceBuffer->GetExtraData()->ExtraGet(OHOS::Camera::imageCount, imageCount);
+        MEDIA_DEBUG_LOG("GetImageCount:%{public}d", imageCount);
+        return imageCount;
+    }
+
+    static int64_t GetImageId(sptr<SurfaceBuffer> surfaceBuffer)
+    {
+        int64_t imageId = 0;
+        surfaceBuffer->GetExtraData()->ExtraGet(OHOS::Camera::imageId, imageId);
+        MEDIA_DEBUG_LOG("GetImageId:%{public}s", std::to_string(imageId).c_str());
+        return imageId;
+    }
+
+    static int32_t GetIsDegradedImage(sptr<SurfaceBuffer> surfaceBuffer)
+    {
+        int32_t isDegradedImage;
+        surfaceBuffer->GetExtraData()->ExtraGet(OHOS::Camera::isDegradedImage, isDegradedImage);
+        MEDIA_DEBUG_LOG("GetIsDegradedImage:%{public}d", isDegradedImage);
+        return isDegradedImage;
+    }
+
+    static int32_t GetDeferredProcessingType(sptr<SurfaceBuffer> surfaceBuffer)
+    {
+        int32_t deferredProcessingType;
+        surfaceBuffer->GetExtraData()->ExtraGet(OHOS::Camera::deferredProcessingType, deferredProcessingType);
+        MEDIA_DEBUG_LOG("GetDeferredProcessingType:%{public}d", deferredProcessingType);
+        return deferredProcessingType;
+    }
+
+    static int32_t GetDataWidth(sptr<SurfaceBuffer> surfaceBuffer)
+    {
+        int32_t dataWidth = 0;
+        surfaceBuffer->GetExtraData()->ExtraGet(OHOS::Camera::dataWidth, dataWidth);
+        MEDIA_DEBUG_LOG("GetDataWidth:%{public}d", dataWidth);
+        return dataWidth;
+    }
+
+    static int32_t GetDataHeight(sptr<SurfaceBuffer> surfaceBuffer)
+    {
+        int32_t dataHeight = 0;
+        surfaceBuffer->GetExtraData()->ExtraGet(OHOS::Camera::dataHeight, dataHeight);
+        MEDIA_DEBUG_LOG("GetDataHeight:%{public}d", dataHeight);
+        return dataHeight;
+    }
+
+    static int32_t GetDeferredImageFormat(sptr<SurfaceBuffer> surfaceBuffer)
+    {
+        int32_t deferredImageFormat = 0;
+        surfaceBuffer->GetExtraData()->ExtraGet(OHOS::Camera::deferredImageFormat, deferredImageFormat);
+        MEDIA_DEBUG_LOG("GetDeferredImageFormat:%{public}d", deferredImageFormat);
+        return deferredImageFormat;
+    }
+
+    static int32_t GetDataStride(sptr<SurfaceBuffer> surfaceBuffer)
+    {
+        int32_t dataStride = -1;
+        surfaceBuffer->GetExtraData()->ExtraGet(OHOS::Camera::dataStride, dataStride);
+        MEDIA_DEBUG_LOG("GetDataStride:%{public}d", dataStride);
+        return dataStride;
+    }
+
+    static int32_t GetCloudImageEnhanceFlag(sptr<SurfaceBuffer> surfaceBuffer)
+    {
+        int32_t cloudImageEnhanceFlag = 0;
+        surfaceBuffer->GetExtraData()->ExtraGet(OHOS::Camera::cloudImageEnhanceFlag, cloudImageEnhanceFlag);
+        MEDIA_DEBUG_LOG("GetCloudImageEnhanceFlag:%{public}d", cloudImageEnhanceFlag);
+        return cloudImageEnhanceFlag;
+    }
+
+    static void DumpSurfaceBuffer(sptr<SurfaceBuffer> surfaceBuffer)
+    {
+        GetCaptureId(surfaceBuffer);
+        GetDataWidth(surfaceBuffer);
+        GetDataHeight(surfaceBuffer);
+        GetDeferredImageFormat(surfaceBuffer);
+        GetIsDegradedImage(surfaceBuffer);
+        GetImageId(surfaceBuffer);
+        GetImageCount(surfaceBuffer);
+        GetDeferredProcessingType(surfaceBuffer);
+        GetBurstSequenceId(surfaceBuffer);
+    }
+
+private:
+    static void CopyMetaData(sptr<SurfaceBuffer> &inBuffer, sptr<SurfaceBuffer> &outBuffer)
+    {
+        std::vector<uint32_t> keys = {};
+        CHECK_ERROR_RETURN_LOG(inBuffer == nullptr, "CopyMetaData: inBuffer is nullptr");
+        auto ret = inBuffer->ListMetadataKeys(keys);
+        CHECK_ERROR_RETURN_LOG(ret != GSError::GSERROR_OK, "CopyMetaData: ListMetadataKeys fail! res=%{public}d", ret);
+        for (uint32_t key : keys) {
+            std::vector<uint8_t> values;
+            ret = inBuffer->GetMetadata(key, values);
+            if (ret != 0) {
+                MEDIA_INFO_LOG("GetMetadata fail! key = %{public}d res = %{public}d", key, ret);
+                continue;
+            }
+            ret = outBuffer->SetMetadata(key, values);
+            if (ret != 0) {
+                MEDIA_INFO_LOG("SetMetadata fail! key = %{public}d res = %{public}d", key, ret);
+                continue;
+            }
+        }
+    }
+};
+}  // namespace CameraStandard
+}  // namespace OHOS
+#endif
\ No newline at end of file
diff --git a/services/camera_service/include/camera_buffer_manager/photo_asset_auxiliary_consumer.h b/services/camera_service/include/camera_buffer_manager/photo_asset_auxiliary_consumer.h
new file mode 100644
index 000000000..418dc4060
--- /dev/null
+++ b/services/camera_service/include/camera_buffer_manager/photo_asset_auxiliary_consumer.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_AUXILIARY_BUFFER_CONSUMER_H
+#define OHOS_CAMERA_AUXILIARY_BUFFER_CONSUMER_H
+
+#include "ibuffer_consumer_listener.h"
+#include <mutex>
+
+namespace OHOS {
+namespace CameraStandard {
+class HStreamCapture;
+namespace DeferredProcessing {
+class TaskManager;
+}
+static const std::string S_GAINMAP = "gainmap";
+static const std::string S_DEEP = "deep";
+static const std::string S_EXIF = "exif";
+static const std::string S_DEBUG = "debug";
+
+class AuxiliaryBufferConsumer : public IBufferConsumerListener {
+public:
+    AuxiliaryBufferConsumer(const std::string surfaceName, wptr<HStreamCapture> streamCapture);
+    ~AuxiliaryBufferConsumer() override;
+
+    void OnBufferAvailable() override;
+private:
+    void ExecuteOnBufferAvailable();
+
+    std::string surfaceName_;
+    wptr<HStreamCapture> streamCapture_ = nullptr;
+};
+}  // namespace CameraStandard
+}  // namespace OHOS
+#endif
\ No newline at end of file
diff --git a/services/camera_service/include/camera_buffer_manager/photo_asset_buffer_consumer.h b/services/camera_service/include/camera_buffer_manager/photo_asset_buffer_consumer.h
new file mode 100644
index 000000000..15f09f5de
--- /dev/null
+++ b/services/camera_service/include/camera_buffer_manager/photo_asset_buffer_consumer.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_PHOTO_ASSET_BUFFER_CONSUMER_H
+#define OHOS_CAMERA_PHOTO_ASSET_BUFFER_CONSUMER_H
+
+#include "ibuffer_consumer_listener.h"
+#include "surface.h"
+#include <mutex>
+
+namespace OHOS {
+namespace CameraStandard {
+class HStreamCapture;
+namespace DeferredProcessing {
+class TaskManager;
+}
+class PhotoAssetBufferConsumer : public IBufferConsumerListener {
+public:
+    explicit PhotoAssetBufferConsumer(wptr<HStreamCapture> streamCapture);
+    ~PhotoAssetBufferConsumer() override;
+    void OnBufferAvailable() override;
+
+private:
+    void ExecuteOnBufferAvailable();
+    void StartWaitAuxiliaryTask(
+        const int32_t captureId, const int32_t auxiliaryCount, int64_t timestamp, sptr<SurfaceBuffer> &surfaceBuffer);
+    void AssembleDeferredPicture(int64_t timestamp, int32_t captureId);
+    void CleanAfterTransPicture(int32_t captureId);
+
+    wptr<HStreamCapture> streamCapture_ = nullptr;
+    std::mutex taskManagerMutex_;
+    std::shared_ptr<DeferredProcessing::TaskManager> taskManager_ = nullptr;
+};
+
+}  // namespace CameraStandard
+}  // namespace OHOS
+#endif
\ No newline at end of file