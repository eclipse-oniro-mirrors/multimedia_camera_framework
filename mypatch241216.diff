diff --git a/services/camera_service/include/avcodec/audio_deferred_process.h b/services/camera_service/include/avcodec/audio_deferred_process.h
index 6081c589..13325180 100644
--- a/services/camera_service/include/avcodec/audio_deferred_process.h
+++ b/services/camera_service/include/avcodec/audio_deferred_process.h
@@ -43,8 +43,8 @@ public:
     void Release();
     
     static constexpr int32_t ONE_THOUSAND = 1000;
-    static constexpr int32_t DURATION_EACH_AUDIO_FRAME = 20;
-    static constexpr int32_t PROCESS_BATCH_SIZE = 8;
+    static constexpr int32_t DURATION_EACH_AUDIO_FRAME = 32;
+    static constexpr int32_t PROCESS_BATCH_SIZE = 5;
 
 private:
     std::string chainName_ = "offline_record_algo";
diff --git a/services/camera_service/include/avcodec/common/sample_info.h b/services/camera_service/include/avcodec/common/sample_info.h
index 6ce90cb6..c2dbf28f 100644
--- a/services/camera_service/include/avcodec/common/sample_info.h
+++ b/services/camera_service/include/avcodec/common/sample_info.h
@@ -39,22 +39,20 @@ constexpr uint32_t DEFAULT_SAMPLERATE = 48000;
 constexpr uint32_t SAMPLERATE_32000 = 32000;
 constexpr uint64_t DEFAULT_BITRATE = 48000;
 constexpr uint32_t DEFAULT_CHANNEL_COUNT = 1;
-constexpr int32_t AUDIO_ENCODE_EXPIREATION_TIME = 2;
+constexpr int32_t AUDIO_ENCODE_EXPIREATION_TIME = 10;
 constexpr OH_AudioChannelLayout CHANNEL_LAYOUT = OH_AudioChannelLayout::CH_LAYOUT_MONO;
 constexpr OH_BitsPerSample SAMPLE_FORMAT = OH_BitsPerSample::SAMPLE_S16LE;
 constexpr int32_t COMPLIANCE_LEVEL = 0;
 constexpr OH_BitsPerSample BITS_PER_CODED_SAMPLE = OH_BitsPerSample::SAMPLE_S16LE;
 constexpr uint32_t DEFAULT_MAX_INPUT_SIZE = 1024 * DEFAULT_CHANNEL_COUNT * sizeof(short);
-constexpr uint32_t INPUT_SIZE_7680 = 48000 / 1000 * 4 * 20 * 2;
-constexpr uint32_t INPUT_SIZE_1280 = 32000 / 1000 * 1 * 20 * 2;
 constexpr int32_t VIDEO_FRAME_INTERVAL = 33333;
 constexpr float VIDEO_FRAME_INTERVAL_MS = 33.33333;
-constexpr int32_t AUDIO_FRAME_INTERVAL = 21333;
+constexpr int32_t AUDIO_FRAME_INTERVAL = 32000;
 constexpr double VIDEO_FRAME_RATE = 30.0;
 constexpr int32_t CACHE_FRAME_COUNT = 45;
 constexpr size_t MAX_AUDIO_FRAME_COUNT = 140;
 constexpr int32_t BUFFER_RELEASE_EXPIREATION_TIME = 150;
-constexpr int32_t BUFFER_ENCODE_EXPIREATION_TIME = 10;
+constexpr int32_t BUFFER_ENCODE_EXPIREATION_TIME = 20;
 constexpr int32_t ROTATION_360 = 360;
 constexpr OH_AVPixelFormat VIDOE_PIXEL_FORMAT = AV_PIXEL_FORMAT_NV21;
 constexpr int32_t IDR_FRAME_COUNT = 2;
diff --git a/services/camera_service/src/avcodec/audio_capturer_session.cpp b/services/camera_service/src/avcodec/audio_capturer_session.cpp
index 409bb437..8e628bac 100644
--- a/services/camera_service/src/avcodec/audio_capturer_session.cpp
+++ b/services/camera_service/src/avcodec/audio_capturer_session.cpp
@@ -86,7 +86,7 @@ bool AudioCapturerSession::CreateAudioCapturer()
     AudioSessionStrategy sessionStrategy;
     sessionStrategy.concurrencyMode = AudioConcurrencyMode::MIX_WITH_OTHERS;
     AudioSessionManager::GetInstance()->ActivateAudioSession(sessionStrategy);
-    audioDeferredProcess_ = sptr(new AudioDeferredProcess());
+    audioDeferredProcess_ = new AudioDeferredProcess();
     if (!audioDeferredProcess_ || audioDeferredProcess_->GetOfflineEffectChain() != 0) {
         return false;
     }
@@ -185,7 +185,7 @@ void AudioCapturerSession::ProcessAudioBuffer()
             audioRecord->ReleaseAudioBuffer();
             MEDIA_DEBUG_LOG("audio release popBuffer");
         }
-        int64_t timeOffset = 20;
+        int64_t timeOffset = 32;
         sptr<AudioRecord> audioRecord = new AudioRecord(GetTickCount() - timeOffset);
         audioRecord->SetAudioBuffer(buffer.get());
         MEDIA_DEBUG_LOG("audio push buffer frameId: %{public}s", audioRecord->GetFrameId().c_str());
diff --git a/services/camera_service/src/avcodec/audio_deferred_process.cpp b/services/camera_service/src/avcodec/audio_deferred_process.cpp
index 2e57c97d..70984bf2 100644
--- a/services/camera_service/src/avcodec/audio_deferred_process.cpp
+++ b/services/camera_service/src/avcodec/audio_deferred_process.cpp
@@ -136,7 +136,8 @@ int32_t AudioDeferredProcess::Process(vector<sptr<AudioRecord>>& audioRecords,
         CHECK_AND_PRINT_LOG(ret == 0, "AudioDeferredProcess::Process err");
         for (uint32_t j = 0; j < batchSize; ++ j) {
             uint8_t* temp = new uint8_t[oneProcessedSize_];
-            memcpy_s(temp, oneProcessedSize_, processedArr.get() + j * oneProcessedSize_, oneProcessedSize_);
+            ret = memcpy_s(temp, oneProcessedSize_, processedArr.get() + j * oneProcessedSize_, oneProcessedSize_);
+            CHECK_AND_PRINT_LOG(ret == 0, "AudioDeferredProcess::Process returnToRecords memcpy_s err");
             processedRecords[i - batchSize + 1 + j]->SetAudioBuffer(temp);
         }
     };
diff --git a/services/camera_service/src/avcodec/audio_encoder.cpp b/services/camera_service/src/avcodec/audio_encoder.cpp
index 0147c543..5f7da63a 100644
--- a/services/camera_service/src/avcodec/audio_encoder.cpp
+++ b/services/camera_service/src/avcodec/audio_encoder.cpp
@@ -143,11 +143,11 @@ bool AudioEncoder::EnqueueBuffer(sptr<AudioRecord> audioRecord)
         context_->inputBufferInfoQueue_.pop();
         context_->inputFrameCount_++;
         bufferInfo->attr.pts = audioRecord->GetTimeStamp();
-        bufferInfo->attr.size = INPUT_SIZE_1280;
+        bufferInfo->attr.size = DEFAULT_MAX_INPUT_SIZE;
         bufferInfo->attr.flags = AVCODEC_BUFFER_FLAGS_NONE;
         auto bufferAddr = OH_AVBuffer_GetAddr(bufferInfo->buffer);
         int32_t bufferCap = OH_AVBuffer_GetCapacity(bufferInfo->buffer);
-        errno_t cpyRet = memcpy_s(bufferAddr, bufferCap, buffer, INPUT_SIZE_1280);
+        errno_t cpyRet = memcpy_s(bufferAddr, bufferCap, buffer, DEFAULT_MAX_INPUT_SIZE);
         CHECK_AND_RETURN_RET_LOG(cpyRet == 0, false, "encoder memcpy_s failed. %{public}d", cpyRet);
         lock.unlock();
         contextLock.unlock();
@@ -241,7 +241,7 @@ int32_t AudioEncoder::Configure()
     OH_AVFormat_SetLongValue(format, OH_MD_KEY_BITRATE, DEFAULT_BITRATE);
     OH_AVFormat_SetIntValue(format, OH_MD_KEY_AUDIO_SAMPLE_FORMAT, SAMPLE_FORMAT);
     OH_AVFormat_SetLongValue(format, OH_MD_KEY_CHANNEL_LAYOUT, CHANNEL_LAYOUT);
-    OH_AVFormat_SetIntValue(format, OH_MD_KEY_MAX_INPUT_SIZE, INPUT_SIZE_1280);
+    OH_AVFormat_SetIntValue(format, OH_MD_KEY_MAX_INPUT_SIZE, DEFAULT_MAX_INPUT_SIZE);
     int ret = OH_AudioCodec_Configure(encoder_, format);
     OH_AVFormat_Destroy(format);
     format = nullptr;
