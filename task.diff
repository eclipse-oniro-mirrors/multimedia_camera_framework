From 1dd28cac2906b4385ab69eec021112c0b29f0a4e Mon Sep 17 00:00:00 2001
From: s00888898 <s00888898@notesmail.huawei.com/>
Date: Thu, 19 Jun 2025 22:23:03 +0800
Subject: [PATCH] TicketNo:DTS2025061233604 Description:fix createAVMuxer
 failed after cpature disable movingPhoto Team:Gitee Feature or Bugfix:Bugfix
 Binary Source:Sync from Gitee PrivateCode(Yes/No):No

Change-Id: I7a05269ff3ae8ee7e53873a7f12237ae0a52314b
---
 .../camera_service/include/hstream_operator.h |  2 +
 .../camera_service/src/hstream_operator.cpp   | 45 ++++++++++++++-----
 2 files changed, 35 insertions(+), 12 deletions(-)

diff --git a/services/camera_service/include/hstream_operator.h b/services/camera_service/include/hstream_operator.h
index 9891559193..cbcd104584 100644
--- a/services/camera_service/include/hstream_operator.h
+++ b/services/camera_service/include/hstream_operator.h
@@ -391,6 +391,8 @@ private:
     bool isOfflineStreamOperator_ =  false;
     int32_t mlastCaptureId = 0;
     int32_t sensorRotation_ = 0;
+    std::map<int32_t, bool> curMotionPhotoStatus_;
+    std::mutex motionPhotoStatusLock_;
 };
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/services/camera_service/src/hstream_operator.cpp b/services/camera_service/src/hstream_operator.cpp
index 4187631419..7c9f89433f 100644
--- a/services/camera_service/src/hstream_operator.cpp
+++ b/services/camera_service/src/hstream_operator.cpp
@@ -180,6 +180,10 @@ HStreamOperator::HStreamOperator(const uint32_t callingTokenId, int32_t opMode)
 HStreamOperator::~HStreamOperator()
 {
     CAMERA_SYNC_TRACE;
+    {
+        std::lock_guard<std::mutex> lock(motionPhotoStatusLock_);
+        curMotionPhotoStatus_.clear();
+    }
     Release();
 }
 
@@ -1445,6 +1449,12 @@ void HStreamOperator::SetSensorRotation(int32_t rotationValue, int32_t sensorOri
 void HStreamOperator::StartMovingPhotoEncode(int32_t rotation, uint64_t timestamp, int32_t format, int32_t captureId)
 {
     CHECK_ERROR_RETURN(!isSetMotionPhoto_);
+    {
+        std::lock_guard<std::mutex> lock(motionPhotoStatusLock_); 
+        curMotionPhotoStatus_[captureId] = isSetMotionPhoto_;
+        MEDIA_DEBUG_LOG("HStreamOperator::StartMovingPhotoEncode cptureId : %{public}d, isSetMotionPhto : %{public}d",
+            captureId, isSetMotionPhoto_);
+    }
     int32_t addMirrorRotation = 0;
     MEDIA_INFO_LOG("sensorRotation is : %{public}d", sensorRotation_);
     if ((sensorRotation_ == STREAM_ROTATE_0 || sensorRotation_ == STREAM_ROTATE_180) && isMovingPhotoMirror_) {
@@ -1601,11 +1611,17 @@ int32_t HStreamOperator::CreateMediaLibrary(sptr<CameraServerPhotoProxy>& camera
         recorder->InsertPhotoAsset(timestamp, photoAssetProxy, captureId);
     });
     #else
-    if (!isBursting && isSetMotionPhoto_ && taskManager_) {
-        MEDIA_INFO_LOG("taskManager setVideoFd start");
-        taskManager_->SetVideoFd(timestamp, photoAssetProxy, captureId);
-    } else {
-        photoAssetProxy.reset();
+    {
+        std::lock_guard<std::mutex> lock(motionPhotoStatusLock_);
+        bool isSetMotionPhoto = curMotionPhotoStatus_.find(captureId) != curMotionPhotoStatus_.end()
+            &&  curMotionPhotoStatus_[captureId];
+        if (!isBursting && isSetMotionPhoto && taskManager_) {
+            MEDIA_INFO_LOG("taskManager setVideoFd start");
+            taskManager_->SetVideoFd(timestamp, photoAssetProxy, captureId);
+            curMotionPhotoStatus_.erase(captureId);
+        } else {
+            photoAssetProxy.reset();
+        }
     }
     #endif
     CameraReportDfxUtils::GetInstance()->SetAddProxyEndInfo(captureId);
@@ -1701,20 +1717,25 @@ int32_t HStreamOperator::CreateMediaLibrary(
     std::shared_ptr<PhotoAssetIntf> photoAssetProxy =
         ProcessPhotoProxy(captureId, picture, isBursting, photoProxy, uri);
     CHECK_ERROR_RETURN_RET_LOG(photoAssetProxy == nullptr, CAMERA_INVALID_ARG, "photoAssetProxy is null");
-
     #ifdef USE_MOVING_PHOTO_PIPELINE
     auto recorder = GetRecorder();
     CHECK_EXECUTE(!isBursting && isSetMotionPhoto_ && recorder, {
         recorder->InsertPhotoAsset(timestamp, photoAssetProxy, captureId);
     });
     #else
-    if (!isBursting && isSetMotionPhoto_ && taskManager_) {
-        MEDIA_INFO_LOG("CreateMediaLibrary captureId :%{public}d", captureId);
-        if (taskManager_) {
-            taskManager_->SetVideoFd(timestamp, photoAssetProxy, captureId);
+    {
+        std::lock_guard<std::mutex> lock(motionPhotoStatusLock_);
+        bool isSetMotionPhoto = curMotionPhotoStatus_.find(captureId) != curMotionPhotoStatus_.end()
+            &&  curMotionPhotoStatus_[captureId];
+        if (!isBursting && isSetMotionPhoto && taskManager_) {
+            MEDIA_INFO_LOG("CreateMediaLibrary captureId :%{public}d", captureId);
+            if (taskManager_) {
+                taskManager_->SetVideoFd(timestamp, photoAssetProxy, captureId);    
+                curMotionPhotoStatus_.erase(captureId);
+            }
+        } else {
+            photoAssetProxy.reset();
         }
-    } else {
-        photoAssetProxy.reset();
     }
     #endif
     CameraReportDfxUtils::GetInstance()->SetAddProxyEndInfo(captureId);
-- 
2.45.2.huawei.8

