# Copyright (c) 2023 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
graphic_surface_path = "//foundation/graphic/graphic_surface"
graphic_2d_path = "//foundation/graphic/graphic_2d"
multimedia_camera_framework_path = "//foundation/multimedia/camera_framework"
multimedia_image_framework_path = "//foundation/multimedia/image_framework"
driver_camera_path = "//drivers/interface/camera"
third_party_path = "//third_party/googletest"
driver_peripheral_path = "//drivers/peripheral/camera"
base_security_path = "//base/security/access_token"
driver_disply_path = "//drivers/peripheral/display"
window_manager_path = "//foundation/window/window_manager"
system_safwk_path = "//utils/system/safwk"
multimedia_media_library_path = "//foundation/multimedia/media_library"

use_sensor = false
if (defined(global_parts_info) && defined(global_parts_info.sensors_sensor)) {
  use_sensor = true
}

use_thermal_manager = false
if (defined(global_parts_info) &&
    defined(global_parts_info.powermgr_thermal_manager)) {
  use_thermal_manager = true
}

use_battery_manager = false
if (defined(global_parts_info) &&
    defined(global_parts_info.powermgr_battery_manager)) {
  use_battery_manager = true
}

use_power_manager = false
if (defined(global_parts_info) &&
    defined(global_parts_info.powermgr_power_manager)) {
  use_power_manager = true
}

gen_camera_picker = true
hicollie_enable = true

From 3adb2335a6a0c0b65eef1793006cefcbee97d119 Mon Sep 17 00:00:00 2001
From: n00564676 <n00564676@notesmail.huawei.com/>
Date: Wed, 11 Sep 2024 10:45:22 +0800
Subject: [PATCH] DTS:DTS2024090604078 TicketNo:DTS2024090604078
 Description:movingphoto timstamp Team:OTHERS Feature or Bugfix:Bugfix Binary
 Source:No PrivateCode(Yes/No):No ------ DO NOT MODIFY, AUTO-GENERATED! ------
 Gitee-Issue: #I9RYCE Time: 2024-09-08T13:42:18.697Z PR-Num: 1433 Gitee-PR:
 https://openharmony.gitee.com/openharmony/multimedia_camera_framework/pulls/1433
 Comments-thread: I169564d19ed8bcf595f2395f56b36c2396910f01
 OpenSourceCenter_CR/openharmony/multimedia_camera_framework

Change-Id: I169564d19ed8bcf595f2395f56b36c2392d222df
Reviewed-by: l00510116
Approved-by: l00512942
Merged-on: https://open.codehub.huawei.com/OpenSourceCenter_CR/openharmony/multimedia_camera_framework/-/change_requests/2673
Merged-by: public hisicitools
---
 common/BUILD.gn                                  |  5 ++++-
 services/camera_service/BUILD.gn                 | 16 ++++++----------
 .../src/avcodec/avcodec_task_manager.cpp         |  8 ++++++--
 3 files changed, 16 insertions(+), 13 deletions(-)

diff --git a/common/BUILD.gn b/common/BUILD.gn
index 0daa89124..afe8ff533 100644
--- a/common/BUILD.gn
+++ b/common/BUILD.gn
@@ -29,7 +29,10 @@ ohos_source_set("camera_utils") {
 
   include_dirs = [ "utils" ]
 
-  sources = [ "utils/camera_xcollie.cpp", "utils/camera_dynamic_loader.cpp" ]
+  sources = [
+    "utils/camera_dynamic_loader.cpp",
+    "utils/camera_xcollie.cpp",
+  ]
 
   external_deps = [
     "c_utils:utils",
diff --git a/services/camera_service/BUILD.gn b/services/camera_service/BUILD.gn
index 5b74cd83e..51dc288a9 100644
--- a/services/camera_service/BUILD.gn
+++ b/services/camera_service/BUILD.gn
@@ -234,12 +234,10 @@ ohos_shared_library("camera_service") {
 
 ohos_shared_library("camera_dynamic_medialibrary") {
   install_enable = true
-  sources = [
-    "${multimedia_camera_framework_path}/services/camera_service/src/media_library/photo_asset_adapter.cpp",
-  ]
+  sources = [ "${multimedia_camera_framework_path}/services/camera_service/src/media_library/photo_asset_adapter.cpp" ]
   cflags = [
     "-fPIC",
-    "-Wall"
+    "-Wall",
   ]
   sanitize = {
     cfi = true
@@ -255,19 +253,17 @@ ohos_shared_library("camera_dynamic_medialibrary") {
     cflags += [ "-DBINDER_IPC_32BIT" ]
   }
 
-  deps = [
-    "${multimedia_camera_framework_path}/common:camera_utils",
-  ]
+  deps = [ "${multimedia_camera_framework_path}/common:camera_utils" ]
 
   external_deps = [
     "data_share:datashare_common",
     "data_share:datashare_consumer",
+    "hilog:libhilog",
+    "image_framework:image_native",
+    "ipc:ipc_single",
     "media_library:media_library",
     "media_library:media_library_manager",
-    "hilog:libhilog",
-    "ipc:ipc_single",
     "samgr:samgr_proxy",
-    "image_framework:image_native"
   ]
 
   cflags_cc = cflags
diff --git a/services/camera_service/src/avcodec/avcodec_task_manager.cpp b/services/camera_service/src/avcodec/avcodec_task_manager.cpp
index 38d68bb7f..dbab969ce 100644
--- a/services/camera_service/src/avcodec/avcodec_task_manager.cpp
+++ b/services/camera_service/src/avcodec/avcodec_task_manager.cpp
@@ -207,6 +207,7 @@ void AvcodecTaskManager::DoMuxerVideo(vector<sptr<FrameRecord>> frameRecords, ui
         vector<sptr<FrameRecord>> choosedBuffer;
         sptr<AudioVideoMuxer> muxer = thisPtr->CreateAVMuxer(frameRecords, captureRotation, choosedBuffer);
         CHECK_ERROR_RETURN_LOG(muxer == nullptr, "CreateAVMuxer failed");
+        CHECK_ERROR_RETURN_LOG(choosedBuffer.empty(), "choosed empty buffer!");
         int64_t videoStartTime = choosedBuffer.front()->GetTimeStamp();
         for (size_t index = 0; index < choosedBuffer.size(); index++) {
             MEDIA_DEBUG_LOG("write sample index %{public}zu", index);
@@ -245,7 +246,6 @@ void AvcodecTaskManager::ChooseVideoBuffer(vector<sptr<FrameRecord>> frameRecord
     vector<sptr<FrameRecord>> &choosedBuffer, int64_t shutterTime)
 {
     choosedBuffer.clear();
-    bool firstIDRFrame = false;
     int64_t nanosecRange = 1500000000LL;
     for (size_t index = 0; index < frameRecords.size(); ++index) {
         auto frame = frameRecords[index];
@@ -254,7 +254,7 @@ void AvcodecTaskManager::ChooseVideoBuffer(vector<sptr<FrameRecord>> frameRecord
             choosedBuffer.push_back(frame);
         }
     }
-    if (!choosedBuffer.empty() && !firstIDRFrame) {
+    if (!choosedBuffer.empty()) {
         // Find the first IDR frame in the buffer
         auto it = find_if(choosedBuffer.begin(), choosedBuffer.end(),
             [](const sptr<FrameRecord>& frame) { return frame->IsIDRFrame(); });
@@ -262,6 +262,10 @@ void AvcodecTaskManager::ChooseVideoBuffer(vector<sptr<FrameRecord>> frameRecord
             choosedBuffer.erase(choosedBuffer.begin(), it);
         }
     }
+    if (choosedBuffer.empty()) {
+        choosedBuffer = frameRecords;
+    }
+    MEDIA_INFO_LOG("ChooseVideoBuffer with size %{public}zu", choosedBuffer.size());
 }
 
 void AvcodecTaskManager::CollectAudioBuffer(vector<sptr<AudioRecord>> audioRecordVec, sptr<AudioVideoMuxer> muxer)
-- 
2.45.2.huawei.5



