# Copyright (c) 2023 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
graphic_surface_path = "//foundation/graphic/graphic_surface"
graphic_2d_path = "//foundation/graphic/graphic_2d"
multimedia_camera_framework_path = "//foundation/multimedia/camera_framework"
multimedia_image_framework_path = "//foundation/multimedia/image_framework"
driver_camera_path = "//drivers/interface/camera"
third_party_path = "//third_party/googletest"
driver_peripheral_path = "//drivers/peripheral/camera"
base_security_path = "//base/security/access_token"
driver_disply_path = "//drivers/peripheral/display"
window_manager_path = "//foundation/window/window_manager"
system_safwk_path = "//utils/system/safwk"
multimedia_media_library_path = "//foundation/multimedia/media_library"

use_sensor = false
if (defined(global_parts_info) && defined(global_parts_info.sensors_sensor)) {
  use_sensor = true
}

use_thermal_manager = false
if (defined(global_parts_info) &&
    defined(global_parts_info.powermgr_thermal_manager)) {
  use_thermal_manager = true
}

use_battery_manager = false
if (defined(global_parts_info) &&
    defined(global_parts_info.powermgr_battery_manager)) {
  use_battery_manager = true
}

use_power_manager = false
if (defined(global_parts_info) &&
    defined(global_parts_info.powermgr_power_manager)) {
  use_power_manager = true
}

gen_camera_picker = true
hicollie_enable = true




From 6d8e2d5aae1b1d286c4e94822b2e0f4d7bf04afe Mon Sep 17 00:00:00 2001
From: n00564676 <n00564676@notesmail.huawei.com/>
Date: Tue, 13 Aug 2024 14:38:07 +0800
Subject: [PATCH] TicketNo:DTS2024051804282 Description:dlopen medialibrary
 Team:EMUI Feature or Bugfix:Bugfix Binary Source:No PrivateCode(Yes/No):No
 ------ DO NOT MODIFY, AUTO-GENERATED! ------ Gitee-Issue: #IAIDAW Time:
 2024-08-07T06:56:26.825Z PR-Num: 1759 Gitee-PR:
 https://openharmony.gitee.com/openharmony/multimedia_camera_framework/pulls/1759

Change-Id: I51040b4f4dfb70aee9cd28f1445cfd68fb6d2723
Reviewed-by: x00680562
Approved-by: l00512942
Merged-on: https://open.codehub.huawei.com/OpenSourceCenter_CR/openharmony/multimedia_camera_framework/-/change_requests/2273
Merged-by: public hisicitools
---
 bundle.json                                   |   1 +
 common/BUILD.gn                               |   2 +-
 common/utils/camera_dynamic_loader.cpp        |  94 ++++++++++
 common/utils/camera_dynamic_loader.h          |  53 ++++++
 .../camera/src/session/capture_session.cpp    |   1 -
 services/camera_service/BUILD.gn              |  47 ++++-
 .../include/avcodec/audio_video_muxer.h       |   8 +-
 .../include/avcodec/avcodec_task_manager.h    |   7 +-
 .../camera_service/include/hcapture_session.h |  13 +-
 .../media_library/photo_asset_adapter.h       |  42 +++++
 .../media_library/photo_asset_interface.h     |  36 ++++
 .../src/avcodec/audio_video_muxer.cpp         |   9 +-
 .../src/avcodec/avcodec_task_manager.cpp      |  11 +-
 .../camera_service/src/camera_privacy.cpp     |  21 ++-
 .../camera_service/src/hcapture_session.cpp   | 165 +++++++++---------
 .../src/media_library/photo_asset_adapter.cpp |  89 ++++++++++
 .../task_manager/task_group/base_task_group.h |   2 +-
 .../task_manager/task_group/itask_group.h     |   1 +
 .../include/base/task_manager/task_manager.h  |   2 +-
 .../include/base/task_manager/task_registry.h |   2 +-
 .../task_group/base_task_group.cpp            |   7 +
 .../src/base/task_manager/task_manager.cpp    |   9 +
 .../src/base/task_manager/task_registry.cpp   |  12 ++
 23 files changed, 522 insertions(+), 112 deletions(-)
 create mode 100644 common/utils/camera_dynamic_loader.cpp
 create mode 100644 common/utils/camera_dynamic_loader.h
 create mode 100644 services/camera_service/include/media_library/photo_asset_adapter.h
 create mode 100644 services/camera_service/include/media_library/photo_asset_interface.h
 create mode 100644 services/camera_service/src/media_library/photo_asset_adapter.cpp

diff --git a/bundle.json b/bundle.json
index beb729330..e2734fc03 100644
--- a/bundle.json
+++ b/bundle.json
@@ -74,6 +74,7 @@
               "//foundation/multimedia/camera_framework/sa_profile:camera_service_sa_profile",
               "//foundation/multimedia/camera_framework/services/etc:camera_service.rc",
               "//foundation/multimedia/camera_framework/services/camera_service:camera_service",
+              "//foundation/multimedia/camera_framework/services/camera_service:camera_dynamic_medialibrary",
 	          "//foundation/multimedia/camera_framework/services/deferred_processing_service:deferred_processing_service"
             ]
           },
diff --git a/common/BUILD.gn b/common/BUILD.gn
index 6a7057d51..0daa89124 100644
--- a/common/BUILD.gn
+++ b/common/BUILD.gn
@@ -29,7 +29,7 @@ ohos_source_set("camera_utils") {
 
   include_dirs = [ "utils" ]
 
-  sources = [ "utils/camera_xcollie.cpp" ]
+  sources = [ "utils/camera_xcollie.cpp", "utils/camera_dynamic_loader.cpp" ]
 
   external_deps = [
     "c_utils:utils",
diff --git a/common/utils/camera_dynamic_loader.cpp b/common/utils/camera_dynamic_loader.cpp
new file mode 100644
index 000000000..3e2066690
--- /dev/null
+++ b/common/utils/camera_dynamic_loader.cpp
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ 
+#include <dlfcn.h>
+#include "camera_log.h"
+#include "camera_dynamic_loader.h"
+ 
+namespace OHOS {
+namespace CameraStandard {
+using namespace std;
+const char *librarySuffix = ".so";
+CameraDynamicLoader::CameraDynamicLoader()
+{
+    MEDIA_INFO_LOG("CameraDynamicLoader ctor");
+}
+
+CameraDynamicLoader::~CameraDynamicLoader()
+{
+    MEDIA_INFO_LOG("CameraDynamicLoader dtor");
+    for (auto iterator = dynamicLibHandle_.begin(); iterator != dynamicLibHandle_.end(); ++iterator) {
+        dlclose(iterator->second);
+        MEDIA_INFO_LOG("close library camera_dynamic success: %{public}s", iterator->first.c_str());
+    }
+}
+
+void* CameraDynamicLoader::OpenDynamicHandle(std::string dynamicLibrary)
+{
+    CAMERA_SYNC_TRACE;
+    std::lock_guard loaderLock(libLock_);
+    if (!EndsWith(dynamicLibrary, librarySuffix)) {
+        MEDIA_ERR_LOG("CloseDynamicHandle with error name!");
+        return nullptr;
+    }
+    if (dynamicLibHandle_[dynamicLibrary] == nullptr) {
+        void* dynamicLibHandle = dlopen(dynamicLibrary.c_str(), RTLD_NOW);
+        if (dynamicLibHandle == nullptr) {
+            MEDIA_ERR_LOG("Failed to open %{public}s, reason: %{public}sn", dynamicLibrary.c_str(), dlerror());
+            return nullptr;
+        }
+        MEDIA_INFO_LOG("open library %{public}s success", dynamicLibrary.c_str());
+        dynamicLibHandle_[dynamicLibrary] = dynamicLibHandle;
+    }
+    return dynamicLibHandle_[dynamicLibrary];
+}
+ 
+void* CameraDynamicLoader::GetFuntion(std::string dynamicLibrary, std::string function)
+{
+    CAMERA_SYNC_TRACE;
+    std::lock_guard loaderLock(libLock_);
+    // if not opened, then open directly
+    if (dynamicLibHandle_[dynamicLibrary] == nullptr) {
+        OpenDynamicHandle(dynamicLibrary);
+    }
+ 
+    void* handle = nullptr;
+    if (dynamicLibHandle_[dynamicLibrary] != nullptr) {
+        handle = dlsym(dynamicLibHandle_[dynamicLibrary], function.c_str());
+        if (handle == nullptr) {
+            MEDIA_ERR_LOG("Failed to load %{public}s, reason: %{public}sn", function.c_str(), dlerror());
+            return nullptr;
+        }
+        MEDIA_INFO_LOG("GetFuntion %{public}s success", function.c_str());
+    }
+    return handle;
+}
+ 
+void CameraDynamicLoader::CloseDynamicHandle(std::string dynamicLibrary)
+{
+    CAMERA_SYNC_TRACE;
+    std::lock_guard loaderLock(libLock_);
+    if (!EndsWith(dynamicLibrary, librarySuffix)) {
+        MEDIA_ERR_LOG("CloseDynamicHandle with error name!");
+        return;
+    }
+    if (dynamicLibHandle_[dynamicLibrary] != nullptr) {
+        dlclose(dynamicLibHandle_[dynamicLibrary]);
+        dynamicLibHandle_[dynamicLibrary] = nullptr;
+        MEDIA_INFO_LOG("close library camera_dynamic success: %{public}s", dynamicLibrary.c_str());
+    }
+}
+}  // namespace Camera
+}  // namespace OHOS
\ No newline at end of file
diff --git a/common/utils/camera_dynamic_loader.h b/common/utils/camera_dynamic_loader.h
new file mode 100644
index 000000000..7d94b373c
--- /dev/null
+++ b/common/utils/camera_dynamic_loader.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ 
+#ifndef OHOS_CAMERA_DYNAMIC_LOADER_H
+#define OHOS_CAMERA_DYNAMIC_LOADER_H
+ 
+#include <map>
+#include <memory>
+#include <mutex>
+#include <string>
+
+namespace OHOS {
+namespace CameraStandard {
+using namespace std;
+
+const std::string MEDIA_LIB_SO = "libcamera_dynamic_medialibrary.z.so";
+
+class CameraDynamicLoader {
+public:
+    CameraDynamicLoader();
+    ~CameraDynamicLoader();
+ 
+    void* OpenDynamicHandle(std::string dynamicLibrary);
+    void CloseDynamicHandle(std::string dynamicLibrary);
+    void* GetFuntion(std::string dynamicLibrary, std::string function);
+    inline bool EndsWith(const std::string& str, const std::string& suffix)
+    {
+        if (str.length() >= suffix.length()) {
+            return str.compare(str.length() - suffix.length(), suffix.length(), suffix) == 0;
+        }
+        return false;
+    }
+
+private:
+    std::map<std::string, void *> dynamicLibHandle_;
+    std::recursive_mutex libLock_;
+};
+ 
+}  // namespace Camera
+}  // namespace OHOS
+#endif // OHOS_CAMERA_DYNAMIC_LOADER_H
\ No newline at end of file
diff --git a/frameworks/native/camera/src/session/capture_session.cpp b/frameworks/native/camera/src/session/capture_session.cpp
index c7cdb7fb8..245dc7fad 100644
--- a/frameworks/native/camera/src/session/capture_session.cpp
+++ b/frameworks/native/camera/src/session/capture_session.cpp
@@ -36,7 +36,6 @@
 #include "input/camera_input.h"
 #include "input/camera_manager.h"
 #include "ipc_skeleton.h"
-#include "media_photo_asset_proxy.h"
 #include "os_account_manager.h"
 #include "output/metadata_output.h"
 #include "output/photo_output.h"
diff --git a/services/camera_service/BUILD.gn b/services/camera_service/BUILD.gn
index a021c8753..5b74cd83e 100644
--- a/services/camera_service/BUILD.gn
+++ b/services/camera_service/BUILD.gn
@@ -129,6 +129,7 @@ ohos_shared_library("camera_service") {
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/session",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/session/photo_session",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/utils",
+    "//foundation/multimedia/media_library/interfaces/inner_api/media_library_helper/include",
   ]
 
   if (target_cpu == "arm") {
@@ -183,8 +184,6 @@ ohos_shared_library("camera_service") {
     "ipc:ipc_single",
     "media_foundation:media_foundation",
     "media_foundation:native_media_core",
-    "media_library:media_library",
-    "media_library:media_library_manager",
     "memmgr:memmgrclient",
     "os_account:libaccountkits",
     "os_account:os_account_innerkits",
@@ -232,3 +231,47 @@ ohos_shared_library("camera_service") {
   part_name = "camera_framework"
   subsystem_name = "multimedia"
 }
+
+ohos_shared_library("camera_dynamic_medialibrary") {
+  install_enable = true
+  sources = [
+    "${multimedia_camera_framework_path}/services/camera_service/src/media_library/photo_asset_adapter.cpp",
+  ]
+  cflags = [
+    "-fPIC",
+    "-Wall"
+  ]
+  sanitize = {
+    cfi = true
+    cfi_cross_dso = true
+    debug = false
+  }
+  include_dirs = [
+    "${multimedia_camera_framework_path}/common/utils",
+    "${multimedia_camera_framework_path}/services/camera_service/include/media_library",
+  ]
+
+  if (target_cpu == "arm") {
+    cflags += [ "-DBINDER_IPC_32BIT" ]
+  }
+
+  deps = [
+    "${multimedia_camera_framework_path}/common:camera_utils",
+  ]
+
+  external_deps = [
+    "data_share:datashare_common",
+    "data_share:datashare_consumer",
+    "media_library:media_library",
+    "media_library:media_library_manager",
+    "hilog:libhilog",
+    "ipc:ipc_single",
+    "samgr:samgr_proxy",
+    "image_framework:image_native"
+  ]
+
+  cflags_cc = cflags
+
+  part_name = "camera_framework"
+  subsystem_name = "multimedia"
+}
diff --git a/services/camera_service/include/avcodec/audio_video_muxer.h b/services/camera_service/include/avcodec/audio_video_muxer.h
index e49678c91..fbdd98cd9 100644
--- a/services/camera_service/include/avcodec/audio_video_muxer.h
+++ b/services/camera_service/include/avcodec/audio_video_muxer.h
@@ -24,8 +24,8 @@
 #include <cstdint>
 #include <refbase.h>
 #include "avmuxer.h"
-#include "media_photo_asset_proxy.h"
 #include "media_description.h"
+#include "media_library/photo_asset_interface.h"
 
 namespace OHOS {
 namespace CameraStandard {
@@ -40,7 +40,7 @@ public:
     explicit AudioVideoMuxer();
     ~AudioVideoMuxer();
 
-    int32_t Create(OH_AVOutputFormat format, std::shared_ptr<Media::PhotoAssetProxy> photoAssetProxy);
+    int32_t Create(OH_AVOutputFormat format, PhotoAssetIntf* photoAssetProxy);
     int32_t AddTrack(int &trackId, std::shared_ptr<Format> format, TrackType type);
     int32_t Start();
     int32_t WriteSampleBuffer(std::shared_ptr<OHOS::Media::AVBuffer> sample, TrackType type);
@@ -50,13 +50,13 @@ public:
     int32_t SetCoverTime(float timems);
     int32_t SetTimedMetadata();
     int32_t GetVideoFd();
-    std::shared_ptr<Media::PhotoAssetProxy> GetPhotoAssetProxy();
+    PhotoAssetIntf* GetPhotoAssetProxy();
     std::atomic<int32_t> releaseSignal_ = 2;
 
 private:
     std::shared_ptr<AVMuxer> muxer_ = nullptr;
     int32_t fd_ = -1;
-    std::shared_ptr<Media::PhotoAssetProxy> photoAssetProxy_;
+    PhotoAssetIntf* photoAssetProxy_ = nullptr;
     int audioTrackId_ = -1;
     int videoTrackId_ = -1;
     int metaTrackId_ = -1;
diff --git a/services/camera_service/include/avcodec/avcodec_task_manager.h b/services/camera_service/include/avcodec/avcodec_task_manager.h
index 7ecf55133..5ada6b7fb 100644
--- a/services/camera_service/include/avcodec/avcodec_task_manager.h
+++ b/services/camera_service/include/avcodec/avcodec_task_manager.h
@@ -34,8 +34,6 @@
 #include "iconsumer_surface.h"
 #include "blocking_queue.h"
 #include "task_manager.h"
-
-#include "media_photo_asset_proxy.h"
 #include "camera_util.h"
 namespace OHOS {
 namespace CameraStandard {
@@ -56,12 +54,11 @@ public:
     void DoMuxerVideo(vector<sptr<FrameRecord>> frameRecords, uint64_t taskName, int32_t captureRotation);
     sptr<AudioVideoMuxer> CreateAVMuxer(vector<sptr<FrameRecord>> frameRecords, int32_t captureRotation);
     void SubmitTask(function<void()> task);
-    void SetVideoFd(int64_t timestamp, shared_ptr<PhotoAssetProxy> photoAssetProxy);
+    void SetVideoFd(int64_t timestamp, PhotoAssetIntf* photoAssetProxy);
     void Stop();
     void ClearTaskResource();
     shared_ptr<TaskManager>& GetTaskManager();
     shared_ptr<TaskManager>& GetEncoderManager();
-
 private:
     void FinishMuxer(sptr<AudioVideoMuxer> muxer);
     void Release();
@@ -75,7 +72,7 @@ private:
     mutex taskManagerMutex_;
     mutex encoderManagerMutex_;
     std::atomic<bool> isActive_ { true };
-    queue<std::pair<int64_t, shared_ptr<PhotoAssetProxy>>> videoFdQueue_;
+    queue<std::pair<int64_t, PhotoAssetIntf*>> videoFdQueue_;
     VideoCodecType videoCodecType_ = VideoCodecType::VIDEO_ENCODE_TYPE_AVC;
 };
 } // CameraStandard
diff --git a/services/camera_service/include/hcapture_session.h b/services/camera_service/include/hcapture_session.h
index 03d209395..21cb2e6cf 100644
--- a/services/camera_service/include/hcapture_session.h
+++ b/services/camera_service/include/hcapture_session.h
@@ -29,6 +29,7 @@
 #include <unordered_set>
 #include "camera_util.h"
 #include "fixed_size_list.h"
+#include "camera_dynamic_loader.h"
 #include "hcamera_device.h"
 #include "hcapture_session_stub.h"
 #include "hstream_capture.h"
@@ -260,6 +261,14 @@ public:
     void DumpSessionInfo(CameraInfoDumper& infoDumper);
     static void DumpSessions(CameraInfoDumper& infoDumper);
     static void DumpCameraSessionSummary(CameraInfoDumper& infoDumper);
+    void ReleaseStreams();
+    void StopMovingPhoto();
+
+    static void OpenMediaLib();
+    static void DelayCloseMediaLib();
+    static shared_ptr<CameraDynamicLoader> dynamicLoader_;
+    static std::optional<uint32_t> closeTimerId_;
+    static std::mutex g_mediaTaskLock_;
 
 private:
     int32_t Initialize(const uint32_t callerToken, int32_t opMode);
@@ -291,12 +300,10 @@ private:
     int32_t LinkInputAndOutputs();
     int32_t UnlinkInputAndOutputs();
 
-    void ReleaseStreams();
     void ClearSketchRepeatStream();
     void ExpandSketchRepeatStream();
     void ExpandMovingPhotoRepeatStream();
     void ClearMovingPhotoRepeatStream();
-    void StopMovingPhoto();
     int32_t CreateMovingPhotoStreamRepeat(int32_t format, int32_t width, int32_t height,
         sptr<OHOS::IBufferProducer> producer);
     int32_t CheckIfColorSpaceMatchesFormat(ColorSpace colorSpace);
@@ -359,8 +366,6 @@ private:
     std::mutex displayListenerLock_;
     sptr<DisplayRotationListener> displayListener_;
 };
-
-
 } // namespace CameraStandard
 } // namespace OHOS
 #endif // OHOS_CAMERA_H_CAPTURE_SESSION_H
diff --git a/services/camera_service/include/media_library/photo_asset_adapter.h b/services/camera_service/include/media_library/photo_asset_adapter.h
new file mode 100644
index 000000000..017f7bb91
--- /dev/null
+++ b/services/camera_service/include/media_library/photo_asset_adapter.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CAMERA_PHOTO_ASSET_INTERFACE_H
+#define CAMERA_PHOTO_ASSET_INTERFACE_H
+
+#include "photo_asset_interface.h"
+#include "media_library_manager.h"
+#include "media_photo_asset_proxy.h"
+namespace OHOS {
+namespace CameraStandard {
+
+class PhotoAssetAdapter : public OHOS::CameraStandard::PhotoAssetIntf {
+public:
+    PhotoAssetAdapter(int32_t cameraShotType);
+    virtual ~PhotoAssetAdapter() = default;
+    void AddPhotoProxy(sptr<Media::PhotoProxy> photoProxy);
+    std::string GetPhotoAssetUri();
+    int32_t GetVideoFd();
+    void NotifyVideoSaveFinished();
+    int32_t GetUserId();
+private:
+    std::shared_ptr<Media::PhotoAssetProxy> photoAssetProxy_ = nullptr;
+    int32_t userId_ = -1;
+};
+
+} // namespace CameraStandard
+} // namespace OHOS
+
+#endif // CAMERA_PHOTO_ASSET_INTERFACE_H
\ No newline at end of file
diff --git a/services/camera_service/include/media_library/photo_asset_interface.h b/services/camera_service/include/media_library/photo_asset_interface.h
new file mode 100644
index 000000000..b1614dd86
--- /dev/null
+++ b/services/camera_service/include/media_library/photo_asset_interface.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_FRAMEWORK_MEDIA_LIBRARY_INTERFACE_H
+#define OHOS_CAMERA_FRAMEWORK_MEDIA_LIBRARY_INTERFACE_H
+#include "photo_proxy.h"
+#include <cstdint>
+#include <string>
+/**
+ * @brief Internal usage only, for camera framework interacts with photo asset related interfaces.
+ * @since 12
+ */
+namespace OHOS::CameraStandard {
+class PhotoAssetIntf {
+public:
+    virtual void AddPhotoProxy(sptr<Media::PhotoProxy> photoProxy);
+    virtual std::string GetPhotoAssetUri();
+    virtual int32_t GetVideoFd();
+    virtual void NotifyVideoSaveFinished();
+    virtual int32_t GetUserId();
+    virtual ~PhotoAssetIntf() = default;
+};
+} // namespace OHOS::CameraStandard
+#endif
\ No newline at end of file
diff --git a/services/camera_service/src/avcodec/audio_video_muxer.cpp b/services/camera_service/src/avcodec/audio_video_muxer.cpp
index fc771721d..4fd9ee979 100644
--- a/services/camera_service/src/avcodec/audio_video_muxer.cpp
+++ b/services/camera_service/src/avcodec/audio_video_muxer.cpp
@@ -18,6 +18,7 @@
 #include "audio_video_muxer.h"
 #include "camera_log.h"
 #include "native_mfmagic.h"
+#include "camera_dynamic_loader.h"
 
 namespace OHOS {
 namespace CameraStandard {
@@ -31,10 +32,12 @@ AudioVideoMuxer::~AudioVideoMuxer()
     MEDIA_INFO_LOG("~AudioVideoMuxer enter");
 }
 
-int32_t AudioVideoMuxer::Create(OH_AVOutputFormat format, std::shared_ptr<Media::PhotoAssetProxy> photoAssetProxy)
+int32_t AudioVideoMuxer::Create(OH_AVOutputFormat format, PhotoAssetIntf* photoAssetProxy)
 {
     photoAssetProxy_ = photoAssetProxy;
-    fd_ = photoAssetProxy_->GetVideoFd();
+    if (photoAssetProxy) {
+        fd_ = photoAssetProxy_->GetVideoFd();
+    }
     MEDIA_INFO_LOG("CreateAVMuxer with videoFd: %{public}d", fd_);
     muxer_ = AVMuxerFactory::CreateAVMuxer(fd_, static_cast<Plugins::OutputFormat>(format));
     CHECK_AND_RETURN_RET_LOG(muxer_ != nullptr, 1, "create muxer failed!");
@@ -109,7 +112,7 @@ int32_t AudioVideoMuxer::GetVideoFd()
     return fd_;
 }
 
-std::shared_ptr<Media::PhotoAssetProxy> AudioVideoMuxer::GetPhotoAssetProxy()
+PhotoAssetIntf* AudioVideoMuxer::GetPhotoAssetProxy()
 {
     return photoAssetProxy_;
 }
diff --git a/services/camera_service/src/avcodec/avcodec_task_manager.cpp b/services/camera_service/src/avcodec/avcodec_task_manager.cpp
index 78fbbe297..b819e5dcf 100644
--- a/services/camera_service/src/avcodec/avcodec_task_manager.cpp
+++ b/services/camera_service/src/avcodec/avcodec_task_manager.cpp
@@ -119,7 +119,7 @@ void AvcodecTaskManager::SubmitTask(function<void()> task)
     }
 }
 
-void AvcodecTaskManager::SetVideoFd(int64_t timestamp, shared_ptr<PhotoAssetProxy> photoAssetProxy)
+void AvcodecTaskManager::SetVideoFd(int64_t timestamp, PhotoAssetIntf* photoAssetProxy)
 {
     lock_guard<mutex> lock(videoFdMutex_);
     MEDIA_INFO_LOG("Set timestamp: %{public}" PRId64, timestamp);
@@ -141,7 +141,7 @@ sptr<AudioVideoMuxer> AvcodecTaskManager::CreateAVMuxer(vector<sptr<FrameRecord>
     sptr<AudioVideoMuxer> muxer = new AudioVideoMuxer();
     OH_AVOutputFormat format = AV_OUTPUT_FORMAT_MPEG_4;
     int64_t timestamp = videoFdQueue_.front().first;
-    shared_ptr<PhotoAssetProxy> photoAssetProxy = videoFdQueue_.front().second;
+    auto photoAssetProxy = videoFdQueue_.front().second;
     videoFdQueue_.pop();
     float coverTime = 0.0f;
     for (size_t index = 0; index < frameRecords.size(); index++) {
@@ -185,10 +185,11 @@ void AvcodecTaskManager::FinishMuxer(sptr<AudioVideoMuxer> muxer)
     CAMERA_SYNC_TRACE;
     MEDIA_INFO_LOG("doMxuer video is finished");
     if (muxer) {
-        shared_ptr<PhotoAssetProxy> proxy = muxer->GetPhotoAssetProxy();
+        PhotoAssetIntf* proxy = muxer->GetPhotoAssetProxy();
         MEDIA_INFO_LOG("PhotoAssetProxy notify enter");
         if (proxy) {
             proxy->NotifyVideoSaveFinished();
+            delete proxy;
         }
         muxer->Stop();
         muxer->Release();
@@ -300,8 +301,12 @@ void AvcodecTaskManager::Release()
     unique_lock<mutex> lock(videoFdMutex_);
     while (!videoFdQueue_.empty()) {
         int32_t fd = videoFdQueue_.front().first;
+        PhotoAssetIntf* photoAssetProxy = videoFdQueue_.front().second;
         MEDIA_INFO_LOG("close with videoFd: %{public}d", fd);
         close(fd);
+        if (photoAssetProxy) {
+            delete photoAssetProxy;
+        }
         videoFdQueue_.pop();
     }
     MEDIA_INFO_LOG("AvcodecTaskManager release end");
diff --git a/services/camera_service/src/camera_privacy.cpp b/services/camera_service/src/camera_privacy.cpp
index 4675d7f5e..4d2f3d2ea 100644
--- a/services/camera_service/src/camera_privacy.cpp
+++ b/services/camera_service/src/camera_privacy.cpp
@@ -16,6 +16,7 @@
 #include "camera_privacy.h"
 #include "camera_log.h"
 #include "hcamera_device.h"
+#include "hcapture_session.h"
 #include "types.h"
 
 namespace OHOS {
@@ -23,12 +24,25 @@ namespace CameraStandard {
 using OHOS::Security::AccessToken::PrivacyKit;
 using OHOS::Security::AccessToken::AccessTokenKit;
 
+sptr<HCaptureSession> CastToSession(sptr<IStreamOperatorCallback> streamOpCb)
+{
+    if (streamOpCb == nullptr) {
+        return nullptr;
+    }
+    return static_cast<HCaptureSession*>(streamOpCb.GetRefPtr());
+}
+
 void PermissionStatusChangeCb::PermStateChangeCallback(Security::AccessToken::PermStateChangeInfo& result)
 {
-    MEDIA_INFO_LOG("enter CameraUseStateChangeNotify permStateChangeType:%{public}d tokenId:%{public}d"
+    MEDIA_INFO_LOG("enter PermissionStatusChangeNotify permStateChangeType:%{public}d tokenId:%{public}d"
         " permissionName:%{public}s", result.permStateChangeType, result.tokenID, result.permissionName.c_str());
     auto device = cameraDevice_.promote();
     if ((result.permStateChangeType == 0) && (device != nullptr)) {
+        auto session = CastToSession(device->GetStreamOperatorCallback());
+        if (session) {
+            session->ReleaseStreams();
+            session->StopMovingPhoto();
+        }
         device->CloseDevice();
         device->OnError(DEVICE_PREEMPT, 0);
     }
@@ -39,6 +53,11 @@ void CameraUseStateChangeCb::StateChangeNotify(Security::AccessToken::AccessToke
     MEDIA_INFO_LOG("enter CameraUseStateChangeNotify tokenId:%{public}d", tokenId);
     auto device = cameraDevice_.promote();
     if ((isShowing == false) && (device != nullptr)) {
+        auto session = CastToSession(device->GetStreamOperatorCallback());
+        if (session) {
+            session->ReleaseStreams();
+            session->StopMovingPhoto();
+        }
         device->CloseDevice();
     }
 }
diff --git a/services/camera_service/src/hcapture_session.cpp b/services/camera_service/src/hcapture_session.cpp
index fa99e7955..255384188 100644
--- a/services/camera_service/src/hcapture_session.cpp
+++ b/services/camera_service/src/hcapture_session.cpp
@@ -57,7 +57,7 @@
 #include "ipc_skeleton.h"
 #include "iservice_registry.h"
 #include "istream_common.h"
-#include "media_library_manager.h"
+#include "media_library/photo_asset_interface.h"
 #include "metadata_utils.h"
 #include "moving_photo/moving_photo_surface_wrapper.h"
 #include "moving_photo_video_cache.h"
@@ -70,11 +70,15 @@
 #include "deferred_processing_service.h"
 #include "picture.h"
 #include "fixed_size_list.h"
+#include "camera_timer.h"
 
 using namespace OHOS::AAFwk;
 namespace OHOS {
 namespace CameraStandard {
 using namespace OHOS::HDI::Display::Composer::V1_1;
+std::shared_ptr<CameraDynamicLoader> HCaptureSession::dynamicLoader_ = std::make_shared<CameraDynamicLoader>();
+std::optional<uint32_t> HCaptureSession::closeTimerId_ = std::nullopt;
+std::mutex HCaptureSession::g_mediaTaskLock_;
 
 namespace {
 static std::map<pid_t, sptr<HCaptureSession>> g_totalSessions;
@@ -181,9 +185,11 @@ HCaptureSession::HCaptureSession(const uint32_t callingTokenId, int32_t opMode)
 
 HCaptureSession::~HCaptureSession()
 {
+    CAMERA_SYNC_TRACE;
     Release(CaptureSessionReleaseType::RELEASE_TYPE_OBJ_DIED);
     if (displayListener_) {
         OHOS::Rosen::DisplayManagerLite::GetInstance().UnregisterDisplayListener(displayListener_);
+        displayListener_ = nullptr;
     }
 }
 
@@ -322,6 +328,7 @@ int32_t HCaptureSession::AddInput(sptr<ICameraDeviceService> cameraDevice)
 
 int32_t HCaptureSession::AddOutputStream(sptr<HStreamCommon> stream)
 {
+    CAMERA_SYNC_TRACE;
     CHECK_ERROR_RETURN_RET_LOG(stream == nullptr, CAMERA_INVALID_ARG,
         "HCaptureSession::AddOutputStream stream is null");
     MEDIA_INFO_LOG("HCaptureSession::AddOutputStream streamId:%{public}d streamType:%{public}d",
@@ -335,12 +342,24 @@ int32_t HCaptureSession::AddOutputStream(sptr<HStreamCommon> stream)
         auto captureStream = CastStream<HStreamCapture>(stream);
         captureStream->SetMode(opMode_);
         captureStream->SetColorSpace(currCaptureColorSpace_);
+        HCaptureSession::OpenMediaLib();
     } else {
         stream->SetColorSpace(currColorSpace_);
     }
     return CAMERA_OK;
 }
 
+void HCaptureSession::OpenMediaLib()
+{
+    std::lock_guard<std::mutex> lock(g_mediaTaskLock_);
+    if (closeTimerId_.has_value()) {
+        CameraTimer::GetInstance()->Unregister(closeTimerId_.value());
+        closeTimerId_.reset();
+    }
+    std::future<void> futureResult = std::async(std::launch::async,
+        [&] { dynamicLoader_->OpenDynamicHandle(MEDIA_LIB_SO); });
+}
+
 void HCaptureSession::StartMovingPhotoStream()
 {
     int32_t errorCode = 0;
@@ -560,6 +579,17 @@ int32_t HCaptureSession::RemoveOutputStream(sptr<HStreamCommon> stream)
     return CAMERA_OK;
 }
 
+void HCaptureSession::DelayCloseMediaLib()
+{
+    std::lock_guard<std::mutex> lock(g_mediaTaskLock_);
+    constexpr uint32_t waitMs = 30 * 1000;
+    if (!closeTimerId_.has_value()) {
+        closeTimerId_ = CameraTimer::GetInstance()->Register([]() {
+            dynamicLoader_->CloseDynamicHandle(MEDIA_LIB_SO);
+        }, waitMs, true);
+    }
+}
+
 int32_t HCaptureSession::RemoveOutput(StreamType streamType, sptr<IStreamCommon> stream)
 {
     int32_t errorCode = CAMERA_INVALID_ARG;
@@ -578,6 +608,7 @@ int32_t HCaptureSession::RemoveOutput(StreamType streamType, sptr<IStreamCommon>
         }
         if (streamType == StreamType::CAPTURE) {
             errorCode = RemoveOutputStream(static_cast<HStreamCapture*>(stream.GetRefPtr()));
+            HCaptureSession::DelayCloseMediaLib();
         } else if (streamType == StreamType::REPEAT) {
             HStreamRepeat* repeatSteam = static_cast<HStreamRepeat*>(stream.GetRefPtr());
             if (enableStreamRotate_ && repeatSteam != nullptr &&
@@ -1415,6 +1446,7 @@ void HCaptureSession::ReleaseStreams()
     if ((cameraDevice != nullptr) && !hdiStreamIds.empty()) {
         cameraDevice->ReleaseStreams(hdiStreamIds);
     }
+    HCaptureSession::DelayCloseMediaLib();
 }
 
 int32_t HCaptureSession::Release(CaptureSessionReleaseType type)
@@ -1458,6 +1490,10 @@ int32_t HCaptureSession::Release(CaptureSessionReleaseType type)
         #endif
         stateMachine_.Transfer(CaptureSessionState::SESSION_RELEASED);
         isSessionStarted_ = false;
+        if (displayListener_) {
+            OHOS::Rosen::DisplayManagerLite::GetInstance().UnregisterDisplayListener(displayListener_);
+            displayListener_ = nullptr;
+        }
         std::lock_guard<std::mutex> lock(movingPhotoStatusLock_);
         livephotoListener_ = nullptr;
         videoCache_ = nullptr;
@@ -1465,7 +1501,7 @@ int32_t HCaptureSession::Release(CaptureSessionReleaseType type)
             taskManager_->ClearTaskResource();
             taskManager_ = nullptr;
         }
-        audioCapturerSession_ = nullptr;
+        HCaptureSession::DelayCloseMediaLib();
     });
     MEDIA_INFO_LOG("HCaptureSession::Release execute success");
     return errorCode;
@@ -1757,45 +1793,29 @@ std::string HCaptureSession::CreateBurstDisplayName(int32_t seqId)
     return formattedTime;
 }
 
+typedef PhotoAssetIntf* (*GetPhotoAssetProxy)(int32_t);
+
 int32_t HCaptureSession::CreateMediaLibrary(sptr<CameraPhotoProxy> &photoProxy,
     std::string &uri, int32_t &cameraShotType, std::string &burstKey, int64_t timestamp)
 {
     CAMERA_SYNC_TRACE;
-    sptr<IRemoteObject> object = nullptr;
-    auto samgr = SystemAbilityManagerClient::GetInstance().GetSystemAbilityManager();
-    CHECK_ERROR_RETURN_RET_LOG(samgr == nullptr, CAMERA_UNKNOWN_ERROR, "Failed to get System ability manager");
-    object = samgr->GetSystemAbility(CAMERA_SERVICE_ID);
-    CHECK_ERROR_RETURN_RET_LOG(object == nullptr, CAMERA_UNKNOWN_ERROR, "object is null");
-    auto mediaLibraryManager = Media::MediaLibraryManager::GetMediaLibraryManager();
-    CHECK_ERROR_RETURN_RET_LOG(mediaLibraryManager == nullptr, CAMERA_UNKNOWN_ERROR,
-        "Error to init mediaLibraryManager");
-    mediaLibraryManager->InitMediaLibraryManager(object);
-    const static int32_t INVALID_UID = -1;
-    const static int32_t BASE_USER_RANGE = 200000;
-    int uid = IPCSkeleton::GetCallingUid();
-    CHECK_ERROR_PRINT_LOG(uid <= INVALID_UID, "Get INVALID_UID UID %{public}d", uid);
-    int32_t userId = uid / BASE_USER_RANGE;
-    MEDIA_DEBUG_LOG("get uid:%{public}d, userId:%{public}d, tokenId:%{public}d", uid, userId,
-        IPCSkeleton::GetCallingTokenID());
-    auto type = isSetMotionPhoto_ ? CameraShotType::MOVING_PHOTO : CameraShotType::IMAGE;
-    cameraShotType = static_cast<int32_t>(type);
+    constexpr int32_t movingPhotoShotType = 2;
+    constexpr int32_t imageShotType = 0;
+    cameraShotType = isSetMotionPhoto_ ? movingPhotoShotType : imageShotType;
     MessageParcel data;
     photoProxy->WriteToParcel(data);
     photoProxy->CameraFreeBufferHandle();
-    sptr<CameraServerPhotoProxy> cameraServerPhotoProxy = new CameraServerPhotoProxy();
-    cameraServerPhotoProxy->ReadFromParcel(data);
-    cameraServerPhotoProxy->SetDisplayName(CreateDisplayName(suffixJpeg));
-    cameraServerPhotoProxy->SetShootingMode(opMode_);
-    int32_t captureId = cameraServerPhotoProxy->GetCaptureId();
-    std::string imageId = cameraServerPhotoProxy->GetPhotoId();
+    sptr<CameraServerPhotoProxy> cameraPhotoProxy = new CameraServerPhotoProxy();
+    cameraPhotoProxy->ReadFromParcel(data);
+    cameraPhotoProxy->SetDisplayName(CreateDisplayName(suffixJpeg));
+    cameraPhotoProxy->SetShootingMode(opMode_);
+    int32_t captureId = cameraPhotoProxy->GetCaptureId();
+    std::string imageId = cameraPhotoProxy->GetPhotoId();
     bool isBursting = false;
     bool isCoverPhoto = false;
     auto captureStreams = streamContainer_.GetStreams(StreamType::CAPTURE);
     for (auto& stream : captureStreams) {
-        MEDIA_INFO_LOG("for captureStreams");
-        if (stream == nullptr) {
-            continue;
-        }
+        CHECK_AND_CONTINUE_LOG(stream != nullptr, "stream is null");
         MEDIA_INFO_LOG("CreateMediaLibrary get captureStream");
         auto streamCapture = CastStream<HStreamCapture>(stream);
         isBursting = streamCapture->IsBurstCapture(captureId);
@@ -1804,83 +1824,56 @@ int32_t HCaptureSession::CreateMediaLibrary(sptr<CameraPhotoProxy> &photoProxy,
             streamCapture->SetBurstImages(captureId, imageId);
             isCoverPhoto = streamCapture->IsBurstCover(captureId);
             int32_t imageSeq = streamCapture->GetCurBurstSeq(captureId);
-            cameraServerPhotoProxy->SetDisplayName(CreateBurstDisplayName(imageSeq));
+            cameraPhotoProxy->SetDisplayName(CreateBurstDisplayName(imageSeq));
             streamCapture->CheckResetBurstKey(captureId);
-            MEDIA_INFO_LOG("CreateMediaLibrary isBursting burstKey:%{public}s isCoverPhoto:%{public}d",
-                burstKey.c_str(), isCoverPhoto);
-            type = CameraShotType::BURST;
-            cameraShotType = static_cast<int32_t>(CameraShotType::BURST);
-            cameraServerPhotoProxy->SetBurstInfo(burstKey, isCoverPhoto);
+            MEDIA_INFO_LOG("isBursting burstKey:%{public}s isCoverPhoto:%{public}d", burstKey.c_str(), isCoverPhoto);
+            int32_t burstShotType = 3;
+            cameraShotType = burstShotType;
+            cameraPhotoProxy->SetBurstInfo(burstKey, isCoverPhoto);
             break;
         }
-        MEDIA_INFO_LOG("CreateMediaLibrary not Bursting");
     }
-
-    if (cameraServerPhotoProxy->GetPhotoQuality() == Media::PhotoQuality::HIGH) {
-        MEDIA_INFO_LOG("CreateMediaLibrary Media::PhotoQuality::HIGH");
-    }
-    if (cameraServerPhotoProxy->GetFormat() == Media::PhotoFormat::JPG) {
-        MEDIA_INFO_LOG("CreateMediaLibrary Media::PhotoFormat::JPG");
-    }
-
-    auto photoAssetProxy = mediaLibraryManager->CreatePhotoAssetProxy(type, uid, userId);
-    photoAssetProxy->AddPhotoProxy((sptr<PhotoProxy>&)cameraServerPhotoProxy);
+    MEDIA_INFO_LOG("GetLocation latitude:%{public}f, quality:%{public}d, format:%{public}d,",
+        cameraPhotoProxy->GetLatitude(), cameraPhotoProxy->GetPhotoQuality(), cameraPhotoProxy->GetFormat());
+    GetPhotoAssetProxy getPhotoAssetProxy = (GetPhotoAssetProxy)dynamicLoader_->GetFuntion(
+        MEDIA_LIB_SO, "createPhotoAssetIntf");
+    PhotoAssetIntf* photoAssetProxy = getPhotoAssetProxy(cameraShotType);
+    photoAssetProxy->AddPhotoProxy((sptr<PhotoProxy>&)cameraPhotoProxy);
     uri = photoAssetProxy->GetPhotoAssetUri();
     if (isSetMotionPhoto_ && taskManager_) {
         MEDIA_INFO_LOG("taskManager setVideoFd start");
         taskManager_->SetVideoFd(timestamp, photoAssetProxy);
+    } else {
+        delete photoAssetProxy;
     }
     return CAMERA_OK;
 }
 
-inline MediaLibraryManager* GetMediaLibraryManager()
-{
-    auto samgr = SystemAbilityManagerClient::GetInstance().GetSystemAbilityManager();
-    CHECK_ERROR_RETURN_RET_LOG(samgr == nullptr, nullptr, "Failed to get System ability manager");
-    sptr<IRemoteObject> object = samgr->GetSystemAbility(CAMERA_SERVICE_ID);
-    CHECK_ERROR_RETURN_RET_LOG(object == nullptr, nullptr, "object is null");
-    auto mediaLibraryManager =  Media::MediaLibraryManager::GetMediaLibraryManager();
-    if (mediaLibraryManager) {
-        mediaLibraryManager->InitMediaLibraryManager(object);
-    }
-    return mediaLibraryManager;
-}
-
 int32_t HCaptureSession::CreateMediaLibrary(std::unique_ptr<Media::Picture> picture, sptr<CameraPhotoProxy> &photoProxy,
     std::string &uri, int32_t &cameraShotType)
 {
-    auto mediaLibraryManager = GetMediaLibraryManager();
-    if (mediaLibraryManager == nullptr) {
-        MEDIA_ERR_LOG("Error to init mediaLibraryManager");
-        return CAMERA_UNKNOWN_ERROR;
-    }
-    const static int32_t INVALID_UID = -1;
-    const static int32_t BASE_USER_RANGE = 200000;
-    int uid = IPCSkeleton::GetCallingUid();
-    if (uid <= INVALID_UID) {
-        MEDIA_ERR_LOG("Get INVALID_UID UID %{public}d", uid);
-    }
-    int32_t userId = uid / BASE_USER_RANGE;
-    MEDIA_DEBUG_LOG("get uid:%{public}d, userId:%{public}d, tokenId:%{public}d", uid, userId,
-        IPCSkeleton::GetCallingTokenID());
-    auto type = isSetMotionPhoto_ ? CameraShotType::MOVING_PHOTO : CameraShotType::IMAGE;
-    cameraShotType = static_cast<int32_t>(type);
-    auto photoAssetProxy = mediaLibraryManager->CreatePhotoAssetProxy(type, uid, userId);
+    constexpr int32_t movingPhotoShotType = 2;
+    constexpr int32_t imageShotType = 0;
+    cameraShotType = isSetMotionPhoto_ ? movingPhotoShotType : imageShotType;
     MessageParcel data;
     photoProxy->WriteToParcel(data);
     photoProxy->CameraFreeBufferHandle();
-    sptr<CameraServerPhotoProxy> cameraServerPhotoProxy = new CameraServerPhotoProxy();
-    cameraServerPhotoProxy->ReadFromParcel(data);
-    PhotoFormat photoFormat = cameraServerPhotoProxy->GetFormat();
+    sptr<CameraServerPhotoProxy> cameraPhotoProxy = new CameraServerPhotoProxy();
+    cameraPhotoProxy->ReadFromParcel(data);
+    PhotoFormat photoFormat = cameraPhotoProxy->GetFormat();
     std::string formatSuffix = photoFormat == PhotoFormat::HEIF ? suffixHeif : suffixJpeg;
-    cameraServerPhotoProxy->SetDisplayName(CreateDisplayName(formatSuffix));
-    cameraServerPhotoProxy->SetShootingMode(opMode_);
+    cameraPhotoProxy->SetDisplayName(CreateDisplayName(formatSuffix));
+    cameraPhotoProxy->SetShootingMode(opMode_);
     MEDIA_INFO_LOG("GetLocation latitude:%{public}f, longitude:%{public}f",
-        cameraServerPhotoProxy->GetLatitude(), cameraServerPhotoProxy->GetLongitude());
-    photoAssetProxy->AddPhotoProxy((sptr<PhotoProxy>&)cameraServerPhotoProxy);
+        cameraPhotoProxy->GetLatitude(), cameraPhotoProxy->GetLongitude());
+
+    GetPhotoAssetProxy getPhotoAssetProxy = (GetPhotoAssetProxy)dynamicLoader_->GetFuntion(
+        MEDIA_LIB_SO, "createPhotoAssetIntf");
+    PhotoAssetIntf* photoAssetProxy = getPhotoAssetProxy(cameraShotType);
+    photoAssetProxy->AddPhotoProxy((sptr<PhotoProxy>&)cameraPhotoProxy);
     std::shared_ptr<Media::Picture> picturePtr(picture.release());
     DeferredProcessing::DeferredProcessingService::GetInstance().
-        NotifyLowQualityImage(userId, cameraServerPhotoProxy->GetPhotoId(), picturePtr);
+        NotifyLowQualityImage(photoAssetProxy->GetUserId(), cameraPhotoProxy->GetPhotoId(), picturePtr);
     uri = photoAssetProxy->GetPhotoAssetUri();
     if (isSetMotionPhoto_) {
         int32_t videoFd = photoAssetProxy->GetVideoFd();
@@ -1888,6 +1881,8 @@ int32_t HCaptureSession::CreateMediaLibrary(std::unique_ptr<Media::Picture> pict
         if (taskManager_) {
             taskManager_->SetVideoFd(videoFd, photoAssetProxy);
         }
+    } else {
+        delete photoAssetProxy;
     }
     return CAMERA_OK;
 }
diff --git a/services/camera_service/src/media_library/photo_asset_adapter.cpp b/services/camera_service/src/media_library/photo_asset_adapter.cpp
new file mode 100644
index 000000000..4cff0b68d
--- /dev/null
+++ b/services/camera_service/src/media_library/photo_asset_adapter.cpp
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ 
+#include "photo_asset_adapter.h"
+#include "camera_log.h"
+#include "iservice_registry.h"
+#include <cstdint>
+#include "media_photo_asset_proxy.h"
+#include "system_ability_definition.h"
+#include "ipc_skeleton.h"
+
+namespace OHOS {
+namespace CameraStandard {
+
+PhotoAssetAdapter::PhotoAssetAdapter(int32_t cameraShotType)
+{
+    MEDIA_INFO_LOG("PhotoAssetAdapter ctor");
+    auto mediaLibraryManager = Media::MediaLibraryManager::GetMediaLibraryManager();
+    CHECK_ERROR_RETURN_LOG(mediaLibraryManager == nullptr, "GetMediaLibraryManager failed!");
+    auto samgr = SystemAbilityManagerClient::GetInstance().GetSystemAbilityManager();
+    CHECK_ERROR_RETURN_LOG(samgr == nullptr, "Failed to get System ability manager!");
+    sptr<IRemoteObject> object = samgr->GetSystemAbility(CAMERA_SERVICE_ID);
+    CHECK_ERROR_RETURN_LOG(object == nullptr, "object is null!");
+    mediaLibraryManager->InitMediaLibraryManager(object);
+    const static int32_t INVALID_UID = -1;
+    const static int32_t BASE_USER_RANGE = 200000;
+    int uid = IPCSkeleton::GetCallingUid();
+    CHECK_ERROR_PRINT_LOG(uid <= INVALID_UID, "Get INVALID_UID UID %{public}d", uid);
+    userId_ = uid / BASE_USER_RANGE;
+    MEDIA_DEBUG_LOG("get uid:%{public}d, userId:%{public}d, tokenId:%{public}d", uid, userId_,
+        IPCSkeleton::GetCallingTokenID());
+    photoAssetProxy_ = mediaLibraryManager->CreatePhotoAssetProxy(
+        static_cast<Media::CameraShotType>(cameraShotType), uid, userId_);
+}
+
+void PhotoAssetAdapter::AddPhotoProxy(sptr<Media::PhotoProxy> photoProxy)
+{
+    if (photoAssetProxy_) {
+        photoAssetProxy_->AddPhotoProxy(photoProxy);
+    }
+}
+
+std::string PhotoAssetAdapter::GetPhotoAssetUri()
+{
+    if (photoAssetProxy_) {
+        return photoAssetProxy_->GetPhotoAssetUri();
+    }
+    return "";
+}
+
+int32_t PhotoAssetAdapter::GetVideoFd()
+{
+    if (photoAssetProxy_) {
+        return photoAssetProxy_->GetVideoFd();
+    }
+    return -1;
+}
+
+int32_t PhotoAssetAdapter::GetUserId()
+{
+    return photoAssetProxy_ ? userId_ : -1;
+}
+
+void PhotoAssetAdapter::NotifyVideoSaveFinished()
+{
+    if (photoAssetProxy_) {
+        photoAssetProxy_->NotifyVideoSaveFinished();
+    }
+}
+
+extern "C" PhotoAssetIntf *createPhotoAssetIntf(int32_t cameraShotType)
+{
+    return new PhotoAssetAdapter(cameraShotType);
+}
+ 
+}  // namespace AVSession
+}  // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/base/task_manager/task_group/base_task_group.h b/services/deferred_processing_service/include/base/task_manager/task_group/base_task_group.h
index 2a8ee3021..e80fca234 100644
--- a/services/deferred_processing_service/include/base/task_manager/task_group/base_task_group.h
+++ b/services/deferred_processing_service/include/base/task_manager/task_group/base_task_group.h
@@ -37,7 +37,7 @@ public:
     TaskGroupHandle GetHandle() final;
     bool SubmitTask(std::any param) override;
     void CancelAllTasks() override;
-
+    size_t GetTaskCount() override;
 protected:
     virtual void Initialize();
     std::function<void()> GetTaskUnlocked();
diff --git a/services/deferred_processing_service/include/base/task_manager/task_group/itask_group.h b/services/deferred_processing_service/include/base/task_manager/task_group/itask_group.h
index 5a1648347..51b19377e 100644
--- a/services/deferred_processing_service/include/base/task_manager/task_group/itask_group.h
+++ b/services/deferred_processing_service/include/base/task_manager/task_group/itask_group.h
@@ -36,6 +36,7 @@ public:
     virtual TaskGroupHandle GetHandle() = 0;
     virtual bool SubmitTask(std::any param) = 0;
     virtual void CancelAllTasks() = 0;
+    virtual size_t GetTaskCount() = 0;
 };
 constexpr TaskGroupHandle INVALID_TASK_GROUP_HANDLE = 0;
 } //namespace DeferredProcessing
diff --git a/services/deferred_processing_service/include/base/task_manager/task_manager.h b/services/deferred_processing_service/include/base/task_manager/task_manager.h
index 40dbcba03..a2540c824 100644
--- a/services/deferred_processing_service/include/base/task_manager/task_manager.h
+++ b/services/deferred_processing_service/include/base/task_manager/task_manager.h
@@ -41,7 +41,7 @@ public:
     bool SubmitTask(std::function<void()> task, uint32_t delayMilli);
     bool SubmitTask(TaskGroupHandle handle, std::any param = std::any());
     EXPORT_API void CancelAllTasks();
-
+    EXPORT_API bool IsEmpty();
 private:
     void Initialize();
     bool RegisterTaskGroup(const std::string& name, TaskFunc func, bool serial, bool delayTask,
diff --git a/services/deferred_processing_service/include/base/task_manager/task_registry.h b/services/deferred_processing_service/include/base/task_manager/task_registry.h
index 221794d53..b9f734fb2 100644
--- a/services/deferred_processing_service/include/base/task_manager/task_registry.h
+++ b/services/deferred_processing_service/include/base/task_manager/task_registry.h
@@ -38,7 +38,7 @@ public:
     bool DeregisterTaskGroup(const std::string& name, TaskGroupHandle& handle);
     bool SubmitTask(TaskGroupHandle handle, std::any param);
     void CancelAllTasks(TaskGroupHandle handle);
-
+    size_t GetTaskCount(TaskGroupHandle handle);
 private:
 
     bool IsTaskGroupAlreadyRegistered(const std::string& name);
diff --git a/services/deferred_processing_service/src/base/task_manager/task_group/base_task_group.cpp b/services/deferred_processing_service/src/base/task_manager/task_group/base_task_group.cpp
index 6b63413b3..011f42299 100644
--- a/services/deferred_processing_service/src/base/task_manager/task_group/base_task_group.cpp
+++ b/services/deferred_processing_service/src/base/task_manager/task_group/base_task_group.cpp
@@ -79,6 +79,13 @@ void BaseTaskGroup::CancelAllTasks()
     }
 }
 
+size_t BaseTaskGroup::GetTaskCount()
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    DP_DEBUG_LOG("Get task count for task group (%s), handle: %{public}d", name_.c_str(), static_cast<int>(handle_));
+    return que_.Size();
+}
+
 std::function<void()> BaseTaskGroup::GetTaskUnlocked()
 {
     if (que_.Empty()) {
diff --git a/services/deferred_processing_service/src/base/task_manager/task_manager.cpp b/services/deferred_processing_service/src/base/task_manager/task_manager.cpp
index 77ad3f41d..870c3b44c 100644
--- a/services/deferred_processing_service/src/base/task_manager/task_manager.cpp
+++ b/services/deferred_processing_service/src/base/task_manager/task_manager.cpp
@@ -132,6 +132,15 @@ void TaskManager::CancelAllTasks()
     taskRegistry_->CancelAllTasks(defaultTaskHandle_);
 }
 
+bool TaskManager::IsEmpty()
+{
+    DP_INFO_LOG("Get tasks count: %{public}d", static_cast<int>(defaultTaskHandle_));
+    if (taskRegistry_ == nullptr) {
+        return true;
+    }
+    return taskRegistry_->GetTaskCount(defaultTaskHandle_) == 0;
+}
+
 bool TaskManager::RegisterTaskGroup(const std::string& name, TaskFunc func, bool serial, bool delayTask,
     TaskGroupHandle& handle)
 {
diff --git a/services/deferred_processing_service/src/base/task_manager/task_registry.cpp b/services/deferred_processing_service/src/base/task_manager/task_registry.cpp
index 0978d5c30..e225c0954 100644
--- a/services/deferred_processing_service/src/base/task_manager/task_registry.cpp
+++ b/services/deferred_processing_service/src/base/task_manager/task_registry.cpp
@@ -102,6 +102,18 @@ void TaskRegistry::CancelAllTasks(TaskGroupHandle handle)
     it->second->CancelAllTasks();
 }
 
+size_t TaskRegistry::GetTaskCount(TaskGroupHandle handle)
+{
+    DP_DEBUG_LOG("Get task count %{public}d", static_cast<int>(handle));
+    std::lock_guard<std::mutex> lock(mutex_);
+    auto it = registry_.find(handle);
+    if (it == registry_.end()) {
+        DP_DEBUG_LOG("failed due to task group %{public}d non-exist!", static_cast<int>(handle));
+        return 0;
+    }
+    return it->second->GetTaskCount();
+}
+
 bool TaskRegistry::IsTaskGroupAlreadyRegistered(const std::string& name)
 {
     std::lock_guard<std::mutex> lock(mutex_);
-- 
2.45.2.huawei.5


