# Copyright (c) 2023 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
graphic_surface_path = "//foundation/graphic/graphic_surface"
graphic_2d_path = "//foundation/graphic/graphic_2d"
multimedia_camera_framework_path = "//foundation/multimedia/camera_framework"
multimedia_image_framework_path = "//foundation/multimedia/image_framework"
driver_camera_path = "//drivers/interface/camera"
third_party_path = "//third_party/googletest"
driver_peripheral_path = "//drivers/peripheral/camera"
base_security_path = "//base/security/access_token"
driver_disply_path = "//drivers/peripheral/display"
window_manager_path = "//foundation/window/window_manager"
system_safwk_path = "//utils/system/safwk"
multimedia_media_library_path = "//foundation/multimedia/media_library"

use_sensor = false
if (defined(global_parts_info) && defined(global_parts_info.sensors_sensor)) {
  use_sensor = true
}

use_thermal_manager = false
if (defined(global_parts_info) &&
    defined(global_parts_info.powermgr_thermal_manager)) {
  use_thermal_manager = true
}

use_battery_manager = false
if (defined(global_parts_info) &&
    defined(global_parts_info.powermgr_battery_manager)) {
  use_battery_manager = true
}

use_power_manager = false
if (defined(global_parts_info) &&
    defined(global_parts_info.powermgr_power_manager)) {
  use_power_manager = true
}

gen_camera_picker = true
hicollie_enable = true





From b4fa7851c1684d937c16fbbc8989e487c4ac55cb Mon Sep 17 00:00:00 2001
From: n00564676 <n00564676@notesmail.huawei.com/>
Date: Mon, 7 Oct 2024 14:20:16 +0800
Subject: [PATCH] TicketNo:DTS2024081529387 Description:fix gn dep Team:OTHERS
 Feature or Bugfix:Bugfix Binary Source:No PrivateCode(Yes/No):No ------ DO
 NOT MODIFY, AUTO-GENERATED! ------ Gitee-Issue: #IAIDAW Time:
 2024-08-07T06:56:26.825Z PR-Num: 1759 Gitee-PR:
 https://openharmony.gitee.com/openharmony/multimedia_camera_framework/pulls/1759

Change-Id: I51040b4f4dfb70aee9cddff1445cfd25fb6d2712
---
 .../src/avcodec/avcodec_task_manager.cpp              | 11 +++++++++--
 services/camera_service/src/hcapture_session.cpp      |  6 ++++++
 2 files changed, 15 insertions(+), 2 deletions(-)

diff --git a/services/camera_service/src/avcodec/avcodec_task_manager.cpp b/services/camera_service/src/avcodec/avcodec_task_manager.cpp
index 16c197d3f..15e73e141 100644
--- a/services/camera_service/src/avcodec/avcodec_task_manager.cpp
+++ b/services/camera_service/src/avcodec/avcodec_task_manager.cpp
@@ -57,10 +57,12 @@ AvcodecTaskManager::AvcodecTaskManager(sptr<AudioCapturerSession> audioCaptureSe
     VideoCodecType type) : videoCodecType_(type)
 {
     CAMERA_SYNC_TRACE;
+    #ifdef MOVING_PHOTO_ADD_AUDIO
     audioCapturerSession_ = audioCaptureSession;
+    audioEncoder_ = make_unique<AudioEncoder>();
+    #endif
     // Create Task Manager
     videoEncoder_ = make_unique<VideoEncoder>(type);
-    audioEncoder_ = make_unique<AudioEncoder>();
 }
 
 shared_ptr<TaskManager>& AvcodecTaskManager::GetTaskManager()
@@ -158,18 +160,21 @@ sptr<AudioVideoMuxer> AvcodecTaskManager::CreateAVMuxer(vector<sptr<FrameRecord>
     formatVideo->PutIntValue(MediaDescriptionKey::MD_KEY_HEIGHT, frameRecords[0]->GetFrameSize()->height);
     int videoTrackId = -1;
     muxer->AddTrack(videoTrackId, formatVideo, VIDEO_TRACK);
+    int audioTrackId = -1;
+    #ifdef MOVING_PHOTO_ADD_AUDIO
     auto formatAudio = make_shared<Format>();
     formatAudio->PutStringValue(MediaDescriptionKey::MD_KEY_CODEC_MIME, OH_AVCODEC_MIMETYPE_AUDIO_AAC);
     formatAudio->PutIntValue(MediaDescriptionKey::MD_KEY_SAMPLE_RATE, DEFAULT_SAMPLERATE);
     formatAudio->PutIntValue(MediaDescriptionKey::MD_KEY_CHANNEL_COUNT, DEFAULT_CHANNEL_COUNT);
-    int audioTrackId = -1;
     muxer->AddTrack(audioTrackId, formatAudio, AUDIO_TRACK);
+    #endif
     int metaTrackId = -1;
     auto formatMeta = make_shared<Format>();
     formatMeta->PutStringValue(MediaDescriptionKey::MD_KEY_CODEC_MIME, TIMED_METADATA_TRACK_MIMETYPE);
     formatMeta->PutStringValue(MediaDescriptionKey::MD_KEY_TIMED_METADATA_KEY, TIMED_METADATA_KEY);
     formatMeta->PutIntValue(MediaDescriptionKey::MD_KEY_TIMED_METADATA_SRC_TRACK_ID, videoTrackId);
     muxer->AddTrack(metaTrackId, formatMeta, META_TRACK);
+ 
     MEDIA_INFO_LOG("CreateMuxer vId:%{public}d,aid:%{public}d,mid:%{public}d", videoTrackId, audioTrackId, metaTrackId);
     muxer->SetTimedMetadata();
     muxer->Start();
@@ -229,6 +234,7 @@ void AvcodecTaskManager::DoMuxerVideo(vector<sptr<FrameRecord>> frameRecords, ui
             }
             frameRecords[index]->UnLockMetaBuffer();
         }
+        #ifdef MOVING_PHOTO_ADD_AUDIO
         // CollectAudioBuffer
         vector<sptr<AudioRecord>> audioRecords;
         if (thisPtr->audioCapturerSession_) {
@@ -237,6 +243,7 @@ void AvcodecTaskManager::DoMuxerVideo(vector<sptr<FrameRecord>> frameRecords, ui
             thisPtr->audioCapturerSession_->GetAudioRecords(startTime, endTime, audioRecords);
         }
         thisPtr->CollectAudioBuffer(audioRecords, muxer);
+        #endif
         thisPtr->FinishMuxer(muxer);
     });
 }
diff --git a/services/camera_service/src/hcapture_session.cpp b/services/camera_service/src/hcapture_session.cpp
index b54038764..4aff15708 100644
--- a/services/camera_service/src/hcapture_session.cpp
+++ b/services/camera_service/src/hcapture_session.cpp
@@ -401,8 +401,10 @@ void HCaptureSession::StartMovingPhotoStream()
             }
             if (isSetMotionPhoto_) {
                 errorCode = curStreamRepeat->Start(settings);
+                #ifdef MOVING_PHOTO_ADD_AUDIO
                 std::lock_guard<std::mutex> lock(movingPhotoStatusLock_);
                 audioCapturerSession_ != nullptr && audioCapturerSession_->StartAudioCapture();
+                #endif
             } else {
                 errorCode = curStreamRepeat->Stop();
                 StopMovingPhoto();
@@ -893,9 +895,11 @@ void HCaptureSession::StopMovingPhoto() __attribute__((no_sanitize("cfi")))
     if (videoCache_) {
         videoCache_->ClearCache();
     }
+    #ifdef MOVING_PHOTO_ADD_AUDIO
     if (audioCapturerSession_) {
         audioCapturerSession_->Stop();
     }
+    #endif
     if (taskManager_) {
         taskManager_->Stop();
     }
@@ -1375,8 +1379,10 @@ int32_t HCaptureSession::StartPreviewStream(const std::shared_ptr<OHOS::Camera::
         int32_t movingPhotoErrorCode = CAMERA_OK;
         if (isSetMotionPhoto_ && !hasDerferedPreview) {
             movingPhotoErrorCode = curStreamRepeat->Start(settings);
+            #ifdef MOVING_PHOTO_ADD_AUDIO
             std::lock_guard<std::mutex> lock(movingPhotoStatusLock_);
             audioCapturerSession_ != nullptr && audioCapturerSession_->StartAudioCapture();
+            #endif
         }
         if (movingPhotoErrorCode != CAMERA_OK) {
             MEDIA_ERR_LOG("Failed to start movingPhoto, rc: %{public}d", movingPhotoErrorCode);
-- 
2.45.2.huawei.5

