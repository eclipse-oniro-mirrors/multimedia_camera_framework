-    camSession->OnCaptureReady(0, streamIds, 0);
+    hStreamOperator->OnFrameShutter(0, streamIds, 0);
+    hStreamOperator->OnFrameShutterEnd(0, streamIds, 0);
+    hStreamOperator->OnCaptureReady(0, streamIds, 0);
     device->Close();
     camSession->Release();
 }
@@ -1522,9 +1623,12 @@ HWTEST_F(HCaptureSessionUnitTest, hcapture_session_unit_test_030, TestSize.Level
     device->Open();
 
     uint32_t callerToken = IPCSkeleton::GetCallingTokenID();
+    sptr<HCaptureSession> camSession = nullptr;
+    sptr<HStreamOperator> hStreamOperator = nullptr;
     SceneMode mode = PORTRAIT;
-    sptr<HCaptureSession> camSession = new (std::nothrow) HCaptureSession(callerToken, mode);
+    InitSessionAndOperator(callerToken, mode, camSession, hStreamOperator);
     ASSERT_NE(camSession, nullptr);
+    ASSERT_NE(hStreamOperator, nullptr);
 
     camSession->BeginConfig();
     camSession->Start();
@@ -1550,68 +1654,12 @@ HWTEST_F(HCaptureSessionUnitTest, hcapture_session_unit_test_030, TestSize.Level
     std::vector<CaptureErrorInfo> info = {};
     info.push_back(it1);
     info.push_back(it2);
-    camSession->OnCaptureError(0, info);
+    hStreamOperator->OnCaptureError(0, info);
 
     std::vector<int32_t> streamIds = {1, 2};
-    camSession->OnFrameShutter(0, streamIds, 0);
-    camSession->OnFrameShutterEnd(0, streamIds, 0);
-    camSession->OnCaptureReady(0, streamIds, 0);
-
-    device->Close();
-    camSession->Release();
-}
-
-/*
- * Feature: coverage
- * Function: Test anomalous branch
- * SubFunction: NA
- * FunctionPoints: NA
- * EnvConditions: NA
- * CaseDescription: Test HCaptureSession with anomalous branch.
- */
-HWTEST_F(HCaptureSessionUnitTest, hcapture_session_unit_test_031, TestSize.Level0)
-{
-    std::vector<string> cameraIds;
-    cameraService_->GetCameraIds(cameraIds);
-    ASSERT_NE(cameraIds.size(), 0);
-    cameraService_->SetServiceStatus(CameraServiceStatus::SERVICE_READY);
-    sptr<ICameraDeviceService> device = nullptr;
-    cameraService_->CreateCameraDevice(cameraIds[0], device);
-    ASSERT_NE(device, nullptr);
-    device->Open();
-
-    uint32_t callerToken = IPCSkeleton::GetCallingTokenID();
-    sptr<HCaptureSession> camSession = new (std::nothrow) HCaptureSession(callerToken, PORTRAIT);
-    ASSERT_NE(camSession, nullptr);
-    EXPECT_EQ(camSession->CommitConfig(), CAMERA_INVALID_STATE);
-    camSession->BeginConfig();
-    camSession->Start();
-
-    sptr<IConsumerSurface> Surface = IConsumerSurface::Create();
-    sptr<IBufferProducer> producer = Surface->GetProducer();
-    sptr<HStreamCapture> streamCapture= new(std::nothrow) HStreamCapture(producer, 0, 0, 0);
-    ASSERT_NE(streamCapture, nullptr);
-
-    EXPECT_EQ(camSession->AddOutput(StreamType::CAPTURE, streamCapture), 0);
-
-    camSession->CommitConfig();
-
-    CaptureErrorInfo it1;
-    it1.streamId_ = 0;
-    it1.error_ = BUFFER_LOST;
-    CaptureErrorInfo it2;
-    it2.streamId_ = 1;
-    it2.error_ =  BUFFER_LOST;
-    std::vector<CaptureErrorInfo> info = {};
-    info.push_back(it1);
-    info.push_back(it2);
-    camSession->OnCaptureError(0, info);
-
-    std::vector<int32_t> streamIds = {0, 1, 2};
-    camSession->OnFrameShutter(0, streamIds, 0);
-    camSession->OnFrameShutterEnd(0, streamIds, 0);
-    camSession->OnCaptureReady(0, streamIds, 0);
-    camSession->BeginConfig();
+    hStreamOperator->OnFrameShutter(0, streamIds, 0);
+    hStreamOperator->OnFrameShutterEnd(0, streamIds, 0);
+    hStreamOperator->OnCaptureReady(0, streamIds, 0);
 
     device->Close();
     camSession->Release();
@@ -1637,9 +1685,12 @@ HWTEST_F(HCaptureSessionUnitTest, hcapture_session_unit_test_032, TestSize.Level
     device->Open();
 
     uint32_t callerToken = IPCSkeleton::GetCallingTokenID();
+    sptr<HCaptureSession> camSession = nullptr;
+    sptr<HStreamOperator> hStreamOperator = nullptr;
     SceneMode mode = PORTRAIT;
-    sptr<HCaptureSession> camSession = new (std::nothrow) HCaptureSession(callerToken, mode);
+    InitSessionAndOperator(callerToken, mode, camSession, hStreamOperator);
     ASSERT_NE(camSession, nullptr);
+    ASSERT_NE(hStreamOperator, nullptr);
     EXPECT_EQ(camSession->Start(), CAMERA_INVALID_STATE);
 
     sptr<IConsumerSurface> Surface = IConsumerSurface::Create();
@@ -1682,13 +1733,16 @@ HWTEST_F(HCaptureSessionUnitTest, hcapture_session_unit_test_032, TestSize.Level
 HWTEST_F(HCaptureSessionUnitTest, hcapture_session_unit_test_033, TestSize.Level0)
 {
     uint32_t callerToken = IPCSkeleton::GetCallingTokenID();
+    sptr<HCaptureSession> camSession = nullptr;
+    sptr<HStreamOperator> hStreamOperator = nullptr;
     SceneMode mode = PORTRAIT;
-    sptr<HCaptureSession> camSession = new (std::nothrow) HCaptureSession(callerToken, mode);
+    InitSessionAndOperator(callerToken, mode, camSession, hStreamOperator);
     ASSERT_NE(camSession, nullptr);
+    ASSERT_NE(hStreamOperator, nullptr);
 
     std::vector<StreamInfo_V1_1> streamInfos = {};
     EXPECT_EQ(camSession->GetCurrentStreamInfos(streamInfos), 0);
-    EXPECT_EQ(camSession->AddOutputStream(nullptr), CAMERA_INVALID_ARG);
+    EXPECT_EQ(camSession->AddOutput(StreamType::REPEAT, nullptr), CAMERA_INVALID_ARG);
     EXPECT_EQ(camSession->RemoveOutputStream(nullptr), CAMERA_INVALID_ARG);
     camSession->Release();
 }
@@ -1704,9 +1758,12 @@ HWTEST_F(HCaptureSessionUnitTest, hcapture_session_unit_test_033, TestSize.Level
 HWTEST_F(HCaptureSessionUnitTest, hcapture_session_unit_test_034, TestSize.Level0)
 {
     uint32_t callerToken = IPCSkeleton::GetCallingTokenID();
+    sptr<HCaptureSession> camSession = nullptr;
+    sptr<HStreamOperator> hStreamOperator = nullptr;
     SceneMode mode = PORTRAIT;
-    sptr<HCaptureSession> camSession = new (std::nothrow) HCaptureSession(callerToken, mode);
+    InitSessionAndOperator(callerToken, mode, camSession, hStreamOperator);
     ASSERT_NE(camSession, nullptr);
+    ASSERT_NE(hStreamOperator, nullptr);
 
     camSession->cameraDevice_ = nullptr;
     EXPECT_EQ(camSession->LinkInputAndOutputs(), CAMERA_INVALID_SESSION_CFG);
@@ -1724,17 +1781,18 @@ HWTEST_F(HCaptureSessionUnitTest, hcapture_session_unit_test_034, TestSize.Level
 HWTEST_F(HCaptureSessionUnitTest, hcapture_session_unit_test_035, TestSize.Level0)
 {
     uint32_t callerToken = IPCSkeleton::GetCallingTokenID();
+    sptr<HCaptureSession> camSession = nullptr;
+    sptr<HStreamOperator> hStreamOperator = nullptr;
     SceneMode mode = PORTRAIT;
-    sptr<HCaptureSession> camSession = new (std::nothrow) HCaptureSession(callerToken, mode);
+    InitSessionAndOperator(callerToken, mode, camSession, hStreamOperator);
     ASSERT_NE(camSession, nullptr);
+    ASSERT_NE(hStreamOperator, nullptr);
 
     bool isNeedUpdate = false;
     ColorSpace colorSpace = ColorSpace::SRGB;
     ColorSpace captureColorSpace = ColorSpace::SRGB;
-    camSession->currColorSpace_ = ColorSpace::BT709;
-    camSession->currCaptureColorSpace_ = ColorSpace::BT709;
     EXPECT_EQ(camSession->SetColorSpace(colorSpace, captureColorSpace, isNeedUpdate), CAMERA_INVALID_STATE);
-    camSession->currColorSpace_ = ColorSpace::SRGB;
+    captureColorSpace = ColorSpace::SRGB;
     EXPECT_EQ(camSession->SetColorSpace(colorSpace, captureColorSpace, isNeedUpdate), CAMERA_INVALID_STATE);
     camSession->Release();
 }
@@ -1750,22 +1808,30 @@ HWTEST_F(HCaptureSessionUnitTest, hcapture_session_unit_test_035, TestSize.Level
 HWTEST_F(HCaptureSessionUnitTest, hcapture_session_unit_test_036, TestSize.Level0)
 {
     uint32_t callerToken = IPCSkeleton::GetCallingTokenID();
+    sptr<HCaptureSession> camSession = nullptr;
+    sptr<HStreamOperator> hStreamOperator = nullptr;
     SceneMode mode = PORTRAIT;
-    sptr<HCaptureSession> camSession = new (std::nothrow) HCaptureSession(callerToken, mode);
+    InitSessionAndOperator(callerToken, mode, camSession, hStreamOperator);
     ASSERT_NE(camSession, nullptr);
+    ASSERT_NE(hStreamOperator, nullptr);
 
-    camSession->RestartStreams();
+    std::vector<string> cameraIds;
+    cameraService_->GetCameraIds(cameraIds);
+    ASSERT_NE(cameraIds.size(), 0);
+    shared_ptr<OHOS::Camera::CameraMetadata> settings;
+    cameraHostManager_->GetCameraAbility(cameraIds[0], settings);
+    hStreamOperator->RestartStreams(settings);
 
     ColorSpace colorSpace = ColorSpace::SRGB;
-    EXPECT_EQ(camSession->CheckIfColorSpaceMatchesFormat(colorSpace), 0);
+    EXPECT_EQ(hStreamOperator->CheckIfColorSpaceMatchesFormat(colorSpace), 0);
     colorSpace = ColorSpace::BT2020_HLG ;
-    EXPECT_EQ(camSession->CheckIfColorSpaceMatchesFormat(colorSpace), 0);
+    EXPECT_EQ(hStreamOperator->CheckIfColorSpaceMatchesFormat(colorSpace), 0);
     colorSpace = ColorSpace::BT2020_PQ ;
-    EXPECT_EQ(camSession->CheckIfColorSpaceMatchesFormat(colorSpace), 0);
+    EXPECT_EQ(hStreamOperator->CheckIfColorSpaceMatchesFormat(colorSpace), 0);
     colorSpace = ColorSpace::BT2020_HLG_LIMIT ;
-    EXPECT_EQ(camSession->CheckIfColorSpaceMatchesFormat(colorSpace), 0);
+    EXPECT_EQ(hStreamOperator->CheckIfColorSpaceMatchesFormat(colorSpace), 0);
     colorSpace = ColorSpace::BT2020_PQ_LIMIT;
-    EXPECT_EQ(camSession->CheckIfColorSpaceMatchesFormat(colorSpace), 0);
+    EXPECT_EQ(hStreamOperator->CheckIfColorSpaceMatchesFormat(colorSpace), 0);
     camSession->Release();
 }
 
@@ -1780,9 +1846,12 @@ HWTEST_F(HCaptureSessionUnitTest, hcapture_session_unit_test_036, TestSize.Level
 HWTEST_F(HCaptureSessionUnitTest, hcapture_session_unit_test_037, TestSize.Level0)
 {
     uint32_t callerToken = IPCSkeleton::GetCallingTokenID();
+    sptr<HCaptureSession> camSession = nullptr;
+    sptr<HStreamOperator> hStreamOperator = nullptr;
     SceneMode mode = PORTRAIT;
-    sptr<HCaptureSession> camSession = new (std::nothrow) HCaptureSession(callerToken, mode);
+    InitSessionAndOperator(callerToken, mode, camSession, hStreamOperator);
     ASSERT_NE(camSession, nullptr);
+    ASSERT_NE(hStreamOperator, nullptr);
     camSession->Release();
 }
 
@@ -1797,17 +1866,26 @@ HWTEST_F(HCaptureSessionUnitTest, hcapture_session_unit_test_037, TestSize.Level
 HWTEST_F(HCaptureSessionUnitTest, hcapture_session_unit_test_038, TestSize.Level0)
 {
     uint32_t callerToken = IPCSkeleton::GetCallingTokenID();
+    sptr<HCaptureSession> camSession = nullptr;
+    sptr<HStreamOperator> hStreamOperator = nullptr;
     SceneMode mode = PORTRAIT;
-    sptr<HCaptureSession> camSession = new (std::nothrow) HCaptureSession(callerToken, mode);
+    InitSessionAndOperator(callerToken, mode, camSession, hStreamOperator);
     ASSERT_NE(camSession, nullptr);
+    ASSERT_NE(hStreamOperator, nullptr);
 
-    camSession->SetColorSpaceForStreams();
+    hStreamOperator->SetColorSpaceForStreams();
 
     std::vector<StreamInfo_V1_1> streamInfos = {};
-    camSession->CancelStreamsAndGetStreamInfos(streamInfos);
+    hStreamOperator->CancelStreamsAndGetStreamInfos(streamInfos);
 
     camSession->isSessionStarted_ = true;
-    camSession->RestartStreams();
+
+    std::vector<string> cameraIds;
+    cameraService_->GetCameraIds(cameraIds);
+    ASSERT_NE(cameraIds.size(), 0);
+    shared_ptr<OHOS::Camera::CameraMetadata> settings;
+    cameraHostManager_->GetCameraAbility(cameraIds[0], settings);
+    hStreamOperator->RestartStreams(settings);
     camSession->Release();
 }
 
@@ -1822,9 +1900,12 @@ HWTEST_F(HCaptureSessionUnitTest, hcapture_session_unit_test_038, TestSize.Level
 HWTEST_F(HCaptureSessionUnitTest, hcapture_session_unit_test_039, TestSize.Level0)
 {
     uint32_t callerToken = IPCSkeleton::GetCallingTokenID();
+    sptr<HCaptureSession> camSession = nullptr;
+    sptr<HStreamOperator> hStreamOperator = nullptr;
     SceneMode mode = PORTRAIT;
-    sptr<HCaptureSession> camSession = new (std::nothrow) HCaptureSession(callerToken, mode);
+    InitSessionAndOperator(callerToken, mode, camSession, hStreamOperator);
     ASSERT_NE(camSession, nullptr);
+    ASSERT_NE(hStreamOperator, nullptr);
 
     float currentFps = 0;
     float currentZoomRatio = 0;
diff --git a/frameworks/native/camera/test/unittest/camera_service/hdi_stream_test/src/hstream_capture_unittest.cpp b/frameworks/native/camera/test/unittest/camera_service/hdi_stream_test/src/hstream_capture_unittest.cpp
index 35e1f87a..37666606 100644
--- a/frameworks/native/camera/test/unittest/camera_service/hdi_stream_test/src/hstream_capture_unittest.cpp
+++ b/frameworks/native/camera/test/unittest/camera_service/hdi_stream_test/src/hstream_capture_unittest.cpp
@@ -129,6 +129,7 @@ public:
     MOCK_METHOD2(OnFrameShutter, int32_t(int32_t captureId, uint64_t timestamp));
     MOCK_METHOD2(OnFrameShutterEnd, int32_t(int32_t captureId, uint64_t timestamp));
     MOCK_METHOD2(OnCaptureReady, int32_t(int32_t captureId, uint64_t timestamp));
+    MOCK_METHOD1(OnOfflineDeliveryFinished, int32_t(int32_t captureId));
     ~MockHStreamCaptureCallbackStub() {}
 };
 
@@ -658,6 +659,7 @@ HWTEST_F(HStreamCaptureUnitTest, CheckResetBurstKeys003, TestSize.Level0)
  */
 HWTEST_F(HStreamCaptureUnitTest, CheckBurstCapture001, TestSize.Level0)
 {
+    MEDIA_INFO_LOG("CheckBurstCapture001 start");
     int32_t format = CAMERA_FORMAT_YUV_420_SP;
     int32_t width = PHOTO_DEFAULT_WIDTH;
     int32_t height = PHOTO_DEFAULT_HEIGHT;
diff --git a/frameworks/native/camera/test/unittest/framework_native/session/src/capture_session_unittest.cpp b/frameworks/native/camera/test/unittest/framework_native/session/src/capture_session_unittest.cpp
index c62c3920..b0c0e357 100644
--- a/frameworks/native/camera/test/unittest/framework_native/session/src/capture_session_unittest.cpp
+++ b/frameworks/native/camera/test/unittest/framework_native/session/src/capture_session_unittest.cpp
@@ -280,36 +280,6 @@ HWTEST_F(CaptureSessionUnitTest, capture_session_unittest_004, TestSize.Level0)
     session->Release();
 }
 
-/*
- * Feature: Framework
- * Function: Test captureSession with SetPreviewRotation and CreateMediaLibrary
- * SubFunction: NA
- * FunctionPoints: NA
- * EnvConditions: NA
- * CaseDescription: Test SetPreviewRotation for captureSession is nullptr and CreateMediaLibrary for
- * captureSession is nullptr and not nullptr
- */
-HWTEST_F(CaptureSessionUnitTest, capture_session_unittest_005, TestSize.Level0)
-{
-    sptr<CaptureSession> session = cameraManager_->CreateCaptureSession();
-    ASSERT_NE(session, nullptr);
-
-    EXPECT_NE(session->GetCaptureSession(), nullptr);
-    sptr<CameraPhotoProxy> photoProxy{new CameraPhotoProxy()};
-    std::string uri;
-    int32_t cameraShotType;
-    string burstKey = "";
-    int64_t timestamp = 0000;
-    session->CreateMediaLibrary(photoProxy, uri, cameraShotType, burstKey, timestamp);
-
-    std::string deviceClass;
-    session->SetCaptureSession(nullptr);
-    session->CreateMediaLibrary(photoProxy, uri, cameraShotType, burstKey, timestamp);
-    EXPECT_EQ(session->SetPreviewRotation(deviceClass), CAMERA_OK);
-
-    session->Release();
-}
-
 /*
  * Feature: Framework
  * Function: Test captureSession with SetFlashMode
@@ -3852,14 +3822,6 @@ HWTEST_F(CaptureSessionUnitTest, capture_session_function_unittest_002, TestSize
 {
     sptr<CaptureSession> session = cameraManager_->CreateCaptureSession();
     ASSERT_NE(session, nullptr);
-    sptr<SurfaceBuffer> surfaceBuffer;
-    sptr<CameraPhotoProxy> photoProxy{new CameraPhotoProxy()};
-    std::string uri;
-    int32_t cameraShotType;
-    string burstKey = "";
-    int64_t timestamp = 0000;
-    session->CreateMediaLibrary(Media::Picture::Create(surfaceBuffer), photoProxy,
-        uri, cameraShotType, burstKey, timestamp);
 
     session->SetExposureCallback(nullptr);
     EXPECT_EQ(session->GetExposureCallback(), nullptr);
diff --git a/frameworks/native/ndk/impl/photo_listener_impl.cpp b/frameworks/native/ndk/impl/photo_listener_impl.cpp
index 1e257861..b9571319 100644
--- a/frameworks/native/ndk/impl/photo_listener_impl.cpp
+++ b/frameworks/native/ndk/impl/photo_listener_impl.cpp
@@ -259,14 +259,14 @@ void PhotoListener::CreateMediaLibrary(sptr<SurfaceBuffer> surfaceBuffer, Buffer
     photoProxy->SetDeferredAttrs(imageIdStr, extraData.deferredProcessingType, extraData.size,
         extraData.deferredImageFormat);
     auto photoOutput = photoOutput_->GetInnerPhotoOutput();
-    if (photoOutput && photoOutput->GetSession()) {
+    if (photoOutput) {
         auto settings = photoOutput->GetDefaultCaptureSetting();
         if (settings) {
             auto location = std::make_shared<Location>();
             settings->GetLocation(location);
             photoProxy->SetLocation(location->latitude, location->longitude);
         }
-        photoOutput->GetSession()->CreateMediaLibrary(photoProxy, uri, cameraShotType, burstKey, timestamp);
+        photoOutput->CreateMediaLibrary(photoProxy, uri, cameraShotType, burstKey, timestamp);
     }
 }
 
diff --git a/frameworks/native/ndk/impl/photo_output_impl.h b/frameworks/native/ndk/impl/photo_output_impl.h
index ade84e39..ab69c493 100644
--- a/frameworks/native/ndk/impl/photo_output_impl.h
+++ b/frameworks/native/ndk/impl/photo_output_impl.h
@@ -196,6 +196,10 @@ public:
         }
     }
 
+    void OnOfflineDeliveryFinished(const int32_t captureId) const override
+    {
+        MEDIA_DEBUG_LOG("OnOfflineDeliveryFinished is called in ndk!");
+    }
 private:
     Camera_PhotoOutput* photoOutput_;
     PhotoOutput_Callbacks callback_;
diff --git a/interfaces/inner_api/native/camera/include/output/capture_output.h b/interfaces/inner_api/native/camera/include/output/capture_output.h
index e13f2bee..0ea7050a 100644
--- a/interfaces/inner_api/native/camera/include/output/capture_output.h
+++ b/interfaces/inner_api/native/camera/include/output/capture_output.h
@@ -142,6 +142,8 @@ public:
 
     virtual int32_t CreateStream() = 0;
 
+    bool IsHasEnableOfflinePhoto();
+
     virtual void AddTag(Tag tag) final;
     virtual void RemoveTag(Tag tag) final;
     virtual bool IsTagSetted(Tag tag) final;
@@ -179,6 +181,7 @@ private:
 
     std::mutex tagsMutex_;
     std::unordered_set<Tag> tags_;
+    bool mIsHasEnableOfflinePhoto_ = false;
 };
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/interfaces/inner_api/native/camera/include/output/photo_output.h b/interfaces/inner_api/native/camera/include/output/photo_output.h
index 5fdbfa17..9696ffd0 100644
--- a/interfaces/inner_api/native/camera/include/output/photo_output.h
+++ b/interfaces/inner_api/native/camera/include/output/photo_output.h
@@ -101,6 +101,13 @@ public:
      * @param errorCode Indicates a {@link ErrorCode} which will give information for photo capture callback error
      */
     virtual void OnCaptureError(const int32_t captureId, const int32_t errorCode) const = 0;
+
+    /**
+     * @brief Called when camera offline delivery finished.
+     *
+     * @param captureId Obtain the constant capture id for the photo capture callback.
+     */
+    virtual void OnOfflineDeliveryFinished(const int32_t captureId) const = 0;
 };
 
 class [[deprecated]] PhotoCallback {
@@ -138,6 +145,13 @@ public:
      * @param errorCode Indicates a {@link ErrorCode} which will give information for photo capture callback error
      */
     virtual void OnCaptureError(const int32_t captureId, const int32_t errorCode) const = 0;
+
+    /**
+     * @brief Called when camera offline delivery finished.
+     *
+     * @param captureId Obtain the constant capture id for the photo capture callback.
+     */
+    virtual void OnOfflineDeliveryFinished(const int32_t captureId) const = 0;
 };
 
 typedef struct Location {
@@ -251,6 +265,11 @@ private:
     std::mutex locationMutex_;
 };
 
+typedef struct captureMonitorInfo {
+    int32_t CaptureHandle;
+    std::chrono::time_point<std::chrono::steady_clock> timeStart;
+} captureMonitorInfo;
+
 constexpr uint8_t CAPTURE_PHOTO = 1 << 0;
 constexpr uint8_t CAPTURE_DEFERRED_PHOTO = 1 << 1;
 constexpr uint8_t CAPTURE_PHOTO_ASSET = 1 << 2;
@@ -476,6 +495,21 @@ public:
      * @brief Enable auto aigc photo.
      */
     int32_t EnableAutoAigcPhoto(bool enabled);
+    bool IsOfflineSupported();
+
+    int32_t EnableOfflinePhoto();
+
+    bool IsHasEnableOfflinePhoto();
+
+    void SetSwitchOfflinePhotoOutput(bool isHasSwitched);
+
+    bool IsHasSwitchOfflinePhoto();
+
+    void CreateMediaLibrary(sptr<CameraPhotoProxy> photoProxy, std::string &uri, int32_t &cameraShotType,
+        std::string &burstKey, int64_t timestamp);
+
+    void CreateMediaLibrary(std::unique_ptr<Media::Picture> picture, sptr<CameraPhotoProxy> photoProxy,
+        std::string &uri, int32_t &cameraShotType, std::string &burstKey, int64_t timestamp);
 
     /**
      * @brief Get photo buffer.
@@ -519,8 +553,10 @@ public:
     std::map<int32_t, sptr<SurfaceBuffer>> captureIdDebugMap_;
     std::atomic<bool> isRawImageDelivery_ = false;
     std::shared_ptr<DeferredProcessing::TaskManager> taskManager_;
+    std::map<int32_t, captureMonitorInfo> captureIdToCaptureInfoMap_;
 private:
     std::mutex callbackMutex_;
+    std::mutex offlineStatusMutex_;
     uint8_t callbackFlag_ = CAPTURE_DEFERRED_PHOTO;
     bool isNativeSurface_ = false;
     DeferredDeliveryImageType deferredType_ = DeferredDeliveryImageType::DELIVERY_NONE;
@@ -528,6 +564,8 @@ private:
     sptr<IStreamCaptureCallback> cameraSvcCallback_;
     std::shared_ptr<PhotoCaptureSetting> defaultCaptureSetting_;
     void CameraServerDied(pid_t pid) override;
+    bool mIsHasEnableOfflinePhoto_ = false;
+    bool isHasSwitched_ = false;
 };
 
 class HStreamCaptureCallbackImpl : public HStreamCaptureCallbackStub {
@@ -589,6 +627,13 @@ public:
      */
     int32_t OnCaptureReady(const int32_t captureId, const uint64_t timestamp) override;
 
+    /**
+     * @brief Called when camera offline delivery finished.
+     *
+     * @param captureId Obtain the constant capture id for the photo capture callback.
+     */
+    int32_t OnOfflineDeliveryFinished(const int32_t captureId) override;
+
     inline sptr<PhotoOutput> GetPhotoOutput()
     {
         if (innerPhotoOutput_ == nullptr) {
diff --git a/interfaces/inner_api/native/camera/include/session/capture_session.h b/interfaces/inner_api/native/camera/include/session/capture_session.h
index 4da8dcde..bbcda9a8 100644
--- a/interfaces/inner_api/native/camera/include/session/capture_session.h
+++ b/interfaces/inner_api/native/camera/include/session/capture_session.h
@@ -465,20 +465,6 @@ public:
      */
     void SetCallback(std::shared_ptr<SessionCallback> callback);
 
-    /**
-     * @brief Set the moving photo callback.
-     *
-     * @param photoProxy Requested for the pointer where moving photo callback is present.
-     * @param uri get uri for medialibary.
-     * @param cameraShotType get cameraShotType for medialibary.
-     */
-
-    void CreateMediaLibrary(sptr<CameraPhotoProxy> photoProxy, std::string &uri, int32_t &cameraShotType,
-                            std::string &burstKey, int64_t timestamp);
-
-    void CreateMediaLibrary(std::unique_ptr<Media::Picture> picture, sptr<CameraPhotoProxy> photoProxy,
-        std::string &uri, int32_t &cameraShotType, std::string &burstKey, int64_t timestamp);
-
     /**
      * @brief Get the application callback information.
      *
@@ -1653,6 +1639,8 @@ public:
 
     int32_t EnableAutoAigcPhoto(bool enabled);
 
+    void EnableOfflinePhoto();
+
     // White Balance
     /**
     * @brief Get Metering mode.
diff --git a/interfaces/inner_api/native/test/test_common.cpp b/interfaces/inner_api/native/test/test_common.cpp
index 8021c8b6..66c0359b 100644
--- a/interfaces/inner_api/native/test/test_common.cpp
+++ b/interfaces/inner_api/native/test/test_common.cpp
@@ -213,6 +213,11 @@ void TestPhotoOutputCallback::OnEstimatedCaptureDuration(const int32_t duration)
     MEDIA_INFO_LOG("OnEstimatedCaptureDuration(), duration: %{public}d", duration);
 }
 
+void TestPhotoOutputCallback::OnOfflineDeliveryFinished(const int32_t captureId) const
+{
+    MEDIA_INFO_LOG("OnOfflineDeliveryFinished(), captureId: %{public}d", captureId);
+}
+
 void TestPhotoOutputCallback::OnCaptureError(const int32_t captureId, const int32_t errorCode) const
 {
     MEDIA_INFO_LOG("OnCaptureError(), testName_: %{public}s, captureID: %{public}d, errorCode: %{public}d",
diff --git a/interfaces/inner_api/native/test/test_common.h b/interfaces/inner_api/native/test/test_common.h
index f54c15f2..609e6abc 100644
--- a/interfaces/inner_api/native/test/test_common.h
+++ b/interfaces/inner_api/native/test/test_common.h
@@ -108,6 +108,7 @@ public:
     void OnFrameShutterEnd(const int32_t captureId, const uint64_t timestamp) const override;
     void OnCaptureReady(const int32_t captureId, const uint64_t timestamp) const override;
     void OnEstimatedCaptureDuration(const int32_t duration) const override;
+    void OnOfflineDeliveryFinished(const int32_t captureId) const override;
 
 private:
     const char* testName_;
diff --git a/interfaces/kits/js/camera_napi/@ohos.multimedia.camera.d.ts b/interfaces/kits/js/camera_napi/@ohos.multimedia.camera.d.ts
index 2b17e22b..653d90a3 100644
--- a/interfaces/kits/js/camera_napi/@ohos.multimedia.camera.d.ts
+++ b/interfaces/kits/js/camera_napi/@ohos.multimedia.camera.d.ts
@@ -8726,13 +8726,56 @@ function getCameraManager(context: Context): CameraManager;
      * @throws { BusinessError } 401 - Parameter error. Possible causes:
      * 1. Mandatory parameters are left unspecified; 2. Incorrect parameter types;
      * 3. Parameter verification failed.
+     */
+    enableAutoAigcPhoto(enabled: boolean): void;
+
+    /**
+     * Confirm if offline processing is supported.
+     *
+     * @returns { boolean } TRUE if the type of offline is supported.
+     * @throws { BusinessError } 202 - Not System Application.
+     * @throws { BusinessError } 7400201 - Camera service fatal error.
+     * @syscap SystemCapability.Multimedia.Camera.Core
+     * @systemapi
+     * @since 16
+     */
+    isOfflineSupported(): boolean;
+
+    /**
+     * Enable offline processing.
+     *
+     * @throws { BusinessError } 202 - Not System Application.
      * @throws { BusinessError } 7400104 - session is not running.
      * @throws { BusinessError } 7400201 - Camera service fatal error.
      * @syscap SystemCapability.Multimedia.Camera.Core
      * @systemapi
      * @since 16
      */
-    enableAutoAigcPhoto(enabled: boolean): void;    
+    enableOffline(): void;
+
+    /**
+     * Subscribes offline Delivery finished events.
+     * This method is valid only after enableOffline() is called.
+     *
+     * @param { 'offlineDeliveryFinished' } type - Event type.
+     * @param { AsyncCallback<void> } callback - Callback used to get offline Delivery finished events.
+     * @syscap SystemCapability.Multimedia.Camera.Core
+     * @systemapi
+     * @since 16
+     */
+    on(type: 'offlineDeliveryFinished', callback: AsyncCallback<void>): void;
+
+    /**
+     * Unsubscribes offline Delivery finished events.
+     * This method is valid only after enableOffline() is called.
+     *
+     * @param { 'offlineDeliveryFinished' } type - Event type.
+     * @param { AsyncCallback<void>} callback - Callback used to get offline Delivery finished events.
+     * @syscap SystemCapability.Multimedia.Camera.Core
+     * @systemapi
+     * @since 16
+     */
+    off(type: 'offlineDeliveryFinished', callback?: AsyncCallback<void>): void
   }
 
   /**
diff --git a/interfaces/kits/js/camera_napi/include/output/photo_output_napi.h b/interfaces/kits/js/camera_napi/include/output/photo_output_napi.h
index c5dc6a18..69124511 100644
--- a/interfaces/kits/js/camera_napi/include/output/photo_output_napi.h
+++ b/interfaces/kits/js/camera_napi/include/output/photo_output_napi.h
@@ -54,6 +54,7 @@ static const std::string CONST_GAINMAP_SURFACE = "gainmap";
 static const std::string CONST_DEEP_SURFACE = "deep";
 static const std::string CONST_EXIF_SURFACE = "exif";
 static const std::string CONST_DEBUG_SURFACE = "debug";
+static const std::string CONST_CAPTURE_OFFLINE_DELIVERY_FINISHED = "offlineDeliveryFinished";
 
 struct CallbackInfo {
     int32_t captureID;
@@ -75,7 +76,8 @@ enum PhotoOutputEventType {
     CAPTURE_DEFERRED_PHOTO_AVAILABLE,
     CAPTURE_PHOTO_ASSET_AVAILABLE,
     CAPTURE_ESTIMATED_CAPTURE_DURATION,
-    CAPTURE_START_WITH_INFO
+    CAPTURE_START_WITH_INFO,
+    CAPTURE_OFFLINE_DELIVERY_FINISHED
 };
 
 static EnumHelper<PhotoOutputEventType> PhotoOutputEventTypeHelper({
@@ -89,7 +91,8 @@ static EnumHelper<PhotoOutputEventType> PhotoOutputEventTypeHelper({
         {CAPTURE_FRAME_SHUTTER_END, CONST_CAPTURE_FRAME_SHUTTER_END},
         {CAPTURE_READY, CONST_CAPTURE_READY},
         {CAPTURE_ESTIMATED_CAPTURE_DURATION, CONST_CAPTURE_ESTIMATED_CAPTURE_DURATION},
-        {CAPTURE_START_WITH_INFO, CONST_CAPTURE_START_WITH_INFO}
+        {CAPTURE_START_WITH_INFO, CONST_CAPTURE_START_WITH_INFO},
+        {CAPTURE_OFFLINE_DELIVERY_FINISHED, CONST_CAPTURE_OFFLINE_DELIVERY_FINISHED}
     },
     PhotoOutputEventType::CAPTURE_INVALID_TYPE
 );
@@ -217,6 +220,7 @@ public:
     void OnCaptureReady(const int32_t captureId, const uint64_t timestamp) const override;
     void OnCaptureError(const int32_t captureId, const int32_t errorCode) const override;
     void OnEstimatedCaptureDuration(const int32_t duration) const override;
+    void OnOfflineDeliveryFinished(const int32_t captureId) const override;
 
 private:
     void UpdateJSCallback(PhotoOutputEventType eventType, const CallbackInfo& info) const;
@@ -229,6 +233,7 @@ private:
     void ExecuteFrameShutterEndCb(const CallbackInfo& info) const;
     void ExecuteCaptureReadyCb(const CallbackInfo& info) const;
     void ExecuteEstimatedCaptureDurationCb(const CallbackInfo& info) const;
+    void ExecuteOfflineDeliveryFinishedCb(const CallbackInfo& info) const;
 };
 
 struct PhotoOutputCallbackInfo {
@@ -327,6 +332,8 @@ public:
     static napi_value GetPhotoRotation(napi_env env, napi_callback_info info);
     static napi_value IsAutoAigcPhotoSupported(napi_env env, napi_callback_info info);
     static napi_value EnableAutoAigcPhoto(napi_env env, napi_callback_info info);
+    static napi_value IsOfflineSupported(napi_env env, napi_callback_info info);
+    static napi_value EnableOfflinePhoto(napi_env env, napi_callback_info info);
 
     PhotoOutputNapi();
     ~PhotoOutputNapi() override;
@@ -390,6 +397,11 @@ private:
         const std::vector<napi_value>& args, bool isOnce);
     void UnregisterCaptureStartWithInfoCallbackListener(
         const std::string& eventName, napi_env env, napi_value callback, const std::vector<napi_value>& args);
+    void RegisterOfflineDeliveryFinishedCallbackListener(
+        const std::string& eventName, napi_env env, napi_value callback,
+        const std::vector<napi_value>& args, bool isOnce);
+    void UnregisterOfflineDeliveryFinishedCallbackListener(
+        const std::string& eventName, napi_env env, napi_value callback, const std::vector<napi_value>& args);
 
     static thread_local napi_ref sConstructor_;
     static thread_local sptr<PhotoOutput> sPhotoOutput_;
diff --git a/services/camera_service/BUILD.gn b/services/camera_service/BUILD.gn
index 569b5949..a5123e92 100644
--- a/services/camera_service/BUILD.gn
+++ b/services/camera_service/BUILD.gn
@@ -20,6 +20,18 @@ ohos_shared_library("camera_service") {
   sources = [
     "${multimedia_camera_framework_path}/frameworks/native/camera/src/ability/camera_ability_parse_util.cpp",
     "${multimedia_camera_framework_path}/frameworks/native/camera/src/output/camera_photo_proxy.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/task_manager/task_group/base_task_group.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/task_manager/task_group/delayed_task_group.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/task_manager/task_group/task_group.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/task_manager/task_manager.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/task_manager/task_registry.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/task_manager/thread_pool.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/task_manager/thread_utils.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/timer/core/timer_core.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/timer/steady_clock.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/timer/time_broker.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/timer/timer.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/utils/dp_utils.cpp",
     "binder/client/src/hcamera_device_callback_proxy.cpp",
     "binder/client/src/hcamera_listener_proxy.cpp",
     "binder/client/src/hcamera_service_callback_proxy.cpp",
@@ -74,6 +86,8 @@ ohos_shared_library("camera_service") {
     "src/hstream_common.cpp",
     "src/hstream_depth_data.cpp",
     "src/hstream_metadata.cpp",
+    "src/hstream_operator.cpp",
+    "src/hstream_operator_manager.cpp",
     "src/hstream_repeat.cpp",
     "src/media_library/photo_asset_proxy.cpp",
     "src/moving_photo/moving_photo_surface_wrapper.cpp",
diff --git a/services/camera_service/binder/base/include/camera_service_ipc_interface_code.h b/services/camera_service/binder/base/include/camera_service_ipc_interface_code.h
index 52b4f057..fbf1f1fa 100644
--- a/services/camera_service/binder/base/include/camera_service_ipc_interface_code.h
+++ b/services/camera_service/binder/base/include/camera_service_ipc_interface_code.h
@@ -171,10 +171,9 @@ enum CaptureSessionInterfaceCode {
     CAMERA_CAPTURE_SESSION_SET_FEATURE_MODE,
     CAMERA_CAPTURE_SESSION_ENABLE_MOTION_PHOTO,
     CAMERA_CAPTURE_SESSION_START_MOVING_PHOTO_CAPTURE,
-    CAMERA_CAPTURE_SESSION_CREATE_MEDIA_LIBRARY_MANAGER,
     CAMERA_CAPTURE_SESSION_SET_PREVIEW_ROTATE,
-    CAMERA_CAPTURE_SESSION_CREATE_MEDIA_LIBRARY_MANAGER_PICTURE,
     CAMERA_CAPTURE_SESSION_UNSET_CALLBACK,
+    CAMERA_CAPTURE_SESSION_SET_COMMIT_CONFIG_FLAG,
 };
 
 /**
@@ -201,6 +200,9 @@ enum StreamCaptureInterfaceCode {
     CAMERA_CAPTURE_DFX,
     CAMERA_STREAM_ADD_MEDIA_LIBRARY_PHOTO_PROXY,
     CAMERA_STREAM_CAPTURE_UNSET_CALLBACK,
+    CAMERA_STREAM_ENABLE_OFFLINE_PHOTO,
+    CAMERA_STREAM_CREATE_MEDIA_LIBRARY_MANAGER,
+    CAMERA_STREAM_CREATE_MEDIA_LIBRARY_MANAGER_PICTURE,
 };
 
 /**
@@ -312,7 +314,8 @@ enum StreamCaptureCallbackInterfaceCode {
     CAMERA_STREAM_CAPTURE_ON_FRAME_SHUTTER,
     CAMERA_STREAM_CAPTURE_ON_CAPTURE_STARTED_V1_2,
     CAMERA_STREAM_CAPTURE_ON_FRAME_SHUTTER_END,
-    CAMERA_STREAM_CAPTURE_ON_CAPTURE_READY
+    CAMERA_STREAM_CAPTURE_ON_CAPTURE_READY,
+    CAMERA_STREAM_CAPTURE_ON_OFFLINE_DELIVERY_FINISHED
 };
 
 /**
diff --git a/services/camera_service/binder/base/include/icapture_session.h b/services/camera_service/binder/base/include/icapture_session.h
index 3c977e1c..5f000b82 100644
--- a/services/camera_service/binder/base/include/icapture_session.h
+++ b/services/camera_service/binder/base/include/icapture_session.h
@@ -24,9 +24,6 @@
 #include "camera_photo_proxy.h"
 #include "ability/camera_ability.h"
 
-namespace OHOS::Media {
-    class Picture;
-}
 namespace OHOS {
 namespace CameraStandard {
 enum class CaptureSessionState : uint32_t {
@@ -79,13 +76,10 @@ public:
 
     virtual int32_t EnableMovingPhotoMirror(bool isMirror, bool isConfig) = 0;
 
-    virtual int32_t CreateMediaLibrary(sptr<CameraPhotoProxy> &photoProxy,
-        std::string &uri, int32_t &cameraShotType, std::string &burstKey, int64_t timestamp) = 0;
-
-    virtual int32_t CreateMediaLibrary(std::unique_ptr<Media::Picture> picture, sptr<CameraPhotoProxy> &photoProxy,
-        std::string &uri, int32_t &cameraShotType, std::string &burstKey, int64_t timestamp) = 0;
     virtual int32_t SetPreviewRotation(std::string &deviceClass) = 0;
 
+    virtual int32_t SetCommitConfigFlag(bool isNeedCommitting) = 0;
+
     DECLARE_INTERFACE_DESCRIPTOR(u"ICaptureSession");
 };
 } // namespace CameraStandard
diff --git a/services/camera_service/binder/base/include/istream_capture.h b/services/camera_service/binder/base/include/istream_capture.h
index 9636343d..e5117671 100644
--- a/services/camera_service/binder/base/include/istream_capture.h
+++ b/services/camera_service/binder/base/include/istream_capture.h
@@ -16,11 +16,15 @@
 #ifndef OHOS_CAMERA_ISTREAM_CAPTURE_H
 #define OHOS_CAMERA_ISTREAM_CAPTURE_H
 
+#include <cstdint>
 #include "camera_metadata_info.h"
 #include "istream_capture_callback.h"
 #include "istream_common.h"
 #include "surface.h"
 
+namespace OHOS::Media {
+    class Picture;
+}
 namespace OHOS {
 namespace CameraStandard {
 class CameraPhotoProxy;
@@ -60,6 +64,14 @@ public:
 
     virtual int32_t AcquireBufferToPrepareProxy(int32_t captureId) = 0;
 
+    virtual int32_t EnableOfflinePhoto(bool isEnable) = 0;
+    
+    virtual int32_t CreateMediaLibrary(sptr<CameraPhotoProxy> &photoProxy,
+        std::string &uri, int32_t &cameraShotType, std::string &burstKey, int64_t timestamp) = 0;
+
+    virtual int32_t CreateMediaLibrary(std::unique_ptr<Media::Picture> picture, sptr<CameraPhotoProxy> &photoProxy,
+        std::string &uri, int32_t &cameraShotType, std::string &burstKey, int64_t timestamp) = 0;
+
     DECLARE_INTERFACE_DESCRIPTOR(u"IStreamCapture");
 };
 } // namespace CameraStandard
diff --git a/services/camera_service/binder/base/include/istream_capture_callback.h b/services/camera_service/binder/base/include/istream_capture_callback.h
index f790c774..e92615cb 100644
--- a/services/camera_service/binder/base/include/istream_capture_callback.h
+++ b/services/camera_service/binder/base/include/istream_capture_callback.h
@@ -36,6 +36,8 @@ public:
 
     virtual int32_t OnCaptureReady(int32_t captureId, uint64_t timestamp) = 0;
 
+    virtual int32_t OnOfflineDeliveryFinished(int32_t captureId) = 0;
+
     DECLARE_INTERFACE_DESCRIPTOR(u"IStreamCaptureCallback");
 };
 } // namespace CameraStandard
diff --git a/services/camera_service/binder/client/include/hcapture_session_proxy.h b/services/camera_service/binder/client/include/hcapture_session_proxy.h
index c400ef01..c76f5d6a 100644
--- a/services/camera_service/binder/client/include/hcapture_session_proxy.h
+++ b/services/camera_service/binder/client/include/hcapture_session_proxy.h
@@ -67,13 +67,9 @@ public:
 
     int32_t EnableMovingPhotoMirror(bool isMirror, bool isConfig) override;
 
-    int32_t CreateMediaLibrary(sptr<CameraPhotoProxy> &photoProxy, std::string &uri, int32_t &cameraShotType,
-        std::string &burstKey, int64_t timestamp) override;
-
-    int32_t CreateMediaLibrary(std::unique_ptr<Media::Picture> picture, sptr<CameraPhotoProxy> &photoProxy,
-        std::string &uri, int32_t &cameraShotType, std::string &burstKey, int64_t timestamp) override;
-
     int32_t SetPreviewRotation(std::string &deviceClass) override;
+
+    int32_t SetCommitConfigFlag(bool isNeedCommitting) override;
 private:
     static inline BrokerDelegator<HCaptureSessionProxy> delegator_;
 };
diff --git a/services/camera_service/binder/client/include/hstream_capture_callback_proxy.h b/services/camera_service/binder/client/include/hstream_capture_callback_proxy.h
index 4fbe5771..28229fb4 100644
--- a/services/camera_service/binder/client/include/hstream_capture_callback_proxy.h
+++ b/services/camera_service/binder/client/include/hstream_capture_callback_proxy.h
@@ -42,6 +42,8 @@ public:
 
     int32_t OnCaptureReady(int32_t captureId, uint64_t timestamp) override;
 
+    int32_t OnOfflineDeliveryFinished(int32_t captureId) override;
+
 private:
     static inline BrokerDelegator<HStreamCaptureCallbackProxy> delegator_;
 };
diff --git a/services/camera_service/binder/client/include/hstream_capture_proxy.h b/services/camera_service/binder/client/include/hstream_capture_proxy.h
index d28a1cf0..217fac7a 100644
--- a/services/camera_service/binder/client/include/hstream_capture_proxy.h
+++ b/services/camera_service/binder/client/include/hstream_capture_proxy.h
@@ -61,6 +61,14 @@ public:
 
     int32_t AcquireBufferToPrepareProxy(int32_t captureId) override;
 
+    int32_t EnableOfflinePhoto(bool isEnable) override;
+
+    int32_t CreateMediaLibrary(sptr<CameraPhotoProxy> &photoProxy,
+        std::string &uri, int32_t &cameraShotType, std::string &burstKey, int64_t timestamp) override;
+
+    int32_t CreateMediaLibrary(std::unique_ptr<Media::Picture> picture, sptr<CameraPhotoProxy> &photoProxy,
+        std::string &uri, int32_t &cameraShotType, std::string &burstKey, int64_t timestamp) override;
+
 private:
     static inline BrokerDelegator<HStreamCaptureProxy> delegator_;
 };
diff --git a/services/camera_service/binder/client/src/hcapture_session_proxy.cpp b/services/camera_service/binder/client/src/hcapture_session_proxy.cpp
index 9668bed0..45fd1cc0 100644
--- a/services/camera_service/binder/client/src/hcapture_session_proxy.cpp
+++ b/services/camera_service/binder/client/src/hcapture_session_proxy.cpp
@@ -16,7 +16,6 @@
 #include "hcapture_session_proxy.h"
 #include "camera_log.h"
 #include "camera_service_ipc_interface_code.h"
-#include "picture.h"
 
 namespace OHOS {
 namespace CameraStandard {
@@ -337,69 +336,35 @@ int32_t HCaptureSessionProxy::EnableMovingPhotoMirror(bool isMirror, bool isConf
     return error;
 }
 
-int32_t HCaptureSessionProxy::CreateMediaLibrary(sptr<CameraPhotoProxy> &photoProxy,
-    std::string &uri, int32_t &cameraShotType, std::string &burstKey, int64_t timestamp)
+int32_t HCaptureSessionProxy::SetPreviewRotation(std::string &deviceClass)
 {
     MessageParcel data;
     MessageParcel reply;
     MessageOption option;
-    CHECK_ERROR_RETURN_RET_LOG(photoProxy == nullptr, IPC_PROXY_ERR,
-        "HCaptureSessionProxy CreateMediaLibrary photoProxy is null");
-    data.WriteInterfaceToken(GetDescriptor());
-    photoProxy->WriteToParcel(data);
-    data.WriteInt64(timestamp);
-    int error = Remote()->SendRequest(
-        static_cast<uint32_t>(CaptureSessionInterfaceCode::CAMERA_CAPTURE_SESSION_CREATE_MEDIA_LIBRARY_MANAGER),
-        data, reply, option);
-    CHECK_ERROR_PRINT_LOG(error != ERR_NONE,
-        "HCaptureSessionProxy CreateMediaLibrary failed, error: %{public}d", error);
-    uri = reply.ReadString();
-    cameraShotType = reply.ReadInt32();
-    burstKey = reply.ReadString();
-    return error;
-}
 
-int32_t HCaptureSessionProxy::CreateMediaLibrary(std::unique_ptr<Media::Picture> picture,
-    sptr<CameraPhotoProxy> &photoProxy, std::string &uri, int32_t &cameraShotType,
-    std::string &burstKey, int64_t timestamp)
-{
-    MessageParcel data;
-    MessageParcel reply;
-    MessageOption option;
-    if (picture == nullptr || photoProxy == nullptr) {
-        MEDIA_ERR_LOG("HCaptureSessionProxy CreateMediaLibrary picture or photoProxy is null");
-        return IPC_PROXY_ERR;
-    }
     data.WriteInterfaceToken(GetDescriptor());
-    MEDIA_DEBUG_LOG("HCaptureSessionProxy CreateMediaLibrary picture->Marshalling E");
-    CHECK_ERROR_PRINT_LOG(!picture->Marshalling(data), "HCaptureSessionProxy picture Marshalling failed");
-    MEDIA_DEBUG_LOG("HCaptureSessionProxy CreateMediaLibrary picture->Marshalling X");
-    photoProxy->WriteToParcel(data);
-    data.WriteInt64(timestamp);
+    data.WriteString(deviceClass);
     int error = Remote()->SendRequest(
-        static_cast<uint32_t>(CaptureSessionInterfaceCode::CAMERA_CAPTURE_SESSION_CREATE_MEDIA_LIBRARY_MANAGER_PICTURE),
+        static_cast<uint32_t>(CaptureSessionInterfaceCode::CAMERA_CAPTURE_SESSION_SET_PREVIEW_ROTATE),
         data, reply, option);
     CHECK_ERROR_PRINT_LOG(error != ERR_NONE,
-        "HCaptureSessionProxy CreateMediaLibrary failed, error: %{public}d", error);
-    uri = reply.ReadString();
-    cameraShotType = reply.ReadInt32();
-    burstKey = reply.ReadString();
+        "HCaptureSessionProxy SetPreviewRotation failed, error: %{public}d", error);
     return error;
 }
 
-int32_t HCaptureSessionProxy::SetPreviewRotation(std::string &deviceClass)
+int32_t HCaptureSessionProxy::SetCommitConfigFlag(bool isNeedCommitting)
 {
     MessageParcel data;
     MessageParcel reply;
     MessageOption option;
 
     data.WriteInterfaceToken(GetDescriptor());
-    data.WriteString(deviceClass);
+    data.WriteBool(isNeedCommitting);
     int error = Remote()->SendRequest(
-        static_cast<uint32_t>(CaptureSessionInterfaceCode::CAMERA_CAPTURE_SESSION_SET_PREVIEW_ROTATE),
+        static_cast<uint32_t>(CaptureSessionInterfaceCode::CAMERA_CAPTURE_SESSION_SET_COMMIT_CONFIG_FLAG),
         data, reply, option);
     CHECK_ERROR_PRINT_LOG(error != ERR_NONE,
-        "HCaptureSessionProxy SetPreviewRotation failed, error: %{public}d", error);
+        "HCaptureSessionProxy SetCommitConfigFlag failed, error: %{public}d", error);
     return error;
 }
 } // namespace CameraStandard
diff --git a/services/camera_service/binder/client/src/hstream_capture_callback_proxy.cpp b/services/camera_service/binder/client/src/hstream_capture_callback_proxy.cpp
index 4c90ee32..d275c008 100644
--- a/services/camera_service/binder/client/src/hstream_capture_callback_proxy.cpp
+++ b/services/camera_service/binder/client/src/hstream_capture_callback_proxy.cpp
@@ -155,5 +155,24 @@ int32_t HStreamCaptureCallbackProxy::OnCaptureReady(int32_t captureId, uint64_t
         "HStreamCaptureCallbackProxy OnCaptureReady failed, error: %{public}d", error);
     return error;
 }
+
+int32_t HStreamCaptureCallbackProxy::OnOfflineDeliveryFinished(int32_t captureId)
+{
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option;
+    option.SetFlags(option.TF_ASYNC);
+
+    data.WriteInterfaceToken(GetDescriptor());
+    data.WriteInt32(captureId);
+
+    int error = Remote()->SendRequest(
+        static_cast<uint32_t>(StreamCaptureCallbackInterfaceCode::CAMERA_STREAM_CAPTURE_ON_OFFLINE_DELIVERY_FINISHED),
+        data, reply, option);
+    if (error != ERR_NONE) {
+        MEDIA_ERR_LOG("HStreamCaptureCallbackProxy OnCaptureReady failed, error: %{public}d", error);
+    }
+    return error;
+}
 } // namespace CameraStandard
 } // namespace OHOS
\ No newline at end of file
diff --git a/services/camera_service/binder/client/src/hstream_capture_proxy.cpp b/services/camera_service/binder/client/src/hstream_capture_proxy.cpp
index a38f0a4c..215a6429 100644
--- a/services/camera_service/binder/client/src/hstream_capture_proxy.cpp
+++ b/services/camera_service/binder/client/src/hstream_capture_proxy.cpp
@@ -18,6 +18,7 @@
 #include "camera_photo_proxy.h"
 #include "camera_service_ipc_interface_code.h"
 #include "metadata_utils.h"
+#include "picture.h"
 
 namespace OHOS {
 namespace CameraStandard {
@@ -299,5 +300,73 @@ int32_t HStreamCaptureProxy::AcquireBufferToPrepareProxy(int32_t captureId)
     }
     return error;
 }
+
+
+int32_t HStreamCaptureProxy::EnableOfflinePhoto(bool isEnable)
+{
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option;
+
+    data.WriteInterfaceToken(GetDescriptor());
+    data.WriteBool(isEnable);
+    int error = Remote()->SendRequest(
+        static_cast<uint32_t>(StreamCaptureInterfaceCode::CAMERA_STREAM_ENABLE_OFFLINE_PHOTO), data, reply, option);
+    if (error != ERR_NONE) {
+        MEDIA_ERR_LOG("HStreamRepeatProxy EnableOfflinePhoto failed, error: %{public}d", error);
+    }
+    return error;
+}
+
+int32_t HStreamCaptureProxy::CreateMediaLibrary(sptr<CameraPhotoProxy> &photoProxy,
+    std::string &uri, int32_t &cameraShotType, std::string &burstKey, int64_t timestamp)
+{
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option;
+    CHECK_ERROR_RETURN_RET_LOG(photoProxy == nullptr, IPC_PROXY_ERR,
+        "HCaptureSessionProxy CreateMediaLibrary photoProxy is null");
+    data.WriteInterfaceToken(GetDescriptor());
+    photoProxy->WriteToParcel(data);
+    data.WriteInt64(timestamp);
+    int error = Remote()->SendRequest(
+        static_cast<uint32_t>(StreamCaptureInterfaceCode::CAMERA_STREAM_CREATE_MEDIA_LIBRARY_MANAGER),
+        data, reply, option);
+    CHECK_ERROR_PRINT_LOG(error != ERR_NONE,
+        "HCaptureSessionProxy CreateMediaLibrary failed, error: %{public}d", error);
+    uri = reply.ReadString();
+    cameraShotType = reply.ReadInt32();
+    burstKey = reply.ReadString();
+    return error;
+}
+
+int32_t HStreamCaptureProxy::CreateMediaLibrary(std::unique_ptr<Media::Picture> picture,
+    sptr<CameraPhotoProxy> &photoProxy, std::string &uri, int32_t &cameraShotType,
+    std::string &burstKey, int64_t timestamp)
+{
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option;
+    if (picture == nullptr || photoProxy == nullptr) {
+        MEDIA_ERR_LOG("HCaptureSessionProxy CreateMediaLibrary picture or photoProxy is null");
+        return IPC_PROXY_ERR;
+    }
+    data.WriteInterfaceToken(GetDescriptor());
+    MEDIA_DEBUG_LOG("HCaptureSessionProxy CreateMediaLibrary picture->Marshalling E");
+    CHECK_ERROR_PRINT_LOG(!picture->Marshalling(data), "HCaptureSessionProxy picture Marshalling failed");
+    MEDIA_DEBUG_LOG("HCaptureSessionProxy CreateMediaLibrary picture->Marshalling X");
+    photoProxy->WriteToParcel(data);
+    data.WriteInt64(timestamp);
+    int error = Remote()->SendRequest(
+        static_cast<uint32_t>(StreamCaptureInterfaceCode::CAMERA_STREAM_CREATE_MEDIA_LIBRARY_MANAGER_PICTURE),
+        data, reply, option);
+    if (error != ERR_NONE) {
+        MEDIA_ERR_LOG("HCaptureSessionProxy CreateMediaLibrary failed, error: %{public}d", error);
+    }
+    uri = reply.ReadString();
+    cameraShotType = reply.ReadInt32();
+    burstKey = reply.ReadString();
+    return error;
+}
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/services/camera_service/binder/server/include/hcapture_session_stub.h b/services/camera_service/binder/server/include/hcapture_session_stub.h
index 8701c958..3e0c71c9 100644
--- a/services/camera_service/binder/server/include/hcapture_session_stub.h
+++ b/services/camera_service/binder/server/include/hcapture_session_stub.h
@@ -45,8 +45,6 @@ private:
     int32_t HandleSetFeatureMode(MessageParcel& data);
     int32_t HandleEnableMovingPhoto(MessageParcel& data);
     int32_t HandleStartMovingPhotoCapture(MessageParcel& data);
-    int32_t HandleCreateMediaLibrary(MessageParcel& data, MessageParcel &reply);
-    int32_t HandleCreateMediaLibraryForPicture(MessageParcel& data, MessageParcel &reply);
 };
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/services/camera_service/binder/server/include/hstream_capture_callback_stub.h b/services/camera_service/binder/server/include/hstream_capture_callback_stub.h
index 79238562..1a7ec733 100644
--- a/services/camera_service/binder/server/include/hstream_capture_callback_stub.h
+++ b/services/camera_service/binder/server/include/hstream_capture_callback_stub.h
@@ -34,6 +34,7 @@ private:
     int HandleOnFrameShutter(MessageParcel& data);
     int HandleOnFrameShutterEnd(MessageParcel& data);
     int HandleOnCaptureReady(MessageParcel& data);
+    int HandleOnOfflineDeliveryFinished(MessageParcel& data);
 };
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/services/camera_service/binder/server/include/hstream_capture_stub.h b/services/camera_service/binder/server/include/hstream_capture_stub.h
index 3cc619ba..2c566829 100644
--- a/services/camera_service/binder/server/include/hstream_capture_stub.h
+++ b/services/camera_service/binder/server/include/hstream_capture_stub.h
@@ -42,6 +42,9 @@ public:
     int32_t HandleSetCameraPhotoRotation(MessageParcel& data);
     int32_t HandleAddMediaLibraryPhotoProxy(MessageParcel& data);
     int32_t HandleAcquireBufferToPrepareProxy(MessageParcel& data);
+    int32_t HandleEnableOfflinePhoto(MessageParcel& data);
+    int32_t HandleCreateMediaLibrary(MessageParcel& data, MessageParcel &reply);
+    int32_t HandleCreateMediaLibraryForPicture(MessageParcel& data, MessageParcel &reply);
 };
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/services/camera_service/binder/server/src/hcapture_session_stub.cpp b/services/camera_service/binder/server/src/hcapture_session_stub.cpp
index ef8200b2..3a2396b9 100644
--- a/services/camera_service/binder/server/src/hcapture_session_stub.cpp
+++ b/services/camera_service/binder/server/src/hcapture_session_stub.cpp
@@ -19,7 +19,6 @@
 #include "camera_xcollie.h"
 #include "camera_service_ipc_interface_code.h"
 #include "camera_photo_proxy.h"
-#include "picture.h"
 #include <memory>
 
 namespace OHOS {
@@ -94,19 +93,19 @@ int HCaptureSessionStub::OnRemoteRequest(
         case static_cast<uint32_t>(CaptureSessionInterfaceCode::CAMERA_CAPTURE_SESSION_START_MOVING_PHOTO_CAPTURE):
             errCode = HandleStartMovingPhotoCapture(data);
             break;
-        case static_cast<uint32_t>(CaptureSessionInterfaceCode::CAMERA_CAPTURE_SESSION_CREATE_MEDIA_LIBRARY_MANAGER):
-            errCode = HandleCreateMediaLibrary(data, reply);
-            break;
-        case static_cast<uint32_t>(
-            CaptureSessionInterfaceCode::CAMERA_CAPTURE_SESSION_CREATE_MEDIA_LIBRARY_MANAGER_PICTURE):
-            errCode = HandleCreateMediaLibraryForPicture(data, reply);
-            break;
         case static_cast<uint32_t>(CaptureSessionInterfaceCode::CAMERA_CAPTURE_SESSION_SET_PREVIEW_ROTATE):
             {
                 std::string deviceClass = data.ReadString();
                 errCode = SetPreviewRotation(deviceClass);
             }
             break;
+
+        case static_cast<uint32_t>(CaptureSessionInterfaceCode::CAMERA_CAPTURE_SESSION_SET_COMMIT_CONFIG_FLAG):
+            {
+                bool isNeedCommiting = data.ReadBool();
+                errCode = SetCommitConfigFlag(isNeedCommiting);
+            }
+            break;
         default:
             MEDIA_ERR_LOG("HCaptureSessionStub request code %{public}u not handled", code);
             errCode = IPCObjectStub::OnRemoteRequest(code, data, reply, option);
@@ -264,48 +263,5 @@ int32_t HCaptureSessionStub::HandleStartMovingPhotoCapture(MessageParcel &data)
     bool isConfig = data.ReadBool();
     return EnableMovingPhotoMirror(isMirror, isConfig);
 }
-
-int32_t HCaptureSessionStub::HandleCreateMediaLibrary(MessageParcel& data, MessageParcel &reply)
-{
-    sptr<CameraPhotoProxy> photoProxy = new CameraPhotoProxy();
-    photoProxy->ReadFromParcel(data);
-    int64_t timestamp = data.ReadInt64();
-    CHECK_ERROR_RETURN_RET_LOG(photoProxy == nullptr, IPC_STUB_INVALID_DATA_ERR,
-        "HCaptureSessionStub HandleCreateMediaLibrary photoProxy is null");
-    std::string uri;
-    int32_t cameraShotType = 0;
-    std::string burstKey;
-    int32_t ret = CreateMediaLibrary(photoProxy, uri, cameraShotType, burstKey, timestamp);
-    CHECK_ERROR_RETURN_RET_LOG(!(reply.WriteString(uri)) || !(reply.WriteInt32(cameraShotType)) ||
-        !(reply.WriteString(burstKey)), IPC_STUB_WRITE_PARCEL_ERR,
-        "HCaptureSessionStub HandleCreateMediaLibrary Write uri and cameraShotType failed");
-    return ret;
-}
-
-int32_t HCaptureSessionStub::HandleCreateMediaLibraryForPicture(MessageParcel& data, MessageParcel &reply)
-{
-    MEDIA_DEBUG_LOG("HCaptureSessionStub HandleCreateMediaLibraryForPicture Picture::Unmarshalling E");
-    Media::Picture *picturePtr = Media::Picture::Unmarshalling(data);
-    MEDIA_DEBUG_LOG("HCaptureSessionStub HandleCreateMediaLibraryForPicture Picture::Unmarshalling X");
-
-    CHECK_ERROR_RETURN_RET_LOG(picturePtr == nullptr, IPC_STUB_INVALID_DATA_ERR,
-        "HCaptureSessionStub HandleCreateMediaLibrary picture is null");
-    std::unique_ptr<Media::Picture> picture(std::move(picturePtr));
-    sptr<CameraPhotoProxy> photoProxy = new CameraPhotoProxy();
-    photoProxy->ReadFromParcel(data);
-    CHECK_ERROR_RETURN_RET_LOG(photoProxy == nullptr, IPC_STUB_INVALID_DATA_ERR,
-        "HCaptureSessionStub HandleCreateMediaLibrary photoProxy is null");
-    int64_t timestamp = data.ReadInt64();
-    std::string uri;
-    int32_t cameraShotType = 0;
-    std::string burstKey;
-    MEDIA_DEBUG_LOG("HCaptureSessionStub HandleCreateMediaLibraryForPicture E");
-    int32_t ret = CreateMediaLibrary(std::move(picture), photoProxy, uri, cameraShotType, burstKey, timestamp);
-    MEDIA_DEBUG_LOG("HCaptureSessionStub HandleCreateMediaLibraryForPicture X");
-    CHECK_ERROR_RETURN_RET_LOG(!(reply.WriteString(uri)) || !(reply.WriteInt32(cameraShotType)) ||
-        !(reply.WriteString(burstKey)), IPC_STUB_WRITE_PARCEL_ERR,
-        "HCaptureSessionStub HandleCreateMediaLibrary Write uri and cameraShotType failed");
-    return ret;
-}
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/services/camera_service/binder/server/src/hstream_capture_callback_stub.cpp b/services/camera_service/binder/server/src/hstream_capture_callback_stub.cpp
index 8ffb8d88..364c95af 100644
--- a/services/camera_service/binder/server/src/hstream_capture_callback_stub.cpp
+++ b/services/camera_service/binder/server/src/hstream_capture_callback_stub.cpp
@@ -47,6 +47,10 @@ int HStreamCaptureCallbackStub::OnRemoteRequest(
         case static_cast<uint32_t>(StreamCaptureCallbackInterfaceCode::CAMERA_STREAM_CAPTURE_ON_CAPTURE_READY):
             errCode = HandleOnCaptureReady(data);
             break;
+        case static_cast<uint32_t>(
+            StreamCaptureCallbackInterfaceCode::CAMERA_STREAM_CAPTURE_ON_OFFLINE_DELIVERY_FINISHED):
+            errCode = HandleOnOfflineDeliveryFinished(data);
+            break;
         default:
             MEDIA_ERR_LOG("HStreamCaptureCallbackStub request code %{public}u not handled", code);
             errCode = IPCObjectStub::OnRemoteRequest(code, data, reply, option);
@@ -110,6 +114,12 @@ int HStreamCaptureCallbackStub::HandleOnCaptureReady(MessageParcel& data)
 
     return OnCaptureReady(captureId, timestamp);
 }
+
+int HStreamCaptureCallbackStub::HandleOnOfflineDeliveryFinished(MessageParcel& data)
+{
+    int32_t captureId = data.ReadInt32();
+    return OnOfflineDeliveryFinished(captureId);
+}
 } // namespace CameraStandard
 } // namespace OHOS
 
diff --git a/services/camera_service/binder/server/src/hstream_capture_stub.cpp b/services/camera_service/binder/server/src/hstream_capture_stub.cpp
index bb2e6fde..fe2ee408 100644
--- a/services/camera_service/binder/server/src/hstream_capture_stub.cpp
+++ b/services/camera_service/binder/server/src/hstream_capture_stub.cpp
@@ -14,11 +14,13 @@
  */
 
 #include "hstream_capture_stub.h"
+#include "camera_server_photo_proxy.h"
 #include "camera_log.h"
 #include "camera_photo_proxy.h"
 #include "camera_service_ipc_interface_code.h"
 #include "camera_util.h"
 #include "metadata_utils.h"
+#include "picture.h"
 
 namespace OHOS {
 namespace CameraStandard {
@@ -83,6 +85,16 @@ int HStreamCaptureStub::OnRemoteRequest(
         case static_cast<uint32_t>(StreamCaptureInterfaceCode::CAMERA_CAPTURE_DFX):
             errCode = HandleAcquireBufferToPrepareProxy(data);
             break;
+        case static_cast<uint32_t>(StreamCaptureInterfaceCode::CAMERA_STREAM_ENABLE_OFFLINE_PHOTO):
+            errCode = HandleEnableOfflinePhoto(data);
+            break;
+        case static_cast<uint32_t>(StreamCaptureInterfaceCode::CAMERA_STREAM_CREATE_MEDIA_LIBRARY_MANAGER):
+            errCode = HandleCreateMediaLibrary(data, reply);
+            break;
+        case static_cast<uint32_t>(
+            StreamCaptureInterfaceCode::CAMERA_STREAM_CREATE_MEDIA_LIBRARY_MANAGER_PICTURE):
+            errCode = HandleCreateMediaLibraryForPicture(data, reply);
+            break;
         default:
             MEDIA_ERR_LOG("HStreamCaptureStub request code %{public}u not handled", code);
             errCode = IPCObjectStub::OnRemoteRequest(code, data, reply, option);
@@ -184,7 +196,8 @@ int32_t HStreamCaptureStub::HandleAddMediaLibraryPhotoProxy(MessageParcel& data)
     sptr<CameraPhotoProxy> photoProxy = new CameraPhotoProxy();
     photoProxy->ReadFromParcel(data);
     int ret = UpdateMediaLibraryPhotoAssetProxy(photoProxy);
-    CHECK_ERROR_PRINT_LOG(ret != ERR_NONE, "HStreamCaptureStub::HandleSetCameraPhotoRotation failed : %{public}d", ret);
+    CHECK_ERROR_PRINT_LOG(ret != ERR_NONE,
+        "HStreamCaptureStub::HandleAddMediaLibraryPhotoProxy failed : %{public}d", ret);
     return ret;
 }
 
@@ -205,5 +218,57 @@ int32_t HStreamCaptureStub::HandleAcquireBufferToPrepareProxy(MessageParcel& dat
                           "HStreamCaptureStub::HandleAcquireBufferToPrepareProxy failed : %{public}d", ret);
     return ret;
 }
+
+int32_t HStreamCaptureStub::HandleEnableOfflinePhoto(MessageParcel& data)
+{
+    bool isEnable = data.ReadBool();
+    int32_t ret = EnableOfflinePhoto(isEnable);
+    CHECK_ERROR_PRINT_LOG(ret != ERR_NONE,
+        "HStreamCaptureStub::HandleEnableOfflinePhoto failed : %{public}d", ret);
+    return ret;
+}
+
+int32_t HStreamCaptureStub::HandleCreateMediaLibrary(MessageParcel& data, MessageParcel &reply)
+{
+    sptr<CameraPhotoProxy> photoProxy = new CameraPhotoProxy();
+    photoProxy->ReadFromParcel(data);
+    int64_t timestamp = data.ReadInt64();
+    CHECK_ERROR_RETURN_RET_LOG(photoProxy == nullptr, IPC_STUB_INVALID_DATA_ERR,
+        "HStreamCaptureStub HandleCreateMediaLibrary photoProxy is null");
+    std::string uri;
+    int32_t cameraShotType = 0;
+    std::string burstKey;
+    int32_t ret = CreateMediaLibrary(photoProxy, uri, cameraShotType, burstKey, timestamp);
+    CHECK_ERROR_RETURN_RET_LOG((!reply.WriteString(uri) || !reply.WriteInt32(cameraShotType) ||
+        !reply.WriteString(burstKey)), IPC_STUB_WRITE_PARCEL_ERR,
+        "HStreamCaptureStub HandleCreateMediaLibrary Write uri and cameraShotType failed");
+    return ret;
+}
+
+int32_t HStreamCaptureStub::HandleCreateMediaLibraryForPicture(MessageParcel& data, MessageParcel &reply)
+{
+    MEDIA_DEBUG_LOG("HStreamCaptureStub HandleCreateMediaLibraryForPicture Picture::Unmarshalling E");
+    Media::Picture *picturePtr = Media::Picture::Unmarshalling(data);
+    MEDIA_DEBUG_LOG("HStreamCaptureStub HandleCreateMediaLibraryForPicture Picture::Unmarshalling X");
+
+    CHECK_ERROR_RETURN_RET_LOG(picturePtr == nullptr, IPC_STUB_INVALID_DATA_ERR,
+        "HStreamCaptureStub HandleCreateMediaLibrary picture is null");
+    std::unique_ptr<Media::Picture> picture(std::move(picturePtr));
+    sptr<CameraPhotoProxy> photoProxy = new CameraPhotoProxy();
+    photoProxy->ReadFromParcel(data);
+    CHECK_ERROR_RETURN_RET_LOG(photoProxy == nullptr, IPC_STUB_INVALID_DATA_ERR,
+        "HStreamCaptureStub HandleCreateMediaLibrary photoProxy is null");
+    int64_t timestamp = data.ReadInt64();
+    std::string uri;
+    int32_t cameraShotType = 0;
+    std::string burstKey;
+    MEDIA_DEBUG_LOG("HStreamCaptureStub HandleCreateMediaLibraryForPicture E");
+    int32_t ret = CreateMediaLibrary(std::move(picture), photoProxy, uri, cameraShotType, burstKey, timestamp);
+    MEDIA_DEBUG_LOG("HStreamCaptureStub HandleCreateMediaLibraryForPicture X");
+    CHECK_ERROR_RETURN_RET_LOG((!(reply.WriteString(uri)) || !(reply.WriteInt32(cameraShotType)) ||
+        !(reply.WriteString(burstKey))), IPC_STUB_WRITE_PARCEL_ERR,
+        "HStreamCaptureStub HandleCreateMediaLibrary Write uri and cameraShotType failed");
+    return ret;
+}
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/services/camera_service/include/dfx/camera_report_uitls.h b/services/camera_service/include/dfx/camera_report_uitls.h
index 7007040f..9ad3503a 100644
--- a/services/camera_service/include/dfx/camera_report_uitls.h
+++ b/services/camera_service/include/dfx/camera_report_uitls.h
@@ -59,6 +59,8 @@ struct DfxCaptureInfo {
     CallerInfo caller;
     uint64_t captureStartTime;
     uint64_t captureEndTime;
+    bool isOfflinCapture = false;
+    uint32_t offlineOutputCnt = 0;
 };
 
 class CameraReportUtils {
@@ -84,7 +86,7 @@ public:
     void SetModeChangePerfEndInfo();
 
     void SetCapturePerfStartInfo(DfxCaptureInfo captureInfo);
-    void SetCapturePerfEndInfo(int32_t captureId);
+    void SetCapturePerfEndInfo(int32_t captureId, bool isOfflinCapture = false, int32_t offlineOutputCnt = 0);
 
     void SetSwitchCamPerfStartInfo(CallerInfo caller);
     void SetSwitchCamPerfEndInfo();
diff --git a/services/camera_service/include/hcamera_device.h b/services/camera_service/include/hcamera_device.h
index 793df14c..2159e6ab 100644
--- a/services/camera_service/include/hcamera_device.h
+++ b/services/camera_service/include/hcamera_device.h
@@ -54,7 +54,7 @@ using OHOS::HDI::Camera::V1_0::CaptureErrorInfo;
 using OHOS::HDI::Camera::V1_0::ICameraDeviceCallback;
 using OHOS::HDI::Camera::V1_3::IStreamOperatorCallback;
 class EXPORT_API HCameraDevice
-    : public HCameraDeviceStub, public ICameraDeviceCallback, public IStreamOperatorCallback {
+    : public HCameraDeviceStub, public ICameraDeviceCallback {
 public:
     explicit HCameraDevice(
         sptr<HCameraHostManager>& cameraHostManager, std::string cameraID, const uint32_t callingTokenId);
@@ -75,34 +75,20 @@ public:
     int32_t EnableResult(std::vector<int32_t>& results) override;
     int32_t DisableResult(std::vector<int32_t>& results) override;
     int32_t ReleaseStreams(std::vector<int32_t>& releaseStreamIds);
-    sptr<OHOS::HDI::Camera::V1_0::IStreamOperator> GetStreamOperator();
     int32_t SetCallback(sptr<ICameraDeviceServiceCallback>& callback) override;
     int32_t UnSetCallback() override;
     int32_t OnError(OHOS::HDI::Camera::V1_0::ErrorType type, int32_t errorCode) override;
     int32_t OnResult(uint64_t timestamp, const std::vector<uint8_t>& result) override;
-    int32_t OnResult(int32_t streamId, const std::vector<uint8_t>& result) override;
+    // int32_t OnResult(int32_t streamId, const std::vector<uint8_t>& result) override;
     std::shared_ptr<OHOS::Camera::CameraMetadata> GetDeviceAbility();
     std::shared_ptr<OHOS::Camera::CameraMetadata> CloneCachedSettings();
     std::string GetCameraId();
     int32_t GetCameraType();
     bool IsOpenedCameraDevice();
     int32_t GetCallerToken();
-    int32_t CreateAndCommitStreams(std::vector<HDI::Camera::V1_1::StreamInfo_V1_1>& streamInfos,
-        std::shared_ptr<OHOS::Camera::CameraMetadata>& deviceSettings, int32_t operationMode);
-    int32_t UpdateStreams(std::vector<StreamInfo_V1_1>& streamInfos);
 
     int32_t OperatePermissionCheck(uint32_t interfaceCode) override;
 
-    int32_t OnCaptureStarted(int32_t captureId, const std::vector<int32_t>& streamIds) override;
-    int32_t OnCaptureStarted_V1_2(
-        int32_t captureId, const std::vector<OHOS::HDI::Camera::V1_2::CaptureStartedInfo>& infos) override;
-    int32_t OnCaptureEnded(int32_t captureId, const std::vector<CaptureEndedInfo>& infos) override;
-    int32_t OnCaptureEndedExt(
-        int32_t captureId, const std::vector<OHOS::HDI::Camera::V1_3::CaptureEndedInfoExt>& infos) override;
-    int32_t OnCaptureError(int32_t captureId, const std::vector<CaptureErrorInfo>& infos) override;
-    int32_t OnFrameShutter(int32_t captureId, const std::vector<int32_t>& streamIds, uint64_t timestamp) override;
-    int32_t OnFrameShutterEnd(int32_t captureId, const std::vector<int32_t>& streamIds, uint64_t timestamp) override;
-    int32_t OnCaptureReady(int32_t captureId, const std::vector<int32_t>& streamIds, uint64_t timestamp) override;
     int32_t ResetDeviceSettings();
     int32_t DispatchDefaultSettingToHdi();
     void SetDeviceMuteMode(bool muteMode);
@@ -135,16 +121,6 @@ public:
         std::lock_guard<std::mutex> lock(cameraPrivacyMutex_);
         return cameraPrivacy_;
     }
-
-    inline int32_t GenerateHdiStreamId()
-    {
-        return hdiStreamIdGenerator_.fetch_add(1);
-    }
-
-    inline void ResetHdiStreamId()
-    {
-        hdiStreamIdGenerator_ = HDI_STREAM_ID_INIT;
-    }
     
     void NotifyCameraSessionStatus(bool running);
 
@@ -182,6 +158,8 @@ public:
     {
         return cameraConcurrentType_;
     }
+    int32_t GetStreamOperator(const sptr<IStreamOperatorCallback> &callbackObj,
+        sptr<OHOS::HDI::Camera::V1_0::IStreamOperator> &streamOperator);
 
 private:
     class FoldScreenListener;
@@ -189,7 +167,6 @@ private:
 
     std::mutex opMutex_; // Lock the operations updateSettings_, streamOperator_, and hdiCameraDevice_.
     std::shared_ptr<OHOS::Camera::CameraMetadata> updateSettings_;
-    sptr<OHOS::HDI::Camera::V1_0::IStreamOperator> streamOperator_;
     sptr<OHOS::HDI::Camera::V1_0::ICameraDevice> hdiCameraDevice_;
     std::shared_ptr<OHOS::Camera::CameraMetadata> cachedSettings_;
     int32_t cameraConcurrentType_;
@@ -234,19 +211,15 @@ private:
     int64_t lastDeviceEjectTime_ = 0;
     std::atomic<int> deviceEjectTimes_ = 1;
 
-    std::atomic<int32_t> hdiStreamIdGenerator_ = HDI_STREAM_ID_INIT;
     void UpdateDeviceOpenLifeCycleSettings(std::shared_ptr<OHOS::Camera::CameraMetadata> changedSettings);
     void ResetDeviceOpenLifeCycleSettings();
 
     sptr<ICameraDeviceServiceCallback> GetDeviceServiceCallback();
     void ResetCachedSettings();
-    int32_t InitStreamOperator();
     void ReportMetadataDebugLog(const std::shared_ptr<OHOS::Camera::CameraMetadata>& settings);
     void RegisterFoldStatusListener();
     void UnregisterFoldStatusListener();
     void CheckOnResultData(std::shared_ptr<OHOS::Camera::CameraMetadata> cameraResult);
-    int32_t CreateStreams(std::vector<HDI::Camera::V1_1::StreamInfo_V1_1>& streamInfos);
-    int32_t CommitStreams(std::shared_ptr<OHOS::Camera::CameraMetadata>& deviceSettings, int32_t operationMode);
     bool CanOpenCamera();
     void ResetZoomTimer();
     void CheckZoomChange(const std::shared_ptr<OHOS::Camera::CameraMetadata>& settings);
diff --git a/services/camera_service/include/hcamera_restore_param.h b/services/camera_service/include/hcamera_restore_param.h
index bcb81f8b..3d3a1383 100644
--- a/services/camera_service/include/hcamera_restore_param.h
+++ b/services/camera_service/include/hcamera_restore_param.h
@@ -69,4 +69,4 @@ private:
 };
 } // namespace CameraStandard
 } // namespace OHOS
-#endif // OHOS_CAMERA_H_STREAM_COMMON_H
+#endif // OHOS_CAMERA_H_STREAM_COMMON_H
\ No newline at end of file
diff --git a/services/camera_service/include/hcamera_service.h b/services/camera_service/include/hcamera_service.h
index e8e2f100..0499cdbb 100644
--- a/services/camera_service/include/hcamera_service.h
+++ b/services/camera_service/include/hcamera_service.h
@@ -35,6 +35,7 @@
 #include "hcamera_service_stub.h"
 #include "hcapture_session.h"
 #include "hstream_capture.h"
+#include "hstream_operator.h"
 #include "hstream_depth_data.h"
 #include "hstream_metadata.h"
 #include "hstream_repeat.h"
diff --git a/services/camera_service/include/hcapture_session.h b/services/camera_service/include/hcapture_session.h
index 7b3f044a..ffd6a532 100644
--- a/services/camera_service/include/hcapture_session.h