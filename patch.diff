From 45de1bdac68116478700aca460e9d04a52b51249 Mon Sep 17 00:00:00 2001
From: f00373274 <f00373274@notesmail.huawei.com/>
Date: Fri, 17 May 2024 17:11:47 +0800
Subject: [PATCH] TicketNo: DTS2024051718591 Description: modify secure camera
 errorcode Team:EMUI Feature or Bugfix:Bugfix Binary Source: No
 PrivateCode(Yes/No):No

Change-Id: Ibeaa7b06d2fcb633b610fe5b8039c0e8de7c1b0c
(cherry picked from commit ad6169fa72d479f1fe92b7d7813b8efd5498a3ab)
---
 .../camera/src/session/capture_session.cpp    |   4 +-
 .../src/session/secure_camera_session.cpp     |   7 +-
 .../src/camera_framework_moduletest.cpp       | 247 ++++++++++
 .../src/v1_1/camera_framework_unittest.cpp    | 426 ++++++++++++++++++
 .../unittest/src/v1_1/camera_ndk_unittest.cpp | 171 +++++++
 .../include/session/secure_camera_session.h   |   2 +
 .../camera_service/src/hcapture_session.cpp   |   2 +-
 7 files changed, 853 insertions(+), 6 deletions(-)

diff --git a/frameworks/native/camera/src/session/capture_session.cpp b/frameworks/native/camera/src/session/capture_session.cpp
index 66f7c01d..4696498b 100755
--- a/frameworks/native/camera/src/session/capture_session.cpp
+++ b/frameworks/native/camera/src/session/capture_session.cpp
@@ -616,11 +616,11 @@ int32_t CaptureSession::AddSecureOutput(sptr<CaptureOutput> &output)
     CAMERA_SYNC_TRACE;
     MEDIA_INFO_LOG("Enter Into SecureCameraSession::AddSecureOutput");
     if (currentMode_ != SceneMode::SECURE) {
-        return CAMERA_UNSUPPORTED;
+        return CAMERA_OPERATION_NOT_ALLOWED;
     }
     if (!IsSessionConfiged() || output == nullptr || isSetSecureOutput_) {
         MEDIA_ERR_LOG("SecureCameraSession::AddSecureOutput operation is Not allowed!");
-        return CAMERA_OK;
+        return CAMERA_OPERATION_NOT_ALLOWED;
     }
     sptr<IStreamCommon> stream = output->GetStream();
     IStreamRepeat* repeatStream = static_cast<IStreamRepeat*>(stream.GetRefPtr());
diff --git a/frameworks/native/camera/src/session/secure_camera_session.cpp b/frameworks/native/camera/src/session/secure_camera_session.cpp
index d78dfe94..0be0db35 100755
--- a/frameworks/native/camera/src/session/secure_camera_session.cpp
+++ b/frameworks/native/camera/src/session/secure_camera_session.cpp
@@ -30,13 +30,14 @@ int32_t SecureCameraSession::AddSecureOutput(sptr<CaptureOutput> &output)
 {
     CAMERA_SYNC_TRACE;
     MEDIA_INFO_LOG("Enter Into SecureCameraSession::AddSecureOutput");
-    if (!IsSessionConfiged() || output == nullptr) {
-        MEDIA_ERR_LOG("SecureCameraSession::CanAddOutput operation is Not allowed!");
-        return CAMERA_OK;
+    if (!IsSessionConfiged() || output == nullptr || isSetSecureOutput_) {
+        MEDIA_ERR_LOG("SecureCameraSession::AddSecureOutput operation is Not allowed!");
+        return CAMERA_OPERATION_NOT_ALLOWED;
     }
     sptr<IStreamCommon> stream = output->GetStream();
     IStreamRepeat* repeatStream = static_cast<IStreamRepeat*>(stream.GetRefPtr());
     repeatStream->EnableSecure(true);
+    isSetSecureOutput_ = true;
     return CAMERA_OK;
 }
 } // namespace CameraStandard
diff --git a/frameworks/native/camera/test/moduletest/src/camera_framework_moduletest.cpp b/frameworks/native/camera/test/moduletest/src/camera_framework_moduletest.cpp
index 6beae045..896274b4 100755
--- a/frameworks/native/camera/test/moduletest/src/camera_framework_moduletest.cpp
+++ b/frameworks/native/camera/test/moduletest/src/camera_framework_moduletest.cpp
@@ -18,6 +18,7 @@
 #include <cinttypes>
 #include <memory>
 #include <vector>
+#include <thread>
 
 #include "accesstoken_kit.h"
 #include "camera_error_code.h"
@@ -41,6 +42,7 @@
 #include "parameter.h"
 #include "scan_session.h"
 #include "session/profession_session.h"
+#include "session/secure_camera_session.h"
 #include "surface.h"
 #include "system_ability_definition.h"
 #include "test_common.h"
@@ -10060,5 +10062,250 @@ HWTEST_F(CameraFrameworkModuleTest, camera_framework_moduletest_076, TestSize.Le
     intResult = previewOutputTrans->Stop();
     EXPECT_EQ(intResult, 0);
 }
+
+/*
+* Feature: Framework
+* Function: Test normal branch for secure camera
+* SubFunction: NA
+* FunctionPoints: NA
+* EnvConditions: NA
+* CaseDescription: Test normal branch for secure camera
+*/
+HWTEST_F(CameraFrameworkModuleTest, camera_framework_securecamera_moduleTest_001, TestSize.Level0)
+{
+    if (session_) {
+        session_->Release();
+    }
+    if (scanSession_) {
+        scanSession_->Release();
+    }
+    if (input_) {
+        sptr<CameraInput> camInput = (sptr<CameraInput>&)input_;
+        camInput->Close();
+        input_->Release();
+    }
+    std::this_thread::sleep_for(std::chrono::seconds(1));
+    std::vector<sptr<CameraDevice>> cameras = manager_->GetSupportedCameras();
+
+    for (sptr<CameraDevice> camDevice : cameras) {
+        std::vector<SceneMode> modes = manager_->GetSupportedModes(camDevice);
+        ASSERT_TRUE(modes.size() != 0);
+
+        if (find(modes.begin(), modes.end(), SceneMode::SECURE) != modes.end()) {
+            sptr<CameraOutputCapability> ability = manager_->
+            GetSupportedOutputCapability(camDevice, SceneMode::SECURE);
+            ASSERT_NE(ability, nullptr);
+
+            sptr<CaptureSession> captureSession = manager_->CreateCaptureSession(SceneMode::SECURE);
+            ASSERT_NE(captureSession, nullptr);
+            sptr<SecureCameraSession> secureSession = nullptr;
+            secureSession = static_cast<SecureCameraSession *> (captureSession.GetRefPtr());
+            ASSERT_NE(secureSession, nullptr);
+            sptr<CaptureInput> inputSecure = manager_->CreateCameraInput(camDevice);
+            ASSERT_NE(inputSecure, nullptr);
+
+            sptr<CameraInput> inputSecure_ = (sptr<CameraInput>&)inputSecure;
+            uint64_t secureSeqId = 0;
+            int intResult = inputSecure_->Open(true, &secureSeqId);
+            EXPECT_EQ(intResult, 0);
+            EXPECT_NE(secureSeqId, 0);
+            std::this_thread::sleep_for(std::chrono::seconds(3));
+            sptr<CaptureOutput> preview = CreatePreviewOutput();
+            ASSERT_NE(preview, nullptr);
+
+            EXPECT_EQ(secureSession->BeginConfig(), 0);
+            EXPECT_EQ(secureSession->AddInput(inputSecure), 0);
+            EXPECT_EQ(secureSession->AddOutput(preview), 0);
+            EXPECT_EQ(secureSession->AddSecureOutput(preview), 0);
+            EXPECT_EQ(secureSession->CommitConfig(), 0);
+            secureSession->Release();
+            inputSecure_->Close();
+            break;
+        }
+    }
+}
+
+/*
+* Feature: Framework
+* Function: Test abnormal branch that is non-securemode while opening securecamera
+* SubFunction: NA
+* FunctionPoints: NA
+* EnvConditions: NA
+* CaseDescription: Test abnormal branch that is non-securemode while opening securecamera
+*/
+HWTEST_F(CameraFrameworkModuleTest, camera_framework_securecamera_moduleTest_002, TestSize.Level0)
+{
+    if (session_) {
+        session_->Release();
+    }
+    if (scanSession_) {
+        scanSession_->Release();
+    }
+    if (input_) {
+        sptr<CameraInput> camInput = (sptr<CameraInput>&)input_;
+        camInput->Close();
+        input_->Release();
+    }
+    std::this_thread::sleep_for(std::chrono::seconds(1));
+    std::vector<sptr<CameraDevice>> cameras = manager_->GetSupportedCameras();
+
+    for (sptr<CameraDevice> camDevice : cameras) {
+        std::vector<SceneMode> modes = manager_->GetSupportedModes(camDevice);
+        ASSERT_TRUE(modes.size() != 0);
+
+        if (find(modes.begin(), modes.end(), SceneMode::SECURE) != modes.end()) {
+            sptr<CameraOutputCapability> ability = manager_->
+                GetSupportedOutputCapability(camDevice, SceneMode::SECURE);
+            ASSERT_NE(ability, nullptr);
+
+            sptr<CaptureInput> inputSecure = manager_->CreateCameraInput(camDevice);
+            ASSERT_NE(inputSecure, nullptr);
+            sptr<CameraInput> inputSecure_ = (sptr<CameraInput>&)inputSecure;
+            uint64_t secureSeqId = 0;
+            int intResult = inputSecure_->Open(true, &secureSeqId);
+            EXPECT_EQ(intResult, 0);
+            EXPECT_NE(secureSeqId, 0);
+
+            sptr<CaptureOutput> preview = CreatePreviewOutput();
+            ASSERT_NE(preview, nullptr);
+            sptr<CaptureSession> captureSession = manager_->CreateCaptureSession(SceneMode::NORMAL);
+            ASSERT_NE(captureSession, nullptr);
+
+            EXPECT_EQ(captureSession->BeginConfig(), 0);
+            EXPECT_EQ(captureSession->AddInput(inputSecure), 0);
+            EXPECT_EQ(captureSession->AddOutput(preview), 0);
+            EXPECT_EQ(captureSession->CommitConfig(), 7400102);
+            captureSession->Release();
+            inputSecure_->Close();
+            break;
+        }
+    }
+}
+
+/*
+* Feature: Framework
+* Function: Test abnormal branch that is add secure output flag twice
+* SubFunction: NA
+* FunctionPoints: NA
+* EnvConditions: NA
+* CaseDescription: Test abnormal branch that is add secure output flag twice
+*/
+HWTEST_F(CameraFrameworkModuleTest, camera_framework_securecamera_moduleTest_003, TestSize.Level0)
+{
+    if (session_) {
+        session_->Release();
+    }
+    if (scanSession_) {
+        scanSession_->Release();
+    }
+    if (input_) {
+        sptr<CameraInput> camInput = (sptr<CameraInput>&)input_;
+        camInput->Close();
+        input_->Release();
+    }
+    std::this_thread::sleep_for(std::chrono::seconds(1));
+    std::vector<sptr<CameraDevice>> cameras = manager_->GetSupportedCameras();
+
+    for (sptr<CameraDevice> camDevice : cameras) {
+        std::vector<SceneMode> modes = manager_->GetSupportedModes(camDevice);
+        ASSERT_TRUE(modes.size() != 0);
+
+        if (find(modes.begin(), modes.end(), SceneMode::SECURE) != modes.end()) {
+            sptr<CameraOutputCapability> ability = manager_->
+                GetSupportedOutputCapability(camDevice, SceneMode::SECURE);
+            ASSERT_NE(ability, nullptr);
+
+            sptr<CaptureInput> inputSecure = manager_->CreateCameraInput(camDevice);
+            ASSERT_NE(inputSecure, nullptr);
+            sptr<CameraInput> inputSecure_ = (sptr<CameraInput>&)inputSecure;
+            uint64_t secureSeqId = 0;
+            int intResult = inputSecure_->Open(true, &secureSeqId);
+            EXPECT_EQ(intResult, 0);
+            EXPECT_NE(secureSeqId, 0);
+
+            sptr<CaptureOutput> preview1 = CreatePreviewOutput();
+            ASSERT_NE(preview1, nullptr);
+            sptr<CaptureOutput> preview2 = CreatePreviewOutput();
+            ASSERT_NE(preview2, nullptr);
+            sptr<CaptureSession> captureSession = manager_->CreateCaptureSession(SceneMode::SECURE);
+            ASSERT_NE(captureSession, nullptr);
+            sptr<SecureCameraSession> secureSession = nullptr;
+            secureSession = static_cast<SecureCameraSession *> (captureSession.GetRefPtr());
+            ASSERT_NE(secureSession, nullptr);
+
+            EXPECT_EQ(secureSession->BeginConfig(), 0);
+            EXPECT_EQ(secureSession->AddInput(inputSecure), 0);
+            EXPECT_EQ(secureSession->AddOutput(preview1), 0);
+            EXPECT_EQ(secureSession->AddOutput(preview2), 0);
+            EXPECT_EQ(secureSession->AddSecureOutput(preview1), 0);
+            EXPECT_EQ(secureSession->AddSecureOutput(preview2), CAMERA_OPERATION_NOT_ALLOWED);
+            EXPECT_EQ(secureSession->CommitConfig(), 0);
+            secureSession->Release();
+            inputSecure_->Close();
+            break;
+        }
+    }
+}
+
+/*
+* Feature: Framework
+* Function: Test abnormal branch that secure output is added after commiting
+* SubFunction: NA
+* FunctionPoints: NA
+* EnvConditions: NA
+* CaseDescription: Test abnormal branch that secure output is added after commiting
+*/
+HWTEST_F(CameraFrameworkModuleTest, camera_framework_securecamera_moduleTest_004, TestSize.Level0)
+{
+    if (session_) {
+        session_->Release();
+    }
+    if (scanSession_) {
+        scanSession_->Release();
+    }
+    if (input_) {
+        sptr<CameraInput> camInput = (sptr<CameraInput>&)input_;
+        camInput->Close();
+        input_->Release();
+    }
+    std::this_thread::sleep_for(std::chrono::seconds(1));
+    std::vector<sptr<CameraDevice>> cameras = manager_->GetSupportedCameras();
+
+    for (sptr<CameraDevice> camDevice : cameras) {
+        std::vector<SceneMode> modes = manager_->GetSupportedModes(camDevice);
+        ASSERT_TRUE(modes.size() != 0);
+
+        if (find(modes.begin(), modes.end(), SceneMode::SECURE) != modes.end()) {
+            sptr<CameraOutputCapability> ability = manager_->
+                GetSupportedOutputCapability(camDevice, SceneMode::SECURE);
+            ASSERT_NE(ability, nullptr);
+
+            sptr<CaptureInput> inputSecure = manager_->CreateCameraInput(camDevice);
+            ASSERT_NE(inputSecure, nullptr);
+            sptr<CameraInput> inputSecure_ = (sptr<CameraInput>&)inputSecure;
+            uint64_t secureSeqId = 0;
+            int intResult = inputSecure_->Open(true, &secureSeqId);
+            EXPECT_EQ(intResult, 0);
+            EXPECT_NE(secureSeqId, 0);
+
+            sptr<CaptureOutput> preview = CreatePreviewOutput();
+            ASSERT_NE(preview, nullptr);
+            sptr<CaptureSession> captureSession = manager_->CreateCaptureSession(SceneMode::SECURE);
+            ASSERT_NE(captureSession, nullptr);
+            sptr<SecureCameraSession> secureSession = nullptr;
+            secureSession = static_cast<SecureCameraSession *> (captureSession.GetRefPtr());
+            ASSERT_NE(secureSession, nullptr);
+
+            EXPECT_EQ(secureSession->BeginConfig(), 0);
+            EXPECT_EQ(secureSession->AddInput(inputSecure), 0);
+            EXPECT_EQ(secureSession->AddOutput(preview), 0);
+            EXPECT_EQ(secureSession->CommitConfig(), 0);
+            EXPECT_EQ(secureSession->AddSecureOutput(preview), CAMERA_OPERATION_NOT_ALLOWED);
+            secureSession->Release();
+            inputSecure_->Close();
+            break;
+        }
+    }
+}
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/frameworks/native/camera/test/unittest/src/v1_1/camera_framework_unittest.cpp b/frameworks/native/camera/test/unittest/src/v1_1/camera_framework_unittest.cpp
index cb8e8ea2..9c20a96d 100755
--- a/frameworks/native/camera/test/unittest/src/v1_1/camera_framework_unittest.cpp
+++ b/frameworks/native/camera/test/unittest/src/v1_1/camera_framework_unittest.cpp
@@ -29,6 +29,7 @@
 #include "nativetoken_kit.h"
 #include "night_session.h"
 #include "scan_session.h"
+#include "secure_camera_session.h"
 #include "surface.h"
 #include "test_common.h"
 #include "token_setproc.h"
@@ -7146,5 +7147,430 @@ HWTEST_F(CameraFrameworkUnitTest, camera_fwcoverage_unittest_112, TestSize.Level
 
     input->Close();
 }
+
+/*
+* Feature: Framework
+* Function: Test normal branch that is support secure camera for open camera
+* SubFunction: NA
+* FunctionPoints: NA
+* EnvConditions: NA
+* CaseDescription: Test normal branch for open camera
+*/
+HWTEST_F(CameraFrameworkUnitTest, camera_opencamera_unittest_001, TestSize.Level0)
+{
+    InSequence s;
+    std::vector<sptr<CameraDevice>> cameras = cameraManager->GetSupportedCameras();
+
+    for (sptr<CameraDevice> camDevice : cameras) {
+        std::vector<SceneMode> modes = cameraManager->GetSupportedModes(camDevice);
+        ASSERT_TRUE(modes.size() != 0);
+
+        if (find(modes.begin(), modes.end(), SceneMode::SECURE) != modes.end()) {
+            sptr<CaptureInput> input = cameraManager->CreateCameraInput(camDevice);
+            ASSERT_NE(input, nullptr);
+            EXPECT_CALL(*mockCameraHostManager, OpenCameraDevice(_, _, _, _));
+            EXPECT_CALL(*mockCameraDevice, SetResultMode(ON_CHANGED));
+            sptr<CameraInput> camInput = (sptr<CameraInput> &)input;
+            std::string cameraSettings = camInput->GetCameraSettings();
+            camInput->SetCameraSettings(cameraSettings);
+
+            uint64_t secureSeqId = 0;
+            sptr<ICameraDeviceService> deviceObj = camInput->GetCameraDevice();
+            ASSERT_NE(deviceObj, nullptr);
+
+            int intResult = camInput->Open(true, &secureSeqId);
+            EXPECT_EQ(intResult, 0);
+            EXPECT_NE(secureSeqId, 0);
+            input->Close();
+            break;
+        }
+    }
+}
+
+/*
+* Feature: Framework
+* Function: Test anomalous branch that is not support secure camera for open camera
+* SubFunction: NA
+* FunctionPoints: NA
+* EnvConditions: NA
+* CaseDescription: Test anomalous branch for open camera
+*/
+HWTEST_F(CameraFrameworkUnitTest, camera_opencamera_unittest_002, TestSize.Level0)
+{
+    InSequence s;
+    std::vector<sptr<CameraDevice>> cameras = cameraManager->GetSupportedCameras();
+
+    for (sptr<CameraDevice> camDevice : cameras) {
+        std::vector<SceneMode> modes = cameraManager->GetSupportedModes(camDevice);
+        ASSERT_TRUE(modes.size() != 0);
+
+        if (find(modes.begin(), modes.end(), SceneMode::SECURE) == modes.end()) {
+            sptr<CaptureInput> input = cameraManager->CreateCameraInput(camDevice);
+            ASSERT_NE(input, nullptr);
+            EXPECT_CALL(*mockCameraHostManager, OpenCameraDevice(_, _, _, _));
+            EXPECT_CALL(*mockCameraDevice, SetResultMode(ON_CHANGED));
+            sptr<CameraInput> camInput = (sptr<CameraInput> &)input;
+            std::string cameraSettings = camInput->GetCameraSettings();
+            camInput->SetCameraSettings(cameraSettings);
+
+            uint64_t secureSeqId = 0;
+            sptr<ICameraDeviceService> deviceObj = camInput->GetCameraDevice();
+            ASSERT_NE(deviceObj, nullptr);
+
+            int intResult = camInput->Open(true, &secureSeqId);
+            EXPECT_EQ(intResult, 0);
+            EXPECT_EQ(secureSeqId, 0);
+            input->Close();
+            break;
+        }
+    }
+}
+
+/*
+* Feature: Framework
+* Function: Test anomalous branch when open secure camera that seq is null
+* SubFunction: NA
+* FunctionPoints: NA
+* EnvConditions: NA
+* CaseDescription: Test anomalous branch for open camera
+*/
+HWTEST_F(CameraFrameworkUnitTest, camera_opencamera_unittest_003, TestSize.Level0)
+{
+    InSequence s;
+    std::vector<sptr<CameraDevice>> cameras = cameraManager->GetSupportedCameras();
+
+    for (sptr<CameraDevice> camDevice : cameras) {
+        std::vector<SceneMode> modes = cameraManager->GetSupportedModes(camDevice);
+        ASSERT_TRUE(modes.size() != 0);
+
+        if (find(modes.begin(), modes.end(), SceneMode::SECURE) != modes.end()) {
+            sptr<CaptureInput> input = cameraManager->CreateCameraInput(camDevice);
+            ASSERT_NE(input, nullptr);
+            EXPECT_CALL(*mockCameraHostManager, OpenCameraDevice(_, _, _, _));
+            EXPECT_CALL(*mockCameraDevice, SetResultMode(ON_CHANGED));
+            sptr<CameraInput> camInput = (sptr<CameraInput> &)input;
+            std::string cameraSettings = camInput->GetCameraSettings();
+            camInput->SetCameraSettings(cameraSettings);
+
+            sptr<ICameraDeviceService> deviceObj = camInput->GetCameraDevice();
+            ASSERT_NE(deviceObj, nullptr);
+
+            uint64_t* secureSeqId = nullptr;
+            int intResult = camInput->Open(true, secureSeqId);
+            EXPECT_EQ(intResult, CAMERA_INVALID_ARG);
+            input->Close();
+            break;
+        }
+    }
+}
+
+/*
+* Feature: Framework
+* Function: Test normal branch that is open non-secure camera
+* SubFunction: NA
+* FunctionPoints: NA
+* EnvConditions: NA
+* CaseDescription: Test normal branch that is open non-secure camera
+*/
+HWTEST_F(CameraFrameworkUnitTest, camera_opencamera_unittest_004, TestSize.Level0)
+{
+    InSequence s;
+    std::vector<sptr<CameraDevice>> cameras = cameraManager->GetSupportedCameras();
+
+    for (sptr<CameraDevice> camDevice : cameras) {
+        std::vector<SceneMode> modes = cameraManager->GetSupportedModes(camDevice);
+        ASSERT_TRUE(modes.size() != 0);
+
+        if (find(modes.begin(), modes.end(), SceneMode::SECURE) == modes.end()) {
+            sptr<CaptureInput> input = cameraManager->CreateCameraInput(camDevice);
+            ASSERT_NE(input, nullptr);
+            EXPECT_CALL(*mockCameraHostManager, OpenCameraDevice(_, _, _, _));
+            EXPECT_CALL(*mockCameraDevice, SetResultMode(ON_CHANGED));
+            sptr<CameraInput> camInput = (sptr<CameraInput> &)input;
+            std::string cameraSettings = camInput->GetCameraSettings();
+            camInput->SetCameraSettings(cameraSettings);
+
+            sptr<ICameraDeviceService> deviceObj = camInput->GetCameraDevice();
+            ASSERT_NE(deviceObj, nullptr);
+
+            uint64_t secureSeqId = 0;
+            int intResult = camInput->Open(false, &secureSeqId);
+            EXPECT_EQ(intResult, CAMERA_OK);
+            EXPECT_EQ(secureSeqId, 0);
+            input->Close();
+            break;
+        }
+    }
+}
+
+/*
+* Feature: Framework
+* Function: Test normal branch that is add secure output flag
+* SubFunction: NA
+* FunctionPoints: NA
+* EnvConditions: NA
+* CaseDescription: Test normal branch that is add secure output flag
+*/
+HWTEST_F(CameraFrameworkUnitTest, camera_securecamera_unittest_001, TestSize.Level0)
+{
+    InSequence s;
+    std::vector<sptr<CameraDevice>> cameras = cameraManager->GetSupportedCameras();
+
+    for (sptr<CameraDevice> camDevice : cameras) {
+        std::vector<SceneMode> modes = cameraManager->GetSupportedModes(camDevice);
+        ASSERT_TRUE(modes.size() != 0);
+
+        if (find(modes.begin(), modes.end(), SceneMode::SECURE) != modes.end()) {
+            sptr<CameraOutputCapability> ability = cameraManager->
+                GetSupportedOutputCapability(camDevice, SceneMode::SECURE);
+            ASSERT_NE(ability, nullptr);
+            sptr<CaptureInput> input = cameraManager->CreateCameraInput(camDevice);
+            ASSERT_NE(input, nullptr);
+            EXPECT_CALL(*mockCameraHostManager, OpenCameraDevice(_, _, _, _));
+            EXPECT_CALL(*mockCameraDevice, SetResultMode(ON_CHANGED));
+            sptr<CameraInput> camInput = (sptr<CameraInput> &)input;
+            std::string cameraSettings = camInput->GetCameraSettings();
+            camInput->SetCameraSettings(cameraSettings);
+            uint64_t secureSeqId = 0;
+            int intResult = camInput->Open(true, &secureSeqId);
+            EXPECT_EQ(intResult, CAMERA_OK);
+            EXPECT_NE(secureSeqId, 0);
+
+            sptr<CaptureOutput> preview = CreatePreviewOutput();
+            ASSERT_NE(preview, nullptr);
+            sptr<CaptureSession> captureSession = cameraManager->CreateCaptureSession(SceneMode::SECURE);
+            ASSERT_NE(captureSession, nullptr);
+            sptr<SecureCameraSession> secureSession = nullptr;
+            secureSession = static_cast<SecureCameraSession *> (captureSession.GetRefPtr());
+            ASSERT_NE(secureSession, nullptr);
+
+            EXPECT_EQ(secureSession->BeginConfig(), 0);
+            EXPECT_EQ(secureSession->AddInput(input), 0);
+            EXPECT_EQ(secureSession->AddOutput(preview), 0);
+            EXPECT_EQ(secureSession->AddSecureOutput(preview), 0);
+            EXPECT_EQ(secureSession->CommitConfig(), 0);
+            secureSession->Release();
+            input->Close();
+            break;
+        }
+    }
+}
+
+/*
+* Feature: Framework
+* Function: Test normal branch that is add secure output flag
+* SubFunction: NA
+* FunctionPoints: NA
+* EnvConditions: NA
+* CaseDescription: Test normal branch that is add secure output flag
+*/
+HWTEST_F(CameraFrameworkUnitTest, camera_securecamera_unittest_002, TestSize.Level0)
+{
+    InSequence s;
+    std::vector<sptr<CameraDevice>> cameras = cameraManager->GetSupportedCameras();
+
+    for (sptr<CameraDevice> camDevice : cameras) {
+        std::vector<SceneMode> modes = cameraManager->GetSupportedModes(camDevice);
+        ASSERT_TRUE(modes.size() != 0);
+
+        if (find(modes.begin(), modes.end(), SceneMode::SECURE) != modes.end()) {
+            sptr<CameraOutputCapability> ability = cameraManager->
+                GetSupportedOutputCapability(camDevice, SceneMode::SECURE);
+            ASSERT_NE(ability, nullptr);
+            sptr<CaptureInput> input = cameraManager->CreateCameraInput(camDevice);
+            ASSERT_NE(input, nullptr);
+            EXPECT_CALL(*mockCameraHostManager, OpenCameraDevice(_, _, _, _));
+            EXPECT_CALL(*mockCameraDevice, SetResultMode(ON_CHANGED));
+            sptr<CameraInput> camInput = (sptr<CameraInput> &)input;
+            std::string cameraSettings = camInput->GetCameraSettings();
+            camInput->SetCameraSettings(cameraSettings);
+            uint64_t secureSeqId = 0;
+            int intResult = camInput->Open(false, &secureSeqId);
+            EXPECT_EQ(intResult, CAMERA_OK);
+            EXPECT_NE(secureSeqId, 0);
+            sptr<CaptureOutput> preview = CreatePreviewOutput();
+            ASSERT_NE(preview, nullptr);
+            sptr<CaptureSession> captureSession = cameraManager->CreateCaptureSession(SceneMode::SECURE);
+            ASSERT_NE(captureSession, nullptr);
+            sptr<SecureCameraSession> secureSession = nullptr;
+            secureSession = static_cast<SecureCameraSession *> (captureSession.GetRefPtr());
+            ASSERT_NE(secureSession, nullptr);
+
+            EXPECT_EQ(secureSession->BeginConfig(), 0);
+            EXPECT_EQ(secureSession->AddInput(input), 0);
+            EXPECT_EQ(secureSession->AddOutput(preview), 0);
+            EXPECT_EQ(secureSession->AddSecureOutput(preview), 0);
+            EXPECT_EQ(secureSession->CommitConfig(), 0);
+            secureSession->Release();
+            input->Close();
+            break;
+        }
+    }
+}
+
+/*
+* Feature: Framework
+* Function: Test abnormal branch that is add secure output flag twice
+* SubFunction: NA
+* FunctionPoints: NA
+* EnvConditions: NA
+* CaseDescription: Test abnormal branch that is add secure output flag twice
+*/
+HWTEST_F(CameraFrameworkUnitTest, camera_securecamera_unittest_003, TestSize.Level0)
+{
+    InSequence s;
+    std::vector<sptr<CameraDevice>> cameras = cameraManager->GetSupportedCameras();
+
+    for (sptr<CameraDevice> camDevice : cameras) {
+        std::vector<SceneMode> modes = cameraManager->GetSupportedModes(camDevice);
+        ASSERT_TRUE(modes.size() != 0);
+
+        if (find(modes.begin(), modes.end(), SceneMode::SECURE) != modes.end()) {
+            sptr<CameraOutputCapability> ability = cameraManager->
+                GetSupportedOutputCapability(camDevice, SceneMode::SECURE);
+            ASSERT_NE(ability, nullptr);
+            sptr<CaptureInput> input = cameraManager->CreateCameraInput(camDevice);
+            ASSERT_NE(input, nullptr);
+            EXPECT_CALL(*mockCameraHostManager, OpenCameraDevice(_, _, _, _));
+            EXPECT_CALL(*mockCameraDevice, SetResultMode(ON_CHANGED));
+            sptr<CameraInput> camInput = (sptr<CameraInput> &)input;
+            std::string cameraSettings = camInput->GetCameraSettings();
+            camInput->SetCameraSettings(cameraSettings);
+            uint64_t secureSeqId = 0;
+            int intResult = camInput->Open(false, &secureSeqId);
+            EXPECT_EQ(intResult, CAMERA_OK);
+            EXPECT_NE(secureSeqId, 0);
+
+            sptr<CaptureOutput> preview1 = CreatePreviewOutput();
+            ASSERT_NE(preview1, nullptr);
+            sptr<CaptureOutput> preview2 = CreatePreviewOutput();
+            ASSERT_NE(preview2, nullptr);
+            sptr<CaptureSession> captureSession = cameraManager->CreateCaptureSession(SceneMode::SECURE);
+            ASSERT_NE(captureSession, nullptr);
+            sptr<SecureCameraSession> secureSession = nullptr;
+            secureSession = static_cast<SecureCameraSession *> (captureSession.GetRefPtr());
+            ASSERT_NE(secureSession, nullptr);
+
+            EXPECT_EQ(secureSession->BeginConfig(), 0);
+            EXPECT_EQ(secureSession->AddInput(input), 0);
+            EXPECT_EQ(secureSession->AddOutput(preview1), 0);
+            EXPECT_EQ(secureSession->AddOutput(preview2), 0);
+            EXPECT_EQ(secureSession->AddSecureOutput(preview1), 0);
+            EXPECT_EQ(secureSession->AddSecureOutput(preview2), OPERATION_NOT_ALLOWED);
+            EXPECT_EQ(secureSession->CommitConfig(), 0);
+            secureSession->Release();
+            input->Close();
+            break;
+        }
+    }
+}
+
+/*
+* Feature: Framework
+* Function: Test abnormal branch that is add secure output flag twice
+* SubFunction: NA
+* FunctionPoints: NA
+* EnvConditions: NA
+* CaseDescription: Test abnormal branch that is add secure output flag twice
+*/
+HWTEST_F(CameraFrameworkUnitTest, camera_securecamera_unittest_004, TestSize.Level0)
+{
+    InSequence s;
+    std::vector<sptr<CameraDevice>> cameras = cameraManager->GetSupportedCameras();
+
+    for (sptr<CameraDevice> camDevice : cameras) {
+        std::vector<SceneMode> modes = cameraManager->GetSupportedModes(camDevice);
+        ASSERT_TRUE(modes.size() != 0);
+
+        if (find(modes.begin(), modes.end(), SceneMode::SECURE) != modes.end()) {
+            sptr<CameraOutputCapability> ability = cameraManager->
+                GetSupportedOutputCapability(camDevice, SceneMode::SECURE);
+            ASSERT_NE(ability, nullptr);
+            sptr<CaptureInput> input = cameraManager->CreateCameraInput(camDevice);
+            ASSERT_NE(input, nullptr);
+            EXPECT_CALL(*mockCameraHostManager, OpenCameraDevice(_, _, _, _));
+            EXPECT_CALL(*mockCameraDevice, SetResultMode(ON_CHANGED));
+            sptr<CameraInput> camInput = (sptr<CameraInput> &)input;
+            std::string cameraSettings = camInput->GetCameraSettings();
+            camInput->SetCameraSettings(cameraSettings);
+            uint64_t secureSeqId = 0;
+            int intResult = camInput->Open(false, &secureSeqId);
+            EXPECT_EQ(intResult, CAMERA_OK);
+            EXPECT_NE(secureSeqId, 0);
+            sptr<CaptureOutput> preview1 = CreatePreviewOutput();
+            ASSERT_NE(preview1, nullptr);
+            sptr<CaptureOutput> preview2 = CreatePreviewOutput();
+            ASSERT_NE(preview2, nullptr);
+            sptr<CaptureSession> captureSession = cameraManager->CreateCaptureSession(SceneMode::SECURE);
+            ASSERT_NE(captureSession, nullptr);
+            sptr<SecureCameraSession> secureSession = nullptr;
+            secureSession = static_cast<SecureCameraSession *> (captureSession.GetRefPtr());
+            ASSERT_NE(secureSession, nullptr);
+
+            EXPECT_EQ(secureSession->BeginConfig(), 0);
+            EXPECT_EQ(secureSession->AddInput(input), 0);
+            EXPECT_EQ(secureSession->AddOutput(preview1), 0);
+            EXPECT_EQ(secureSession->AddOutput(preview2), 0);
+            EXPECT_EQ(secureSession->AddSecureOutput(preview1), 0);
+            EXPECT_EQ(secureSession->AddSecureOutput(preview2), OPERATION_NOT_ALLOWED);
+            EXPECT_EQ(secureSession->CommitConfig(), 0);
+            secureSession->Release();
+            input->Close();
+            break;
+        }
+    }
+}
+
+/*
+* Feature: Framework
+* Function: Test abnormal branch that secure output is added after commiting
+* SubFunction: NA
+* FunctionPoints: NA
+* EnvConditions: NA
+* CaseDescription: Test abnormal branch that secure output is added after commiting
+*/
+HWTEST_F(CameraFrameworkUnitTest, camera_securecamera_unittest_005, TestSize.Level0)
+{
+    InSequence s;
+    std::vector<sptr<CameraDevice>> cameras = cameraManager->GetSupportedCameras();
+
+    for (sptr<CameraDevice> camDevice : cameras) {
+        std::vector<SceneMode> modes = cameraManager->GetSupportedModes(camDevice);
+        ASSERT_TRUE(modes.size() != 0);
+
+        if (find(modes.begin(), modes.end(), SceneMode::SECURE) != modes.end()) {
+            sptr<CameraOutputCapability> ability = cameraManager->
+                GetSupportedOutputCapability(camDevice, SceneMode::SECURE);
+            ASSERT_NE(ability, nullptr);
+            sptr<CaptureInput> input = cameraManager->CreateCameraInput(camDevice);
+            ASSERT_NE(input, nullptr);
+            EXPECT_CALL(*mockCameraHostManager, OpenCameraDevice(_, _, _, _));
+            EXPECT_CALL(*mockCameraDevice, SetResultMode(ON_CHANGED));
+            sptr<CameraInput> camInput = (sptr<CameraInput> &)input;
+            std::string cameraSettings = camInput->GetCameraSettings();
+            camInput->SetCameraSettings(cameraSettings);
+            uint64_t secureSeqId = 0;
+            int intResult = camInput->Open(false, &secureSeqId);
+            EXPECT_EQ(intResult, CAMERA_OK);
+            EXPECT_NE(secureSeqId, 0);
+            sptr<CaptureOutput> preview = CreatePreviewOutput();
+            ASSERT_NE(preview, nullptr);
+            sptr<CaptureSession> captureSession = cameraManager->CreateCaptureSession(SceneMode::SECURE);
+            ASSERT_NE(captureSession, nullptr);
+            sptr<SecureCameraSession> secureSession = nullptr;
+            secureSession = static_cast<SecureCameraSession *> (captureSession.GetRefPtr());
+            ASSERT_NE(secureSession, nullptr);
+
+            EXPECT_EQ(secureSession->BeginConfig(), 0);
+            EXPECT_EQ(secureSession->AddInput(input), 0);
+            EXPECT_EQ(secureSession->AddOutput(preview), 0);
+            EXPECT_EQ(secureSession->CommitConfig(), 0);
+            EXPECT_EQ(secureSession->AddSecureOutput(preview), OPERATION_NOT_ALLOWED);
+            secureSession->Release();
+            input->Close();
+            break;
+        }
+    }
+}
 } // CameraStandard
 } // OHOS
diff --git a/frameworks/native/camera/test/unittest/src/v1_1/camera_ndk_unittest.cpp b/frameworks/native/camera/test/unittest/src/v1_1/camera_ndk_unittest.cpp
index 374059f4..4c281426 100644
--- a/frameworks/native/camera/test/unittest/src/v1_1/camera_ndk_unittest.cpp
+++ b/frameworks/native/camera/test/unittest/src/v1_1/camera_ndk_unittest.cpp
@@ -2699,5 +2699,176 @@ HWTEST_F(CameraNdkUnitTest, camera_fwcoveragendk_unittest_013, TestSize.Level0)
     EXPECT_EQ(OH_CameraInput_Release(cameraInput), 0);
     ReleaseImageReceiver();
 }
+
+/*
+ * Feature: Framework
+ * Function: Test securecmaera normal branch
+ * SubFunction: NA
+ * FunctionPoints: NA
+ * EnvConditions: NA
+ * CaseDescription: Test securecmaera normal branch
+ */
+HWTEST_F(CameraNdkUnitTest, camera_frameworkndk_unittest_067, TestSize.Level0)
+{
+    Camera_CaptureSession* captureSession = nullptr;
+    Camera_ErrorCode ret = OH_CameraManager_CreateCaptureSession(cameraManager, &captureSession);
+    EXPECT_EQ(ret, CAMERA_OK);
+    EXPECT_NE(captureSession, nullptr);
+
+    Camera_Input *cameraInput = nullptr;
+    Camera_Position cameraPosition = Camera_Position::CAMERA_POSITION_FRONT;
+    Camera_Type cameraType = Camera_Type::CAMERA_TYPE_DEFAULT;
+    ret = OH_CameraManager_CreateCameraInput_WithPositionAndType(cameraManager,
+                                                                 cameraPosition, cameraType, &cameraInput);
+    EXPECT_EQ(ret, CAMERA_OK);
+    EXPECT_NE(&cameraInput, nullptr);
+
+    uint64_t seqId = 0;
+    ret = OH_CameraInput_OpenSecureCamera(cameraInput, &seqId);
+    EXPECT_EQ(ret, CAMERA_OK);
+    EXPECT_NE(seqId, 0);
+
+    ret = OH_CaptureSession_BeginConfig(captureSession);
+    EXPECT_EQ(ret, 0);
+    ret = OH_CaptureSession_AddInput(captureSession, cameraInput);
+    EXPECT_EQ(ret, 0);
+
+    ret = OH_CaptureSession_SetSessionMode(captureSession, static_cast<Camera_SceneMode>(15));
+    EXPECT_EQ(ret, 0);
+
+    Camera_PreviewOutput* previewOutput = CreatePreviewOutput();
+    EXPECT_NE(previewOutput, nullptr);
+    Camera_PreviewOutput* previewOutput2 = CreatePreviewOutput();
+    EXPECT_NE(previewOutput, nullptr);
+
+    ret = OH_CaptureSession_AddPreviewOutput(captureSession, previewOutput);
+    EXPECT_EQ(ret, 0);
+    ret = OH_CaptureSession_AddPreviewOutput(captureSession, previewOutput2);
+    EXPECT_EQ(ret, 0);
+    ret = OH_CaptureSession_AddSecureOutput(captureSession, previewOutput2);
+    EXPECT_EQ(ret, 0);
+
+    ret = OH_CaptureSession_CommitConfig(captureSession);
+    EXPECT_EQ(ret, 0);
+
+    ret = OH_PreviewOutput_Release(previewOutput);
+    EXPECT_EQ(ret, 0);
+    ret = OH_PreviewOutput_Release(previewOutput2);
+    EXPECT_EQ(ret, 0);
+    ret = OH_CameraInput_Release(cameraInput);
+    EXPECT_EQ(ret, 0);
+    ret = OH_CaptureSession_Release(captureSession);
+    EXPECT_EQ(ret, 0);
+}
+
+/*
+ * Feature: Framework
+ * Function: Test securecmaera open normal camera for secure mode
+ * SubFunction: NA
+ * FunctionPoints: NA
+ * EnvConditions: NA
+ * CaseDescription: Test securecmaera open secure camera
+ */
+HWTEST_F(CameraNdkUnitTest, camera_frameworkndk_unittest_068, TestSize.Level0)
+{
+    Camera_CaptureSession* captureSession = nullptr;
+    Camera_ErrorCode ret = OH_CameraManager_CreateCaptureSession(cameraManager, &captureSession);
+    EXPECT_EQ(ret, CAMERA_OK);
+    EXPECT_NE(captureSession, nullptr);
+
+    Camera_Input *cameraInput = nullptr;
+    Camera_Position cameraPosition = Camera_Position::CAMERA_POSITION_FRONT;
+    Camera_Type cameraType = Camera_Type::CAMERA_TYPE_DEFAULT;
+    ret = OH_CameraManager_CreateCameraInput_WithPositionAndType(cameraManager,
+                                                                 cameraPosition, cameraType, &cameraInput);
+
+    ret = OH_CameraInput_Open(cameraInput);
+    EXPECT_EQ(ret, CAMERA_OK);
+
+    ret = OH_CaptureSession_BeginConfig(captureSession);
+    EXPECT_EQ(ret, 0);
+    ret = OH_CaptureSession_AddInput(captureSession, cameraInput);
+    EXPECT_EQ(ret, 0);
+
+    ret = OH_CaptureSession_SetSessionMode(captureSession, static_cast<Camera_SceneMode>(15));
+    EXPECT_EQ(ret, 0);
+
+    Camera_PreviewOutput* previewOutput = CreatePreviewOutput();
+    EXPECT_NE(previewOutput, nullptr);
+
+    ret = OH_CaptureSession_AddPreviewOutput(captureSession, previewOutput);
+    EXPECT_EQ(ret, 0);
+
+    ret = OH_CaptureSession_CommitConfig(captureSession);
+    EXPECT_NE(ret, 0);
+
+    ret = OH_PreviewOutput_Release(previewOutput);
+    EXPECT_EQ(ret, 0);
+    ret = OH_CameraInput_Release(cameraInput);
+    EXPECT_EQ(ret, 0);
+    ret = OH_CaptureSession_Release(captureSession);
+    EXPECT_EQ(ret, 0);
+}
+
+/*
+ * Feature: Framework
+ * Function: Test securecmaera abnormal branch that add twice securepreviewout
+ * SubFunction: NA
+ * FunctionPoints: NA
+ * EnvConditions: NA
+ * CaseDescription: Test securecmaera abnormal branch that add twice securepreviewout
+ */
+HWTEST_F(CameraNdkUnitTest, camera_frameworkndk_unittest_069, TestSize.Level0)
+{
+    Camera_CaptureSession* captureSession = nullptr;
+    Camera_ErrorCode ret = OH_CameraManager_CreateCaptureSession(cameraManager, &captureSession);
+    EXPECT_EQ(ret, CAMERA_OK);
+    EXPECT_NE(captureSession, nullptr);
+
+    Camera_Input *cameraInput = nullptr;
+    Camera_Position cameraPosition = Camera_Position::CAMERA_POSITION_FRONT;
+    Camera_Type cameraType = Camera_Type::CAMERA_TYPE_DEFAULT;
+    ret = OH_CameraManager_CreateCameraInput_WithPositionAndType(cameraManager,
+                                                                 cameraPosition, cameraType, &cameraInput);
+
+    uint64_t seqId = 0;
+    ret = OH_CameraInput_OpenSecureCamera(cameraInput, &seqId);
+    EXPECT_EQ(ret, CAMERA_OK);
+    EXPECT_NE(seqId, 0);
+
+    ret = OH_CaptureSession_BeginConfig(captureSession);
+    EXPECT_EQ(ret, 0);
+    ret = OH_CaptureSession_AddInput(captureSession, cameraInput);
+    EXPECT_EQ(ret, 0);
+
+    ret = OH_CaptureSession_SetSessionMode(captureSession, static_cast<Camera_SceneMode>(15));
+    EXPECT_EQ(ret, 0);
+
+    Camera_PreviewOutput* previewOutput = CreatePreviewOutput();
+    EXPECT_NE(previewOutput, nullptr);
+    Camera_PreviewOutput* previewOutput2 = CreatePreviewOutput();
+    EXPECT_NE(previewOutput, nullptr);
+
+    ret = OH_CaptureSession_AddPreviewOutput(captureSession, previewOutput);
+    EXPECT_EQ(ret, 0);
+    ret = OH_CaptureSession_AddPreviewOutput(captureSession, previewOutput2);
+    EXPECT_EQ(ret, 0);
+    ret = OH_CaptureSession_AddSecureOutput(captureSession, previewOutput2);
+    EXPECT_EQ(ret, 0);
+    ret = OH_CaptureSession_AddSecureOutput(captureSession, previewOutput);
+    EXPECT_NE(ret, 0);
+
+    ret = OH_CaptureSession_CommitConfig(captureSession);
+    EXPECT_EQ(ret, 0);
+
+    ret = OH_PreviewOutput_Release(previewOutput);
+    EXPECT_EQ(ret, 0);
+    ret = OH_PreviewOutput_Release(previewOutput2);
+    EXPECT_EQ(ret, 0);
+    ret = OH_CameraInput_Release(cameraInput);
+    EXPECT_EQ(ret, 0);
+    ret = OH_CaptureSession_Release(captureSession);
+    EXPECT_EQ(ret, 0);
+}
 } // CameraStandard
 } // OHOS
\ No newline at end of file
diff --git a/interfaces/inner_api/native/camera/include/session/secure_camera_session.h b/interfaces/inner_api/native/camera/include/session/secure_camera_session.h
index f9f656ec..d1777082 100755
--- a/interfaces/inner_api/native/camera/include/session/secure_camera_session.h
+++ b/interfaces/inner_api/native/camera/include/session/secure_camera_session.h
@@ -33,6 +33,8 @@ public:
      * @param CaptureOutput to be added to session.
      */
     int32_t AddSecureOutput(sptr<CaptureOutput>& output);
+private:
+    volatile bool isSetSecureOutput_ = false;
 };
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/services/camera_service/src/hcapture_session.cpp b/services/camera_service/src/hcapture_session.cpp
index 436f20af..9f58f992 100755
--- a/services/camera_service/src/hcapture_session.cpp
+++ b/services/camera_service/src/hcapture_session.cpp
@@ -764,7 +764,7 @@ int32_t HCaptureSession::CommitConfig()
         device ->GetSecureCameraSeq(&secureSeqId);
         if (((GetopMode() == secureMode) ^ (secureSeqId != 0))) {
             MEDIA_ERR_LOG("secureCamera is not allowed commit mode = %{public}d.", GetopMode());
-            errorCode = CAMERA_INVALID_ARG;
+            errorCode = CAMERA_OPERATION_NOT_ALLOWED;
             return;
         }
 
-- 
2.40.1.huawei.3

