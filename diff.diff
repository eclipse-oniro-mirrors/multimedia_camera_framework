diff --git a/frameworks/native/camera/src/input/camera_manager.cpp b/frameworks/native/camera/src/input/camera_manager.cpp
index 0f9977ef6..43545ae99 100644
--- a/frameworks/native/camera/src/input/camera_manager.cpp
+++ b/frameworks/native/camera/src/input/camera_manager.cpp
@@ -30,6 +30,7 @@
 
 #include "ability/camera_ability_parse_util.h"
 #include "aperture_video_session.h"
+#include "bundle_mgr_interface.h"
 #include "camera_device_ability_items.h"
 #include "camera_error_code.h"
 #include "camera_log.h"
@@ -836,9 +837,30 @@ void CameraManager::InitCameraManager()
     foldScreenType_ = system::GetParameter("const.window.foldscreen.type", "");
     isSystemApp_ = CameraSecurity::CheckSystemApp();
     CheckWhiteList();
+    bundleName_ = system::GetParameter("const.camera.folded_lens_change", "default");
+    curBundleName_ = GetBundleName();
     MEDIA_DEBUG_LOG("IsSystemApp = %{public}d", isSystemApp_);
 }
 
+std::string CameraManager::GetBundleName()
+{
+    auto bundleName = "";
+    OHOS::sptr<OHOS::ISystemAbilityManager> samgr =
+            OHOS::SystemAbilityManagerClient::GetInstance().GetSystemAbilityManager();
+    CHECK_ERROR_RETURN_RET_LOG(samgr == nullptr, bundleName, "GetClientBundle Get ability manager failed");
+    OHOS::sptr<OHOS::IRemoteObject> remoteObject =
+            samgr->GetSystemAbility(BUNDLE_MGR_SERVICE_SYS_ABILITY_ID);
+    CHECK_ERROR_RETURN_RET_LOG(remoteObject == nullptr, bundleName, "GetClientBundle object is NULL.");
+    sptr<AppExecFwk::IBundleMgr> bms = OHOS::iface_cast<AppExecFwk::IBundleMgr>(remoteObject);
+    CHECK_ERROR_RETURN_RET_LOG(bms == nullptr, bundleName, "GetClientBundle bundle manager service is NULL.");
+    AppExecFwk::BundleInfo bundleInfo;
+    auto ret = bms->GetBundleInfoForSelf(0, bundleInfo);
+    CHECK_ERROR_RETURN_RET_LOG(ret != ERR_OK, bundleName, "GetBundleInfoForSelf failed.");
+    bundleName = bundleInfo.name.c_str();
+    MEDIA_INFO_LOG("bundleName: [%{public}s]", bundleName);
+    return bundleName;
+}
+
 int32_t CameraManager::RefreshServiceProxy()
 {
     sptr<IRemoteObject> object = nullptr;
@@ -1869,6 +1891,13 @@ std::vector<sptr<CameraDevice>> CameraManager::GetSupportedCameras()
             deviceInfo->GetPosition() == CAMERA_POSITION_FOLD_INNER ||
             deviceInfo->GetPosition() == CAMERA_POSITION_FRONT) && !GetIsInWhiteList() &&
             curFoldStatus == FoldStatus::EXPAND) {
+            auto it = std::find_if(supportedCameraDeviceList.begin(), supportedCameraDeviceList.end(),
+                [&deviceInfo](sptr<CameraDevice> cameraDevice) {
+                return cameraDevice->GetPosition() == deviceInfo->GetPosition();
+            });
+            if (it != supportedCameraDeviceList.end()) {
+                continue;
+            }
             supportedCameraDeviceList.emplace_back(deviceInfo);
             continue;
         }
@@ -1892,6 +1921,11 @@ std::vector<sptr<CameraDevice>> CameraManager::GetSupportedCameras()
             supportedCameraDeviceList.emplace_back(deviceInfo);
             continue;
         }
+        if (!foldScreenType_.empty() && foldScreenType_[0] == '4' && curFoldStatus == FoldStatus::FOLDED &&
+            it->second == curFoldStatus && deviceInfo->GetPosition() == CAMERA_POSITION_BACK
+            && bundleName_ != curBundleName_) {
+            continue;
+        }
         if (it->second == curFoldStatus) {
             supportedCameraDeviceList.emplace_back(deviceInfo);
         }
diff --git a/interfaces/inner_api/native/camera/include/input/camera_manager.h b/interfaces/inner_api/native/camera/include/input/camera_manager.h
index 8bd6b6fa1..adfb53924 100644
--- a/interfaces/inner_api/native/camera/include/input/camera_manager.h
+++ b/interfaces/inner_api/native/camera/include/input/camera_manager.h
@@ -946,6 +946,7 @@ private:
     }
 
     void CheckWhiteList();
+    std::string GetBundleName();
     std::mutex cameraDeviceListMutex_;
     std::mutex innerCameraMutex_;
     std::vector<sptr<CameraDevice>> cameraDeviceList_ = {};
@@ -980,6 +981,8 @@ private:
     std::string foldScreenType_;
     bool isSystemApp_ = false;
     bool isInWhiteList_ = false;
+    std::string bundleName_ = "";
+    std::string curBundleName_ = "";
     sptr<CameraDevice> innerCamera_ = nullptr;
     FoldStatus preFoldStatus = FoldStatus::UNKNOWN_FOLD;
 };
diff --git a/services/camera_service/include/hcamera_device.h b/services/camera_service/include/hcamera_device.h
index b7d38ad51..1433a3fe6 100644
--- a/services/camera_service/include/hcamera_device.h
+++ b/services/camera_service/include/hcamera_device.h
@@ -83,6 +83,7 @@ public:
     std::shared_ptr<OHOS::Camera::CameraMetadata> CloneCachedSettings();
     std::string GetCameraId();
     int32_t GetCameraType();
+    int32_t GetCameraPosition();
     bool IsOpenedCameraDevice();
     int32_t GetCallerToken();
 
diff --git a/services/camera_service/include/hcapture_session.h b/services/camera_service/include/hcapture_session.h
index 164126958..e736102c2 100644
--- a/services/camera_service/include/hcapture_session.h
+++ b/services/camera_service/include/hcapture_session.h
@@ -217,6 +217,7 @@ private:
     void ClearMovingPhotoRepeatStream();
     int32_t SetHasFitedRotation(bool isHasFitedRotation) override;
     void InitialHStreamOperator();
+    void UpdateSettingForSpecialBundle();
     StateMachine stateMachine_;
 
 #ifdef CAMERA_USE_SENSOR
@@ -250,6 +251,7 @@ private:
     std::mutex cameraRotateStrategyInfosLock_;
     std::vector<CameraRotateStrategyInfo> cameraRotateStrategyInfos_;
     bool isHasFitedRotation_ = false;
+    std::string bundleName_ = "";
 };
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/services/camera_service/src/camera_util.cpp b/services/camera_service/src/camera_util.cpp
index 28b4356c2..554c6b3a7 100644
--- a/services/camera_service/src/camera_util.cpp
+++ b/services/camera_service/src/camera_util.cpp
@@ -521,6 +521,7 @@ std::string GetFileStream(const std::string &filepath)
         return NULL;
     }
     std::ifstream file(canonicalPath, std::ios::in | std::ios::binary);
+    free(canonicalPath);
     // 文件流的异常处理，不能用try catch的形式
     if (!file) {
         MEDIA_INFO_LOG("Failed to open the file!");
@@ -562,23 +563,23 @@ bool RemoveFile(const std::string& path)
         return false;
     }
     if (remove(canonicalPath) == 0) {
+        free(canonicalPath);
         MEDIA_INFO_LOG("File removed successfully.");
         return true;
     }
+    free(canonicalPath);
     return false;
 }
 
 bool CheckPathExist(const char *path)
 {
     char *canonicalPath = realpath(path, nullptr);
-    if (canonicalPath == nullptr) {
-        return false;
-    }
     if (canonicalPath == nullptr) {
         MEDIA_ERR_LOG("CheckPathExist path is nullptr");
         return false;
     }
     std::ifstream profileStream(canonicalPath);
+    free(canonicalPath);
     return profileStream.good();
 }
 } // namespace CameraStandard
diff --git a/services/camera_service/src/hcamera_device.cpp b/services/camera_service/src/hcamera_device.cpp
index 18a2a478d..35f357108 100644
--- a/services/camera_service/src/hcamera_device.cpp
+++ b/services/camera_service/src/hcamera_device.cpp
@@ -194,6 +194,16 @@ int32_t HCameraDevice::GetCameraType()
     return OTHER;
 }
 
+int32_t HCameraDevice::GetCameraPosition()
+{
+    camera_metadata_item_t item;
+    CHECK_ERROR_RETURN_RET_LOG(deviceAbility_ == nullptr, 0,
+        "HCameraDevice::GetCameraPosition deviceAbility_ is nullptr");
+    int ret = OHOS::Camera::FindCameraMetadataItem(deviceAbility_->get(), OHOS_ABILITY_CAMERA_POSITION, &item);
+    CHECK_ERROR_RETURN_RET_LOG(ret != CAM_META_SUCCESS, 0, "HCameraDevice::GetCameraPosition failed");
+    return static_cast<camera_position_enum_t>(item.data.u8[0]);
+}
+
 bool HCameraDevice::IsOpenedCameraDevice()
 {
     return isOpenedCameraDevice_.load();
diff --git a/services/camera_service/src/hcamera_device_manager.cpp b/services/camera_service/src/hcamera_device_manager.cpp
index e20819aef..55ba7ebbf 100644
--- a/services/camera_service/src/hcamera_device_manager.cpp
+++ b/services/camera_service/src/hcamera_device_manager.cpp
@@ -47,7 +47,7 @@ HCameraDeviceManager::HCameraDeviceManager()
 
 HCameraDeviceManager::~HCameraDeviceManager()
 {
-    HCameraDeviceManager::cameraDeviceManager_ = nullptr;
+    MEDIA_INFO_LOG("~HCameraDeviceManager");
 }
 
 sptr<HCameraDeviceManager> &HCameraDeviceManager::GetInstance()
diff --git a/services/camera_service/src/hcapture_session.cpp b/services/camera_service/src/hcapture_session.cpp
index a6b8b4490..4e40f2a09 100644
--- a/services/camera_service/src/hcapture_session.cpp
+++ b/services/camera_service/src/hcapture_session.cpp
@@ -96,6 +96,8 @@ constexpr int32_t WIDE_TELE_ZOOM_PER = 3;
 constexpr int32_t ZOOM_IN_PER = 0;
 constexpr int32_t ZOOM_OUT_PERF = 1;
 constexpr int32_t ZOOM_BEZIER_VALUE_COUNT = 5;
+constexpr int32_t SPECIAL_BUNDLE_FPS = 15;
+constexpr int32_t SPECIAL_BUNDLE_ROTATE = 0;
 static const int32_t SESSIONID_BEGIN = 1;
 static const int32_t SESSIONID_MAX = INT32_MAX - 1000;
 static std::atomic<int32_t> g_currentSessionId = SESSIONID_BEGIN;
@@ -1113,12 +1115,7 @@ int32_t HCaptureSession::Start()
         camera_position_enum_t cameraPosition = static_cast<camera_position_enum_t>(usedAsPositionU8);
         auto hStreamOperatorSptr = GetStreamOperator();
         CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr, "hStreamOperatorSptr is null");
-        if (OHOS::Rosen::DisplayManagerLite::GetInstance().GetFoldStatus() == OHOS::Rosen::FoldStatus::FOLDED &&
-            !isHasFitedRotation_) {
-            auto infos = GetCameraRotateStrategyInfos();
-            auto frameRateRange = hStreamOperatorSptr->GetFrameRateRange();
-            UpdateCameraRotateAngleAndZoom(infos, frameRateRange); // 普通设备无此参数
-        }
+        UpdateSettingForSpecialBundle();
         errorCode = hStreamOperatorSptr->StartPreviewStream(settings, cameraPosition);
         if (errorCode == CAMERA_OK) {
             isSessionStarted_ = true;
@@ -1138,6 +1135,34 @@ int32_t HCaptureSession::Start()
     return errorCode;
 }
 
+void HCaptureSession::UpdateSettingForSpecialBundle()
+{
+    OHOS::Rosen::FoldStatus foldstatus = OHOS::Rosen::DisplayManagerLite::GetInstance().GetFoldStatus();
+    auto hStreamOperatorSptr = GetStreamOperator();
+    if (hStreamOperatorSptr != nullptr && foldstatus == OHOS::Rosen::FoldStatus::FOLDED && !isHasFitedRotation_) {
+        auto infos = GetCameraRotateStrategyInfos();
+        auto frameRateRange = hStreamOperatorSptr->GetFrameRateRange();
+        UpdateCameraRotateAngleAndZoom(infos, frameRateRange); // 普通设备无此参数
+        auto cameraDevice = GetCameraDevice();
+        if (cameraDevice == nullptr) {
+            return;
+        }
+        int32_t cameraPosition = cameraDevice->GetCameraPosition();
+        if (cameraPosition == OHOS_CAMERA_POSITION_FRONT) {
+            return;
+        }
+        std::string specialBundle = system::GetParameter("const.camera.folded_lens_change", "default");
+        if (specialBundle == bundleName_ && !frameRateRange.empty() && frameRateRange[0] == SPECIAL_BUNDLE_FPS) {
+            std::shared_ptr<OHOS::Camera::CameraMetadata> settings =
+                std::make_shared<OHOS::Camera::CameraMetadata>(1, 1);
+            int32_t rotateDegree = SPECIAL_BUNDLE_ROTATE;
+            MEDIA_INFO_LOG("HCaptureSession::UpdateSettingForSpecialBundle rotateDegree: %{public}d.", rotateDegree);
+            settings->addEntry(OHOS_CONTROL_ROTATE_ANGLE, &rotateDegree, 1);
+            cameraDevice->UpdateSettingOnce(settings);
+        }
+    }
+}
+
 void HCaptureSession::UpdateMuteSetting(bool muteMode, std::shared_ptr<OHOS::Camera::CameraMetadata>& settings)
 {
     int32_t count = 1;
@@ -1466,7 +1491,8 @@ void HCaptureSession::UpdateCameraRotateAngleAndZoom(std::vector<CameraRotateStr
     std::vector<int32_t> &frameRateRange)
 {
     int uid = IPCSkeleton::GetCallingUid();
-    std::string bundleName = GetClientBundle(uid);
+    CHECK_EXECUTE(bundleName_ == "", bundleName_ = GetClientBundle(uid));
+    std::string bundleName = bundleName_;
     auto it = std::find_if(infos.begin(), infos.end(), [&bundleName](const auto &info) {
         return info.bundleName == bundleName;
     });
diff --git a/services/camera_service/src/hstream_operator_manager.cpp b/services/camera_service/src/hstream_operator_manager.cpp
index 0fdb06fa5..5fc8ea0a3 100644
--- a/services/camera_service/src/hstream_operator_manager.cpp
+++ b/services/camera_service/src/hstream_operator_manager.cpp
@@ -27,7 +27,7 @@ HStreamOperatorManager::HStreamOperatorManager() {}
 
 HStreamOperatorManager::~HStreamOperatorManager()
 {
-    HStreamOperatorManager::streamOperatorManager_ = nullptr;
+    MEDIA_INFO_LOG("~HStreamOperatorManager");
 }
 
 sptr<HStreamOperatorManager> &HStreamOperatorManager::GetInstance()
diff --git a/services/camera_service/src/param_update/camera_rotate_param_reader.cpp b/services/camera_service/src/param_update/camera_rotate_param_reader.cpp
index cd73c748c..b92532f7a 100644
--- a/services/camera_service/src/param_update/camera_rotate_param_reader.cpp
+++ b/services/camera_service/src/param_update/camera_rotate_param_reader.cpp
@@ -58,12 +58,14 @@ bool CameraRoateParamReader::VerifyCertSfFile(
         return false;
     }
     // 验证CERT.SF文件是否合法
-    if (!CameraRoateParamSignTool::VerifyFileSign(PUBKEY_PATH, certFile, verifyFile)) {
+    if (!CameraRoateParamSignTool::VerifyFileSign(PUBKEY_PATH, certFile, canonicalPath)) {
+        free(canonicalPath);
         MEDIA_ERR_LOG("signToolManager verify failed %{public}s,%{public}s, %{public}s", PUBKEY_PATH.c_str(),
-            certFile.c_str(), verifyFile.c_str());
+            certFile.c_str(), canonicalPath);
         return false;
     }
-    std::ifstream file(verifyFile);
+    std::ifstream file(canonicalPath);
+    free(canonicalPath);
     if (!file.good()) {
         MEDIA_ERR_LOG("Verify is not good,verifyFile:%{public}s", verifyFile.c_str());
         return false;
@@ -97,6 +99,7 @@ bool CameraRoateParamReader::VerifyParamFile(const std::string& cfgDirPath, cons
         return false;
     }
     std::ifstream file(canonicalPathManifest);
+    free(canonicalPathManifest);
     std::string line;
     std::string sha256Digest;
 