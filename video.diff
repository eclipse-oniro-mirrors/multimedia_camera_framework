
From 21c433c5b0d26c814d44cbaf7995bfe06b343fcf Mon Sep 17 00:00:00 2001
From: n00564676 <nimaosen1@huawei.com>
Date: Sun, 16 Feb 2025 11:12:20 +0800
Subject: [PATCH] modify videoEncoder TicketNo: DTS2025040721928 Description:
 modify videoEncoder Team:gitee Feature or Bugfix: Binary Source: sync from
 gitee PrivateCode(Yes/No):No ------ DO NOT MODIFY, AUTO-GENERATED! ------
 Gitee-Issue: #IBLMMP Time: 2025-02-11T13:44:43.160049Z PR-Num: 2801 Gitee-PR:
 https://openharmony.gitee.com/openharmony/multimedia_camera_framework/pulls/2801
 cherry picked from commit 3e2cdda97ed35feeb3ca869cce2f3f9e9c00f6a6

Change-Id: I173928147435089f099daf1e827f1e846ac3a7c7
Reviewed-by: f00880772
Approved-by: l00512942
Merged-on: https://open.codehub.huawei.com/OpenSourceCenter_CR/openharmony/multimedia_camera_framework/-/change_requests/4444
Merged-by: public hisicitools
---
 .../include/avcodec/avcodec_task_manager.h    |   2 +-
 .../include/avcodec/common/frame_record.h     |   6 +-
 .../include/avcodec/common/sample_info.h      |  91 ++++++++
 .../include/avcodec/video_encoder.h           |  23 +-
 .../src/avcodec/avcodec_task_manager.cpp      |  15 +-
 .../src/avcodec/common/frame_record.cpp       |   3 -
 .../src/avcodec/video_encoder.cpp             | 215 +++++++++---------
 .../camera_service/src/hcapture_session.cpp   |   3 +-
 8 files changed, 234 insertions(+), 124 deletions(-)

diff --git a/services/camera_service/include/avcodec/avcodec_task_manager.h b/services/camera_service/include/avcodec/avcodec_task_manager.h
index 3b5494a39..9e277d7c4 100644
--- a/services/camera_service/include/avcodec/avcodec_task_manager.h
+++ b/services/camera_service/include/avcodec/avcodec_task_manager.h
@@ -80,7 +80,7 @@ private:
     void IgnoreDeblur(vector<sptr<FrameRecord>> frameRecords, vector<sptr<FrameRecord>> &choosedBuffer,
         int64_t shutterTime);
     void Release();
-    unique_ptr<VideoEncoder> videoEncoder_ = nullptr;
+    shared_ptr<VideoEncoder> videoEncoder_ = nullptr;
     unique_ptr<AudioEncoder> audioEncoder_ = nullptr;
     shared_ptr<TaskManager> taskManager_ = nullptr;
     shared_ptr<TaskManager> videoEncoderManager_ = nullptr;
diff --git a/services/camera_service/include/avcodec/common/frame_record.h b/services/camera_service/include/avcodec/common/frame_record.h
index 93a7fbc03..b5a0338a4 100644
--- a/services/camera_service/include/avcodec/common/frame_record.h
+++ b/services/camera_service/include/avcodec/common/frame_record.h
@@ -92,12 +92,12 @@ public:
         videoBuffer_ = buffer;
     }
 
-    inline OH_AVBuffer* GetEncodeBuffer()
+    inline std::shared_ptr<Media::AVBuffer> GetEncodeBuffer()
     {
         return encodedBuffer;
     }
 
-    inline void CacheBuffer(OH_AVBuffer* buffer)
+    inline void CacheBuffer(std::shared_ptr<Media::AVBuffer> buffer)
     {
         MEDIA_DEBUG_LOG("cacheBuffer start");
         encodedBuffer = buffer;
@@ -207,7 +207,7 @@ public:
         { GRAPHIC_ROTATE_270, 90 },
     };
 
-    OH_AVBuffer* encodedBuffer = nullptr;
+    std::shared_ptr<Media::AVBuffer> encodedBuffer = nullptr;
     std::string frameId_;
     std::mutex bufferMutex_;
 
diff --git a/services/camera_service/include/avcodec/common/sample_info.h b/services/camera_service/include/avcodec/common/sample_info.h
index 6f6f4baab..fa1d2ac92 100644
--- a/services/camera_service/include/avcodec/common/sample_info.h
+++ b/services/camera_service/include/avcodec/common/sample_info.h
@@ -25,6 +25,7 @@
 #include "native_avbuffer.h"
 #include "native_audio_channel_layout.h"
 #include <refbase.h>
+#include "avcodec_common.h"
 
 namespace OHOS {
 namespace CameraStandard {
@@ -160,6 +161,96 @@ public:
     std::condition_variable outputCond_;
     std::queue<sptr<CodecAVBufferInfo>> outputBufferInfoQueue_;
 };
+
+class VideoCodecAVBufferInfo : public RefBase {
+public:
+    explicit VideoCodecAVBufferInfo(uint32_t argBufferIndex, std::shared_ptr<OHOS::Media::AVBuffer> argBuffer)
+        : bufferIndex(argBufferIndex), buffer(argBuffer)
+    {
+    }
+    ~VideoCodecAVBufferInfo() = default;
+    uint32_t bufferIndex = 0;
+    std::shared_ptr<OHOS::Media::AVBuffer> buffer = nullptr;
+
+    std::shared_ptr<OHOS::Media::AVBuffer> GetCopyAVBuffer()
+    {
+        MEDIA_INFO_LOG("CodecBufferInfo OH_AVBuffer_Create with size: %{public}d", buffer->memory_->GetSize());
+        auto allocator = Media::AVAllocatorFactory::CreateSharedAllocator(Media::MemoryFlag::MEMORY_READ_WRITE);
+        CHECK_ERROR_RETURN_RET_LOG(allocator == nullptr, nullptr, "create allocator failed");
+        std::shared_ptr<Media::AVBuffer> destBuffer = Media::AVBuffer::CreateAVBuffer(allocator,
+            buffer->memory_->GetCapacity());
+        CHECK_ERROR_RETURN_RET_LOG(destBuffer == nullptr, nullptr, "destBuffer is null");
+        auto sourceAddr = buffer->memory_->GetAddr();
+        auto destAddr = destBuffer->memory_->GetAddr();
+        errno_t cpyRet = memcpy_s(reinterpret_cast<void *>(destAddr), buffer->memory_->GetSize(),
+                                  reinterpret_cast<void *>(sourceAddr), buffer->memory_->GetSize());
+        if (cpyRet != 0) {
+            MEDIA_ERR_LOG("CodecBufferInfo memcpy_s failed. %{public}d", cpyRet);
+        }
+        destBuffer->pts_ = buffer->pts_;
+        destBuffer->flag_ = buffer->flag_;
+        destBuffer->memory_->SetSize(buffer->memory_->GetSize());
+        return destBuffer;
+    }
+
+    std::shared_ptr<OHOS::Media::AVBuffer> AddCopyAVBuffer(std::shared_ptr<OHOS::Media::AVBuffer> IDRBuffer)
+    {
+        if (IDRBuffer == nullptr) {
+            MEDIA_WARNING_LOG("AddCopyAVBuffer without IDRBuffer!");
+            return IDRBuffer;
+        }
+        int32_t destBufferSize = IDRBuffer->memory_->GetSize() + buffer->memory_->GetSize();
+        auto allocator = Media::AVAllocatorFactory::CreateSharedAllocator(Media::MemoryFlag::MEMORY_READ_WRITE);
+        CHECK_ERROR_RETURN_RET_LOG(allocator == nullptr, nullptr, "create allocator failed");
+        std::shared_ptr<Media::AVBuffer> destBuffer = Media::AVBuffer::CreateAVBuffer(allocator, destBufferSize);
+        CHECK_ERROR_RETURN_RET_LOG(destBuffer == nullptr, nullptr, "destBuffer is null");
+        auto destAddr = destBuffer->memory_->GetAddr();
+        auto sourceIDRAddr = IDRBuffer->memory_->GetAddr();
+        errno_t cpyRet = memcpy_s(reinterpret_cast<void *>(destAddr), destBufferSize,
+                                  reinterpret_cast<void *>(sourceIDRAddr), IDRBuffer->memory_->GetSize());
+        if (cpyRet != 0) {
+            MEDIA_ERR_LOG("CodecBufferInfo memcpy_s IDR frame failed. %{public}d", cpyRet);
+        }
+        destAddr = destAddr + IDRBuffer->memory_->GetSize();
+        auto sourceAddr = buffer->memory_->GetAddr();
+        cpyRet = memcpy_s(reinterpret_cast<void *>(destAddr), buffer->memory_->GetSize(),
+                          reinterpret_cast<void *>(sourceAddr), buffer->memory_->GetSize());
+        if (cpyRet != 0) {
+            MEDIA_ERR_LOG("CodecBufferInfo memcpy_s I frame failed. %{public}d", cpyRet);
+        }
+        destBuffer->memory_->SetSize(destBufferSize);
+        destBuffer->flag_ = IDRBuffer->flag_ | buffer->flag_;
+        MEDIA_INFO_LOG("CodecBufferInfo copy with size: %{public}d, %{public}d", destBufferSize, destBuffer->flag_);
+        return destBuffer;
+    }
+};
+
+class VideoCodecUserData : public RefBase {
+public:
+    VideoCodecUserData() = default;
+    ~VideoCodecUserData()
+    {
+        inputMutex_.lock();
+        while (!inputBufferInfoQueue_.empty()) {
+            inputBufferInfoQueue_.pop();
+        }
+        inputMutex_.unlock();
+        outputMutex_.lock();
+        while (!outputBufferInfoQueue_.empty()) {
+            outputBufferInfoQueue_.pop();
+        }
+        outputMutex_.unlock();
+    };
+    uint32_t inputFrameCount_ = 0;
+    std::mutex inputMutex_;
+    std::condition_variable inputCond_;
+    std::queue<sptr<VideoCodecAVBufferInfo>> inputBufferInfoQueue_;
+
+    uint32_t outputFrameCount_ = 0;
+    std::mutex outputMutex_;
+    std::condition_variable outputCond_;
+    std::queue<sptr<VideoCodecAVBufferInfo>> outputBufferInfoQueue_;
+};
 } // CameraStandard
 } // OHOS
 #endif // AVCODEC_SAMPLE_SAMPLE_INFO_H
\ No newline at end of file
diff --git a/services/camera_service/include/avcodec/video_encoder.h b/services/camera_service/include/avcodec/video_encoder.h
index e3da1a223..d67c5295d 100644
--- a/services/camera_service/include/avcodec/video_encoder.h
+++ b/services/camera_service/include/avcodec/video_encoder.h
@@ -17,15 +17,17 @@
 #define AVCODEC_SAMPLE_VIDEO_ENCODER_H
 
 #include "frame_record.h"
-#include "native_avcodec_videoencoder.h"
+#include "avcodec_video_encoder.h"
 #include "output/camera_output_capability.h"
 #include "sample_info.h"
 #include "camera_util.h"
+#include "surface_buffer.h"
 
 namespace OHOS {
 namespace CameraStandard {
 using namespace std;
-class VideoEncoder {
+using namespace OHOS::MediaAVCodec;
+class VideoEncoder : public std::enable_shared_from_this<VideoEncoder> {
 public:
     VideoEncoder() = default;
     explicit VideoEncoder(VideoCodecType type);
@@ -42,17 +44,28 @@ public:
     int32_t Release();
     int32_t GetSurface();
     int32_t ReleaseSurfaceBuffer(sptr<FrameRecord> frameRecord);
+    int32_t DetachCodecBuffer(sptr<SurfaceBuffer> &surfaceBuffer, sptr<FrameRecord> frameRecord);
+    struct CallBack : public MediaCodecCallback {
+        explicit CallBack(std::weak_ptr<VideoEncoder> encoder) : videoEncoder_(encoder) {}
+        ~CallBack() override = default;
+        void OnError(AVCodecErrorType errorType, int32_t errorCode) override;
+        void OnOutputFormatChanged(const Format &format) override;
+        void OnInputBufferAvailable(uint32_t index, std::shared_ptr<AVBuffer> buffer) override;
+        void OnOutputBufferAvailable(uint32_t index, std::shared_ptr<AVBuffer> buffer) override;
+    private:
+        std::weak_ptr<VideoEncoder> videoEncoder_;
+    };
 
 private:
-    int32_t SetCallback(CodecUserData *codecUserData);
+    int32_t SetCallback();
     int32_t Configure();
     void RestartVideoCodec(shared_ptr<Size> size, int32_t rotation);
     bool EnqueueBuffer(sptr<FrameRecord> frameRecord, int32_t keyFrameInterval);
     std::atomic<bool> isStarted_ { false };
     std::mutex encoderMutex_;
-    OH_AVCodec *encoder_ = nullptr;
+    shared_ptr<AVCodecVideoEncoder> encoder_ = nullptr;
     std::mutex contextMutex_;
-    CodecUserData *context_ = nullptr;
+    sptr<VideoCodecUserData> context_ = nullptr;
     shared_ptr<Size> size_;
     int32_t rotation_;
     std::mutex surfaceMutex_; // guard codecSurface_
diff --git a/services/camera_service/src/avcodec/avcodec_task_manager.cpp b/services/camera_service/src/avcodec/avcodec_task_manager.cpp
index 8355dfad9..754c7f5af 100644
--- a/services/camera_service/src/avcodec/avcodec_task_manager.cpp
+++ b/services/camera_service/src/avcodec/avcodec_task_manager.cpp
@@ -61,7 +61,7 @@ AvcodecTaskManager::AvcodecTaskManager(sptr<AudioCapturerSession> audioCaptureSe
     audioEncoder_ = make_unique<AudioEncoder>();
     #endif
     // Create Task Manager
-    videoEncoder_ = make_unique<VideoEncoder>(type);
+    videoEncoder_ = make_shared<VideoEncoder>(type);
 }
 
 shared_ptr<TaskManager>& AvcodecTaskManager::GetTaskManager()
@@ -98,6 +98,9 @@ void AvcodecTaskManager::EncodeVideoBuffer(sptr<FrameRecord> frameRecord, CacheC
         isEncodeSuccess = thisPtr->videoEncoder_->EncodeSurfaceBuffer(frameRecord);
         if (isEncodeSuccess) {
             thisPtr->videoEncoder_->ReleaseSurfaceBuffer(frameRecord);
+        } else {
+            sptr<SurfaceBuffer> releaseBuffer;
+            thisPtr->videoEncoder_->DetachCodecBuffer(releaseBuffer, frameRecord);
         }
         frameRecord->SetEncodedResult(isEncodeSuccess);
         frameRecord->SetFinishStatus();
@@ -217,21 +220,19 @@ void AvcodecTaskManager::DoMuxerVideo(vector<sptr<FrameRecord>> frameRecords, ui
         int64_t videoStartTime = choosedBuffer.front()->GetTimeStamp();
         for (size_t index = 0; index < choosedBuffer.size(); index++) {
             MEDIA_DEBUG_LOG("write sample index %{public}zu", index);
-            OH_AVBuffer *buffer = choosedBuffer[index]->encodedBuffer;
+            shared_ptr<Media::AVBuffer> buffer = choosedBuffer[index]->encodedBuffer;
             {
                 std::lock_guard<std::mutex> lock(choosedBuffer[index]->bufferMutex_);
                 OH_AVCodecBufferAttr attr = {0, 0, 0, AVCODEC_BUFFER_FLAGS_NONE};
                 CHECK_AND_CONTINUE_LOG(buffer != nullptr, "video encodedBuffer is null");
-                OH_AVBuffer_GetBufferAttr(buffer, &attr);
-                attr.pts = NanosecToMicrosec(choosedBuffer[index]->GetTimeStamp() - videoStartTime);
+                buffer->pts_ = NanosecToMicrosec(choosedBuffer[index]->GetTimeStamp() - videoStartTime);
                 MEDIA_DEBUG_LOG("choosed buffer pts:%{public}" PRIu64, attr.pts);
-                OH_AVBuffer_SetBufferAttr(buffer, &attr);
-                muxer->WriteSampleBuffer(buffer->buffer_, VIDEO_TRACK);
+                muxer->WriteSampleBuffer(buffer, VIDEO_TRACK);
             }
             sptr<SurfaceBuffer> metaSurfaceBuffer = frameRecords[index]->GetMetaBuffer();
             if (metaSurfaceBuffer) {
                 shared_ptr<AVBuffer> metaAvBuffer = AVBuffer::CreateAVBuffer(metaSurfaceBuffer);
-                metaAvBuffer->pts_ = buffer->buffer_->pts_;
+                 metaAvBuffer->pts_ = buffer->pts_;
                 MEDIA_DEBUG_LOG("metaAvBuffer pts_ %{public}llu, avBufferSize: %{public}d",
                     (long long unsigned)(metaAvBuffer->pts_), metaAvBuffer->memory_->GetSize());
                 muxer->WriteSampleBuffer(metaAvBuffer, META_TRACK);
diff --git a/services/camera_service/src/avcodec/common/frame_record.cpp b/services/camera_service/src/avcodec/common/frame_record.cpp
index e35d8375e..c995548d6 100644
--- a/services/camera_service/src/avcodec/common/frame_record.cpp
+++ b/services/camera_service/src/avcodec/common/frame_record.cpp
@@ -35,9 +35,6 @@ FrameRecord::FrameRecord(sptr<SurfaceBuffer> videoBuffer, int64_t timestamp, Gra
 FrameRecord::~FrameRecord()
 {
     MEDIA_DEBUG_LOG("FrameRecord::~FrameRecord");
-    if (encodedBuffer) {
-        OH_AVBuffer_Destroy(encodedBuffer);
-    }
     encodedBuffer = nullptr;
 }
 
diff --git a/services/camera_service/src/avcodec/video_encoder.cpp b/services/camera_service/src/avcodec/video_encoder.cpp
index b9a1aeb86..c0949d73c 100644
--- a/services/camera_service/src/avcodec/video_encoder.cpp
+++ b/services/camera_service/src/avcodec/video_encoder.cpp
@@ -14,10 +14,10 @@
  */
 
 #include "video_encoder.h"
-#include "sample_callback.h"
 #include "camera_log.h"
 #include <sync_fence.h>
-#include "native_window.h"
+#include "native_mfmagic.h"
+#include "media_description.h"
 
 namespace OHOS {
 namespace CameraStandard {
@@ -40,8 +40,8 @@ VideoEncoder::VideoEncoder(VideoCodecType type) : videoCodecType_(type)
 int32_t VideoEncoder::Create(const std::string &codecMime)
 {
     std::lock_guard<std::mutex> lock(encoderMutex_);
-    encoder_ = OH_VideoEncoder_CreateByMime(codecMime.data());
-    CHECK_AND_RETURN_RET_LOG(encoder_ != nullptr, 1, "Create failed");
+    encoder_ = VideoEncoderFactory::CreateByMime(codecMime);
+    CHECK_ERROR_RETURN_RET_LOG(encoder_ == nullptr, 1, "Create failed");
     return 0;
 }
 
@@ -50,13 +50,13 @@ int32_t VideoEncoder::Config()
     std::lock_guard<std::mutex> lock(encoderMutex_);
     CHECK_AND_RETURN_RET_LOG(encoder_ != nullptr, 1, "Encoder is null");
     std::unique_lock<std::mutex> contextLock(contextMutex_);
-    context_ = new CodecUserData;
+    context_ = new VideoCodecUserData;
     // Configure video encoder
     int32_t ret = Configure();
-    CHECK_AND_RETURN_RET_LOG(ret == 0, 1, "Configure failed");
+    CHECK_ERROR_RETURN_RET_LOG(ret != AV_ERR_OK, 1, "Configure failed");
     // SetCallback for video encoder
-    ret = SetCallback(context_);
-    CHECK_AND_RETURN_RET_LOG(ret == 0, 1, "Set callback failed");
+    ret = SetCallback();
+    CHECK_ERROR_RETURN_RET_LOG(ret != AV_ERR_OK, 1, "Set callback failed");
     contextLock.unlock();
     return 0;
 }
@@ -66,11 +66,11 @@ int32_t VideoEncoder::Start()
     std::lock_guard<std::mutex> lock(encoderMutex_);
     CHECK_AND_RETURN_RET_LOG(encoder_ != nullptr, 1, "Encoder is null");
      // Prepare video encoder
-    int ret = OH_VideoEncoder_Prepare(encoder_);
-    CHECK_AND_RETURN_RET_LOG(ret == AV_ERR_OK, 1, "Prepare failed, ret: %{public}d", ret);
+    int ret = encoder_->Prepare();
+    CHECK_ERROR_RETURN_RET_LOG(ret != AV_ERR_OK, 1, "Prepare failed, ret: %{public}d", ret);
     // Start video encoder
-    ret = OH_VideoEncoder_Start(encoder_);
-    CHECK_AND_RETURN_RET_LOG(ret == AV_ERR_OK, 1, "Start failed, ret: %{public}d", ret);
+    ret = encoder_->Start();
+    CHECK_ERROR_RETURN_RET_LOG(ret != AV_ERR_OK, 1, "Start failed, ret: %{public}d", ret);
     isStarted_ = true;
     return 0;
 }
@@ -78,15 +78,10 @@ int32_t VideoEncoder::Start()
 int32_t VideoEncoder::GetSurface()
 {
     std::lock_guard<std::mutex> lock(encoderMutex_);
-    OHNativeWindow *nativeWindow;
-    CHECK_AND_RETURN_RET_LOG(encoder_ != nullptr, 1, "Encoder is null");
-    int ret = OH_VideoEncoder_GetSurface(encoder_, &nativeWindow);
-    CHECK_AND_RETURN_RET_LOG(ret == AV_ERR_OK, 1, "Get surface failed, ret: %{public}d", ret);
-    surfaceMutex_.lock();
-    codecSurface_ = nativeWindow->surface;
-    OH_NativeWindow_DestroyNativeWindow(nativeWindow);
-    CHECK_AND_RETURN_RET_LOG(codecSurface_ != nullptr, 1, "Surface is null");
-    surfaceMutex_.unlock();
+    CHECK_ERROR_RETURN_RET_LOG(encoder_ == nullptr, 1, "Encoder is null");
+    std::lock_guard<std::mutex> surfaceLock(surfaceMutex_);
+    codecSurface_ = encoder_->CreateInputSurface();
+    CHECK_ERROR_RETURN_RET_LOG(codecSurface_ == nullptr, 1, "Surface is null");
     return 0;
 }
 
@@ -95,6 +90,22 @@ int32_t VideoEncoder::ReleaseSurfaceBuffer(sptr<FrameRecord> frameRecord)
     CAMERA_SYNC_TRACE;
     CHECK_AND_RETURN_RET_LOG(frameRecord->GetSurfaceBuffer() != nullptr, 1,
         "SurfaceBuffer is released %{public}s", frameRecord->GetFrameId().c_str());
+    sptr<SurfaceBuffer> releaseBuffer;
+    int32_t ret = DetachCodecBuffer(releaseBuffer, frameRecord);
+    CHECK_ERROR_RETURN_RET_LOG(ret != SURFACE_ERROR_OK, ret, " %{public}s ReleaseSurfaceBuffer failed",
+        frameRecord->GetFrameId().c_str());
+    frameRecord->SetSurfaceBuffer(releaseBuffer);
+    // after request surfaceBuffer
+    frameRecord->NotifyBufferRelease();
+    MEDIA_INFO_LOG("release codec surface buffer end");
+    return 0;
+}
+
+int32_t VideoEncoder::DetachCodecBuffer(sptr<SurfaceBuffer> &surfaceBuffer, sptr<FrameRecord> frameRecord)
+{
+    CHECK_ERROR_RETURN_RET_LOG(frameRecord == nullptr, 1, "frameRecord is null");
+    std::lock_guard<std::mutex> lock(surfaceMutex_);
+    CHECK_ERROR_RETURN_RET_LOG(codecSurface_ == nullptr, 1, "codecSurface_ is null");
     sptr<SyncFence> syncFence = SyncFence::INVALID_FENCE;
     BufferRequestConfig requestConfig = {
         .width = frameRecord->GetFrameSize()->width,
@@ -104,33 +115,14 @@ int32_t VideoEncoder::ReleaseSurfaceBuffer(sptr<FrameRecord> frameRecord)
         .usage = frameRecord->GetUsage(),
         .timeout = 0,
     };
-    sptr<SurfaceBuffer> releaseBuffer;
-    {
-        std::lock_guard<std::mutex> lock(surfaceMutex_);
-        CHECK_AND_RETURN_RET_LOG(codecSurface_ != nullptr, 1, "codecSurface_ is null");
-        SurfaceError ret = codecSurface_->RequestBuffer(releaseBuffer, syncFence, requestConfig);
-        if (ret != SURFACE_ERROR_OK) {
-            MEDIA_ERR_LOG("RequestBuffer failed. %{public}d", ret);
-            return ret;
-        }
-        constexpr uint32_t waitForEver = -1;
-        (void)syncFence->Wait(waitForEver);
-
-        if (!releaseBuffer) {
-            MEDIA_ERR_LOG("Failed to requestBuffer, %{public}s", frameRecord->GetFrameId().c_str());
-            return ret;
-        }
-        ret = codecSurface_->DetachBufferFromQueue(releaseBuffer);
-        if (ret != SURFACE_ERROR_OK) {
-            MEDIA_ERR_LOG("Failed to detach buffer");
-            return ret;
-        }
-    }
-    frameRecord->SetSurfaceBuffer(releaseBuffer);
-    // after request surfaceBuffer
-    frameRecord->NotifyBufferRelease();
-    MEDIA_INFO_LOG("release codec surface buffer end");
-    return 0;
+    SurfaceError ret = codecSurface_->RequestBuffer(surfaceBuffer, syncFence, requestConfig);
+    CHECK_ERROR_RETURN_RET_LOG(ret != SURFACE_ERROR_OK, ret, "RequestBuffer failed. %{public}d", ret);
+    constexpr uint32_t waitForEver = -1;
+    (void)syncFence->Wait(waitForEver);
+    CHECK_ERROR_RETURN_RET_LOG(surfaceBuffer == nullptr, ret, "Failed to request codec Buffer");
+    ret = codecSurface_->DetachBufferFromQueue(surfaceBuffer);
+    CHECK_ERROR_RETURN_RET_LOG(ret != SURFACE_ERROR_OK, ret, "Failed to detach buffer %{public}d", ret);
+    return ret;
 }
 
 int32_t VideoEncoder::PushInputData(sptr<CodecAVBufferInfo> info)
@@ -139,26 +131,26 @@ int32_t VideoEncoder::PushInputData(sptr<CodecAVBufferInfo> info)
     CHECK_AND_RETURN_RET_LOG(encoder_ != nullptr, 1, "Decoder is null");
     int32_t ret = AV_ERR_OK;
     ret = OH_AVBuffer_SetBufferAttr(info->buffer, &info->attr);
-    CHECK_AND_RETURN_RET_LOG(ret == AV_ERR_OK, 1, "Set avbuffer attr failed, ret: %{public}d", ret);
-    ret = OH_VideoEncoder_PushInputBuffer(encoder_, info->bufferIndex);
-    CHECK_AND_RETURN_RET_LOG(ret == AV_ERR_OK, 1, "Push input data failed, ret: %{public}d", ret);
+    CHECK_ERROR_RETURN_RET_LOG(ret != AV_ERR_OK, 1, "Set avbuffer attr failed, ret: %{public}d", ret);
+    ret = encoder_->QueueInputBuffer(info->bufferIndex);
+    CHECK_ERROR_RETURN_RET_LOG(ret != AV_ERR_OK, 1, "Push input data failed, ret: %{public}d", ret);
     return 0;
 }
 
 int32_t VideoEncoder::NotifyEndOfStream()
 {
     std::lock_guard<std::mutex> lock(encoderMutex_);
-    CHECK_AND_RETURN_RET_LOG(encoder_ != nullptr, 1, "Encoder is null");
-    int32_t ret = OH_VideoEncoder_NotifyEndOfStream(encoder_);
-    CHECK_AND_RETURN_RET_LOG(ret == AV_ERR_OK, 1,
+    CHECK_ERROR_RETURN_RET_LOG(encoder_ == nullptr, 1, "Encoder is null");
+    int32_t ret = encoder_->NotifyEos();
+    CHECK_ERROR_RETURN_RET_LOG(ret != AV_ERR_OK, 1,
         "Notify end of stream failed, ret: %{public}d", ret);
     return 0;
 }
 
 int32_t VideoEncoder::FreeOutputData(uint32_t bufferIndex)
 {
-    int32_t ret = OH_VideoEncoder_FreeOutputBuffer(encoder_, bufferIndex);
-    CHECK_AND_RETURN_RET_LOG(ret == AV_ERR_OK, 1,
+    int32_t ret = encoder_->ReleaseOutputBuffer(bufferIndex);
+    CHECK_ERROR_RETURN_RET_LOG(ret != AV_ERR_OK, 1,
         "Free output data failed, ret: %{public}d", ret);
     return 0;
 }
@@ -167,9 +159,9 @@ int32_t VideoEncoder::Stop()
 {
     CAMERA_SYNC_TRACE;
     std::lock_guard<std::mutex> lock(encoderMutex_);
-    CHECK_AND_RETURN_RET_LOG(encoder_ != nullptr, 1, "Encoder is null");
-    int ret = OH_VideoEncoder_Stop(encoder_);
-    CHECK_AND_RETURN_RET_LOG(ret == AV_ERR_OK, 1, "Stop failed, ret: %{public}d", ret);
+    CHECK_ERROR_RETURN_RET_LOG(encoder_ == nullptr, 1, "Encoder is null");
+    int ret = encoder_->Stop();
+    CHECK_ERROR_RETURN_RET_LOG(ret != AV_ERR_OK, 1, "Stop failed, ret: %{public}d", ret);
     isStarted_ = false;
     return 0;
 }
@@ -197,10 +189,9 @@ bool VideoEncoder::EnqueueBuffer(sptr<FrameRecord> frameRecord, int32_t keyFrame
     }
     if (keyFrameInterval == KEY_FRAME_INTERVAL) {
         std::lock_guard<std::mutex> lock(encoderMutex_);
-        OH_AVFormat *format = OH_AVFormat_Create();
-        OH_AVFormat_SetIntValue(format, OH_MD_KEY_REQUEST_I_FRAME, true);
-        OH_VideoEncoder_SetParameter(encoder_, format);
-        OH_AVFormat_Destroy(format);
+        MediaAVCodec::Format format = MediaAVCodec::Format();
+        format.PutIntValue(MediaDescriptionKey::MD_KEY_REQUEST_I_FRAME, true);
+        encoder_->SetParameter(format);
     }
     sptr<SurfaceBuffer> buffer = frameRecord->GetSurfaceBuffer();
     if (buffer == nullptr) {
@@ -252,37 +243,37 @@ bool VideoEncoder::EncodeSurfaceBuffer(sptr<FrameRecord> frameRecord)
             [this]() { return !isStarted_ || !context_->outputBufferInfoQueue_.empty(); });
         CHECK_AND_CONTINUE_LOG(!context_->outputBufferInfoQueue_.empty(),
             "Buffer queue is empty, continue, cond ret: %{public}d", condRet);
-        sptr<CodecAVBufferInfo> bufferInfo = context_->outputBufferInfoQueue_.front();
+        sptr<VideoCodecAVBufferInfo> bufferInfo = context_->outputBufferInfoQueue_.front();
         MEDIA_INFO_LOG("Out buffer count: %{public}u, size: %{public}d, flag: %{public}u, pts:%{public}" PRIu64 ", "
-            "timestamp:%{public}" PRIu64, context_->outputFrameCount_, bufferInfo->attr.size, bufferInfo->attr.flags,
-            bufferInfo->attr.pts, frameRecord->GetTimeStamp());
+            "timestamp:%{public}" PRIu64, context_->outputFrameCount_, bufferInfo->buffer->memory_->GetSize(),
+            bufferInfo->buffer->flag_, bufferInfo->buffer->pts_, frameRecord->GetTimeStamp());
         context_->outputBufferInfoQueue_.pop();
         context_->outputFrameCount_++;
         lock.unlock();
         contextLock.unlock();
-        std::lock_guard<std::mutex> encoderLock(encoderMutex_);
-        CHECK_ERROR_RETURN_RET_LOG(!isStarted_ || encoder_ == nullptr, false, "Encode when encoder is stop");
-        if (bufferInfo->attr.flags == AVCODEC_BUFFER_FLAGS_CODEC_DATA) {
+        std::lock_guard<std::mutex> encodeLock(encoderMutex_);
+        CHECK_ERROR_RETURN_RET_LOG(!isStarted_ || encoder_ == nullptr, false, "EncodeSurfaceBuffer when encoder stop!");
+        if (bufferInfo->buffer->flag_ == AVCODEC_BUFFER_FLAGS_CODEC_DATA) {
             // first return IDR frame
-            OH_AVBuffer *IDRBuffer = bufferInfo->GetCopyAVBuffer();
+            std::shared_ptr<Media::AVBuffer> IDRBuffer = bufferInfo->GetCopyAVBuffer();
             frameRecord->CacheBuffer(IDRBuffer);
             frameRecord->SetIDRProperty(true);
             successFrame_ = false;
-        } else if (bufferInfo->attr.flags == AVCODEC_BUFFER_FLAGS_SYNC_FRAME) {
+        } else if (bufferInfo->buffer->flag_ == AVCODEC_BUFFER_FLAGS_SYNC_FRAME) {
             // then return I frame
-            OH_AVBuffer *tempBuffer = bufferInfo->AddCopyAVBuffer(frameRecord->encodedBuffer);
+            std::shared_ptr<Media::AVBuffer> tempBuffer = bufferInfo->AddCopyAVBuffer(frameRecord->encodedBuffer);
             if (tempBuffer != nullptr) {
                 frameRecord->encodedBuffer = tempBuffer;
             }
             successFrame_ = true;
-        } else if (bufferInfo->attr.flags == AVCODEC_BUFFER_FLAGS_NONE) {
+        } else if (bufferInfo->buffer->flag_ == AVCODEC_BUFFER_FLAGS_NONE) {
             // return P frame
-            OH_AVBuffer *PBuffer = bufferInfo->GetCopyAVBuffer();
+            std::shared_ptr<Media::AVBuffer> PBuffer = bufferInfo->GetCopyAVBuffer();
             frameRecord->CacheBuffer(PBuffer);
             frameRecord->SetIDRProperty(false);
             successFrame_ = true;
         } else {
-            MEDIA_ERR_LOG("Flag is not acceptted number: %{public}u", bufferInfo->attr.flags);
+            MEDIA_ERR_LOG("Flag is not acceptted number: %{public}u", bufferInfo->buffer->flag_);
             int32_t ret = FreeOutputData(bufferInfo->bufferIndex);
             CHECK_AND_BREAK_LOG(ret == 0, "FreeOutputData failed");
             continue;
@@ -304,53 +295,69 @@ int32_t VideoEncoder::Release()
     {
         std::lock_guard<std::mutex> lock(encoderMutex_);
         if (encoder_ != nullptr) {
-            OH_VideoEncoder_Destroy(encoder_);
-            encoder_ = nullptr;
+            encoder_->Release();
         }
     }
     std::unique_lock<std::mutex> contextLock(contextMutex_);
-    if (context_ != nullptr) {
-        delete context_;
-        context_ = nullptr;
-    }
     isStarted_ = false;
     return 0;
 }
 
-int32_t VideoEncoder::SetCallback(CodecUserData *codecUserData)
+void VideoEncoder::CallBack::OnError(AVCodecErrorType errorType, int32_t errorCode)
+{
+    (void)errorCode;
+    MEDIA_ERR_LOG("On decoder error, error code: %{public}d", errorCode);
+}
+
+void VideoEncoder::CallBack::OnOutputFormatChanged(const Format &format)
+{
+    MEDIA_ERR_LOG("OnCodecFormatChange");
+}
+
+void VideoEncoder::CallBack::OnInputBufferAvailable(uint32_t index, std::shared_ptr<AVBuffer> buffer)
+{
+    MEDIA_DEBUG_LOG("OnInputBufferAvailable");
+}
+
+void VideoEncoder::CallBack::OnOutputBufferAvailable(uint32_t index, std::shared_ptr<AVBuffer> buffer)
+{
+    MEDIA_DEBUG_LOG("OnOutputBufferAvailable");
+    auto encoder = videoEncoder_.lock();
+    CHECK_ERROR_RETURN_LOG(encoder == nullptr, "encoder is nullptr");
+    CHECK_ERROR_RETURN_LOG(encoder->context_ == nullptr, "encoder context is nullptr");
+    std::unique_lock<std::mutex> lock(encoder->context_->outputMutex_);
+    encoder->context_->outputBufferInfoQueue_.emplace(new VideoCodecAVBufferInfo(index, buffer));
+    encoder->context_->outputCond_.notify_all();
+}
+
+int32_t VideoEncoder::SetCallback()
 {
     int32_t ret = AV_ERR_OK;
-    ret = OH_VideoEncoder_RegisterCallback(encoder_,
-        {SampleCallback::OnCodecError, SampleCallback::OnCodecFormatChange,
-         SampleCallback::OnNeedInputBuffer, SampleCallback::OnNewOutputBuffer}, codecUserData);
-    CHECK_AND_RETURN_RET_LOG(ret == AV_ERR_OK, 1, "Set callback failed, ret: %{public}d", ret);
+    auto callback = make_shared<CallBack>(weak_from_this());
+    ret = encoder_->SetCallback(callback);
+    CHECK_ERROR_RETURN_RET_LOG(ret != AV_ERR_OK, 1, "Set callback failed, ret: %{public}d", ret);
     return 0;
 }
 
 int32_t VideoEncoder::Configure()
 {
-    OH_AVFormat *format = OH_AVFormat_Create();
-    CHECK_AND_RETURN_RET_LOG(format != nullptr, 1, "AVFormat create failed");
+    MediaAVCodec::Format format = MediaAVCodec::Format();
     int32_t bitrate = static_cast<int32_t>(pow(float(size_->width) * float(size_->height) / DEFAULT_SIZE,
         VIDEO_BITRATE_CONSTANT) * BITRATE_22M);
-    bitrate_ = (videoCodecType_ == VideoCodecType::VIDEO_ENCODE_TYPE_AVC
-        ? static_cast<int32_t>(bitrate * HEVC_TO_AVC_FACTOR) : bitrate);
+    bitrate_ = videoCodecType_ == VideoCodecType::VIDEO_ENCODE_TYPE_AVC
+        ? static_cast<int32_t>(bitrate * HEVC_TO_AVC_FACTOR) : bitrate;
     MEDIA_INFO_LOG("Current resolution is : %{public}d*%{public}d, encode type : %{public}d, set bitrate : %{public}d",
         size_->width, size_->height, videoCodecType_, bitrate_);
-
-    OH_AVFormat_SetIntValue(format, OH_MD_KEY_WIDTH, size_->width);
-    OH_AVFormat_SetIntValue(format, OH_MD_KEY_HEIGHT, size_->height);
-    OH_AVFormat_SetIntValue(format, OH_MD_KEY_ROTATION, rotation_);
-    OH_AVFormat_SetDoubleValue(format, OH_MD_KEY_FRAME_RATE, VIDEO_FRAME_RATE);
-    OH_AVFormat_SetIntValue(format, OH_MD_KEY_VIDEO_ENCODE_BITRATE_MODE, VBR);
-    OH_AVFormat_SetLongValue(format, OH_MD_KEY_BITRATE, bitrate_);
-    OH_AVFormat_SetIntValue(format, OH_MD_KEY_PIXEL_FORMAT, VIDOE_PIXEL_FORMAT);
-    OH_AVFormat_SetIntValue(format, OH_MD_KEY_I_FRAME_INTERVAL, INT_MAX);
-    int ret = OH_VideoEncoder_Configure(encoder_, format);
-    OH_AVFormat_Destroy(format);
-    format = nullptr;
-    CHECK_AND_RETURN_RET_LOG(ret == AV_ERR_OK, 1, "Config failed, ret: %{public}d", ret);
-
+    format.PutIntValue(MediaDescriptionKey::MD_KEY_WIDTH, size_->width);
+    format.PutIntValue(MediaDescriptionKey::MD_KEY_HEIGHT, size_->height);
+    format.PutIntValue(MediaDescriptionKey::MD_KEY_ROTATION_ANGLE, rotation_);
+    format.PutDoubleValue(MediaDescriptionKey::MD_KEY_FRAME_RATE, VIDEO_FRAME_RATE);
+    format.PutIntValue(MediaDescriptionKey::MD_KEY_VIDEO_ENCODE_BITRATE_MODE, VBR);
+    format.PutLongValue(MediaDescriptionKey::MD_KEY_BITRATE, bitrate_);
+    format.PutIntValue(MediaDescriptionKey::MD_KEY_PIXEL_FORMAT, VIDOE_PIXEL_FORMAT);
+    format.PutIntValue(MediaDescriptionKey::MD_KEY_I_FRAME_INTERVAL, INT_MAX);
+    int ret = encoder_->Configure(format);
+    CHECK_ERROR_RETURN_RET_LOG(ret != AV_ERR_OK, 1, "Config failed, ret: %{public}d", ret);
     return 0;
 }
 } // CameraStandard
diff --git a/services/camera_service/src/hcapture_session.cpp b/services/camera_service/src/hcapture_session.cpp
index e93fc9b3c..ade1c829d 100644
--- a/services/camera_service/src/hcapture_session.cpp
+++ b/services/camera_service/src/hcapture_session.cpp
@@ -2263,7 +2263,8 @@ int32_t HCaptureSession::CreateMediaLibrary(std::unique_ptr<Media::Picture> pict
     std::shared_ptr<PhotoAssetIntf> photoAssetProxy =
         ProcessPhotoProxy(captureId, picturePtr, isBursting, cameraPhotoProxy, uri);
     CHECK_ERROR_RETURN_RET_LOG(photoAssetProxy == nullptr, CAMERA_INVALID_ARG, "photoAssetProxy is null");
-    if (!isBursting && isSetMotionPhoto_) {
+    if (!isBursting && isSetMotionPhoto_ && taskManager_) {
+        MEDIA_INFO_LOG("CreateMediaLibrary captureId :%{public}d", captureId);
         if (taskManager_) {
             taskManager_->SetVideoFd(timestamp, photoAssetProxy, captureId);
         }
-- 
2.45.2.huawei.8

