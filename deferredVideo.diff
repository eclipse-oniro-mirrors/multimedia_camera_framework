From 3fe5f1fb412e37c2a1ecb19544227393ebe351f3 Mon Sep 17 00:00:00 2001
From: w30052493 <wangxiaoxiong8@huawei.com>
Date: Fri, 30 Aug 2024 16:39:18 +0800
Subject: [PATCH] =?UTF-8?q?TicketNo:=20AR20240517283806=20Description:=20?=
 =?UTF-8?q?=E5=88=86=E6=AE=B5=E5=BC=8F=E8=A7=86=E9=A2=91=E8=87=AA=E9=AA=8C?=
 =?UTF-8?q?=E8=AF=81=20Team:EMUI=20Feature=20or=20Bugfix:Bugfix=20Binary?=
 =?UTF-8?q?=20Source:No=20PrivateCode(Yes/No):No?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Change-Id: I59a8ea147d727a0b7fa00e79d58e71e6ee8b0786
---
 bundle.json                                   |   2 +
 .../src/output/video_output_napi.cpp          | 184 ++++++-
 frameworks/native/camera/BUILD.gn             |   8 +
 .../deferred_video_proc_session.cpp           | 222 ++++++++
 .../camera/src/input/camera_manager.cpp       |  61 +++
 .../camera/src/output/preview_output.cpp      |   7 +
 .../native/camera/src/output/video_output.cpp |  76 +++
 .../camera/src/session/capture_session.cpp    |  49 ++
 .../camera/src/utils/dps_metadata_info.cpp    |   8 +-
 .../src/camera_framework_moduletest.cpp       |   5 +
 .../native/camera/test/unittest/BUILD.gn      | 116 +++++
 .../include/camera_deferred_video_unittest.h  |  63 +++
 .../v1_1/camera_deferred_video_unittest.cpp   | 302 +++++++++++
 .../native/ndk/impl/video_output_impl.cpp     |   6 +
 .../deferred_photo_proc_session.h             |  22 +-
 .../deferred_proc_session/deferred_type.h     |  48 ++
 .../deferred_video_proc_session.h             |  91 ++++
 .../camera/include/input/camera_device.h      |   1 +
 .../camera/include/input/camera_manager.h     |  19 +
 .../camera/include/output/preview_output.h    |   2 +
 .../camera/include/output/video_output.h      |  23 +
 .../camera/include/session/capture_session.h  |   3 +
 .../inner_api/native/test/test_common.cpp     |   5 +
 .../inner_api/native/test/test_common.h       |   1 +
 .../include/output/video_output_napi.h        |  39 +-
 multimedia_camera_framework.gni               |  12 +
 services/camera_service/BUILD.gn              |   8 +-
 .../camera_service_ipc_interface_code.h       |   4 +-
 .../binder/base/include/icamera_service.h     |   6 +
 .../base/include/istream_repeat_callback.h    |   9 +
 .../client/include/hcamera_service_proxy.h    |   4 +
 .../include/hstream_repeat_callback_proxy.h   |   2 +
 .../client/src/hcamera_service_proxy.cpp      |  35 ++
 .../src/hstream_repeat_callback_proxy.cpp     |  20 +
 .../server/include/hcamera_service_stub.h     |   1 +
 .../include/hstream_repeat_callback_stub.h    |   1 +
 .../server/src/hcamera_service_stub.cpp       |  27 +
 .../src/hstream_repeat_callback_stub.cpp      |  13 +
 .../camera_service/include/hcamera_service.h  |   3 +
 .../camera_service/include/hstream_repeat.h   |   1 +
 .../camera_service/src/hcamera_service.cpp    |  17 +
 .../camera_service/src/hcapture_session.cpp   |  23 +-
 .../camera_service/src/hstream_repeat.cpp     |  16 +
 services/deferred_processing_service/BUILD.gn |  86 ++++
 .../IDeferredVideoProcessingSession.idl       |  12 +
 ...DeferredVideoProcessingSessionCallback.idl |   8 +
 .../ideferred_photo_processing_session.h      |  94 ++--
 ...ferred_photo_processing_session_callback.h |   5 +
 .../ideferred_video_processing_session.h      |  57 +++
 ...ferred_video_processing_session_callback.h |  52 ++
 .../deferred_photo_processing_session_proxy.h |  86 ++--
 ..._video_processing_session_callback_proxy.h |  59 +++
 .../deferred_video_processing_session_proxy.h |  66 +++
 ...eferred_photo_processing_session_proxy.cpp |  12 +-
 ...ideo_processing_session_callback_proxy.cpp | 122 +++++
 ...eferred_video_processing_session_proxy.cpp | 181 +++++++
 ...d_video_processing_session_callback_stub.h |  42 ++
 .../deferred_video_processing_session_stub.h  |  44 ++
 ...photo_processing_session_callback_stub.cpp |   5 +-
 ...deferred_photo_processing_session_stub.cpp |   4 +-
 ...video_processing_session_callback_stub.cpp |  67 +++
 ...deferred_video_processing_session_stub.cpp |  90 ++++
 .../include/base/basic_definitions.h          | 121 ++++-
 .../include/base/buffer_info.h                |  21 +-
 .../include/base/command_server/command.h     |  62 +++
 .../base/command_server/command_server.h      |  88 ++++
 .../base/command_server/command_server_impl.h |  47 ++
 .../include/base/dps.h                        |  77 +++
 .../include/base/iimage_process_callbacks.h   |   6 +-
 .../include/base/ivideo_process_callbacks.h   |  37 ++
 .../include/base/task_manager/thread_pool.h   | 182 +++----
 .../include/base/task_manager/thread_utils.h  |  71 +--
 .../include/deferred_processing_service.h     | 114 +++--
 .../include/dfx/dps_video_report.h            |  64 +++
 .../event_monitor/base/events_strategy.h      |  42 ++
 .../command/event_status_change_command.h     |  43 ++
 .../include/event_monitor/events_info.h       |  50 ++
 .../include/event_monitor/events_monitor.h    |  78 ++-
 .../include/event_monitor/events_subscriber.h |  45 ++
 .../include/event_monitor/ievents_listener.h  |  10 +-
 .../impl/battery_level_strategy.h             |  37 ++
 .../event_monitor/impl/battery_strategy.h     |  34 ++
 .../event_monitor/impl/charging_strategy.h    |  34 ++
 .../event_monitor/impl/screen_strategy.h      |  34 ++
 .../event_monitor/impl/thermal_strategy.h     |  34 ++
 .../include/media_manager/demuxer.h           |  47 ++
 .../include/media_manager/media_format.h      | 105 ++++
 .../include/media_manager/media_manager.h     |  70 +++
 .../include/media_manager/mpeg_manager.h      |  66 +++
 .../media_manager/mpeg_manager_factory.h      |  41 ++
 .../include/media_manager/muxer.h             |  49 ++
 .../include/media_manager/reader.h            |  60 +++
 .../include/media_manager/track.h             |  55 ++
 .../include/media_manager/track_factory.h     |  34 ++
 .../include/media_manager/writer.h            |  52 ++
 .../command/service_died_command.h            |  38 ++
 .../command/video_process_command.h           |  82 +++
 .../post_processor/video_post_processor.h     | 102 ++++
 .../schedule/base/ischeduler_video_state.h    |  57 +++
 .../schedule/impl/video_battery_level_state.h |  35 ++
 .../schedule/impl/video_battery_state.h       |  35 ++
 .../schedule/impl/video_camera_state.h        |  35 ++
 .../schedule/impl/video_charging_state.h      |  35 ++
 .../include/schedule/impl/video_hal_state.h   |  35 ++
 .../schedule/impl/video_media_library_state.h |  35 ++
 .../schedule/impl/video_photo_process_state.h |  35 ++
 .../schedule/impl/video_screen_state.h        |  35 ++
 .../schedule/impl/video_temperature_state.h   |  35 ++
 .../photo_job_repository/deferred_photo_job.h | 209 ++++----
 .../include/schedule/scheduler_coordinator.h  |  85 ++--
 .../include/schedule/scheduler_manager.h      |  17 +-
 .../deferred_video_controller.h               |  65 +++
 .../deferred_video_processor.h                |  58 +++
 .../strategy/ivideo_state_change_listener.h   |  37 ++
 .../strategy/ivideo_strategy.h                |  37 ++
 .../strategy/video_strategy_center.h          | 116 +++++
 .../video_job_repository/deferred_video_job.h | 149 ++++++
 .../ivideo_job_repository_listener.h          |  34 ++
 .../video_job_repository/video_job_queue.h    |  64 +++
 .../video_job_repository.h                    |  65 +++
 .../include/session/command/session_command.h |  61 +++
 .../include/session/command/sync_command.h    |  56 ++
 .../include/session/command/video_command.h   |  77 +++
 .../deferred_photo_processing_session.h       | 130 ++---
 .../include/session/session_coordinator.h     |  32 +-
 .../include/session/session_manager.h         | 106 ++--
 .../deferred_video_processing_session.h       |  61 +++
 .../video_session/video_session_info.h        |  49 ++
 .../include/utils/dp_catch.h                  |  55 ++
 .../include/utils/dp_log.h                    |  80 ++-
 .../include/utils/dp_power_manager.h          |  47 ++
 .../include/utils/dp_timer.h                  |  42 ++
 .../include/utils/dp_utils.h                  | 177 ++++---
 .../src/base/basic_definitions.cpp            |  47 ++
 .../src/base/buffer_info.cpp                  |  21 +-
 .../src/base/buffer_manager/shared_buffer.cpp |  10 +-
 .../src/base/command_server/command.cpp       |  46 ++
 .../base/command_server/command_server.cpp    |  66 +++
 .../command_server/command_server_impl.cpp    |  67 +++
 .../src/base/dps.cpp                          | 102 ++++
 .../src/base/task_manager/thread_pool.cpp     | 323 ++++++------
 .../src/base/task_manager/thread_utils.cpp    | 114 +++--
 .../src/deferred_processing_service.cpp       |  74 +--
 .../src/dfx/dps_video_report.cpp              | 170 +++++++
 .../command/event_status_change_command.cpp   |  44 ++
 .../src/event_monitor/events_info.cpp         | 145 ++++++
 .../src/event_monitor/events_monitor.cpp      | 338 +++++-------
 .../src/event_monitor/events_subscriber.cpp   | 120 +++++
 .../impl/battery_level_strategy.cpp           |  58 +++
 .../event_monitor/impl/battery_strategy.cpp   |  49 ++
 .../event_monitor/impl/charging_strategy.cpp  |  49 ++
 .../event_monitor/impl/screen_strategy.cpp    |  49 ++
 .../event_monitor/impl/thermal_strategy.cpp   |  47 ++
 .../src/media_manager/demuxer.cpp             |  95 ++++
 .../src/media_manager/media_manager.cpp       | 267 ++++++++++
 .../src/media_manager/mpeg_manager.cpp        | 242 +++++++++
 .../media_manager/mpeg_manager_factory.cpp    |  76 +++
 .../src/media_manager/muxer.cpp               | 119 +++++
 .../src/media_manager/reader.cpp              | 212 ++++++++
 .../src/media_manager/track.cpp               |  40 ++
 .../src/media_manager/track_factory.cpp       |  58 +++
 .../src/media_manager/writer.cpp              |  94 ++++
 .../command/service_died_command.cpp          |  46 ++
 .../command/video_process_command.cpp         | 103 ++++
 .../post_processor/photo_post_processor.cpp   |  24 +-
 .../post_processor/video_post_processor.cpp   | 479 ++++++++++++++++++
 .../schedule/base/ischeduler_video_state.cpp  |  61 +++
 .../impl/video_battery_level_state.cpp        |  45 ++
 .../src/schedule/impl/video_battery_state.cpp |  45 ++
 .../src/schedule/impl/video_camera_state.cpp  |  43 ++
 .../schedule/impl/video_charging_state.cpp    |  41 ++
 .../src/schedule/impl/video_hal_state.cpp     |  43 ++
 .../impl/video_media_library_state.cpp        |  41 ++
 .../impl/video_photo_process_state.cpp        |  41 ++
 .../src/schedule/impl/video_screen_state.cpp  |  45 ++
 .../schedule/impl/video_temperature_state.cpp |  45 ++
 .../deferred_photo_controller.cpp             |   3 +-
 .../photo_job_repository.cpp                  |   9 +-
 .../src/schedule/scheduler_coordinator.cpp    |   1 +
 .../src/schedule/scheduler_manager.cpp        |  51 +-
 .../deferred_video_controller.cpp             | 220 ++++++++
 .../deferred_video_processor.cpp              | 142 ++++++
 .../strategy/video_strategy_center.cpp        | 339 +++++++++++++
 .../deferred_video_job.cpp                    |  68 +++
 .../video_job_repository/video_job_queue.cpp  | 130 +++++
 .../video_job_repository.cpp                  | 231 +++++++++
 .../src/session/command/session_command.cpp   |  74 +++
 .../src/session/command/sync_command.cpp      |  94 ++++
 .../src/session/command/video_command.cpp     |  94 ++++
 .../deferred_photo_processing_session.cpp     |  10 +-
 .../src/session/session_coordinator.cpp       | 152 +++++-
 .../src/session/session_info.cpp              | 214 ++++----
 .../src/session/session_manager.cpp           |  52 +-
 .../deferred_video_processing_session.cpp     | 102 ++++
 .../video_session/video_session_info.cpp      | 128 +++++
 .../src/utils/dp_power_manager.cpp            |  95 ++++
 .../src/utils/dp_timer.cpp                    |  59 +++
 .../src/utils/dp_utils.cpp                    |  90 +++-
 services/etc/camera_service.cfg               |   8 +
 199 files changed, 12280 insertions(+), 1400 deletions(-)
 create mode 100644 frameworks/native/camera/src/deferred_proc_session/deferred_video_proc_session.cpp
 create mode 100755 frameworks/native/camera/test/unittest/include/camera_deferred_video_unittest.h
 create mode 100755 frameworks/native/camera/test/unittest/src/v1_1/camera_deferred_video_unittest.cpp
 create mode 100644 interfaces/inner_api/native/camera/include/deferred_proc_session/deferred_type.h
 create mode 100644 interfaces/inner_api/native/camera/include/deferred_proc_session/deferred_video_proc_session.h
 create mode 100644 services/deferred_processing_service/binder/IDeferredVideoProcessingSession.idl
 create mode 100644 services/deferred_processing_service/binder/IDeferredVideoProcessingSessionCallback.idl
 create mode 100644 services/deferred_processing_service/binder/base/include/ideferred_video_processing_session.h
 create mode 100644 services/deferred_processing_service/binder/base/include/ideferred_video_processing_session_callback.h
 create mode 100644 services/deferred_processing_service/binder/client/include/deferred_video_processing_session_callback_proxy.h
 create mode 100644 services/deferred_processing_service/binder/client/include/deferred_video_processing_session_proxy.h
 create mode 100644 services/deferred_processing_service/binder/client/src/deferred_video_processing_session_callback_proxy.cpp
 create mode 100644 services/deferred_processing_service/binder/client/src/deferred_video_processing_session_proxy.cpp
 create mode 100644 services/deferred_processing_service/binder/server/include/deferred_video_processing_session_callback_stub.h
 create mode 100644 services/deferred_processing_service/binder/server/include/deferred_video_processing_session_stub.h
 create mode 100644 services/deferred_processing_service/binder/server/src/deferred_video_processing_session_callback_stub.cpp
 create mode 100644 services/deferred_processing_service/binder/server/src/deferred_video_processing_session_stub.cpp
 create mode 100644 services/deferred_processing_service/include/base/command_server/command.h
 create mode 100644 services/deferred_processing_service/include/base/command_server/command_server.h
 create mode 100644 services/deferred_processing_service/include/base/command_server/command_server_impl.h
 create mode 100644 services/deferred_processing_service/include/base/dps.h
 create mode 100644 services/deferred_processing_service/include/base/ivideo_process_callbacks.h
 create mode 100644 services/deferred_processing_service/include/dfx/dps_video_report.h
 create mode 100644 services/deferred_processing_service/include/event_monitor/base/events_strategy.h
 create mode 100644 services/deferred_processing_service/include/event_monitor/command/event_status_change_command.h
 create mode 100644 services/deferred_processing_service/include/event_monitor/events_info.h
 create mode 100644 services/deferred_processing_service/include/event_monitor/events_subscriber.h
 create mode 100644 services/deferred_processing_service/include/event_monitor/impl/battery_level_strategy.h
 create mode 100644 services/deferred_processing_service/include/event_monitor/impl/battery_strategy.h
 create mode 100644 services/deferred_processing_service/include/event_monitor/impl/charging_strategy.h
 create mode 100644 services/deferred_processing_service/include/event_monitor/impl/screen_strategy.h
 create mode 100644 services/deferred_processing_service/include/event_monitor/impl/thermal_strategy.h
 create mode 100644 services/deferred_processing_service/include/media_manager/demuxer.h
 create mode 100644 services/deferred_processing_service/include/media_manager/media_format.h
 create mode 100644 services/deferred_processing_service/include/media_manager/media_manager.h
 create mode 100644 services/deferred_processing_service/include/media_manager/mpeg_manager.h
 create mode 100644 services/deferred_processing_service/include/media_manager/mpeg_manager_factory.h
 create mode 100644 services/deferred_processing_service/include/media_manager/muxer.h
 create mode 100644 services/deferred_processing_service/include/media_manager/reader.h
 create mode 100644 services/deferred_processing_service/include/media_manager/track.h
 create mode 100644 services/deferred_processing_service/include/media_manager/track_factory.h
 create mode 100644 services/deferred_processing_service/include/media_manager/writer.h
 create mode 100644 services/deferred_processing_service/include/post_processor/command/service_died_command.h
 create mode 100644 services/deferred_processing_service/include/post_processor/command/video_process_command.h
 create mode 100644 services/deferred_processing_service/include/post_processor/video_post_processor.h
 create mode 100644 services/deferred_processing_service/include/schedule/base/ischeduler_video_state.h
 create mode 100644 services/deferred_processing_service/include/schedule/impl/video_battery_level_state.h
 create mode 100644 services/deferred_processing_service/include/schedule/impl/video_battery_state.h
 create mode 100644 services/deferred_processing_service/include/schedule/impl/video_camera_state.h
 create mode 100644 services/deferred_processing_service/include/schedule/impl/video_charging_state.h
 create mode 100644 services/deferred_processing_service/include/schedule/impl/video_hal_state.h
 create mode 100644 services/deferred_processing_service/include/schedule/impl/video_media_library_state.h
 create mode 100644 services/deferred_processing_service/include/schedule/impl/video_photo_process_state.h
 create mode 100644 services/deferred_processing_service/include/schedule/impl/video_screen_state.h
 create mode 100644 services/deferred_processing_service/include/schedule/impl/video_temperature_state.h
 create mode 100644 services/deferred_processing_service/include/schedule/video_processor/deferred_video_controller.h
 create mode 100644 services/deferred_processing_service/include/schedule/video_processor/deferred_video_processor.h
 create mode 100644 services/deferred_processing_service/include/schedule/video_processor/strategy/ivideo_state_change_listener.h
 create mode 100644 services/deferred_processing_service/include/schedule/video_processor/strategy/ivideo_strategy.h
 create mode 100644 services/deferred_processing_service/include/schedule/video_processor/strategy/video_strategy_center.h
 create mode 100644 services/deferred_processing_service/include/schedule/video_processor/video_job_repository/deferred_video_job.h
 create mode 100644 services/deferred_processing_service/include/schedule/video_processor/video_job_repository/ivideo_job_repository_listener.h
 create mode 100644 services/deferred_processing_service/include/schedule/video_processor/video_job_repository/video_job_queue.h
 create mode 100644 services/deferred_processing_service/include/schedule/video_processor/video_job_repository/video_job_repository.h
 create mode 100644 services/deferred_processing_service/include/session/command/session_command.h
 create mode 100644 services/deferred_processing_service/include/session/command/sync_command.h
 create mode 100644 services/deferred_processing_service/include/session/command/video_command.h
 create mode 100644 services/deferred_processing_service/include/session/video_session/deferred_video_processing_session.h
 create mode 100644 services/deferred_processing_service/include/session/video_session/video_session_info.h
 create mode 100644 services/deferred_processing_service/include/utils/dp_catch.h
 create mode 100644 services/deferred_processing_service/include/utils/dp_power_manager.h
 create mode 100644 services/deferred_processing_service/include/utils/dp_timer.h
 create mode 100644 services/deferred_processing_service/src/base/basic_definitions.cpp
 create mode 100644 services/deferred_processing_service/src/base/command_server/command.cpp
 create mode 100644 services/deferred_processing_service/src/base/command_server/command_server.cpp
 create mode 100644 services/deferred_processing_service/src/base/command_server/command_server_impl.cpp
 create mode 100644 services/deferred_processing_service/src/base/dps.cpp
 create mode 100644 services/deferred_processing_service/src/dfx/dps_video_report.cpp
 create mode 100644 services/deferred_processing_service/src/event_monitor/command/event_status_change_command.cpp
 create mode 100644 services/deferred_processing_service/src/event_monitor/events_info.cpp
 create mode 100644 services/deferred_processing_service/src/event_monitor/events_subscriber.cpp
 create mode 100644 services/deferred_processing_service/src/event_monitor/impl/battery_level_strategy.cpp
 create mode 100644 services/deferred_processing_service/src/event_monitor/impl/battery_strategy.cpp
 create mode 100644 services/deferred_processing_service/src/event_monitor/impl/charging_strategy.cpp
 create mode 100644 services/deferred_processing_service/src/event_monitor/impl/screen_strategy.cpp
 create mode 100644 services/deferred_processing_service/src/event_monitor/impl/thermal_strategy.cpp
 create mode 100644 services/deferred_processing_service/src/media_manager/demuxer.cpp
 create mode 100644 services/deferred_processing_service/src/media_manager/media_manager.cpp
 create mode 100644 services/deferred_processing_service/src/media_manager/mpeg_manager.cpp
 create mode 100644 services/deferred_processing_service/src/media_manager/mpeg_manager_factory.cpp
 create mode 100644 services/deferred_processing_service/src/media_manager/muxer.cpp
 create mode 100644 services/deferred_processing_service/src/media_manager/reader.cpp
 create mode 100644 services/deferred_processing_service/src/media_manager/track.cpp
 create mode 100644 services/deferred_processing_service/src/media_manager/track_factory.cpp
 create mode 100644 services/deferred_processing_service/src/media_manager/writer.cpp
 create mode 100644 services/deferred_processing_service/src/post_processor/command/service_died_command.cpp
 create mode 100644 services/deferred_processing_service/src/post_processor/command/video_process_command.cpp
 create mode 100644 services/deferred_processing_service/src/post_processor/video_post_processor.cpp
 create mode 100644 services/deferred_processing_service/src/schedule/base/ischeduler_video_state.cpp
 create mode 100644 services/deferred_processing_service/src/schedule/impl/video_battery_level_state.cpp
 create mode 100644 services/deferred_processing_service/src/schedule/impl/video_battery_state.cpp
 create mode 100644 services/deferred_processing_service/src/schedule/impl/video_camera_state.cpp
 create mode 100644 services/deferred_processing_service/src/schedule/impl/video_charging_state.cpp
 create mode 100644 services/deferred_processing_service/src/schedule/impl/video_hal_state.cpp
 create mode 100644 services/deferred_processing_service/src/schedule/impl/video_media_library_state.cpp
 create mode 100644 services/deferred_processing_service/src/schedule/impl/video_photo_process_state.cpp
 create mode 100644 services/deferred_processing_service/src/schedule/impl/video_screen_state.cpp
 create mode 100644 services/deferred_processing_service/src/schedule/impl/video_temperature_state.cpp
 create mode 100644 services/deferred_processing_service/src/schedule/video_processor/deferred_video_controller.cpp
 create mode 100644 services/deferred_processing_service/src/schedule/video_processor/deferred_video_processor.cpp
 create mode 100644 services/deferred_processing_service/src/schedule/video_processor/strategy/video_strategy_center.cpp
 create mode 100644 services/deferred_processing_service/src/schedule/video_processor/video_job_repository/deferred_video_job.cpp
 create mode 100644 services/deferred_processing_service/src/schedule/video_processor/video_job_repository/video_job_queue.cpp
 create mode 100644 services/deferred_processing_service/src/schedule/video_processor/video_job_repository/video_job_repository.cpp
 create mode 100644 services/deferred_processing_service/src/session/command/session_command.cpp
 create mode 100644 services/deferred_processing_service/src/session/command/sync_command.cpp
 create mode 100644 services/deferred_processing_service/src/session/command/video_command.cpp
 create mode 100644 services/deferred_processing_service/src/session/video_session/deferred_video_processing_session.cpp
 create mode 100644 services/deferred_processing_service/src/session/video_session/video_session_info.cpp
 create mode 100644 services/deferred_processing_service/src/utils/dp_power_manager.cpp
 create mode 100644 services/deferred_processing_service/src/utils/dp_timer.cpp

diff --git a/bundle.json b/bundle.json
index e2734fc03..6bd68433b 100644
--- a/bundle.json
+++ b/bundle.json
@@ -52,6 +52,8 @@
               "samgr",
               "sensor",
               "thermal_manager",
+              "battery_manager",
+              "power_manager",
               "window_manager",
               "memmgr"
             ],
diff --git a/frameworks/js/camera_napi/src/output/video_output_napi.cpp b/frameworks/js/camera_napi/src/output/video_output_napi.cpp
index b22e9c224..b4be39046 100644
--- a/frameworks/js/camera_napi/src/output/video_output_napi.cpp
+++ b/frameworks/js/camera_napi/src/output/video_output_napi.cpp
@@ -65,7 +65,7 @@ thread_local uint32_t VideoOutputNapi::videoOutputTaskId = CAMERA_VIDEO_OUTPUT_T
 
 VideoCallbackListener::VideoCallbackListener(napi_env env) : ListenerBase(env) {}
 
-void VideoCallbackListener::UpdateJSCallbackAsync(VideoOutputEventType eventType, const int32_t value) const
+void VideoCallbackListener::UpdateJSCallbackAsync(VideoOutputEventType eventType, const VideoCallbackInfo& info) const
 {
     MEDIA_DEBUG_LOG("UpdateJSCallbackAsync is called");
     uv_loop_s* loop = nullptr;
@@ -80,14 +80,14 @@ void VideoCallbackListener::UpdateJSCallbackAsync(VideoOutputEventType eventType
         return;
     }
     std::unique_ptr<VideoOutputCallbackInfo> callbackInfo =
-        std::make_unique<VideoOutputCallbackInfo>(eventType, value, shared_from_this());
+        std::make_unique<VideoOutputCallbackInfo>(eventType, info, shared_from_this());
     work->data = callbackInfo.get();
     int ret = uv_queue_work_with_qos(loop, work, [] (uv_work_t* work) {}, [] (uv_work_t* work, int status) {
         VideoOutputCallbackInfo* callbackInfo = reinterpret_cast<VideoOutputCallbackInfo *>(work->data);
         if (callbackInfo) {
             auto listener = callbackInfo->listener_.lock();
             if (listener) {
-                listener->UpdateJSCallback(callbackInfo->eventType_, callbackInfo->value_);
+                listener->UpdateJSCallback(callbackInfo->eventType_, callbackInfo->info_);
             }
             delete callbackInfo;
         }
@@ -105,25 +105,74 @@ void VideoCallbackListener::OnFrameStarted() const
 {
     CAMERA_SYNC_TRACE;
     MEDIA_DEBUG_LOG("OnFrameStarted is called");
-    UpdateJSCallbackAsync(VideoOutputEventType::VIDEO_FRAME_START, -1);
+    VideoCallbackInfo info;
+    UpdateJSCallbackAsync(VideoOutputEventType::VIDEO_FRAME_START, info);
 }
 
 void VideoCallbackListener::OnFrameEnded(const int32_t frameCount) const
 {
     CAMERA_SYNC_TRACE;
     MEDIA_DEBUG_LOG("OnFrameEnded is called, frameCount: %{public}d", frameCount);
-    UpdateJSCallbackAsync(VideoOutputEventType::VIDEO_FRAME_END, frameCount);
+    VideoCallbackInfo info;
+    info.frameCount = frameCount;
+    UpdateJSCallbackAsync(VideoOutputEventType::VIDEO_FRAME_END, info);
 }
 
 void VideoCallbackListener::OnError(const int32_t errorCode) const
 {
     MEDIA_DEBUG_LOG("OnError is called, errorCode: %{public}d", errorCode);
-    UpdateJSCallbackAsync(VideoOutputEventType::VIDEO_FRAME_ERROR, errorCode);
+    VideoCallbackInfo info;
+    info.errorCode = errorCode;
+    UpdateJSCallbackAsync(VideoOutputEventType::VIDEO_FRAME_ERROR, info);
 }
 
-void VideoCallbackListener::UpdateJSCallback(VideoOutputEventType eventType, const int32_t value) const
+void VideoCallbackListener::OnDeferredVideoEnhancementInfo(const CaptureEndedInfoExt captureEndedInfo) const
+{
+    MEDIA_DEBUG_LOG("OnDeferredVideoEnhancementInfo is called");
+    VideoCallbackInfo info;
+    info.isDeferredVideoEnhancementAvailable = captureEndedInfo.isDeferredVideoEnhancementAvailable;
+    info.videoId = captureEndedInfo.videoId;
+    MEDIA_INFO_LOG("OnDeferredVideoEnhancementInfo isDeferredVideo:%{public}d videoId:%{public}s ",
+        info.isDeferredVideoEnhancementAvailable, info.videoId.c_str());
+    UpdateJSCallbackAsync(VideoOutputEventType::VIDEO_DEFERRED_ENHANCEMENT, info);
+}
+
+void VideoCallbackListener::ExecuteOnDeferredVideoCb(const VideoCallbackInfo& info) const
+{
+    MEDIA_INFO_LOG("ExecuteOnDeferredVideoCb");
+    napi_value result[ARGS_TWO] = {nullptr, nullptr};
+    napi_value retVal;
+
+    napi_get_undefined(env_, &result[PARAM0]);
+    napi_get_undefined(env_, &result[PARAM1]);
+    
+    napi_value propValue;
+    napi_create_object(env_, &result[PARAM1]);
+    napi_get_boolean(env_, info.isDeferredVideoEnhancementAvailable, &propValue);
+    napi_set_named_property(env_, result[PARAM1], "isDeferredVideoEnhancementAvailable", propValue);
+    napi_create_string_utf8(env_, info.videoId.c_str(), NAPI_AUTO_LENGTH, &propValue);
+    napi_set_named_property(env_, result[PARAM1], "videoId", propValue);
+
+    ExecuteCallbackNapiPara callbackNapiPara { .recv = nullptr, .argc = ARGS_TWO, .argv = result, .result = &retVal };
+    ExecuteCallback(CONST_VIDEO_DEFERRED_ENHANCEMENT, callbackNapiPara);
+}
+
+void VideoCallbackListener::UpdateJSCallback(VideoOutputEventType eventType, const VideoCallbackInfo& info) const
 {
     MEDIA_DEBUG_LOG("UpdateJSCallback is called");
+    switch (eventType) {
+        // case VideoOutputEventType::VIDEO_FRAME_START:
+        // case VideoOutputEventType::VIDEO_FRAME_END:
+        // case VideoOutputEventType::VIDEO_FRAME_ERROR:
+        // case VideoOutputEventType::VIDEO_INVALID_TYPE:
+        //     break;
+        case VideoOutputEventType::VIDEO_DEFERRED_ENHANCEMENT:
+            ExecuteOnDeferredVideoCb(info);
+            break;
+        default:
+            MEDIA_ERR_LOG("Incorrect photo callback event type received from JS");
+    }
+
     napi_value result[ARGS_ONE];
     napi_value retVal;
     napi_value propValue;
@@ -135,7 +184,7 @@ void VideoCallbackListener::UpdateJSCallback(VideoOutputEventType eventType, con
     }
     if (eventType == VideoOutputEventType::VIDEO_FRAME_ERROR) {
         napi_create_object(env_, &result[PARAM0]);
-        napi_create_int32(env_, value, &propValue);
+        napi_create_int32(env_, info.errorCode, &propValue);
         napi_set_named_property(env_, result[PARAM0], "code", propValue);
     } else {
         napi_get_undefined(env_, &result[PARAM0]);
@@ -182,7 +231,10 @@ napi_value VideoOutputNapi::Init(napi_env env, napi_value exports)
         DECLARE_NAPI_FUNCTION("getActiveProfile", GetActiveProfile),
         DECLARE_NAPI_FUNCTION("getSupportedVideoMetaTypes", GetSupportedVideoMetaTypes),
         DECLARE_NAPI_FUNCTION("attachMetaSurface", AttachMetaSurface),
-        DECLARE_NAPI_FUNCTION("getVideoRotation", GetVideoRotation)
+        DECLARE_NAPI_FUNCTION("getVideoRotation", GetVideoRotation),
+        DECLARE_NAPI_FUNCTION("isAutoDeferredVideoEnhancementSupported", IsAutoDeferredVideoEnhancementSupported),
+        DECLARE_NAPI_FUNCTION("isAutoDeferredVideoEnhancementEnabled", IsAutoDeferredVideoEnhancementEnabled),
+        DECLARE_NAPI_FUNCTION("enableAutoDeferredVideoEnhancement", EnableAutoDeferredVideoEnhancement)
     };
 
     status = napi_define_class(env, CAMERA_VIDEO_OUTPUT_NAPI_CLASS_NAME, NAPI_AUTO_LENGTH,
@@ -793,6 +845,26 @@ void VideoOutputNapi::UnregisterErrorCallbackListener(
     videoCallback_->RemoveCallbackRef(CONST_VIDEO_FRAME_ERROR, callback);
 }
 
+void VideoOutputNapi::RegisterDeferredVideoCallbackListener(
+    const std::string& eventName, napi_env env, napi_value callback, const std::vector<napi_value>& args, bool isOnce)
+{
+    if (videoCallback_ == nullptr) {
+        videoCallback_ = make_shared<VideoCallbackListener>(env);
+        videoOutput_->SetCallback(videoCallback_);
+    }
+    videoCallback_->SaveCallbackReference(CONST_VIDEO_DEFERRED_ENHANCEMENT, callback, isOnce);
+}
+
+void VideoOutputNapi::UnregisterDeferredVideoCallbackListener(
+    const std::string& eventName, napi_env env, napi_value callback, const std::vector<napi_value>& args)
+{
+    if (videoCallback_ == nullptr) {
+        MEDIA_ERR_LOG("videoCallback is null");
+        return;
+    }
+    videoCallback_->RemoveCallbackRef(CONST_VIDEO_DEFERRED_ENHANCEMENT, callback);
+}
+
 const VideoOutputNapi::EmitterFunctions& VideoOutputNapi::GetEmitterFunctions()
 {
     static const EmitterFunctions funMap = {
@@ -804,7 +876,10 @@ const VideoOutputNapi::EmitterFunctions& VideoOutputNapi::GetEmitterFunctions()
             &VideoOutputNapi::UnregisterFrameEndCallbackListener } },
         { CONST_VIDEO_FRAME_ERROR, {
             &VideoOutputNapi::RegisterErrorCallbackListener,
-            &VideoOutputNapi::UnregisterErrorCallbackListener } } };
+            &VideoOutputNapi::UnregisterErrorCallbackListener } },
+        { CONST_VIDEO_DEFERRED_ENHANCEMENT, {
+            &VideoOutputNapi::RegisterDeferredVideoCallbackListener,
+            &VideoOutputNapi::UnregisterDeferredVideoCallbackListener } }};
     return funMap;
 }
 
@@ -822,5 +897,94 @@ napi_value VideoOutputNapi::Off(napi_env env, napi_callback_info info)
 {
     return ListenerTemplate<VideoOutputNapi>::Off(env, info);
 }
+
+napi_value VideoOutputNapi::IsAutoDeferredVideoEnhancementSupported(napi_env env, napi_callback_info info)
+{
+    napi_value result = CameraNapiUtils::GetUndefinedValue(env);
+    if (!CameraNapiSecurity::CheckSystemApp(env)) {
+        MEDIA_ERR_LOG("SystemApi IsAutoDeferredVideoEnhancementSupported is called!");
+        return result;
+    }
+    MEDIA_DEBUG_LOG("VideoOutputNapi::IsAutoDeferredVideoEnhancementSupported is called");
+ 
+    VideoOutputNapi* videoOutputNapi = nullptr;
+    CameraNapiParamParser jsParamParser(env, info, videoOutputNapi);
+    if (!jsParamParser.AssertStatus(SERVICE_FATL_ERROR, "parse parameter occur error")) {
+        MEDIA_ERR_LOG("VideoOutputNapi::IsAutoDeferredVideoEnhancementSupported parse parameter occur error");
+        return result;
+    }
+    if (videoOutputNapi->videoOutput_ == nullptr) {
+        MEDIA_ERR_LOG("VideoOutputNapi::IsAutoDeferredVideoEnhancementSupported get native object fail");
+        CameraNapiUtils::ThrowError(env, SERVICE_FATL_ERROR, "get native object fail");
+        return result;
+    }
+    int32_t res = videoOutputNapi->videoOutput_->IsAutoDeferredVideoEnhancementSupported();
+    if (res > 1) {
+        CameraNapiUtils::ThrowError(env, SERVICE_FATL_ERROR, "inner fail");
+        return result;
+    }
+    napi_get_boolean(env, res, &result);
+    return result;
+}
+
+napi_value VideoOutputNapi::IsAutoDeferredVideoEnhancementEnabled(napi_env env, napi_callback_info info)
+{
+    napi_value result = CameraNapiUtils::GetUndefinedValue(env);
+    if (!CameraNapiSecurity::CheckSystemApp(env)) {
+        MEDIA_ERR_LOG("SystemApi IsAutoDeferredVideoEnhancementEnabled is called!");
+        return result;
+    }
+    MEDIA_DEBUG_LOG("VideoOutputNapi::IsAutoDeferredVideoEnhancementEnabled is called");
+ 
+    VideoOutputNapi* videoOutputNapi = nullptr;
+    CameraNapiParamParser jsParamParser(env, info, videoOutputNapi);
+    if (!jsParamParser.AssertStatus(SERVICE_FATL_ERROR, "parse parameter occur error")) {
+        MEDIA_ERR_LOG("VideoOutputNapi::IsAutoDeferredVideoEnhancementEnabled parse parameter occur error");
+        return result;
+    }
+    if (videoOutputNapi->videoOutput_ == nullptr) {
+        MEDIA_ERR_LOG("VideoOutputNapi::IsAutoDeferredVideoEnhancementEnabled get native object fail");
+        CameraNapiUtils::ThrowError(env, SERVICE_FATL_ERROR, "get native object fail");
+        return result;
+    }
+    int32_t res = videoOutputNapi->videoOutput_->IsAutoDeferredVideoEnhancementEnabled();
+    if (res > 1) {
+        CameraNapiUtils::ThrowError(env, SERVICE_FATL_ERROR, "inner fail");
+        return result;
+    }
+    napi_get_boolean(env, res, &result);
+    return result;
+}
+
+napi_value VideoOutputNapi::EnableAutoDeferredVideoEnhancement(napi_env env, napi_callback_info info)
+{
+    napi_value result = CameraNapiUtils::GetUndefinedValue(env);
+    if (!CameraNapiSecurity::CheckSystemApp(env)) {
+        MEDIA_ERR_LOG("SystemApi EnableAutoDeferredVideoEnhancement is called!");
+        return result;
+    }
+    napi_status status;
+    size_t argc = ARGS_ONE;
+    napi_value argv[ARGS_ONE] = {0};
+    napi_value thisVar = nullptr;
+    CAMERA_NAPI_GET_JS_ARGS(env, info, argc, argv, thisVar);
+    if (argc != ARGS_ONE) {
+        CameraNapiUtils::ThrowError(env, INVALID_ARGUMENT, "requires one parameter");
+        return result;
+    }
+    int32_t res = 0;
+    napi_get_undefined(env, &result);
+    VideoOutputNapi* videoOutputNapi = nullptr;
+    status = napi_unwrap(env, thisVar, reinterpret_cast<void**>(&videoOutputNapi));
+    if (status == napi_ok && videoOutputNapi != nullptr) {
+        bool isEnable;
+        napi_get_value_bool(env, argv[PARAM0], &isEnable);
+        res = videoOutputNapi->videoOutput_->EnableAutoDeferredVideoEnhancement(isEnable);
+    }
+    if (res > 0) {
+        CameraNapiUtils::ThrowError(env, SERVICE_FATL_ERROR, "inner fail");
+    }
+    return result;
+}
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/frameworks/native/camera/BUILD.gn b/frameworks/native/camera/BUILD.gn
index 7dad281b4..08b757696 100644
--- a/frameworks/native/camera/BUILD.gn
+++ b/frameworks/native/camera/BUILD.gn
@@ -47,6 +47,7 @@ config("camera_framework_local_config") {
     "${multimedia_camera_framework_path}/services/deferred_processing_service/binder/server/include",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/session",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/session/photo_session",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/session/video_session",
   ]
 }
 
@@ -64,8 +65,12 @@ ohos_shared_library("camera_framework") {
   sources = [
     "${multimedia_camera_framework_path}/services/deferred_processing_service/binder/client/src/deferred_photo_processing_session_callback_proxy.cpp",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/binder/client/src/deferred_photo_processing_session_proxy.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/binder/client/src/deferred_video_processing_session_callback_proxy.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/binder/client/src/deferred_video_processing_session_proxy.cpp",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/binder/server/src/deferred_photo_processing_session_callback_stub.cpp",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/binder/server/src/deferred_photo_processing_session_stub.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/binder/server/src/deferred_video_processing_session_callback_stub.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/binder/server/src/deferred_video_processing_session_stub.cpp",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/task_manager/task_group/base_task_group.cpp",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/task_manager/task_group/delayed_task_group.cpp",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/task_manager/task_group/task_group.cpp",
@@ -98,6 +103,7 @@ ohos_shared_library("camera_framework") {
     "src/ability/camera_ability_const.cpp",
     "src/ability/camera_ability_parse_util.cpp",
     "src/deferred_proc_session/deferred_photo_proc_session.cpp",
+    "src/deferred_proc_session/deferred_video_proc_session.cpp",
     "src/input/camera_device.cpp",
     "src/input/camera_input.cpp",
     "src/input/camera_manager.cpp",
@@ -170,6 +176,8 @@ ohos_shared_library("camera_framework") {
 
   external_deps = [
     "access_token:libtokenid_sdk",
+    "bundle_framework:appexecfwk_base",
+    "bundle_framework:appexecfwk_core",
     "c_utils:utils",
     "data_share:datashare_common",
     "data_share:datashare_consumer",
diff --git a/frameworks/native/camera/src/deferred_proc_session/deferred_video_proc_session.cpp b/frameworks/native/camera/src/deferred_proc_session/deferred_video_proc_session.cpp
new file mode 100644
index 000000000..55e61ef31
--- /dev/null
+++ b/frameworks/native/camera/src/deferred_proc_session/deferred_video_proc_session.cpp
@@ -0,0 +1,222 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "deferred_proc_session/deferred_video_proc_session.h"
+#include "camera_log.h"
+#include "camera_util.h"
+#include "iservice_registry.h"
+#include "system_ability_definition.h"
+
+namespace OHOS {
+namespace CameraStandard {
+
+int32_t DeferredVideoProcessingSessionCallback::OnProcessVideoDone(const std::string& videoId,
+    const sptr<IPCFileDescriptor>& ipcFileDescriptor)
+{
+    MEDIA_INFO_LOG("DeferredVideoProcessingSessionCallback::OnProcessVideoDone() is called!");
+    if (deferredVideoProcSession_ != nullptr && deferredVideoProcSession_->GetCallback() != nullptr) {
+        deferredVideoProcSession_->GetCallback()->OnProcessVideoDone(videoId, ipcFileDescriptor);
+    } else {
+        MEDIA_INFO_LOG("DeferredVideoProcessingSessionCallback::OnProcessVideoDone not set!, Discarding callback");
+    }
+    return ERR_OK;
+}
+
+int32_t DeferredVideoProcessingSessionCallback::OnError(const std::string& videoId,
+    int32_t errorCode)
+{
+    MEDIA_INFO_LOG("DeferredVideoProcessingSessionCallback::OnError() is called, errorCode: %{public}d", errorCode);
+    if (deferredVideoProcSession_ != nullptr && deferredVideoProcSession_->GetCallback() != nullptr) {
+        deferredVideoProcSession_->GetCallback()->OnError(videoId, DpsErrorCode(errorCode));
+    } else {
+        MEDIA_INFO_LOG("DeferredVideoProcessingSessionCallback::OnError not set!, Discarding callback");
+    }
+    return ERR_OK;
+}
+
+int32_t DeferredVideoProcessingSessionCallback::OnStateChanged(int32_t status)
+{
+    MEDIA_INFO_LOG("DeferredVideoProcessingSessionCallback::OnStateChanged() is called, status:%{public}d", status);
+    if (deferredVideoProcSession_ != nullptr && deferredVideoProcSession_->GetCallback() != nullptr) {
+        deferredVideoProcSession_->GetCallback()->OnStateChanged(DpsStatusCode(status));
+    } else {
+        MEDIA_INFO_LOG("DeferredVideoProcessingSessionCallback::OnStateChanged not set!, Discarding callback");
+    }
+    return ERR_OK;
+}
+
+DeferredVideoProcSession::DeferredVideoProcSession(int userId,
+    std::shared_ptr<IDeferredVideoProcSessionCallback> callback)
+{
+    MEDIA_INFO_LOG("enter.");
+    userId_ = userId;
+    callback_ = callback;
+}
+
+DeferredVideoProcSession::~DeferredVideoProcSession()
+{
+    MEDIA_INFO_LOG("DeferredVideoProcSession::DeferredVideoProcSession Destructor!");
+    if (remoteSession_ != nullptr) {
+        (void)remoteSession_->AsObject()->RemoveDeathRecipient(deathRecipient_);
+        remoteSession_ = nullptr;
+    }
+}
+
+void DeferredVideoProcSession::BeginSynchronize()
+{
+    if (remoteSession_ == nullptr) {
+        MEDIA_ERR_LOG("DeferredVideoProcSession::BeginSynchronize failed due to binder died.");
+    } else {
+        MEDIA_INFO_LOG("DeferredVideoProcSession:BeginSynchronize() enter.");
+        auto ret = remoteSession_->BeginSynchronize();
+        CHECK_ERROR_PRINT_LOG(ret != ERR_OK, "EndSynchronize failed errorCode: %{public}d", ret);
+    }
+}
+
+void DeferredVideoProcSession::EndSynchronize()
+{
+    if (remoteSession_ == nullptr) {
+        MEDIA_ERR_LOG("DeferredVideoProcSession::EndSynchronize failed due to binder died.");
+    } else {
+        MEDIA_INFO_LOG("DeferredVideoProcSession::EndSynchronize() enter.");
+        auto ret = remoteSession_->EndSynchronize();
+        CHECK_ERROR_PRINT_LOG(ret != ERR_OK, "EndSynchronize failed errorCode: %{public}d", ret);
+    }
+}
+
+void DeferredVideoProcSession::AddVideo(const std::string& videoId, const sptr<IPCFileDescriptor> srcFd,
+    const sptr<IPCFileDescriptor> dstFd)
+{
+    if (remoteSession_ == nullptr) {
+        MEDIA_ERR_LOG("DeferredVideoProcSession::AddVideo failed due to binder died.");
+    } else {
+        MEDIA_INFO_LOG("DeferredVideoProcSession::AddVideo() enter.");
+        auto ret = remoteSession_->AddVideo(videoId, srcFd, dstFd);
+        CHECK_ERROR_PRINT_LOG(ret != ERR_OK, "AddVideo failed errorCode: %{public}d", ret);
+    }
+}
+
+void DeferredVideoProcSession::RemoveVideo(const std::string& videoId, const bool restorable)
+{
+    if (remoteSession_ == nullptr) {
+        MEDIA_ERR_LOG("DeferredVideoProcSession::RemoveVideo failed due to binder died.");
+    } else {
+        MEDIA_INFO_LOG("DeferredVideoProcSession RemoveVideo() enter.");
+        auto ret = remoteSession_->RemoveVideo(videoId, restorable);
+        CHECK_ERROR_PRINT_LOG(ret != ERR_OK, "RemoveVideo failed errorCode: %{public}d", ret);
+    }
+}
+
+void DeferredVideoProcSession::RestoreVideo(const std::string& videoId)
+{
+    if (remoteSession_ == nullptr) {
+        MEDIA_ERR_LOG("DeferredVideoProcSession::RestoreVideo failed due to binder died.");
+    } else {
+        MEDIA_INFO_LOG("DeferredVideoProcSession RestoreVideo() enter.");
+        auto ret = remoteSession_->RestoreVideo(videoId);
+        CHECK_ERROR_PRINT_LOG(ret != ERR_OK, "RestoreVideo failed errorCode: %{public}d", ret);
+    }
+}
+
+int32_t DeferredVideoProcSession::SetDeferredVideoSession(
+    sptr<DeferredProcessing::IDeferredVideoProcessingSession>& session)
+{
+    remoteSession_ = session;
+    sptr<IRemoteObject> object = remoteSession_->AsObject();
+    pid_t pid = 0;
+    deathRecipient_ = new(std::nothrow) CameraDeathRecipient(pid);
+    CHECK_AND_RETURN_RET_LOG(deathRecipient_ != nullptr, CAMERA_ALLOC_ERROR, "failed to new CameraDeathRecipient.");
+
+    deathRecipient_->SetNotifyCb(std::bind(&DeferredVideoProcSession::CameraServerDied, this, std::placeholders::_1));
+    bool result = object->AddDeathRecipient(deathRecipient_);
+    if (!result) {
+        MEDIA_ERR_LOG("failed to add deathRecipient");
+        return -1;  // return error
+    }
+    return ERR_OK;
+}
+
+void DeferredVideoProcSession::CameraServerDied(pid_t pid)
+{
+    MEDIA_ERR_LOG("camera server has died, pid:%{public}d!", pid);
+    if (remoteSession_ != nullptr) {
+        (void)remoteSession_->AsObject()->RemoveDeathRecipient(deathRecipient_);
+        remoteSession_ = nullptr;
+    }
+    deathRecipient_ = nullptr;
+    ReconnectDeferredProcessingSession();
+    if (callback_ != nullptr) {
+        MEDIA_INFO_LOG("Reconnect session successful, send sync requestion.");
+        callback_->OnError("", DpsErrorCode::ERROR_SESSION_SYNC_NEEDED);
+    }
+}
+
+void DeferredVideoProcSession::ReconnectDeferredProcessingSession()
+{
+    MEDIA_INFO_LOG("DeferredVideoProcSession::ReconnectDeferredProcessingSession, enter.");
+    ConnectDeferredProcessingSession();
+    if (remoteSession_ == nullptr) {
+        MEDIA_INFO_LOG("Reconnecting deferred processing session failed.");
+        ReconnectDeferredProcessingSession();
+    }
+}
+
+void DeferredVideoProcSession::ConnectDeferredProcessingSession()
+{
+    MEDIA_INFO_LOG("DeferredVideoProcSession::ConnectDeferredProcessingSession, enter.");
+    if (remoteSession_ != nullptr) {
+        MEDIA_INFO_LOG("remoteSession_ is not null");
+        return;
+    }
+    sptr<IRemoteObject> object = nullptr;
+    auto samgr = SystemAbilityManagerClient::GetInstance().GetSystemAbilityManager();
+    if (samgr == nullptr) {
+        MEDIA_ERR_LOG("Failed to get System ability manager");
+        return;
+    }
+    object = samgr->GetSystemAbility(CAMERA_SERVICE_ID);
+    if (object == nullptr) {
+        MEDIA_ERR_LOG("object is null");
+        return;
+    }
+    serviceProxy_ = iface_cast<ICameraService>(object);
+    if (serviceProxy_ == nullptr) {
+        MEDIA_ERR_LOG("serviceProxy_ is null.");
+        return;
+    }
+    sptr<DeferredProcessing::IDeferredVideoProcessingSession> session = nullptr;
+    sptr<DeferredProcessing::IDeferredVideoProcessingSessionCallback> remoteCallback = nullptr;
+    sptr<DeferredVideoProcSession> deferredVideoProcSession = nullptr;
+    deferredVideoProcSession = new(std::nothrow) DeferredVideoProcSession(userId_, callback_);
+    if (deferredVideoProcSession == nullptr) {
+        return;
+    }
+    remoteCallback = new(std::nothrow) DeferredVideoProcessingSessionCallback(deferredVideoProcSession);
+    if (remoteCallback == nullptr) {
+        return;
+    }
+    serviceProxy_->CreateDeferredVideoProcessingSession(userId_, remoteCallback, session);
+    if (session) {
+        SetDeferredVideoSession(session);
+    }
+}
+
+std::shared_ptr<IDeferredVideoProcSessionCallback> DeferredVideoProcSession::GetCallback()
+{
+    return callback_;
+}
+
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/frameworks/native/camera/src/input/camera_manager.cpp b/frameworks/native/camera/src/input/camera_manager.cpp
index 6fa59d107..0bf3491ab 100644
--- a/frameworks/native/camera/src/input/camera_manager.cpp
+++ b/frameworks/native/camera/src/input/camera_manager.cpp
@@ -431,6 +431,67 @@ int CameraManager::CreateDeferredPhotoProcessingSession(int userId,
     return CameraErrorCode::SUCCESS;
 }
 
+sptr<DeferredVideoProcSession> CameraManager::CreateDeferredVideoProcessingSession(int userId,
+    std::shared_ptr<IDeferredVideoProcSessionCallback> callback)
+{
+    CAMERA_SYNC_TRACE;
+    sptr<DeferredVideoProcSession> deferredVideoProcSession = nullptr;
+    int ret = CreateDeferredVideoProcessingSession(userId, callback, &deferredVideoProcSession);
+    if (ret != CameraErrorCode::SUCCESS) {
+        MEDIA_ERR_LOG("Failed to CreateDeferredVideoProcessingSession with error code:%{public}d", ret);
+        return nullptr;
+    }
+    return deferredVideoProcSession;
+}
+
+int CameraManager::CreateDeferredVideoProcessingSession(int userId,
+    std::shared_ptr<IDeferredVideoProcSessionCallback> callback,
+    sptr<DeferredVideoProcSession> *pDeferredVideoProcSession)
+{
+    CAMERA_SYNC_TRACE;
+    sptr<DeferredProcessing::IDeferredVideoProcessingSession> session = nullptr;
+    sptr<DeferredProcessing::IDeferredVideoProcessingSessionCallback> remoteCallback = nullptr;
+    sptr<DeferredVideoProcSession> deferredVideoProcSession = nullptr;
+    int32_t retCode = CAMERA_OK;
+
+    sptr<IRemoteObject> object = nullptr;
+    auto samgr = SystemAbilityManagerClient::GetInstance().GetSystemAbilityManager();
+    if (samgr == nullptr) {
+        MEDIA_ERR_LOG("Failed to get System ability manager");
+        return CameraErrorCode::SERVICE_FATL_ERROR;
+    }
+    object = samgr->GetSystemAbility(CAMERA_SERVICE_ID);
+    if (object == nullptr) {
+        MEDIA_ERR_LOG("object is null");
+        return CameraErrorCode::SERVICE_FATL_ERROR;
+    }
+    sptr<ICameraService> serviceProxy = iface_cast<ICameraService>(object);
+
+    if (serviceProxy == nullptr) {
+        MEDIA_ERR_LOG("serviceProxy is null");
+        return CameraErrorCode::SERVICE_FATL_ERROR;
+    }
+
+    deferredVideoProcSession = new(std::nothrow) DeferredVideoProcSession(userId, callback);
+    remoteCallback = new(std::nothrow) DeferredVideoProcessingSessionCallback(deferredVideoProcSession);
+
+    retCode = serviceProxy->CreateDeferredVideoProcessingSession(userId, remoteCallback, session);
+    if (retCode == CAMERA_OK) {
+        if (session != nullptr) {
+            deferredVideoProcSession->SetDeferredVideoSession(session);
+        } else {
+            MEDIA_ERR_LOG("Failed to CreateDeferredVideoProcessingSession as session is null");
+            return CameraErrorCode::SERVICE_FATL_ERROR;
+        }
+    } else {
+        MEDIA_ERR_LOG("Failed to get video session!, %{public}d", retCode);
+        return ServiceToCameraError(retCode);
+    }
+
+    *pDeferredVideoProcSession = deferredVideoProcSession;
+    return CameraErrorCode::SUCCESS;
+}
+
 sptr<PhotoOutput> CameraManager::CreatePhotoOutput(sptr<IBufferProducer> &surface)
 {
     CAMERA_SYNC_TRACE;
diff --git a/frameworks/native/camera/src/output/preview_output.cpp b/frameworks/native/camera/src/output/preview_output.cpp
index 8cad65a21..eb137776e 100644
--- a/frameworks/native/camera/src/output/preview_output.cpp
+++ b/frameworks/native/camera/src/output/preview_output.cpp
@@ -165,6 +165,13 @@ int32_t PreviewOutputCallbackImpl::OnSketchStatusChanged(SketchStatus status)
     return CAMERA_OK;
 }
 
+int32_t PreviewOutputCallbackImpl::OnDeferredVideoEnhancementInfo(CaptureEndedInfoExt captureEndedInfo)
+{
+    MEDIA_INFO_LOG("PreviewOutput::OnDeferredVideoEnhancementInfo called");
+    // empty impl
+    return CAMERA_OK;
+}
+
 int32_t PreviewOutput::OnSketchStatusChanged(SketchStatus status)
 {
     CHECK_ERROR_RETURN_RET(sketchWrapper_ == nullptr, CAMERA_INVALID_STATE);
diff --git a/frameworks/native/camera/src/output/video_output.cpp b/frameworks/native/camera/src/output/video_output.cpp
index 8c8166b23..ddba26b3d 100644
--- a/frameworks/native/camera/src/output/video_output.cpp
+++ b/frameworks/native/camera/src/output/video_output.cpp
@@ -79,6 +79,18 @@ int32_t VideoOutputCallbackImpl::OnSketchStatusChanged(SketchStatus status)
     return CAMERA_OK;
 }
 
+int32_t VideoOutputCallbackImpl::OnDeferredVideoEnhancementInfo(CaptureEndedInfoExt captureEndedInfo)
+{
+    MEDIA_INFO_LOG("VideoOutputCallbackImpl::OnDeferredVideoEnhancementInfo callback in video");
+    auto item = videoOutput_.promote();
+    if (item != nullptr && item->GetApplicationCallback() != nullptr) {
+        item->GetApplicationCallback()->OnDeferredVideoEnhancementInfo(captureEndedInfo);
+    } else {
+        MEDIA_INFO_LOG("Discarding VideoOutputCallbackImpl::OnDeferredVideoEnhancementInfo callback in video");
+    }
+    return CAMERA_OK;
+}
+
 void VideoOutput::SetCallback(std::shared_ptr<VideoStateCallback> callback)
 {
     std::lock_guard<std::mutex> lock(outputCallbackMutex_);
@@ -430,6 +442,7 @@ int32_t VideoOutput::canSetFrameRateRange(int32_t minFrameRate, int32_t maxFrame
     MEDIA_WARNING_LOG("Can not set frame rate range with invalid parameters");
     return CameraErrorCode::INVALID_ARGUMENT;
 }
+
 int32_t VideoOutput::GetVideoRotation(int32_t imageRotation)
 {
     MEDIA_DEBUG_LOG("VideoOutput GetVideoRotation is called");
@@ -465,5 +478,68 @@ int32_t VideoOutput::GetVideoRotation(int32_t imageRotation)
         result, sensorOrientation);
     return result;
 }
+
+int32_t VideoOutput::IsAutoDeferredVideoEnhancementSupported()
+{
+    MEDIA_INFO_LOG("IsAutoDeferredVideoEnhancementSupported");
+    sptr<CameraDevice> cameraObj;
+    auto captureSession = GetSession();
+    CHECK_ERROR_RETURN_RET_LOG(captureSession == nullptr, SERVICE_FATL_ERROR,
+        "VideoOutput IsAutoDeferredVideoEnhancementSupported error!, captureSession is nullptr");
+    auto inputDevice = captureSession->GetInputDevice();
+    CHECK_ERROR_RETURN_RET_LOG(inputDevice == nullptr, SERVICE_FATL_ERROR,
+        "VideoOutput IsAutoDeferredVideoEnhancementSupported error!, inputDevice is nullptr");
+    cameraObj = inputDevice->GetCameraDeviceInfo();
+    CHECK_ERROR_RETURN_RET_LOG(cameraObj == nullptr, SERVICE_FATL_ERROR,
+        "VideoOutput IsAutoDeferredVideoEnhancementSupported error!, cameraObj is nullptr");
+
+    int32_t curMode = captureSession->GetMode();
+    int32_t isSupported  = cameraObj->modeVideoDeferredType_[curMode];
+    MEDIA_INFO_LOG("IsAutoDeferredVideoEnhancementSupported curMode:%{public}d, modeSupportType:%{public}d",
+        curMode, isSupported);
+    return isSupported;
+}
+
+int32_t VideoOutput::IsAutoDeferredVideoEnhancementEnabled()
+{
+    MEDIA_INFO_LOG("VideoOutput IsAutoDeferredVideoEnhancementEnabled");
+    auto captureSession = GetSession();
+    CHECK_ERROR_RETURN_RET_LOG(captureSession == nullptr, SERVICE_FATL_ERROR,
+        "VideoOutput IsAutoDeferredVideoEnhancementEnabled error!, captureSession is nullptr");
+
+    auto inputDevice = captureSession->GetInputDevice();
+    CHECK_ERROR_RETURN_RET_LOG(inputDevice == nullptr, SERVICE_FATL_ERROR,
+        "VideoOutput IsAutoDeferredVideoEnhancementEnabled error!, inputDevice is nullptr");
+
+    sptr<CameraDevice> cameraObj = inputDevice->GetCameraDeviceInfo();
+    CHECK_ERROR_RETURN_RET_LOG(cameraObj == nullptr, SERVICE_FATL_ERROR,
+        "VideoOutput IsAutoDeferredVideoEnhancementEnabled error!, cameraObj is nullptr");
+
+    int32_t curMode = captureSession->GetMode();
+    bool isEnabled = captureSession->IsVideoDeferred();
+    MEDIA_INFO_LOG("IsAutoDeferredVideoEnhancementEnabled curMode:%{public}d, isEnabled:%{public}d",
+        curMode, isEnabled);
+    return isEnabled;
+}
+
+int32_t VideoOutput::EnableAutoDeferredVideoEnhancement(bool enabled)
+{
+    MEDIA_INFO_LOG("EnableAutoDeferredVideoEnhancement");
+    CAMERA_SYNC_TRACE;
+    sptr<CameraDevice> cameraObj;
+    auto captureSession = GetSession();
+    CHECK_ERROR_RETURN_RET_LOG(captureSession == nullptr, SERVICE_FATL_ERROR,
+        "VideoOutput EnableAutoDeferredVideoEnhancement error!, captureSession is nullptr");
+    auto inputDevice = captureSession->GetInputDevice();
+    CHECK_ERROR_RETURN_RET_LOG(inputDevice == nullptr, SERVICE_FATL_ERROR,
+        "VideoOutput EnableAutoDeferredVideoEnhancement error!, inputDevice is nullptr");
+
+    cameraObj = inputDevice->GetCameraDeviceInfo();
+    CHECK_ERROR_RETURN_RET_LOG(cameraObj == nullptr, SERVICE_FATL_ERROR,
+        "VideoOutput EnableAutoDeferredVideoEnhancement error!, cameraObj is nullptr");
+    captureSession->EnableAutoDeferredVideoEnhancement(enabled);
+    captureSession->SetUserId();
+    return SUCCESS;
+}
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/frameworks/native/camera/src/session/capture_session.cpp b/frameworks/native/camera/src/session/capture_session.cpp
index 3c58678c5..4f4c49237 100644
--- a/frameworks/native/camera/src/session/capture_session.cpp
+++ b/frameworks/native/camera/src/session/capture_session.cpp
@@ -595,6 +595,18 @@ void CaptureSession::UpdateDeviceDeferredability()
                 static_cast<DeferredDeliveryImageType>(item.data.u8[i + 1]);
         }
     }
+
+    inputDevice->GetCameraDeviceInfo()->modeVideoDeferredType_ = {};
+    ret = Camera::FindCameraMetadataItem(metadata->get(), OHOS_ABILITY_AUTO_DEFERRED_VIDEO_ENHANCE, &item);
+    MEDIA_INFO_LOG("UpdateDeviceDeferredability get video ret: %{public}d", ret);
+    MEDIA_DEBUG_LOG("UpdateDeviceDeferredability video item: %{public}d count: %{public}d", item.item, item.count);
+    for (uint32_t i = 0; i < item.count; i++) {
+        if (i % DEFERRED_MODE_DATA_SIZE == 0) {
+            MEDIA_DEBUG_LOG("UpdateDeviceDeferredability mode index:%{public}d, video deferredType:%{public}d",
+                item.data.u8[i], item.data.u8[i + 1]);
+            inputDevice->GetCameraDeviceInfo()->modeVideoDeferredType_[item.data.u8[i]] = item.data.u8[i + 1];
+        }
+    }
 }
 
 void CaptureSession::FindTagId()
@@ -2834,6 +2846,12 @@ bool CaptureSession::IsImageDeferred()
     return isImageDeferred_;
 }
 
+bool CaptureSession::IsVideoDeferred()
+{
+    MEDIA_INFO_LOG("CaptureSession IsVideoDeferred:%{public}d", isVideoDeferred_);
+    return isVideoDeferred_;
+}
+
 SceneFeaturesMode CaptureSession::GetFeaturesMode()
 {
     SceneFeaturesMode sceneFeaturesMode;
@@ -4374,6 +4392,37 @@ void CaptureSession::EnableDeferredType(DeferredDeliveryImageType type, bool isE
     isDeferTypeSetted_ = isEnableByUser;
 }
 
+void CaptureSession::EnableAutoDeferredVideoEnhancement(bool isEnableByUser)
+{
+    MEDIA_INFO_LOG("EnableAutoDeferredVideoEnhancement isEnableByUser:%{public}d", isEnableByUser);
+    if (IsSessionCommited()) {
+        MEDIA_ERR_LOG("EnableAutoDeferredVideoEnhancement session has committed!");
+        return;
+    }
+    this->LockForControl();
+    if (changedMetadata_ == nullptr) {
+        MEDIA_ERR_LOG("EnableAutoDeferredVideoEnhancement changedMetadata_ is NULL");
+        return;
+    }
+
+    bool status = false;
+    camera_metadata_item_t item;
+    isVideoDeferred_ = isEnableByUser;
+    int ret = Camera::FindCameraMetadataItem(changedMetadata_->get(), OHOS_CONTROL_AUTO_DEFERRED_VIDEO_ENHANCE, &item);
+    if (ret == CAM_META_ITEM_NOT_FOUND) {
+        status = changedMetadata_->addEntry(OHOS_CONTROL_AUTO_DEFERRED_VIDEO_ENHANCE, &isEnableByUser, 1);
+    } else if (ret == CAM_META_SUCCESS) {
+        status = changedMetadata_->updateEntry(OHOS_CONTROL_AUTO_DEFERRED_VIDEO_ENHANCE, &isEnableByUser, 1);
+    }
+    if (!status) {
+        MEDIA_ERR_LOG("EnableAutoDeferredVideoEnhancement Failed to set type!");
+    }
+    int32_t errCode = this->UnlockForControl();
+    if (errCode != CameraErrorCode::SUCCESS) {
+        MEDIA_DEBUG_LOG("EnableAutoDeferredVideoEnhancement Failed");
+    }
+}
+
 void CaptureSession::SetUserId()
 {
     MEDIA_INFO_LOG("CaptureSession::SetUserId");
diff --git a/frameworks/native/camera/src/utils/dps_metadata_info.cpp b/frameworks/native/camera/src/utils/dps_metadata_info.cpp
index f2a61508e..c1bb81761 100644
--- a/frameworks/native/camera/src/utils/dps_metadata_info.cpp
+++ b/frameworks/native/camera/src/utils/dps_metadata_info.cpp
@@ -154,10 +154,10 @@ template<class T>
 DpsMetadataError DpsMetadata::Get(const std::string &key, DpsDataType type, T &value) const
 {
     auto it = datas.find(key);
-    DP_CHECK_ERROR_RETURN_RET(it == datas.end(), DPS_METADATA_ERROR_NO_ENTRY);
-    DP_CHECK_ERROR_RETURN_RET(it->second.type != type, DPS_METADATA_ERROR_TYPE_ERROR);
+    DP_CHECK_RETURN_RET(it == datas.end(), DPS_METADATA_ERROR_NO_ENTRY);
+    DP_CHECK_RETURN_RET(it->second.type != type, DPS_METADATA_ERROR_TYPE_ERROR);
     auto dpVal = std::any_cast<T>(&it->second.val);
-    DP_CHECK_ERROR_RETURN_RET(dpVal == nullptr, DPS_METADATA_ERROR_TYPE_ERROR);
+    DP_CHECK_RETURN_RET(dpVal == nullptr, DPS_METADATA_ERROR_TYPE_ERROR);
     value = *dpVal;
     return DPS_METADATA_OK;
 }
@@ -165,7 +165,7 @@ DpsMetadataError DpsMetadata::Get(const std::string &key, DpsDataType type, T &v
 DpsMetadataError DpsMetadata::Set(const std::string &key, DpsDataType type, const std::any& val)
 {
     auto it = datas.find(key);
-    DP_CHECK_ERROR_RETURN_RET(it == datas.end() && datas.size() > DPS_MAX_USER_DATA_COUNT,
+    DP_CHECK_RETURN_RET(it == datas.end() && datas.size() > DPS_MAX_USER_DATA_COUNT,
         DPS_METADATA_ERROR_OUT_OF_RANGE);
     datas[key].type = type;
     datas[key].val = val;
diff --git a/frameworks/native/camera/test/moduletest/src/camera_framework_moduletest.cpp b/frameworks/native/camera/test/moduletest/src/camera_framework_moduletest.cpp
index db7099980..9c264e3c9 100644
--- a/frameworks/native/camera/test/moduletest/src/camera_framework_moduletest.cpp
+++ b/frameworks/native/camera/test/moduletest/src/camera_framework_moduletest.cpp
@@ -425,6 +425,11 @@ class AppVideoCallback : public VideoStateCallback {
         g_videoEvents[static_cast<int>(CAM_VIDEO_EVENTS::CAM_VIDEO_FRAME_ERR)] = 1;
         return;
     }
+    void OnDeferredVideoEnhancementInfo(const CaptureEndedInfoExt info) const override
+    {
+        MEDIA_DEBUG_LOG("AppVideoCallback::OnDeferredVideoEnhancementInfo");
+        return;
+    }
 };
 
 class AppMetadataCallback : public MetadataObjectCallback, public MetadataStateCallback {
diff --git a/frameworks/native/camera/test/unittest/BUILD.gn b/frameworks/native/camera/test/unittest/BUILD.gn
index 76ddb2889..0443b9649 100644
--- a/frameworks/native/camera/test/unittest/BUILD.gn
+++ b/frameworks/native/camera/test/unittest/BUILD.gn
@@ -206,19 +206,32 @@ ohos_unittest("camera_framework_deferred_unittest") {
     "${multimedia_camera_framework_path}/services/deferred_processing_service/binder/client/include",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/binder/server/include",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/base/buffer_manager",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/base/command_server",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/base/task_manager",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/base/task_manager/task_group",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/base/timer",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/base/timer/core",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/dfx",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/event_monitor",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/event_monitor/base",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/event_monitor/command",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/event_monitor/impl",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/media_manager",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/post_processor",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/post_processor/command",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule/base",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule/impl",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule/photo_processor",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule/photo_processor/photo_job_repository",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule/photo_processor/strategy",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule/video_processor",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule/video_processor/strategy",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule/video_processor/video_job_repository",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/session",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/session/command",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/session/photo_session",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/session/video_session",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/utils",
     "${multimedia_camera_framework_path}/interfaces/inner_api/native/camera/include/utils",
   ]
@@ -226,6 +239,93 @@ ohos_unittest("camera_framework_deferred_unittest") {
   sources = [
     "${multimedia_camera_framework_path}/interfaces/inner_api/native/test/test_common.cpp",
     "src/v1_1/camera_deferred_unittest.cpp",
+    "src/v1_1/camera_deferred_video_unittest.cpp",
+    "${multimedia_camera_framework_path}/frameworks/native/camera/src/utils/dps_metadata_info.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/binder/client/src/deferred_photo_processing_session_callback_proxy.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/binder/client/src/deferred_photo_processing_session_proxy.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/binder/server/src/deferred_photo_processing_session_callback_stub.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/binder/server/src/deferred_photo_processing_session_stub.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/binder/client/src/deferred_video_processing_session_callback_proxy.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/binder/client/src/deferred_video_processing_session_proxy.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/binder/server/src/deferred_video_processing_session_callback_stub.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/binder/server/src/deferred_video_processing_session_stub.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/basic_definitions.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/buffer_info.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/buffer_manager/shared_buffer.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/dps.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/task_manager/task_group/base_task_group.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/task_manager/task_group/delayed_task_group.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/task_manager/task_group/task_group.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/task_manager/task_manager.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/task_manager/task_registry.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/task_manager/thread_pool.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/task_manager/thread_utils.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/timer/core/timer_core.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/timer/steady_clock.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/timer/time_broker.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/timer/timer.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/command_server/command_server_impl.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/command_server/command_server.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/base/command_server/command.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/deferred_processing_service.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/dfx/dps_event_report.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/event_monitor/events_info.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/event_monitor/events_monitor.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/event_monitor/events_subscriber.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/event_monitor/impl/thermal_strategy.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/event_monitor/impl/screen_strategy.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/event_monitor/impl/charging_strategy.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/event_monitor/impl/battery_strategy.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/event_monitor/impl/battery_level_strategy.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/event_monitor/command/event_status_change_command.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/media_manager/demuxer.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/media_manager/media_manager.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/media_manager/mpeg_manager_factory.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/media_manager/mpeg_manager.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/media_manager/muxer.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/media_manager/reader.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/media_manager/track_factory.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/media_manager/track.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/media_manager/writer.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/post_processor/command/service_died_command.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/post_processor/command/video_process_command.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/post_processor/photo_post_processor.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/post_processor/video_post_processor.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/schedule/base/ischeduler_video_state.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/schedule/impl/video_battery_level_state.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/schedule/impl/video_battery_state.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/schedule/impl/video_camera_state.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/schedule/impl/video_charging_state.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/schedule/impl/video_hal_state.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/schedule/impl/video_media_library_state.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/schedule/impl/video_photo_process_state.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/schedule/impl/video_screen_state.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/schedule/impl/video_temperature_state.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/schedule/photo_processor/deferred_photo_controller.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/schedule/photo_processor/deferred_photo_processor.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/schedule/photo_processor/photo_job_repository/deferred_photo_job.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/schedule/photo_processor/photo_job_repository/photo_job_repository.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/schedule/photo_processor/strategy/background_strategy.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/schedule/photo_processor/strategy/user_initiated_strategy.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/schedule/scheduler_coordinator.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/schedule/scheduler_manager.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/schedule/video_processor/deferred_video_controller.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/schedule/video_processor/deferred_video_processor.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/schedule/video_processor/strategy/video_strategy_center.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/schedule/video_processor/video_job_repository/deferred_video_job.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/schedule/video_processor/video_job_repository/video_job_queue.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/schedule/video_processor/video_job_repository/video_job_repository.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/session/command/session_command.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/session/command/sync_command.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/session/command/video_command.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/session/photo_session/deferred_photo_processing_session.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/session/session_coordinator.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/session/session_info.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/session/session_manager.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/session/video_session/video_session_info.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/session/video_session/deferred_video_processing_session.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/utils/dp_utils.cpp",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/src/utils/dp_power_manager.cpp"
   ]
 
   deps = [
@@ -236,6 +336,7 @@ ohos_unittest("camera_framework_deferred_unittest") {
   ]
 
   external_deps = [
+    "ability_base:want",
     "access_token:libaccesstoken_sdk",
     "access_token:libnativetoken",
     "access_token:libprivacy_sdk",
@@ -244,11 +345,14 @@ ohos_unittest("camera_framework_deferred_unittest") {
     "audio_framework:audio_client",
     "av_codec:av_codec_client",
     "c_utils:utils",
+    "common_event_service:cesfwk_innerkits",
     "data_share:datashare_common",
     "data_share:datashare_consumer",
     "drivers_interface_camera:libbuffer_handle_sequenceable_1.0",
     "drivers_interface_camera:libcamera_proxy_1.0",
     "drivers_interface_camera:libcamera_proxy_1.1",
+    "drivers_interface_camera:libcamera_proxy_1.2",
+    "drivers_interface_camera:libcamera_proxy_1.3",
     "drivers_interface_camera:libmap_data_sequenceable_1.0",
     "drivers_interface_camera:metadata",
     "drivers_peripheral_display:hdi_gralloc_client",
@@ -258,6 +362,7 @@ ohos_unittest("camera_framework_deferred_unittest") {
     "hisysevent:libhisysevent",
     "hitrace:hitrace_meter",
     "image_framework:image_native",
+    "init:libbegetutil",
     "ipc:ipc_core",
     "media_foundation:media_foundation",
     "media_foundation:native_media_core",
@@ -265,6 +370,7 @@ ohos_unittest("camera_framework_deferred_unittest") {
     "media_library:media_library_manager",
     "os_account:os_account_innerkits",
     "safwk:system_ability_fwk",
+    "samgr:samgr_proxy",
     "window_manager:libdm_lite",
   ]
 
@@ -274,6 +380,16 @@ ohos_unittest("camera_framework_deferred_unittest") {
     defines += [ "CAMERA_USE_SENSOR" ]
   }
 
+  if (use_battery_manager) {
+    external_deps += [ "battery_manager:batterysrv_client" ]
+    defines += [ "CAMERA_USE_BATTERY" ]
+  }
+
+  if (use_power_manager) {
+    external_deps += [ "power_manager:powermgr_client" ]
+    defines += [ "CAMERA_USE_POWER" ]
+  }
+
   cflags = [
     "-fPIC",
     "-Werror=unused",
diff --git a/frameworks/native/camera/test/unittest/include/camera_deferred_video_unittest.h b/frameworks/native/camera/test/unittest/include/camera_deferred_video_unittest.h
new file mode 100755
index 000000000..07c43efa6
--- /dev/null
+++ b/frameworks/native/camera/test/unittest/include/camera_deferred_video_unittest.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CAMERA_FRAMEWORK_DEFERRED_UNITTEST_H
+#define CAMERA_FRAMEWORK_DEFERRED_UNITTEST_H
+
+#include "gtest/gtest.h"
+#include "ideferred_video_processing_session.h"
+#include "dps.h"
+#include "deferred_video_proc_session.h"
+
+namespace OHOS {
+namespace CameraStandard {
+class TestDeferredVideoProcSessionCallback : public DeferredVideoProcessingSessionCallback {
+public:
+    TestDeferredVideoProcSessionCallback() = default;
+    ~TestDeferredVideoProcSessionCallback() = default;
+
+    ErrCode OnProcessVideoDone(const std::string& videoId, const sptr<IPCFileDescriptor>& ipcFd);
+    ErrCode OnError(const std::string& videoId, int32_t errorCode);
+    ErrCode OnStateChanged(int32_t status);
+};
+
+class DeferredVideoUnitTest : public testing::Test {
+public:
+    /* SetUpTestCase:The preset action of the test suite is executed before the first TestCase */
+    static void SetUpTestCase(void);
+
+    /* TearDownTestCase:The test suite cleanup action is executed after the last TestCase */
+    static void TearDownTestCase(void);
+
+    /* SetUp:Execute before each test case */
+    void SetUp();
+
+    /* TearDown:Execute after each test case */
+    void TearDown();
+
+    void NativeAuthorization();
+    void BeginSchedule(bool isCharging);
+    void PauseSchedule();
+    uint64_t g_tokenId_;
+    int32_t g_uid_;
+    int32_t g_userId_;
+    sptr<DeferredProcessing::IDeferredVideoProcessingSession> session_ {nullptr};
+    std::shared_ptr<DeferredProcessing::SessionManager> sessionManager_ {nullptr};
+    std::shared_ptr<DeferredProcessing::SchedulerManager> schedulerManager_ {nullptr};
+    std::shared_ptr<DeferredProcessing::VideoJobRepository> jobRepository_ {nullptr};
+};
+} // CameraStandard
+} // OHOS
+#endif // CAMERA_FRAMEWORK_DEFERRED_UNITTEST_H
diff --git a/frameworks/native/camera/test/unittest/src/v1_1/camera_deferred_video_unittest.cpp b/frameworks/native/camera/test/unittest/src/v1_1/camera_deferred_video_unittest.cpp
new file mode 100755
index 000000000..c8f72f6bb
--- /dev/null
+++ b/frameworks/native/camera/test/unittest/src/v1_1/camera_deferred_video_unittest.cpp
@@ -0,0 +1,302 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "camera_deferred_video_unittest.h"
+
+#include "access_token.h"
+#include "accesstoken_kit.h"
+#include "basic_definitions.h"
+#include "gmock/gmock.h"
+#include "hap_token_info.h"
+#include "nativetoken_kit.h"
+#include "ipc_skeleton.h"
+#include "token_setproc.h"
+#include "os_account_manager.h"
+#include "events_monitor.h"
+#include "camera_log.h"
+#include "deferred_processing_service.h"
+
+using namespace testing::ext;
+using namespace OHOS::CameraStandard::DeferredProcessing;
+
+namespace OHOS {
+namespace CameraStandard {
+ErrCode TestDeferredVideoProcSessionCallback::OnProcessVideoDone(const std::string& videoId,
+    const sptr<IPCFileDescriptor>& ipcFd)
+{
+    MEDIA_INFO_LOG("TestDeferredVideoProcSessionCallback OnProcessVideoDone.");
+    return ERR_OK;
+}
+
+ErrCode TestDeferredVideoProcSessionCallback::OnError(const std::string& videoId, int32_t errorCode)
+{
+    MEDIA_INFO_LOG("TestDeferredVideoProcSessionCallback OnError.");
+    return ERR_OK;
+}
+
+ErrCode TestDeferredVideoProcSessionCallback::OnStateChanged(int32_t status)
+{
+    MEDIA_INFO_LOG("TestDeferredVideoProcSessionCallback OnStateChanged.");
+    return ERR_OK;
+}
+
+void DeferredVideoUnitTest::SetUpTestCase(void)
+{
+    MEDIA_DEBUG_LOG("DeferredUnitTest::SetUpTestCase started!");
+}
+
+void DeferredVideoUnitTest::TearDownTestCase(void)
+{
+    MEDIA_DEBUG_LOG("DeferredUnitTest::TearDownTestCase started!");
+}
+
+void DeferredVideoUnitTest::SetUp()
+{
+    MEDIA_DEBUG_LOG("SetUp testName:%{public}s",
+        ::testing::UnitTest::GetInstance()->current_test_info()->name());
+    NativeAuthorization();
+    auto callback = sptr<TestDeferredVideoProcSessionCallback>::MakeSptr();
+    session_ = DeferredProcessingService::GetInstance().CreateDeferredVideoProcessingSession(g_userId_, callback);
+    sessionManager_ = DPS_GetSessionManager();
+    schedulerManager_ = DPS_GetSchedulerManager();
+    jobRepository_ = schedulerManager_->videoController_[g_userId_]->videoJobRepository_;
+}
+
+void DeferredVideoUnitTest::TearDown()
+{
+    MEDIA_DEBUG_LOG("DeferredUnitTest::TearDown started!");
+}
+
+void DeferredVideoUnitTest::NativeAuthorization()
+{
+    const char *perms[2];
+    perms[0] = "ohos.permission.DISTRIBUTED_DATASYNC";
+    perms[1] = "ohos.permission.CAMERA";
+    NativeTokenInfoParams infoInstance = {
+        .dcapsNum = 0,
+        .permsNum = 2,
+        .aclsNum = 0,
+        .dcaps = NULL,
+        .perms = perms,
+        .acls = NULL,
+        .processName = "native_camera_tdd",
+        .aplStr = "system_basic",
+    };
+    g_tokenId_ = GetAccessTokenId(&infoInstance);
+    g_uid_ = IPCSkeleton::GetCallingUid();
+    AccountSA::OsAccountManager::GetOsAccountLocalIdFromUid(g_uid_, g_userId_);
+    MEDIA_DEBUG_LOG("tokenId:%{public}" PRIu64 " uid:%{public}d userId:%{public}d",
+        g_tokenId_, g_uid_, g_userId_);
+    SetSelfTokenID(g_tokenId_);
+    OHOS::Security::AccessToken::AccessTokenKit::ReloadNativeTokenInfo();
+}
+
+void DeferredVideoUnitTest::BeginSchedule(bool isCharging)
+{
+    if (isCharging) {
+        EventsMonitor::GetInstance().NotifyChargingStatus(CHARGING);
+        EventsMonitor::GetInstance().NotifyBatteryLevel(BATTERY_LEVEL_OKAY);
+    } else {
+        EventsMonitor::GetInstance().NotifyChargingStatus(DISCHARGING);
+        EventsMonitor::GetInstance().NotifyBatteryStatus(BATTERY_OKAY);
+    }
+    EventsMonitor::GetInstance().NotifyMediaLibraryStatus(true);
+    EventsMonitor::GetInstance().NotifyImageEnhanceStatus(HDI_READY);
+    EventsMonitor::GetInstance().NotifyThermalLevel(LEVEL_0);
+    EventsMonitor::GetInstance().NotifyScreenStatus(SCREEN_OFF);
+}
+
+void DeferredVideoUnitTest::PauseSchedule()
+{
+    EventsMonitor::GetInstance().NotifyScreenStatus(SCREEN_ON);
+}
+
+constexpr int VIDEO_REQUEST_FD_ID1 = 111;
+// constexpr int VIDEO_REQUEST_FD_ID2 = 222;
+// constexpr int VIDEO_REQUEST_FD_ID3 = 333;
+constexpr int VIDEO_REQUEST_FD_TEMP = 888;
+
+constexpr int64_t TIME_PROCESS = 200;
+constexpr int64_t TIME_TEST_WAIT = 1000;
+
+HWTEST_F(DeferredVideoUnitTest, AddJob, TestSize.Level0)
+{
+    std::string videoId = "video1";
+    sptr<IPCFileDescriptor> srcFd = sptr<IPCFileDescriptor>::MakeSptr(VIDEO_REQUEST_FD_ID1);
+    sptr<IPCFileDescriptor> dstFd = sptr<IPCFileDescriptor>::MakeSptr(VIDEO_REQUEST_FD_TEMP);
+    session_->AddVideo(videoId, srcFd, dstFd);
+    BeginSchedule(false);
+    std::this_thread::sleep_for(std::chrono::milliseconds(TIME_PROCESS));
+    auto num = jobRepository_->GetRunningJobCounts();
+    ASSERT_EQ(num, 1);
+    auto taskVideo = jobRepository_->GetJob();
+    ASSERT_NE(taskVideo, nullptr);
+    EXPECT_EQ(taskVideo->GetVideoId(), "video1");
+    EXPECT_EQ(taskVideo->GetCurStatus(), VideoJobStatus::RUNNING);
+
+    PauseSchedule();
+    std::this_thread::sleep_for(std::chrono::milliseconds(TIME_TEST_WAIT));
+}
+
+HWTEST_F(DeferredVideoUnitTest, AddJob_C, TestSize.Level0)
+{
+    std::string videoId = "video1";
+    sptr<IPCFileDescriptor> srcFd = sptr<IPCFileDescriptor>::MakeSptr(VIDEO_REQUEST_FD_ID1);
+    sptr<IPCFileDescriptor> dstFd = sptr<IPCFileDescriptor>::MakeSptr(VIDEO_REQUEST_FD_TEMP);
+    session_->AddVideo(videoId, srcFd, dstFd);
+    BeginSchedule(true);
+    std::this_thread::sleep_for(std::chrono::milliseconds(TIME_PROCESS));
+    auto num = jobRepository_->GetRunningJobCounts();
+    ASSERT_EQ(num, 1);
+    auto taskVideo = jobRepository_->GetJob();
+    ASSERT_NE(taskVideo, nullptr);
+    EXPECT_EQ(taskVideo->GetVideoId(), "video1");
+    EXPECT_EQ(taskVideo->GetCurStatus(), VideoJobStatus::RUNNING);
+
+    PauseSchedule();
+    std::this_thread::sleep_for(std::chrono::milliseconds(TIME_TEST_WAIT));
+}
+
+HWTEST_F(DeferredVideoUnitTest, PauseJob, TestSize.Level0)
+{
+    std::string videoId = "video1";
+    sptr<IPCFileDescriptor> srcFd = sptr<IPCFileDescriptor>::MakeSptr(VIDEO_REQUEST_FD_ID1);
+    sptr<IPCFileDescriptor> dstFd = sptr<IPCFileDescriptor>::MakeSptr(VIDEO_REQUEST_FD_TEMP);
+    session_->AddVideo(videoId, srcFd, dstFd);
+    BeginSchedule(false);
+    std::this_thread::sleep_for(std::chrono::milliseconds(TIME_PROCESS));
+    auto num = jobRepository_->GetRunningJobCounts();
+    ASSERT_EQ(num, 1);
+    auto taskVideo = jobRepository_->GetJob();
+    ASSERT_NE(taskVideo, nullptr);
+    EXPECT_EQ(taskVideo->GetVideoId(), "video1");
+    EXPECT_EQ(taskVideo->GetCurStatus(), VideoJobStatus::RUNNING);
+
+    EventsMonitor::GetInstance().NotifyBatteryStatus(BATTERY_LOW);
+    std::this_thread::sleep_for(std::chrono::milliseconds(TIME_PROCESS));
+    num = jobRepository_->GetRunningJobCounts();
+    ASSERT_EQ(num, 0);
+    taskVideo = jobRepository_->GetJob();
+    ASSERT_NE(taskVideo, nullptr);
+    EXPECT_EQ(taskVideo->GetVideoId(), "video1");
+    EXPECT_EQ(taskVideo->GetCurStatus(), VideoJobStatus::PAUSE);
+
+    PauseSchedule();
+    std::this_thread::sleep_for(std::chrono::milliseconds(TIME_TEST_WAIT));
+}
+
+HWTEST_F(DeferredVideoUnitTest, PauseJob_C, TestSize.Level0)
+{
+    std::string videoId = "video1";
+    sptr<IPCFileDescriptor> srcFd = sptr<IPCFileDescriptor>::MakeSptr(VIDEO_REQUEST_FD_ID1);
+    sptr<IPCFileDescriptor> dstFd = sptr<IPCFileDescriptor>::MakeSptr(VIDEO_REQUEST_FD_TEMP);
+    session_->AddVideo(videoId, srcFd, dstFd);
+    BeginSchedule(true);
+    std::this_thread::sleep_for(std::chrono::milliseconds(TIME_PROCESS));
+    auto num = jobRepository_->GetRunningJobCounts();
+    ASSERT_EQ(num, 1);
+    auto taskVideo = jobRepository_->GetJob();
+    ASSERT_NE(taskVideo, nullptr);
+    EXPECT_EQ(taskVideo->GetVideoId(), "video1");
+    EXPECT_EQ(taskVideo->GetCurStatus(), VideoJobStatus::RUNNING);
+
+    EventsMonitor::GetInstance().NotifyBatteryLevel(BATTERY_LEVEL_LOW);
+    std::this_thread::sleep_for(std::chrono::milliseconds(TIME_PROCESS));
+    num = jobRepository_->GetRunningJobCounts();
+    ASSERT_EQ(num, 0);
+    taskVideo = jobRepository_->GetJob();
+    ASSERT_NE(taskVideo, nullptr);
+    EXPECT_EQ(taskVideo->GetVideoId(), "video1");
+    EXPECT_EQ(taskVideo->GetCurStatus(), VideoJobStatus::PAUSE);
+
+    PauseSchedule();
+    std::this_thread::sleep_for(std::chrono::milliseconds(TIME_TEST_WAIT));
+}
+
+HWTEST_F(DeferredVideoUnitTest, DeleteJob, TestSize.Level0)
+{
+    std::string videoId_1 = "video1";
+    sptr<IPCFileDescriptor> srcFd_1 = sptr<IPCFileDescriptor>::MakeSptr(VIDEO_REQUEST_FD_ID1);
+    sptr<IPCFileDescriptor> dstFd_1 = sptr<IPCFileDescriptor>::MakeSptr(VIDEO_REQUEST_FD_TEMP);
+    session_->AddVideo(videoId_1, srcFd_1, dstFd_1);
+    std::string videoId_2 = "video2";
+    sptr<IPCFileDescriptor> srcFd_2 = sptr<IPCFileDescriptor>::MakeSptr(VIDEO_REQUEST_FD_ID1);
+    sptr<IPCFileDescriptor> dstFd_2 = sptr<IPCFileDescriptor>::MakeSptr(VIDEO_REQUEST_FD_TEMP);
+    session_->AddVideo(videoId_2, srcFd_2, dstFd_2);
+    BeginSchedule(true);
+    std::this_thread::sleep_for(std::chrono::milliseconds(TIME_PROCESS));
+    auto jobQueue = jobRepository_->jobQueue_;
+    ASSERT_NE(jobQueue, nullptr);
+    auto taskVideo = jobRepository_->GetJob();
+    ASSERT_NE(taskVideo, nullptr);
+    EXPECT_EQ(taskVideo->GetVideoId(), "video1");
+    EXPECT_EQ(taskVideo->GetCurStatus(), VideoJobStatus::RUNNING);
+
+    session_->RemoveVideo(videoId_2, false);
+    std::this_thread::sleep_for(std::chrono::milliseconds(TIME_PROCESS));
+    jobQueue = jobRepository_->jobQueue_;
+    ASSERT_NE(jobQueue, nullptr);
+    taskVideo = jobRepository_->GetJob();
+    ASSERT_NE(taskVideo, nullptr);
+    EXPECT_EQ(taskVideo->GetVideoId(), "video1");
+    EXPECT_EQ(taskVideo->GetCurStatus(), VideoJobStatus::RUNNING);
+
+
+    taskVideo = jobRepository_->GetJobUnLocked(videoId_2);
+    EXPECT_EQ(taskVideo, nullptr);
+
+    PauseSchedule();
+    std::this_thread::sleep_for(std::chrono::milliseconds(TIME_TEST_WAIT));
+}
+
+HWTEST_F(DeferredVideoUnitTest, DeleteJob_R, TestSize.Level0)
+{
+    std::string videoId_1 = "video1";
+    sptr<IPCFileDescriptor> srcFd_1 = sptr<IPCFileDescriptor>::MakeSptr(VIDEO_REQUEST_FD_ID1);
+    sptr<IPCFileDescriptor> dstFd_1 = sptr<IPCFileDescriptor>::MakeSptr(VIDEO_REQUEST_FD_TEMP);
+    session_->AddVideo(videoId_1, srcFd_1, dstFd_1);
+    std::string videoId_2 = "video2";
+    sptr<IPCFileDescriptor> srcFd_2 = sptr<IPCFileDescriptor>::MakeSptr(VIDEO_REQUEST_FD_ID1);
+    sptr<IPCFileDescriptor> dstFd_2 = sptr<IPCFileDescriptor>::MakeSptr(VIDEO_REQUEST_FD_TEMP);
+    session_->AddVideo(videoId_2, srcFd_2, dstFd_2);
+    BeginSchedule(true);
+    std::this_thread::sleep_for(std::chrono::milliseconds(TIME_PROCESS));
+    auto jobQueue = jobRepository_->jobQueue_;
+    ASSERT_NE(jobQueue, nullptr);
+    auto taskVideo = jobRepository_->GetJob();
+    ASSERT_NE(taskVideo, nullptr);
+    EXPECT_EQ(taskVideo->GetVideoId(), "video1");
+    EXPECT_EQ(taskVideo->GetCurStatus(), VideoJobStatus::RUNNING);
+
+    session_->RemoveVideo(videoId_2, true);
+    std::this_thread::sleep_for(std::chrono::milliseconds(TIME_PROCESS));
+    jobQueue = jobRepository_->jobQueue_;
+    ASSERT_NE(jobQueue, nullptr);
+    taskVideo = jobRepository_->GetJob();
+    ASSERT_NE(taskVideo, nullptr);
+    EXPECT_EQ(taskVideo->GetVideoId(), "video1");
+    EXPECT_EQ(taskVideo->GetCurStatus(), VideoJobStatus::RUNNING);
+
+    taskVideo = jobRepository_->GetJobUnLocked(videoId_2);
+    ASSERT_NE(jobQueue, nullptr);
+    EXPECT_EQ(taskVideo->GetVideoId(), "video2");
+    EXPECT_EQ(taskVideo->GetCurStatus(), VideoJobStatus::DELETED);
+
+    PauseSchedule();
+    std::this_thread::sleep_for(std::chrono::milliseconds(TIME_TEST_WAIT));
+}
+
+} // CameraStandard
+} // OHOS
diff --git a/frameworks/native/ndk/impl/video_output_impl.cpp b/frameworks/native/ndk/impl/video_output_impl.cpp
index 2ab1036bb..5620f11f4 100644
--- a/frameworks/native/ndk/impl/video_output_impl.cpp
+++ b/frameworks/native/ndk/impl/video_output_impl.cpp
@@ -58,6 +58,12 @@ public:
         }
     }
 
+    void OnDeferredVideoEnhancementInfo(const CaptureEndedInfoExt info) const override
+    {
+        // empty impl
+        MEDIA_DEBUG_LOG("OnDeferredVideoEnhancementInfo is called!");
+    }
+
 private:
     Camera_VideoOutput* videoOutput_;
     VideoOutput_Callbacks callback_;
diff --git a/interfaces/inner_api/native/camera/include/deferred_proc_session/deferred_photo_proc_session.h b/interfaces/inner_api/native/camera/include/deferred_proc_session/deferred_photo_proc_session.h
index cc55210ca..7c65bad59 100644
--- a/interfaces/inner_api/native/camera/include/deferred_proc_session/deferred_photo_proc_session.h
+++ b/interfaces/inner_api/native/camera/include/deferred_proc_session/deferred_photo_proc_session.h
@@ -25,31 +25,13 @@
 #include "deferred_photo_processing_session_callback_stub.h"
 #include "dps_metadata_info.h"
 #include "hcamera_service_proxy.h"
+#include "deferred_type.h"
+
 namespace OHOS::Media {
     class Picture;
 }
 namespace OHOS {
 namespace CameraStandard {
-enum DpsErrorCode {
-    // session specific error code
-    ERROR_SESSION_SYNC_NEEDED = 0,
-    ERROR_SESSION_NOT_READY_TEMPORARILY = 1,
-
-    // process error code
-    ERROR_IMAGE_PROC_INVALID_PHOTO_ID = 2,
-    ERROR_IMAGE_PROC_FAILED = 3,
-    ERROR_IMAGE_PROC_TIMEOUT = 4,
-    ERROR_IMAGE_PROC_ABNORMAL = 5,
-    ERROR_IMAGE_PROC_INTERRUPTED = 6,
-};
-
-enum DpsStatusCode {
-    SESSION_STATE_IDLE = 0,
-    SESSION_STATE_RUNNALBE,
-    SESSION_STATE_RUNNING,
-    SESSION_STATE_SUSPENDED,
-};
-
 class IDeferredPhotoProcSessionCallback : public RefBase {
 public:
     IDeferredPhotoProcSessionCallback() = default;
diff --git a/interfaces/inner_api/native/camera/include/deferred_proc_session/deferred_type.h b/interfaces/inner_api/native/camera/include/deferred_proc_session/deferred_type.h
new file mode 100644
index 000000000..446a85849
--- /dev/null
+++ b/interfaces/inner_api/native/camera/include/deferred_proc_session/deferred_type.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DEFERRED_TYPE_H
+#define OHOS_CAMERA_DEFERRED_TYPE_H
+
+namespace OHOS {
+namespace CameraStandard {
+enum DpsErrorCode {
+    // session specific error code
+    ERROR_SESSION_SYNC_NEEDED = 0,
+    ERROR_SESSION_NOT_READY_TEMPORARILY = 1,
+
+    // image process error code
+    ERROR_IMAGE_PROC_INVALID_PHOTO_ID = 2,
+    ERROR_IMAGE_PROC_FAILED = 3,
+    ERROR_IMAGE_PROC_TIMEOUT = 4,
+    ERROR_IMAGE_PROC_ABNORMAL = 5,
+    ERROR_IMAGE_PROC_INTERRUPTED = 6,
+
+    // video process error code
+    ERROR_VIDEO_PROC_INVALID_VIDEO_ID = 7,
+    ERROR_VIDEO_PROC_FAILED = 8,
+    ERROR_VIDEO_PROC_TIMEOUT = 9,
+    ERROR_VIDEO_PROC_INTERRUPTED = 10,
+};
+
+enum DpsStatusCode {
+    SESSION_STATE_IDLE = 0,
+    SESSION_STATE_RUNNALBE,
+    SESSION_STATE_RUNNING,
+    SESSION_STATE_SUSPENDED,
+};
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DEFERRED_TYPE_H
\ No newline at end of file
diff --git a/interfaces/inner_api/native/camera/include/deferred_proc_session/deferred_video_proc_session.h b/interfaces/inner_api/native/camera/include/deferred_proc_session/deferred_video_proc_session.h
new file mode 100644
index 000000000..ef9dd1933
--- /dev/null
+++ b/interfaces/inner_api/native/camera/include/deferred_proc_session/deferred_video_proc_session.h
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DEFERRED_VIDEO_PROCESSOR_H
+#define OHOS_CAMERA_DEFERRED_VIDEO_PROCESSOR_H
+
+#include <refbase.h>
+#include <iostream>
+#include <mutex>
+
+#include "camera_death_recipient.h"
+#include "ideferred_video_processing_session.h"
+#include "ideferred_video_processing_session_callback.h"
+#include "deferred_video_processing_session_callback_stub.h"
+#include "hcamera_service_proxy.h"
+#include "ipc_file_descriptor.h"
+#include "deferred_type.h"
+
+namespace OHOS {
+namespace CameraStandard {
+class IDeferredVideoProcSessionCallback : public RefBase {
+public:
+    IDeferredVideoProcSessionCallback() = default;
+    virtual ~IDeferredVideoProcSessionCallback() = default;
+    virtual void OnProcessVideoDone(const std::string& videoId, const sptr<IPCFileDescriptor> ipcFd) = 0;
+    virtual void OnError(const std::string& videoId, const DpsErrorCode errorCode) = 0;
+    virtual void OnStateChanged(const DpsStatusCode status) = 0;
+};
+
+class DeferredVideoProcSession : public RefBase {
+public:
+    DeferredVideoProcSession(int userId, std::shared_ptr<IDeferredVideoProcSessionCallback> callback);
+    virtual ~DeferredVideoProcSession();
+    void BeginSynchronize();
+    void EndSynchronize();
+    void AddVideo(const std::string& videoId, const sptr<IPCFileDescriptor> srcFd,
+        const sptr<IPCFileDescriptor> dstFd);
+    void RemoveVideo(const std::string& videoId, const bool restorable = false);
+    void RestoreVideo(const std::string& videoId);
+    std::shared_ptr<IDeferredVideoProcSessionCallback> GetCallback();
+private:
+    friend class CameraManager;
+    int32_t SetDeferredVideoSession(sptr<DeferredProcessing::IDeferredVideoProcessingSession>& session);
+    void CameraServerDied(pid_t pid);
+    void ReconnectDeferredProcessingSession();
+    void ConnectDeferredProcessingSession();
+    int userId_;
+    std::shared_ptr<IDeferredVideoProcSessionCallback> callback_;
+    sptr<DeferredProcessing::IDeferredVideoProcessingSession> remoteSession_;
+    sptr<CameraDeathRecipient> deathRecipient_ = nullptr;
+    sptr<ICameraService> serviceProxy_;
+};
+
+class DeferredVideoProcessingSessionCallback : public DeferredProcessing::DeferredVideoProcessingSessionCallbackStub {
+public:
+    DeferredVideoProcessingSessionCallback() : deferredVideoProcSession_(nullptr) {
+    }
+
+    explicit DeferredVideoProcessingSessionCallback(sptr<DeferredVideoProcSession> deferredVideoProcSession)
+        : deferredVideoProcSession_(deferredVideoProcSession)
+    {
+    }
+
+    ~DeferredVideoProcessingSessionCallback()
+    {
+        deferredVideoProcSession_ = nullptr;
+    }
+
+    ErrCode OnProcessVideoDone(const std::string& videoId, const sptr<IPCFileDescriptor>& ipcFileDescriptor) override;
+    ErrCode OnError(const std::string& videoId, int32_t errorCode) override;
+    ErrCode OnStateChanged(int32_t status) override;
+
+private:
+    sptr<DeferredVideoProcSession> deferredVideoProcSession_;
+};
+
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DEFERRED_VIDEO_PROCESSOR_H
\ No newline at end of file
diff --git a/interfaces/inner_api/native/camera/include/input/camera_device.h b/interfaces/inner_api/native/camera/include/input/camera_device.h
index d0941a19c..1433925ed 100644
--- a/interfaces/inner_api/native/camera/include/input/camera_device.h
+++ b/interfaces/inner_api/native/camera/include/input/camera_device.h
@@ -229,6 +229,7 @@ public:
     std::unordered_map<int32_t, std::vector<Profile>> modePhotoProfiles_ = {};
     std::unordered_map<int32_t, std::vector<VideoProfile>> modeVideoProfiles_ = {};
     std::unordered_map<int32_t, DeferredDeliveryImageType> modeDeferredType_ = {};
+    std::unordered_map<int32_t, int32_t> modeVideoDeferredType_ = {};
 private:
     std::string cameraID_;
     const std::shared_ptr<OHOS::Camera::CameraMetadata> baseAbility_;
diff --git a/interfaces/inner_api/native/camera/include/input/camera_manager.h b/interfaces/inner_api/native/camera/include/input/camera_manager.h
index f77a3be98..75bef7ae9 100644
--- a/interfaces/inner_api/native/camera/include/input/camera_manager.h
+++ b/interfaces/inner_api/native/camera/include/input/camera_manager.h
@@ -26,6 +26,7 @@
 
 #include "camera_stream_info_parse.h"
 #include "deferred_proc_session/deferred_photo_proc_session.h"
+#include "deferred_proc_session/deferred_video_proc_session.h"
 #include "hcamera_listener_stub.h"
 #include "hcamera_service_callback_stub.h"
 #include "hcamera_service_proxy.h"
@@ -260,6 +261,24 @@ public:
     static int CreateDeferredPhotoProcessingSession(int userId,
         std::shared_ptr<IDeferredPhotoProcSessionCallback> callback,
         sptr<DeferredPhotoProcSession> *pDeferredPhotoProcSession);
+    
+    /**
+    * @brief Create deferred video processing session.
+    *
+    * @return Returns pointer to capture session.
+    */
+    static sptr<DeferredVideoProcSession> CreateDeferredVideoProcessingSession(int userId,
+        std::shared_ptr<IDeferredVideoProcSessionCallback> callback);
+
+    /**
+    * @brief Create deferred video processing session.
+    *
+    * @param Returns pointer to capture session.
+    * @return Returns error code.
+    */
+    static int CreateDeferredVideoProcessingSession(int userId,
+        std::shared_ptr<IDeferredVideoProcSessionCallback> callback,
+        sptr<DeferredVideoProcSession> *pDeferredVideoProcSession);
 
     /**
      * @brief Create photo output instance.
diff --git a/interfaces/inner_api/native/camera/include/output/preview_output.h b/interfaces/inner_api/native/camera/include/output/preview_output.h
index 46ae75525..1268c77ff 100644
--- a/interfaces/inner_api/native/camera/include/output/preview_output.h
+++ b/interfaces/inner_api/native/camera/include/output/preview_output.h
@@ -267,6 +267,8 @@ public:
      * @param status Indicates a {@link SketchStatus} which will give information for preview callback error.
      */
     int32_t OnSketchStatusChanged(SketchStatus status) override;
+
+    int32_t OnDeferredVideoEnhancementInfo(CaptureEndedInfoExt captureEndedInfo) override;
 };
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/interfaces/inner_api/native/camera/include/output/video_output.h b/interfaces/inner_api/native/camera/include/output/video_output.h
index 8c7a2d564..1f7bb6bce 100644
--- a/interfaces/inner_api/native/camera/include/output/video_output.h
+++ b/interfaces/inner_api/native/camera/include/output/video_output.h
@@ -56,6 +56,8 @@ public:
      * @param errorCode Indicates a {@link ErrorCode} which will give information for video callback error.
      */
     virtual void OnError(const int32_t errorCode) const = 0;
+
+    virtual void OnDeferredVideoEnhancementInfo(const CaptureEndedInfoExt info) const = 0;
 };
 
 class VideoOutput : public CaptureOutput {
@@ -186,6 +188,25 @@ public:
      *
      */
     void AttachMetaSurface(sptr<Surface> surface, VideoMetaType videoMetaType);
+    /**
+     * @brief To check the autoDeferredVideoEnhance capability is supported or not.
+     *
+     * @return Returns true/false if the autoDeferredVideoEnhance is supported/not-supported respectively.
+     */
+    int32_t IsAutoDeferredVideoEnhancementSupported();
+
+    /**
+     * @brief To check the autoDeferredVideoEnhance capability is supported or not.
+     *
+     * @return Returns true/false if the autoDeferredVideoEnhance is supported/not-supported respectively.
+     */
+    int32_t IsAutoDeferredVideoEnhancementEnabled();
+
+    /**
+     * @brief Enable or not enable for autoDeferredVideoEnhance capability.
+     *
+     */
+    int32_t EnableAutoDeferredVideoEnhancement(bool enabled);
 
 private:
     int32_t videoFormat_;
@@ -234,6 +255,8 @@ public:
      * @param status sketch status.
      */
     int32_t OnSketchStatusChanged(SketchStatus status) override;
+
+    int32_t OnDeferredVideoEnhancementInfo(CaptureEndedInfoExt captureEndedInfo) override;
 };
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/interfaces/inner_api/native/camera/include/session/capture_session.h b/interfaces/inner_api/native/camera/include/session/capture_session.h
index c7d445e2e..ed8561d11 100644
--- a/interfaces/inner_api/native/camera/include/session/capture_session.h
+++ b/interfaces/inner_api/native/camera/include/session/capture_session.h
@@ -1444,9 +1444,11 @@ public:
                                     const std::shared_ptr<OHOS::Camera::CameraMetadata> &result);
 
     void EnableDeferredType(DeferredDeliveryImageType deferredType, bool isEnableByUser);
+    void EnableAutoDeferredVideoEnhancement(bool isEnableByUser);
     void SetUserId();
     bool IsMovingPhotoEnabled();
     bool IsImageDeferred();
+    bool IsVideoDeferred();
     virtual bool CanSetFrameRateRange(int32_t minFps, int32_t maxFps, CaptureOutput* curOutput);
     bool CanSetFrameRateRangeForOutput(int32_t minFps, int32_t maxFps, CaptureOutput* curOutput);
 
@@ -1644,6 +1646,7 @@ protected:
     std::shared_ptr<MetadataResultProcessor> metadataResultProcessor_ = nullptr;
     bool isImageDeferred_ = false;
     std::atomic<bool> isRawImageDelivery_ { false };
+    bool isVideoDeferred_ = false;
     std::atomic<bool> isMovingPhotoEnabled_ { false };
 
     std::shared_ptr<AbilityCallback> abilityCallback_;
diff --git a/interfaces/inner_api/native/test/test_common.cpp b/interfaces/inner_api/native/test/test_common.cpp
index e39df8a45..152f86e20 100644
--- a/interfaces/inner_api/native/test/test_common.cpp
+++ b/interfaces/inner_api/native/test/test_common.cpp
@@ -265,6 +265,11 @@ void TestVideoOutputCallback::OnError(const int32_t errorCode) const
                    testName_, errorCode);
 }
 
+void TestVideoOutputCallback::OnDeferredVideoEnhancementInfo(const CaptureEndedInfoExt info) const
+{
+    MEDIA_INFO_LOG("TestVideoOutputCallback:OnDeferredVideoEnhancementInfo()");
+}
+
 TestMetadataOutputObjectCallback::TestMetadataOutputObjectCallback(const char* testName) : testName_(testName) {
 }
 
diff --git a/interfaces/inner_api/native/test/test_common.h b/interfaces/inner_api/native/test/test_common.h
index bbf5a50c8..14c37a54f 100644
--- a/interfaces/inner_api/native/test/test_common.h
+++ b/interfaces/inner_api/native/test/test_common.h
@@ -133,6 +133,7 @@ public:
     void OnFrameStarted() const override;
     void OnFrameEnded(const int32_t frameCount) const override;
     void OnError(const int32_t errorCode) const override;
+    void OnDeferredVideoEnhancementInfo(const CaptureEndedInfoExt info) const override;
 
 private:
     const char* testName_;
diff --git a/interfaces/kits/js/camera_napi/include/output/video_output_napi.h b/interfaces/kits/js/camera_napi/include/output/video_output_napi.h
index bf9e47d8b..21abdc661 100644
--- a/interfaces/kits/js/camera_napi/include/output/video_output_napi.h
+++ b/interfaces/kits/js/camera_napi/include/output/video_output_napi.h
@@ -29,13 +29,28 @@ static const char CAMERA_VIDEO_OUTPUT_NAPI_CLASS_NAME[] = "VideoOutput";
 static const std::string CONST_VIDEO_FRAME_START = "frameStart";
 static const std::string CONST_VIDEO_FRAME_END = "frameEnd";
 static const std::string CONST_VIDEO_FRAME_ERROR = "error";
+static const std::string CONST_VIDEO_DEFERRED_ENHANCEMENT = "deferredVideoEnhancementInfo";
 
-enum VideoOutputEventType { VIDEO_FRAME_START, VIDEO_FRAME_END, VIDEO_FRAME_ERROR, VIDEO_INVALID_TYPE };
+struct VideoCallbackInfo {
+    int32_t frameCount = 0;
+    int32_t errorCode;
+    bool isDeferredVideoEnhancementAvailable = false;
+    std::string videoId = "";
+};
+
+enum VideoOutputEventType {
+    VIDEO_FRAME_START,
+    VIDEO_FRAME_END,
+    VIDEO_FRAME_ERROR,
+    VIDEO_INVALID_TYPE,
+    VIDEO_DEFERRED_ENHANCEMENT
+};
 
 static EnumHelper<VideoOutputEventType> VideoOutputEventTypeHelper({
         {VIDEO_FRAME_START, CONST_VIDEO_FRAME_START},
         {VIDEO_FRAME_END, CONST_VIDEO_FRAME_END},
         {VIDEO_FRAME_ERROR, CONST_VIDEO_FRAME_ERROR},
+        {VIDEO_DEFERRED_ENHANCEMENT, CONST_VIDEO_DEFERRED_ENHANCEMENT},
     },
     VideoOutputEventType::VIDEO_INVALID_TYPE
 );
@@ -50,20 +65,21 @@ public:
     void OnFrameStarted() const override;
     void OnFrameEnded(const int32_t frameCount) const override;
     void OnError(const int32_t errorCode) const override;
+    void OnDeferredVideoEnhancementInfo(const CaptureEndedInfoExt info) const override;
 
 private:
-    void UpdateJSCallback(VideoOutputEventType eventType, const int32_t value) const;
-    void UpdateJSCallbackAsync(VideoOutputEventType eventType, const int32_t value) const;
+    void UpdateJSCallback(VideoOutputEventType eventType, const VideoCallbackInfo& info) const;
+    void UpdateJSCallbackAsync(VideoOutputEventType eventType, const VideoCallbackInfo& info) const;
+    void ExecuteOnDeferredVideoCb(const VideoCallbackInfo& info) const;
 };
 
 struct VideoOutputCallbackInfo {
     VideoOutputEventType eventType_;
-    int32_t value_;
+    VideoCallbackInfo info_;
     weak_ptr<const VideoCallbackListener> listener_;
-    VideoOutputCallbackInfo(
-        VideoOutputEventType eventType, int32_t value, shared_ptr<const VideoCallbackListener> listener)
-        : eventType_(eventType), value_(value), listener_(listener)
-    {}
+    VideoOutputCallbackInfo(VideoOutputEventType eventType, VideoCallbackInfo info,
+        shared_ptr<const VideoCallbackListener> listener)
+        : eventType_(eventType), info_(info), listener_(listener) {}
 };
 
 class VideoOutputNapi : public CameraNapiEventEmitter<VideoOutputNapi> {
@@ -83,6 +99,9 @@ public:
     static napi_value EnableMirror(napi_env env, napi_callback_info info);
     static napi_value GetSupportedVideoMetaTypes(napi_env env, napi_callback_info info);
     static napi_value AttachMetaSurface(napi_env env, napi_callback_info info);
+    static napi_value IsAutoDeferredVideoEnhancementSupported(napi_env env, napi_callback_info info);
+    static napi_value IsAutoDeferredVideoEnhancementEnabled(napi_env env, napi_callback_info info);
+    static napi_value EnableAutoDeferredVideoEnhancement(napi_env env, napi_callback_info info);
     VideoOutputNapi();
     ~VideoOutputNapi() override;
     sptr<VideoOutput> GetVideoOutput();
@@ -109,6 +128,10 @@ private:
         const std::vector<napi_value>& args, bool isOnce);
     void UnregisterErrorCallbackListener(
         const std::string& eventName, napi_env env, napi_value callback, const std::vector<napi_value>& args);
+    void RegisterDeferredVideoCallbackListener(const std::string& eventName, napi_env env, napi_value callback,
+        const std::vector<napi_value>& args, bool isOnce);
+    void UnregisterDeferredVideoCallbackListener(
+        const std::string& eventName, napi_env env, napi_value callback, const std::vector<napi_value>& args);
 
     static thread_local napi_ref sConstructor_;
     static thread_local sptr<VideoOutput> sVideoOutput_;
diff --git a/multimedia_camera_framework.gni b/multimedia_camera_framework.gni
index 7f74b8d35..1b8bf0b6d 100644
--- a/multimedia_camera_framework.gni
+++ b/multimedia_camera_framework.gni
@@ -34,5 +34,17 @@ if (defined(global_parts_info) &&
   use_thermal_manager = true
 }
 
+use_battery_manager = false
+if (defined(global_parts_info) &&
+    defined(global_parts_info.powermgr_battery_manager)) {
+  use_battery_manager = true
+}
+
+use_power_manager = false
+if (defined(global_parts_info) &&
+    defined(global_parts_info.powermgr_power_manager)) {
+  use_power_manager = true
+}
+
 gen_camera_picker = true
 hicollie_enable = true
diff --git a/services/camera_service/BUILD.gn b/services/camera_service/BUILD.gn
index 51dc288a9..13402cf09 100644
--- a/services/camera_service/BUILD.gn
+++ b/services/camera_service/BUILD.gn
@@ -114,7 +114,6 @@ ohos_shared_library("camera_service") {
     "${multimedia_camera_framework_path}/services/deferred_processing_service/binder/base/include",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/binder/client/include",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/binder/server/include",
-    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/base/buffer_manager",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/base/task_manager",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/base/task_manager/task_group",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/base/timer",
@@ -122,12 +121,19 @@ ohos_shared_library("camera_service") {
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/dfx",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/event_monitor",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/post_processor",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/post_processor/command",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule/base",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule/impl",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule/photo_processor",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule/photo_processor/photo_job_repository",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule/photo_processor/strategy",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule/video_processor",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule/video_processor/strategy",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule/video_processor/video_job_repository",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/session",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/session/photo_session",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/session/video_session",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/utils",
     "//foundation/multimedia/media_library/interfaces/inner_api/media_library_helper/include",
   ]
diff --git a/services/camera_service/binder/base/include/camera_service_ipc_interface_code.h b/services/camera_service/binder/base/include/camera_service_ipc_interface_code.h
index 250e4b8fe..d59426a8f 100644
--- a/services/camera_service/binder/base/include/camera_service_ipc_interface_code.h
+++ b/services/camera_service/binder/base/include/camera_service_ipc_interface_code.h
@@ -104,6 +104,7 @@ enum CameraServiceInterfaceCode {
     CAMERA_SERVICE_SET_TORCH_LEVEL,
     CAMERA_SERVICE_PRE_SWITCH_CAMERA,
     CAMERA_SERVICE_CREATE_DEFERRED_PHOTO_PROCESSING_SESSION,
+    CAMERA_SERVICE_CREATE_DEFERRED_VIDEO_PROCESSING_SESSION,
     CAMERA_SERVICE_GET_CAMERA_IDS,
     CAMERA_SERVICE_GET_CAMERA_ABILITY,
     CAMERA_SERVICE_DESTROY_STUB_OBJ,
@@ -251,7 +252,8 @@ enum StreamRepeatCallbackInterfaceCode {
     CAMERA_STREAM_REPEAT_ON_FRAME_STARTED = 0,
     CAMERA_STREAM_REPEAT_ON_FRAME_ENDED,
     CAMERA_STREAM_REPEAT_ON_ERROR,
-    CAMERA_STREAM_SKETCH_STATUS_ON_CHANGED
+    CAMERA_STREAM_SKETCH_STATUS_ON_CHANGED,
+    CAMERA_STREAM_REPEAT_VIDEO_DEFERRED_INFO
 };
 
 /**
diff --git a/services/camera_service/binder/base/include/icamera_service.h b/services/camera_service/binder/base/include/icamera_service.h
index d06896190..7cfb3d90f 100644
--- a/services/camera_service/binder/base/include/icamera_service.h
+++ b/services/camera_service/binder/base/include/icamera_service.h
@@ -29,6 +29,8 @@
 #include "surface.h"
 #include "ideferred_photo_processing_session.h"
 #include "ideferred_photo_processing_session_callback.h"
+#include "ideferred_video_processing_session.h"
+#include "ideferred_video_processing_session_callback.h"
 
 namespace OHOS {
 namespace CameraStandard {
@@ -82,6 +84,10 @@ public:
     virtual int32_t CreateDeferredPhotoProcessingSession(int32_t userId,
         sptr<DeferredProcessing::IDeferredPhotoProcessingSessionCallback>& callback,
         sptr<DeferredProcessing::IDeferredPhotoProcessingSession>& session) = 0;
+    
+    virtual int32_t CreateDeferredVideoProcessingSession(int32_t userId,
+        sptr<DeferredProcessing::IDeferredVideoProcessingSessionCallback>& callback,
+        sptr<DeferredProcessing::IDeferredVideoProcessingSession>& session) = 0;
 
     virtual int32_t CreatePhotoOutput(const sptr<OHOS::IBufferProducer> &producer, int32_t format,
                                       int32_t width, int32_t height, sptr<IStreamCapture> &photoOutput) = 0;
diff --git a/services/camera_service/binder/base/include/istream_repeat_callback.h b/services/camera_service/binder/base/include/istream_repeat_callback.h
index 332005a5f..94f0a70da 100644
--- a/services/camera_service/binder/base/include/istream_repeat_callback.h
+++ b/services/camera_service/binder/base/include/istream_repeat_callback.h
@@ -33,6 +33,13 @@ typedef struct {
     float sketchRatio;
 } SketchStatusData;
 
+struct CaptureEndedInfoExt {
+    int streamId;
+    int frameCount;
+    bool isDeferredVideoEnhancementAvailable;
+    std::string videoId;
+};
+
 class IStreamRepeatCallback : public IRemoteBroker {
 public:
     virtual int32_t OnFrameStarted() = 0;
@@ -43,6 +50,8 @@ public:
 
     virtual int32_t OnSketchStatusChanged(SketchStatus status) = 0;
 
+    virtual int32_t OnDeferredVideoEnhancementInfo(CaptureEndedInfoExt captureEndedInfo) = 0;
+
     DECLARE_INTERFACE_DESCRIPTOR(u"IStreamRepeatCallback");
 };
 } // namespace CameraStandard
diff --git a/services/camera_service/binder/client/include/hcamera_service_proxy.h b/services/camera_service/binder/client/include/hcamera_service_proxy.h
index 6ca13e222..8f7f346a3 100644
--- a/services/camera_service/binder/client/include/hcamera_service_proxy.h
+++ b/services/camera_service/binder/client/include/hcamera_service_proxy.h
@@ -62,6 +62,10 @@ public:
     int32_t CreateDeferredPhotoProcessingSession(int32_t userId,
         sptr<DeferredProcessing::IDeferredPhotoProcessingSessionCallback>& callback,
         sptr<DeferredProcessing::IDeferredPhotoProcessingSession>& session) override;
+    
+    int32_t CreateDeferredVideoProcessingSession(int32_t userId,
+        sptr<DeferredProcessing::IDeferredVideoProcessingSessionCallback>& callback,
+        sptr<DeferredProcessing::IDeferredVideoProcessingSession>& session) override;
 
     int32_t CreatePhotoOutput(const sptr<OHOS::IBufferProducer> &producer, int32_t format,
                               int32_t width, int32_t height, sptr<IStreamCapture> &photoOutput) override;
diff --git a/services/camera_service/binder/client/include/hstream_repeat_callback_proxy.h b/services/camera_service/binder/client/include/hstream_repeat_callback_proxy.h
index 194b9f2e9..b95b6f1b8 100644
--- a/services/camera_service/binder/client/include/hstream_repeat_callback_proxy.h
+++ b/services/camera_service/binder/client/include/hstream_repeat_callback_proxy.h
@@ -36,6 +36,8 @@ public:
     int32_t OnFrameError(int32_t errorCode) override;
 
     int32_t OnSketchStatusChanged(SketchStatus status) override;
+    
+    int32_t OnDeferredVideoEnhancementInfo(CaptureEndedInfoExt captureEndedInfo) override;
 
 private:
     static inline BrokerDelegator<HStreamRepeatCallbackProxy> delegator_;
diff --git a/services/camera_service/binder/client/src/hcamera_service_proxy.cpp b/services/camera_service/binder/client/src/hcamera_service_proxy.cpp
index 97615b3b5..0ca86719f 100644
--- a/services/camera_service/binder/client/src/hcamera_service_proxy.cpp
+++ b/services/camera_service/binder/client/src/hcamera_service_proxy.cpp
@@ -294,6 +294,41 @@ int32_t HCameraServiceProxy::CreateDeferredPhotoProcessingSession(int32_t userId
     return error;
 }
 
+int32_t HCameraServiceProxy::CreateDeferredVideoProcessingSession(int32_t userId,
+    sptr<DeferredProcessing::IDeferredVideoProcessingSessionCallback>& callback,
+    sptr<DeferredProcessing::IDeferredVideoProcessingSession>& session)
+{
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option;
+
+    if (callback == nullptr) {
+        MEDIA_ERR_LOG("HCameraServiceProxy CreateDeferredVideoProcessingSession callback is null");
+        return IPC_PROXY_ERR;
+    }
+
+    data.WriteInterfaceToken(GetDescriptor());
+    data.WriteInt32(userId);
+    data.WriteRemoteObject(callback->AsObject());
+
+    int error = Remote()->SendRequest(
+        static_cast<uint32_t>(CameraServiceInterfaceCode::CAMERA_SERVICE_CREATE_DEFERRED_VIDEO_PROCESSING_SESSION),
+        data, reply, option);
+    if (error != ERR_NONE) {
+        MEDIA_ERR_LOG("HCameraServiceProxy CreateDeferredVideoProcessingSession failed, error: %{public}d", error);
+        return error;
+    }
+
+    auto remoteObject = reply.ReadRemoteObject();
+    if (remoteObject != nullptr) {
+        session = iface_cast<DeferredProcessing::IDeferredVideoProcessingSession>(remoteObject);
+    } else {
+        MEDIA_ERR_LOG("HCameraServiceProxy CreateDeferredVideoProcessingSession session is null");
+        error = IPC_PROXY_ERR;
+    }
+    return error;
+}
+
 int32_t HCameraServiceProxy::CreatePhotoOutput(const sptr<OHOS::IBufferProducer> &producer, int32_t format,
                                                int32_t width, int32_t height,
                                                sptr<IStreamCapture> &photoOutput)
diff --git a/services/camera_service/binder/client/src/hstream_repeat_callback_proxy.cpp b/services/camera_service/binder/client/src/hstream_repeat_callback_proxy.cpp
index 31f5a2d72..46eea1caa 100644
--- a/services/camera_service/binder/client/src/hstream_repeat_callback_proxy.cpp
+++ b/services/camera_service/binder/client/src/hstream_repeat_callback_proxy.cpp
@@ -97,5 +97,25 @@ int32_t HStreamRepeatCallbackProxy::OnSketchStatusChanged(SketchStatus status)
     }
     return error;
 }
+
+int32_t HStreamRepeatCallbackProxy::OnDeferredVideoEnhancementInfo(CaptureEndedInfoExt captureEndedInfo)
+{
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option;
+    option.SetFlags(option.TF_ASYNC);
+    data.WriteInterfaceToken(GetDescriptor());
+    data.WriteInt32(captureEndedInfo.streamId);
+    data.WriteInt32(captureEndedInfo.frameCount);
+    data.WriteBool(captureEndedInfo.isDeferredVideoEnhancementAvailable);
+    data.WriteString(captureEndedInfo.videoId);
+    int error = Remote()->SendRequest(
+        static_cast<uint32_t>(StreamRepeatCallbackInterfaceCode::CAMERA_STREAM_REPEAT_VIDEO_DEFERRED_INFO), data, reply,
+        option);
+    if (error != ERR_NONE) {
+        MEDIA_ERR_LOG("HStreamRepeatCallbackProxy OnDeferredVideoEnhancementInfo failed, error: %{public}d", error);
+    }
+    return error;
+}
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/services/camera_service/binder/server/include/hcamera_service_stub.h b/services/camera_service/binder/server/include/hcamera_service_stub.h
index ae2a79732..1b83c772f 100644
--- a/services/camera_service/binder/server/include/hcamera_service_stub.h
+++ b/services/camera_service/binder/server/include/hcamera_service_stub.h
@@ -43,6 +43,7 @@ private:
     int HandleSetFoldStatusCallback(MessageParcel &data, MessageParcel &reply);
     int HandleCreateCaptureSession(MessageParcel &data, MessageParcel &reply);
     int HandleCreateDeferredPhotoProcessingSession(MessageParcel &data, MessageParcel &reply);
+    int HandleCreateDeferredVideoProcessingSession(MessageParcel &data, MessageParcel &reply);
     int HandleCreatePhotoOutput(MessageParcel &data, MessageParcel &reply);
     int HandleCreatePreviewOutput(MessageParcel &data, MessageParcel &reply);
     int HandleCreateDeferredPreviewOutput(MessageParcel &data, MessageParcel &reply);
diff --git a/services/camera_service/binder/server/include/hstream_repeat_callback_stub.h b/services/camera_service/binder/server/include/hstream_repeat_callback_stub.h
index 4ccb00ed7..68b6d4ff3 100644
--- a/services/camera_service/binder/server/include/hstream_repeat_callback_stub.h
+++ b/services/camera_service/binder/server/include/hstream_repeat_callback_stub.h
@@ -30,6 +30,7 @@ private:
     int HandleOnFrameEnded(MessageParcel& data);
     int HandleOnFrameError(MessageParcel& data);
     int HandleOnSketchStatusChanged(MessageParcel& data);
+    int HandleOnDeferredVideoEnhancementInfo(MessageParcel& data);
 };
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/services/camera_service/binder/server/src/hcamera_service_stub.cpp b/services/camera_service/binder/server/src/hcamera_service_stub.cpp
index 174a0d955..65305c4b0 100644
--- a/services/camera_service/binder/server/src/hcamera_service_stub.cpp
+++ b/services/camera_service/binder/server/src/hcamera_service_stub.cpp
@@ -75,6 +75,9 @@ int HCameraServiceStub::OnRemoteRequest(uint32_t code, MessageParcel& data, Mess
         case static_cast<uint32_t>(CameraServiceInterfaceCode::CAMERA_SERVICE_CREATE_DEFERRED_PHOTO_PROCESSING_SESSION):
             errCode = HCameraServiceStub::HandleCreateDeferredPhotoProcessingSession(data, reply);
             break;
+        case static_cast<uint32_t>(CameraServiceInterfaceCode::CAMERA_SERVICE_CREATE_DEFERRED_VIDEO_PROCESSING_SESSION):
+            errCode = HCameraServiceStub::HandleCreateDeferredVideoProcessingSession(data, reply);
+            break;
         case static_cast<uint32_t>(CameraServiceInterfaceCode::CAMERA_SERVICE_CREATE_PHOTO_OUTPUT):
             errCode = HCameraServiceStub::HandleCreatePhotoOutput(data, reply);
             break;
@@ -392,6 +395,30 @@ int HCameraServiceStub::HandleCreateDeferredPhotoProcessingSession(MessageParcel
     return ret;
 }
 
+int HCameraServiceStub::HandleCreateDeferredVideoProcessingSession(MessageParcel &data, MessageParcel &reply)
+{
+    sptr<DeferredProcessing::IDeferredVideoProcessingSession> session = nullptr;
+
+    int32_t userId = data.ReadInt32();
+    auto remoteObject = data.ReadRemoteObject();
+    CHECK_AND_RETURN_RET_LOG(remoteObject != nullptr, IPC_STUB_INVALID_DATA_ERR,
+        "HandleCreateDeferredVideoProcessingSession DeferredVideoProcessingSessionCallback is null");
+
+    auto callback = iface_cast<DeferredProcessing::IDeferredVideoProcessingSessionCallback>(remoteObject);
+    CHECK_AND_RETURN_RET_LOG(callback != nullptr, IPC_STUB_INVALID_DATA_ERR,
+                             "HCameraServiceStub HandleCreateDeferredVideoProcessingSession callback is null");
+    int errCode = CreateDeferredVideoProcessingSession(userId, callback, session);
+    if (errCode != ERR_NONE) {
+        MEDIA_ERR_LOG("HandleCreateDeferredVideoProcessingSession create failed : %{public}d", errCode);
+        return errCode;
+    }
+
+    CHECK_AND_RETURN_RET_LOG(reply.WriteRemoteObject(session->AsObject()), IPC_STUB_WRITE_PARCEL_ERR,
+        " HandleCreateDeferredVideoProcessingSession Write HandleCreateDeferredVideoProcessingSession obj failed");
+
+    return errCode;
+}
+
 int HCameraServiceStub::HandleCreatePhotoOutput(MessageParcel& data, MessageParcel& reply)
 {
     sptr<IStreamCapture> photoOutput = nullptr;
diff --git a/services/camera_service/binder/server/src/hstream_repeat_callback_stub.cpp b/services/camera_service/binder/server/src/hstream_repeat_callback_stub.cpp
index 8b3ba4294..54c196381 100644
--- a/services/camera_service/binder/server/src/hstream_repeat_callback_stub.cpp
+++ b/services/camera_service/binder/server/src/hstream_repeat_callback_stub.cpp
@@ -39,6 +39,9 @@ int HStreamRepeatCallbackStub::OnRemoteRequest(
         case static_cast<uint32_t>(StreamRepeatCallbackInterfaceCode::CAMERA_STREAM_SKETCH_STATUS_ON_CHANGED):
             errCode = HStreamRepeatCallbackStub::HandleOnSketchStatusChanged(data);
             break;
+        case static_cast<uint32_t>(StreamRepeatCallbackInterfaceCode::CAMERA_STREAM_REPEAT_VIDEO_DEFERRED_INFO):
+            errCode = HStreamRepeatCallbackStub::HandleOnDeferredVideoEnhancementInfo(data);
+            break;
         default:
             MEDIA_ERR_LOG("HStreamRepeatCallbackStub request code %{public}u not handled", code);
             errCode = IPCObjectStub::OnRemoteRequest(code, data, reply, option);
@@ -65,5 +68,15 @@ int HStreamRepeatCallbackStub::HandleOnSketchStatusChanged(MessageParcel& data)
     int32_t status = data.ReadInt32();
     return OnSketchStatusChanged(static_cast<SketchStatus>(status));
 }
+
+int HStreamRepeatCallbackStub::HandleOnDeferredVideoEnhancementInfo(MessageParcel& data)
+{
+    CaptureEndedInfoExt captureEndedInfo;
+    captureEndedInfo.streamId = data.ReadInt32();
+    captureEndedInfo.frameCount = data.ReadInt32();
+    captureEndedInfo.isDeferredVideoEnhancementAvailable = data.ReadBool();
+    captureEndedInfo.videoId = data.ReadString();
+    return OnDeferredVideoEnhancementInfo(captureEndedInfo);
+}
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/services/camera_service/include/hcamera_service.h b/services/camera_service/include/hcamera_service.h
index 98525bfbb..352687b09 100644
--- a/services/camera_service/include/hcamera_service.h
+++ b/services/camera_service/include/hcamera_service.h
@@ -100,6 +100,9 @@ public:
     int32_t CreateDeferredPhotoProcessingSession(int32_t userId,
         sptr<DeferredProcessing::IDeferredPhotoProcessingSessionCallback>& callback,
         sptr<DeferredProcessing::IDeferredPhotoProcessingSession>& session) override;
+    int32_t CreateDeferredVideoProcessingSession(int32_t userId,
+        sptr<DeferredProcessing::IDeferredVideoProcessingSessionCallback>& callback,
+        sptr<DeferredProcessing::IDeferredVideoProcessingSession>& session) override;
     int32_t CreatePhotoOutput(const sptr<OHOS::IBufferProducer>& producer, int32_t format, int32_t width,
         int32_t height, sptr<IStreamCapture>& photoOutput) override;
     int32_t CreateDeferredPreviewOutput(
diff --git a/services/camera_service/include/hstream_repeat.h b/services/camera_service/include/hstream_repeat.h
index 8dc80c2c1..6f046d481 100644
--- a/services/camera_service/include/hstream_repeat.h
+++ b/services/camera_service/include/hstream_repeat.h
@@ -63,6 +63,7 @@ public:
     int32_t OnFrameEnded(int32_t frameCount);
     int32_t OnFrameError(int32_t errorType);
     int32_t OnSketchStatusChanged(SketchStatus status);
+    int32_t OnDeferredVideoEnhancementInfo(CaptureEndedInfoExt captureEndedInfo);
     int32_t AddDeferredSurface(const sptr<OHOS::IBufferProducer>& producer) override;
     int32_t ForkSketchStreamRepeat(
         int32_t width, int32_t height, sptr<IStreamRepeat>& sketchStream, float sketchRatio) override;
diff --git a/services/camera_service/src/hcamera_service.cpp b/services/camera_service/src/hcamera_service.cpp
index bb57aa801..75431094b 100644
--- a/services/camera_service/src/hcamera_service.cpp
+++ b/services/camera_service/src/hcamera_service.cpp
@@ -473,6 +473,23 @@ int32_t HCameraService::CreateDeferredPhotoProcessingSession(int32_t userId,
     return CAMERA_OK;
 }
 
+int32_t HCameraService::CreateDeferredVideoProcessingSession(int32_t userId,
+    sptr<DeferredProcessing::IDeferredVideoProcessingSessionCallback>& callback,
+    sptr<DeferredProcessing::IDeferredVideoProcessingSession>& session)
+{
+    CAMERA_SYNC_TRACE;
+    MEDIA_INFO_LOG("HCameraService::CreateDeferredVideoProcessingSession enter.");
+    sptr<DeferredProcessing::IDeferredVideoProcessingSession> videoSession;
+    int32_t uid = IPCSkeleton::GetCallingUid();
+    AccountSA::OsAccountManager::GetOsAccountLocalIdFromUid(uid, userId);
+    MEDIA_INFO_LOG("CreateDeferredVideoProcessingSession get uid:%{public}d userId:%{public}d", uid, userId);
+    videoSession =
+        DeferredProcessing::DeferredProcessingService::GetInstance().CreateDeferredVideoProcessingSession(userId,
+        callback);
+    session = videoSession;
+    return CAMERA_OK;
+}
+
 int32_t HCameraService::CreatePhotoOutput(const sptr<OHOS::IBufferProducer>& producer, int32_t format, int32_t width,
     int32_t height, sptr<IStreamCapture>& photoOutput)
 {
diff --git a/services/camera_service/src/hcapture_session.cpp b/services/camera_service/src/hcapture_session.cpp
index b54038764..b46d8e7c5 100644
--- a/services/camera_service/src/hcapture_session.cpp
+++ b/services/camera_service/src/hcapture_session.cpp
@@ -2112,7 +2112,28 @@ int32_t StreamOperatorCallback::OnCaptureEnded(int32_t captureId, const std::vec
 int32_t StreamOperatorCallback::OnCaptureEndedExt(int32_t captureId,
     const std::vector<OHOS::HDI::Camera::V1_3::CaptureEndedInfoExt>& infos)
 {
-    MEDIA_INFO_LOG("StreamOperatorCallback::OnCaptureEndedExt");
+    MEDIA_INFO_LOG("StreamOperatorCallback::OnCaptureEndedExt captureId:%{public}d", captureId);
+    std::lock_guard<std::mutex> lock(cbMutex_);
+    for (auto& captureInfo : infos) {
+        sptr<HStreamCommon> curStream = GetHdiStreamByStreamID(captureInfo.streamId_);
+        if (curStream == nullptr) {
+            MEDIA_ERR_LOG("StreamOperatorCallback::OnCaptureEndedExt StreamId: %{public}d not found."
+                          " Framecount: %{public}d",
+                captureInfo.streamId_, captureInfo.frameCount_);
+            return CAMERA_INVALID_ARG;
+        } else if (curStream->GetStreamType() == StreamType::REPEAT) {
+            CastStream<HStreamRepeat>(curStream)->OnFrameEnded(captureInfo.frameCount_);
+            CaptureEndedInfoExt extInfo;
+            extInfo.streamId = captureInfo.streamId_;
+            extInfo.frameCount = captureInfo.frameCount_;
+            extInfo.isDeferredVideoEnhancementAvailable = captureInfo.isDeferredVideoEnhancementAvailable_;
+            extInfo.videoId = captureInfo.videoId_;
+            MEDIA_INFO_LOG("StreamOperatorCallback::OnCaptureEndedExt captureId:%{public}d videoId:%{public}s "
+                           "isDeferredVideo:%{public}d",
+                captureId, extInfo.videoId.c_str(), extInfo.isDeferredVideoEnhancementAvailable);
+            CastStream<HStreamRepeat>(curStream)->OnDeferredVideoEnhancementInfo(extInfo);
+        }
+    }
     return CAMERA_OK;
 }
 
diff --git a/services/camera_service/src/hstream_repeat.cpp b/services/camera_service/src/hstream_repeat.cpp
index d7722f5df..c1e747e0c 100644
--- a/services/camera_service/src/hstream_repeat.cpp
+++ b/services/camera_service/src/hstream_repeat.cpp
@@ -364,6 +364,22 @@ int32_t HStreamRepeat::OnFrameEnded(int32_t frameCount)
     return CAMERA_OK;
 }
 
+int32_t HStreamRepeat::OnDeferredVideoEnhancementInfo(CaptureEndedInfoExt captureEndedInfo)
+{
+    CAMERA_SYNC_TRACE;
+    MEDIA_INFO_LOG("HStreamRepeat::OnDeferredVideoEnhancementInfo");
+    if (repeatStreamType_ == RepeatStreamType::VIDEO) {
+        // report video end dfx
+        CameraReportUtils::GetInstance().SetVideoEndInfo(1);
+        std::lock_guard<std::mutex> lock(callbackLock_);
+        if (streamRepeatCallback_ != nullptr) {
+            streamRepeatCallback_->OnDeferredVideoEnhancementInfo(captureEndedInfo);
+        }
+    }
+    UpdateSketchStatus(SketchStatus::STOPED);
+    return CAMERA_OK;
+}
+
 int32_t HStreamRepeat::OnFrameError(int32_t errorType)
 {
     std::lock_guard<std::mutex> lock(callbackLock_);
diff --git a/services/deferred_processing_service/BUILD.gn b/services/deferred_processing_service/BUILD.gn
index 12b336547..d37c7066e 100644
--- a/services/deferred_processing_service/BUILD.gn
+++ b/services/deferred_processing_service/BUILD.gn
@@ -22,8 +22,14 @@ ohos_shared_library("deferred_processing_service") {
     "binder/client/src/deferred_photo_processing_session_proxy.cpp",
     "binder/server/src/deferred_photo_processing_session_callback_stub.cpp",
     "binder/server/src/deferred_photo_processing_session_stub.cpp",
+    "binder/client/src/deferred_video_processing_session_callback_proxy.cpp",
+    "binder/client/src/deferred_video_processing_session_proxy.cpp",
+    "binder/server/src/deferred_video_processing_session_callback_stub.cpp",
+    "binder/server/src/deferred_video_processing_session_stub.cpp",
+    "src/base/basic_definitions.cpp",
     "src/base/buffer_info.cpp",
     "src/base/buffer_manager/shared_buffer.cpp",
+    "src/base/dps.cpp",
     "src/base/task_manager/task_group/base_task_group.cpp",
     "src/base/task_manager/task_group/delayed_task_group.cpp",
     "src/base/task_manager/task_group/task_group.cpp",
@@ -35,10 +41,44 @@ ohos_shared_library("deferred_processing_service") {
     "src/base/timer/steady_clock.cpp",
     "src/base/timer/time_broker.cpp",
     "src/base/timer/timer.cpp",
+    "src/base/command_server/command_server_impl.cpp",
+    "src/base/command_server/command_server.cpp",
+    "src/base/command_server/command.cpp",
     "src/deferred_processing_service.cpp",
     "src/dfx/dps_event_report.cpp",
+    "src/dfx/dps_video_report.cpp",
+    "src/event_monitor/events_info.cpp",
     "src/event_monitor/events_monitor.cpp",
+    "src/event_monitor/events_subscriber.cpp",
+    "src/event_monitor/impl/thermal_strategy.cpp",
+    "src/event_monitor/impl/screen_strategy.cpp",
+    "src/event_monitor/impl/charging_strategy.cpp",
+    "src/event_monitor/impl/battery_strategy.cpp",
+    "src/event_monitor/impl/battery_level_strategy.cpp",
+    "src/event_monitor/command/event_status_change_command.cpp",
+    "src/media_manager/demuxer.cpp",
+    "src/media_manager/media_manager.cpp",
+    "src/media_manager/mpeg_manager_factory.cpp",
+    "src/media_manager/mpeg_manager.cpp",
+    "src/media_manager/muxer.cpp",
+    "src/media_manager/reader.cpp",
+    "src/media_manager/track_factory.cpp",
+    "src/media_manager/track.cpp",
+    "src/media_manager/writer.cpp",
+    "src/post_processor/command/service_died_command.cpp",
+    "src/post_processor/command/video_process_command.cpp",
     "src/post_processor/photo_post_processor.cpp",
+    "src/post_processor/video_post_processor.cpp",
+    "src/schedule/base/ischeduler_video_state.cpp",
+    "src/schedule/impl/video_battery_level_state.cpp",
+    "src/schedule/impl/video_battery_state.cpp",
+    "src/schedule/impl/video_camera_state.cpp",
+    "src/schedule/impl/video_charging_state.cpp",
+    "src/schedule/impl/video_hal_state.cpp",
+    "src/schedule/impl/video_media_library_state.cpp",
+    "src/schedule/impl/video_photo_process_state.cpp",
+    "src/schedule/impl/video_screen_state.cpp",
+    "src/schedule/impl/video_temperature_state.cpp",
     "src/schedule/photo_processor/deferred_photo_controller.cpp",
     "src/schedule/photo_processor/deferred_photo_processor.cpp",
     "src/schedule/photo_processor/photo_job_repository/deferred_photo_job.cpp",
@@ -47,10 +87,23 @@ ohos_shared_library("deferred_processing_service") {
     "src/schedule/photo_processor/strategy/user_initiated_strategy.cpp",
     "src/schedule/scheduler_coordinator.cpp",
     "src/schedule/scheduler_manager.cpp",
+    "src/schedule/video_processor/deferred_video_controller.cpp",
+    "src/schedule/video_processor/deferred_video_processor.cpp",
+    "src/schedule/video_processor/strategy/video_strategy_center.cpp",
+    "src/schedule/video_processor/video_job_repository/deferred_video_job.cpp",
+    "src/schedule/video_processor/video_job_repository/video_job_queue.cpp",
+    "src/schedule/video_processor/video_job_repository/video_job_repository.cpp",
+    "src/session/command/session_command.cpp",
+    "src/session/command/sync_command.cpp",
+    "src/session/command/video_command.cpp",
     "src/session/photo_session/deferred_photo_processing_session.cpp",
     "src/session/session_coordinator.cpp",
     "src/session/session_info.cpp",
     "src/session/session_manager.cpp",
+    "src/session/video_session/video_session_info.cpp",
+    "src/session/video_session/deferred_video_processing_session.cpp",
+    "src/utils/dp_power_manager.cpp",
+    "src/utils/dp_timer.cpp",
     "src/utils/dp_utils.cpp",
   ]
   cflags = [
@@ -71,19 +124,32 @@ ohos_shared_library("deferred_processing_service") {
     "${multimedia_camera_framework_path}/services/deferred_processing_service/binder/client/include",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/binder/server/include",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/base/buffer_manager",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/base/command_server",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/base/task_manager",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/base/task_manager/task_group",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/base/timer",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/base/timer/core",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/dfx",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/event_monitor",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/event_monitor/base",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/event_monitor/command",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/event_monitor/impl",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/media_manager",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/post_processor",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/post_processor/command",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule/base",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule/impl",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule/photo_processor",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule/photo_processor/photo_job_repository",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule/photo_processor/strategy",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule/video_processor",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule/video_processor/strategy",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/schedule/video_processor/video_job_repository",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/session",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/session/command",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/session/photo_session",
+    "${multimedia_camera_framework_path}/services/deferred_processing_service/include/session/video_session",
     "${multimedia_camera_framework_path}/services/deferred_processing_service/include/utils",
     "${multimedia_camera_framework_path}/interfaces/inner_api/native/camera/include/utils",
   ]
@@ -98,6 +164,15 @@ ohos_shared_library("deferred_processing_service") {
     "ability_base:want",
     "access_token:libaccesstoken_sdk",
     "access_token:libprivacy_sdk",
+    "av_codec:av_codec_client",
+    "av_codec:native_media_acodec",
+    "av_codec:native_media_avcencinfo",
+    "av_codec:native_media_avdemuxer",
+    "av_codec:native_media_avmuxer",
+    "av_codec:native_media_avsource",
+    "av_codec:native_media_codecbase",
+    "av_codec:native_media_venc",
+    "av_codec:native_media_aenc",
     "bundle_framework:appexecfwk_base",
     "bundle_framework:appexecfwk_core",
     "c_utils:utils",
@@ -116,6 +191,7 @@ ohos_shared_library("deferred_processing_service") {
     "hitrace:hitrace_meter",
     "image_framework:image",
     "image_framework:image_native",
+    "init:libbegetutil",
     "ipc:ipc_core",
     "ipc:ipc_single",
     "safwk:system_ability_fwk",
@@ -144,6 +220,16 @@ ohos_shared_library("deferred_processing_service") {
     defines += [ "CAMERA_USE_THERMAL" ]
   }
 
+  if (use_battery_manager) {
+    external_deps += [ "battery_manager:batterysrv_client" ]
+    defines += [ "CAMERA_USE_BATTERY" ]
+  }
+
+  if (use_power_manager) {
+    external_deps += [ "power_manager:powermgr_client" ]
+    defines += [ "CAMERA_USE_POWER" ]
+  }
+
   cflags_cc = cflags
 
   part_name = "camera_framework"
diff --git a/services/deferred_processing_service/binder/IDeferredVideoProcessingSession.idl b/services/deferred_processing_service/binder/IDeferredVideoProcessingSession.idl
new file mode 100644
index 000000000..a7c099ece
--- /dev/null
+++ b/services/deferred_processing_service/binder/IDeferredVideoProcessingSession.idl
@@ -0,0 +1,12 @@
+sequenceable IpcFileDescriptor..OHOS.IPCFileDescriptor;
+interface OHOS.CameraStandard.DeferredProcessing.IDeferredVideoProcessingSession {
+    void BeginSynchronize();
+
+    void EndSynchronize();
+
+    void AddVideo([in] String videoId, [in] IPCFileDescriptor srcFd, [in] IPCFileDescriptor dstFd);
+
+    void RemoveVideo([in] String videoId, [in] boolean restorable);
+
+    void RestoreVideo([in] String videoId);
+}
\ No newline at end of file
diff --git a/services/deferred_processing_service/binder/IDeferredVideoProcessingSessionCallback.idl b/services/deferred_processing_service/binder/IDeferredVideoProcessingSessionCallback.idl
new file mode 100644
index 000000000..07ff8b713
--- /dev/null
+++ b/services/deferred_processing_service/binder/IDeferredVideoProcessingSessionCallback.idl
@@ -0,0 +1,8 @@
+sequenceable IpcFileDescriptor..OHOS.IPCFileDescriptor;
+interface OHOS.CameraStandard.DeferredProcessing.IDeferredVideoProcessingSessionCallback {
+    void OnProcessVideoDone([in] String videoId, [in] IPCFileDescriptor fd);
+
+    void OnError([in] String videoId, [in] int errorCode);
+    
+    void OnStateChanged([in] int status);
+}
\ No newline at end of file
diff --git a/services/deferred_processing_service/binder/base/include/ideferred_photo_processing_session.h b/services/deferred_processing_service/binder/base/include/ideferred_photo_processing_session.h
index d4a75c403..ea66ac134 100644
--- a/services/deferred_processing_service/binder/base/include/ideferred_photo_processing_session.h
+++ b/services/deferred_processing_service/binder/base/include/ideferred_photo_processing_session.h
@@ -1,47 +1,47 @@
-/*
- * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef OHOS_IDEFERRED_PHOTO_PROCESSING_SESSION_H
-#define OHOS_IDEFERRED_PHOTO_PROCESSING_SESSION_H
-
-#include "iremote_broker.h"
-#include "foundation/multimedia/camera_framework/interfaces/inner_api/native/camera/include/utils/dps_metadata_info.h"
-
-namespace OHOS {
-namespace CameraStandard {
-namespace DeferredProcessing {
-class IDeferredPhotoProcessingSession : public IRemoteBroker {
-public:
-    virtual int32_t BeginSynchronize() = 0;
-
-    virtual int32_t EndSynchronize() = 0;
-
-    virtual int32_t AddImage(const std::string imageId, DpsMetadata& metadata, const bool discardable = false) = 0;
-
-    virtual int32_t RemoveImage(const std::string imageId, const bool restorable = false) = 0;
-
-    virtual int32_t RestoreImage(const std::string imageId) = 0;
-
-    virtual int32_t ProcessImage(const std::string appName, const std::string imageId) = 0;
-
-    virtual int32_t CancelProcessImage(const std::string imageId) = 0;
-
-    DECLARE_INTERFACE_DESCRIPTOR(u"IDeferredPhotoProcessingSession");
-};
-} // namespace DeferredProcessing
-} // namespace CameraStandard
-} // namespace OHOS
-
-#endif // OHOS_IDEFERRED_PHOTO_PROCESSING_SESSION_H
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_IDEFERRED_PHOTO_PROCESSING_SESSION_H
+#define OHOS_IDEFERRED_PHOTO_PROCESSING_SESSION_H
+
+#include "iremote_broker.h"
+#include "foundation/multimedia/camera_framework/interfaces/inner_api/native/camera/include/utils/dps_metadata_info.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class IDeferredPhotoProcessingSession : public IRemoteBroker {
+public:
+    virtual int32_t BeginSynchronize() = 0;
+
+    virtual int32_t EndSynchronize() = 0;
+
+    virtual int32_t AddImage(const std::string& imageId, DpsMetadata& metadata, const bool discardable = false) = 0;
+
+    virtual int32_t RemoveImage(const std::string& imageId, const bool restorable = false) = 0;
+
+    virtual int32_t RestoreImage(const std::string& imageId) = 0;
+
+    virtual int32_t ProcessImage(const std::string& appName, const std::string imageId) = 0;
+
+    virtual int32_t CancelProcessImage(const std::string& imageId) = 0;
+
+    DECLARE_INTERFACE_DESCRIPTOR(u"IDeferredPhotoProcessingSession");
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+
+#endif // OHOS_IDEFERRED_PHOTO_PROCESSING_SESSION_H
diff --git a/services/deferred_processing_service/binder/base/include/ideferred_photo_processing_session_callback.h b/services/deferred_processing_service/binder/base/include/ideferred_photo_processing_session_callback.h
index afa4b3da6..2a9e556ef 100644
--- a/services/deferred_processing_service/binder/base/include/ideferred_photo_processing_session_callback.h
+++ b/services/deferred_processing_service/binder/base/include/ideferred_photo_processing_session_callback.h
@@ -36,6 +36,11 @@ enum ErrorCode {
     ERROR_IMAGE_PROC_TIMEOUT = 4,
     ERROR_IMAGE_PROC_ABNORMAL = 5,
     ERROR_IMAGE_PROC_INTERRUPTED = 6,
+
+    ERROR_VIDEO_PROC_INVALID_VIDEO_ID = 7,
+    ERROR_VIDEO_PROC_FAILED = 8,
+    ERROR_VIDEO_PROC_TIMEOUT = 9,
+    ERROR_VIDEO_PROC_INTERRUPTED = 10,
 };
 
 enum StatusCode {
diff --git a/services/deferred_processing_service/binder/base/include/ideferred_video_processing_session.h b/services/deferred_processing_service/binder/base/include/ideferred_video_processing_session.h
new file mode 100644
index 000000000..9ec749fc4
--- /dev/null
+++ b/services/deferred_processing_service/binder/base/include/ideferred_video_processing_session.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERASTANDARD_DEFERREDPROCESSING_IDEFERREDVIDEOPROCESSINGSESSION_H
+#define OHOS_CAMERASTANDARD_DEFERREDPROCESSING_IDEFERREDVIDEOPROCESSINGSESSION_H
+
+#include <string_ex.h>
+#include <cstdint>
+#include <iremote_broker.h>
+#include "ipc_file_descriptor.h"
+
+using OHOS::IPCFileDescriptor;
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class IDeferredVideoProcessingSession : public IRemoteBroker {
+public:
+    DECLARE_INTERFACE_DESCRIPTOR(u"OHOS.CameraStandard.DeferredProcessing.IDeferredVideoProcessingSession");
+
+    virtual int32_t BeginSynchronize() = 0;
+
+    virtual int32_t EndSynchronize() = 0;
+
+    virtual int32_t AddVideo(
+        const std::string& videoId,
+        const sptr<IPCFileDescriptor>& srcFd,
+        const sptr<IPCFileDescriptor>& dstFd) = 0;
+
+    virtual int32_t RemoveVideo(
+        const std::string& videoId,
+        bool restorable) = 0;
+
+    virtual int32_t RestoreVideo(
+        const std::string& videoId) = 0;
+protected:
+    const int VECTOR_MAX_SIZE = 102400;
+    const int LIST_MAX_SIZE = 102400;
+    const int MAP_MAX_SIZE = 102400;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERASTANDARD_DEFERREDPROCESSING_IDEFERREDVIDEOPROCESSINGSESSION_H
+
diff --git a/services/deferred_processing_service/binder/base/include/ideferred_video_processing_session_callback.h b/services/deferred_processing_service/binder/base/include/ideferred_video_processing_session_callback.h
new file mode 100644
index 000000000..b0c6cfc3b
--- /dev/null
+++ b/services/deferred_processing_service/binder/base/include/ideferred_video_processing_session_callback.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERASTANDARD_DEFERREDPROCESSING_IDEFERREDVIDEOPROCESSINGSESSIONCALLBACK_H
+#define OHOS_CAMERASTANDARD_DEFERREDPROCESSING_IDEFERREDVIDEOPROCESSINGSESSIONCALLBACK_H
+
+#include <string_ex.h>
+#include <cstdint>
+#include <iremote_broker.h>
+#include "ipc_file_descriptor.h"
+
+using OHOS::IPCFileDescriptor;
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class IDeferredVideoProcessingSessionCallback : public IRemoteBroker {
+public:
+    DECLARE_INTERFACE_DESCRIPTOR(u"OHOS.CameraStandard.DeferredProcessing.IDeferredVideoProcessingSessionCallback");
+
+    virtual ErrCode OnProcessVideoDone(
+        const std::string& videoId,
+        const sptr<IPCFileDescriptor>& fd) = 0;
+
+    virtual ErrCode OnError(
+        const std::string& videoId,
+        int32_t errorCode) = 0;
+
+    virtual ErrCode OnStateChanged(
+        int32_t status) = 0;
+protected:
+    const int VECTOR_MAX_SIZE = 102400;
+    const int LIST_MAX_SIZE = 102400;
+    const int MAP_MAX_SIZE = 102400;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERASTANDARD_DEFERREDPROCESSING_IDEFERREDVIDEOPROCESSINGSESSIONCALLBACK_H
+
diff --git a/services/deferred_processing_service/binder/client/include/deferred_photo_processing_session_proxy.h b/services/deferred_processing_service/binder/client/include/deferred_photo_processing_session_proxy.h
index 7acc9b4ff..04549abe8 100644
--- a/services/deferred_processing_service/binder/client/include/deferred_photo_processing_session_proxy.h
+++ b/services/deferred_processing_service/binder/client/include/deferred_photo_processing_session_proxy.h
@@ -1,43 +1,43 @@
-/*
- * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef OHOS_DEFERRED_PHOTO_PROCESSING_SESSION_PROXY_H
-#define OHOS_DEFERRED_PHOTO_PROCESSING_SESSION_PROXY_H
-
-#include "iremote_proxy.h"
-#include "ideferred_photo_processing_session.h"
-
-namespace OHOS {
-namespace CameraStandard {
-namespace DeferredProcessing {
-class DeferredPhotoProcessingSessionProxy : public IRemoteProxy<IDeferredPhotoProcessingSession> {
-public:
-    explicit DeferredPhotoProcessingSessionProxy(const sptr<IRemoteObject> &impl);
-    virtual ~DeferredPhotoProcessingSessionProxy() = default;
-    int32_t BeginSynchronize() override;
-    int32_t EndSynchronize() override;
-    int32_t AddImage(const std::string imageId, DpsMetadata& metadata, const bool discardable) override;
-    int32_t RemoveImage(const std::string imageId, const bool restorable) override;
-    int32_t RestoreImage(const std::string imageId) override;
-    int32_t ProcessImage(const std::string appName, const std::string imageId) override;
-    int32_t CancelProcessImage(const std::string imageId) override;
-
-private:
-    static inline BrokerDelegator<DeferredPhotoProcessingSessionProxy> delegator_;
-};
-} // namespace DeferredProcessing
-} // namespace CameraStandard
-} // namespace OHOS
-#endif // OHOS_DEFERRED_PHOTO_PROCESSING_SESSION_PROXY_H
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_DEFERRED_PHOTO_PROCESSING_SESSION_PROXY_H
+#define OHOS_DEFERRED_PHOTO_PROCESSING_SESSION_PROXY_H
+
+#include "iremote_proxy.h"
+#include "ideferred_photo_processing_session.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class DeferredPhotoProcessingSessionProxy : public IRemoteProxy<IDeferredPhotoProcessingSession> {
+public:
+    explicit DeferredPhotoProcessingSessionProxy(const sptr<IRemoteObject> &impl);
+    virtual ~DeferredPhotoProcessingSessionProxy() = default;
+    int32_t BeginSynchronize() override;
+    int32_t EndSynchronize() override;
+    int32_t AddImage(const std::string& imageId, DpsMetadata& metadata, const bool discardable) override;
+    int32_t RemoveImage(const std::string& imageId, const bool restorable) override;
+    int32_t RestoreImage(const std::string& imageId) override;
+    int32_t ProcessImage(const std::string& appName, const std::string imageId) override;
+    int32_t CancelProcessImage(const std::string& imageId) override;
+
+private:
+    static inline BrokerDelegator<DeferredPhotoProcessingSessionProxy> delegator_;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_DEFERRED_PHOTO_PROCESSING_SESSION_PROXY_H
diff --git a/services/deferred_processing_service/binder/client/include/deferred_video_processing_session_callback_proxy.h b/services/deferred_processing_service/binder/client/include/deferred_video_processing_session_callback_proxy.h
new file mode 100644
index 000000000..b43ba39dd
--- /dev/null
+++ b/services/deferred_processing_service/binder/client/include/deferred_video_processing_session_callback_proxy.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERASTANDARD_DEFERREDPROCESSING_DEFERREDVIDEOPROCESSINGSESSIONCALLBACKPROXY_H
+#define OHOS_CAMERASTANDARD_DEFERREDPROCESSING_DEFERREDVIDEOPROCESSINGSESSIONCALLBACKPROXY_H
+
+#include "ideferred_video_processing_session_callback.h"
+#include <iremote_proxy.h>
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class DeferredVideoProcessingSessionCallbackProxy : public IRemoteProxy<IDeferredVideoProcessingSessionCallback> {
+public:
+    explicit DeferredVideoProcessingSessionCallbackProxy(
+        const sptr<IRemoteObject>& remote)
+        : IRemoteProxy<IDeferredVideoProcessingSessionCallback>(remote)
+    {
+    }
+
+    virtual ~DeferredVideoProcessingSessionCallbackProxy()
+    {
+    }
+
+    ErrCode OnProcessVideoDone(
+        const std::string& videoId,
+        const sptr<IPCFileDescriptor>& fd) override;
+
+    ErrCode OnError(
+        const std::string& videoId,
+        int32_t errorCode) override;
+
+    ErrCode OnStateChanged(
+        int32_t status) override;
+
+private:
+    static constexpr int32_t COMMAND_ON_PROCESS_VIDEO_DONE = MIN_TRANSACTION_ID + 0;
+    static constexpr int32_t COMMAND_ON_ERROR = MIN_TRANSACTION_ID + 1;
+    static constexpr int32_t COMMAND_ON_STATE_CHANGED = MIN_TRANSACTION_ID + 2;
+
+    static inline BrokerDelegator<DeferredVideoProcessingSessionCallbackProxy> delegator_;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERASTANDARD_DEFERREDPROCESSING_DEFERREDVIDEOPROCESSINGSESSIONCALLBACKPROXY_H
+
diff --git a/services/deferred_processing_service/binder/client/include/deferred_video_processing_session_proxy.h b/services/deferred_processing_service/binder/client/include/deferred_video_processing_session_proxy.h
new file mode 100644
index 000000000..7be4230af
--- /dev/null
+++ b/services/deferred_processing_service/binder/client/include/deferred_video_processing_session_proxy.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERASTANDARD_DEFERREDPROCESSING_DEFERREDVIDEOPROCESSINGSESSIONPROXY_H
+#define OHOS_CAMERASTANDARD_DEFERREDPROCESSING_DEFERREDVIDEOPROCESSINGSESSIONPROXY_H
+
+#include "ideferred_video_processing_session.h"
+#include <iremote_proxy.h>
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class DeferredVideoProcessingSessionProxy : public IRemoteProxy<IDeferredVideoProcessingSession> {
+public:
+    explicit DeferredVideoProcessingSessionProxy(
+        const sptr<IRemoteObject>& remote)
+        : IRemoteProxy<IDeferredVideoProcessingSession>(remote)
+    {
+    }
+
+    virtual ~DeferredVideoProcessingSessionProxy()
+    {
+    }
+
+    ErrCode BeginSynchronize() override;
+
+    ErrCode EndSynchronize() override;
+
+    ErrCode AddVideo(
+        const std::string& videoId,
+        const sptr<IPCFileDescriptor>& srcFd,
+        const sptr<IPCFileDescriptor>& dstFd) override;
+
+    ErrCode RemoveVideo(
+        const std::string& videoId,
+        bool restorable) override;
+
+    ErrCode RestoreVideo(
+        const std::string& videoId) override;
+
+private:
+    static constexpr int32_t COMMAND_BEGIN_SYNCHRONIZE = MIN_TRANSACTION_ID + 0;
+    static constexpr int32_t COMMAND_END_SYNCHRONIZE = MIN_TRANSACTION_ID + 1;
+    static constexpr int32_t COMMAND_ADD_VIDEO = MIN_TRANSACTION_ID + 2;
+    static constexpr int32_t COMMAND_REMOVE_VIDEO = MIN_TRANSACTION_ID + 3;
+    static constexpr int32_t COMMAND_RESTORE_VIDEO = MIN_TRANSACTION_ID + 4;
+
+    static inline BrokerDelegator<DeferredVideoProcessingSessionProxy> delegator_;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERASTANDARD_DEFERREDPROCESSING_DEFERREDVIDEOPROCESSINGSESSIONPROXY_H
+
diff --git a/services/deferred_processing_service/binder/client/src/deferred_photo_processing_session_proxy.cpp b/services/deferred_processing_service/binder/client/src/deferred_photo_processing_session_proxy.cpp
index 9a7f3b88c..5562ecf75 100644
--- a/services/deferred_processing_service/binder/client/src/deferred_photo_processing_session_proxy.cpp
+++ b/services/deferred_processing_service/binder/client/src/deferred_photo_processing_session_proxy.cpp
@@ -54,7 +54,7 @@ int32_t DeferredPhotoProcessingSessionProxy::EndSynchronize()
     return error;
 }
 
-int32_t DeferredPhotoProcessingSessionProxy::AddImage(const std::string imageId,
+int32_t DeferredPhotoProcessingSessionProxy::AddImage(const std::string& imageId,
                                                       DpsMetadata& metadata, const bool discardable)
 {
     MessageParcel data;
@@ -74,7 +74,7 @@ int32_t DeferredPhotoProcessingSessionProxy::AddImage(const std::string imageId,
     return error;
 }
 
-int32_t DeferredPhotoProcessingSessionProxy::RemoveImage(const std::string imageId, const bool restorable)
+int32_t DeferredPhotoProcessingSessionProxy::RemoveImage(const std::string& imageId, const bool restorable)
 {
     MessageParcel data;
     MessageParcel reply;
@@ -92,7 +92,7 @@ int32_t DeferredPhotoProcessingSessionProxy::RemoveImage(const std::string image
     return error;
 }
 
-int32_t DeferredPhotoProcessingSessionProxy::RestoreImage(const std::string imageId)
+int32_t DeferredPhotoProcessingSessionProxy::RestoreImage(const std::string& imageId)
 {
     MessageParcel data;
     MessageParcel reply;
@@ -109,7 +109,7 @@ int32_t DeferredPhotoProcessingSessionProxy::RestoreImage(const std::string imag
     return error;
 }
 
-int32_t DeferredPhotoProcessingSessionProxy::ProcessImage(const std::string appName, const std::string imageId)
+int32_t DeferredPhotoProcessingSessionProxy::ProcessImage(const std::string& appName, const std::string imageId)
 {
     MessageParcel data;
     MessageParcel reply;
@@ -127,7 +127,7 @@ int32_t DeferredPhotoProcessingSessionProxy::ProcessImage(const std::string appN
     return error;
 }
 
-int32_t DeferredPhotoProcessingSessionProxy::CancelProcessImage(const std::string imageId)
+int32_t DeferredPhotoProcessingSessionProxy::CancelProcessImage(const std::string& imageId)
 {
     MessageParcel data;
     MessageParcel reply;
@@ -144,6 +144,6 @@ int32_t DeferredPhotoProcessingSessionProxy::CancelProcessImage(const std::strin
     return error;
 }
 
-} //namespace DeferredProcessing
+} // namespace DeferredProcessing
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/services/deferred_processing_service/binder/client/src/deferred_video_processing_session_callback_proxy.cpp b/services/deferred_processing_service/binder/client/src/deferred_video_processing_session_callback_proxy.cpp
new file mode 100644
index 000000000..e77e47778
--- /dev/null
+++ b/services/deferred_processing_service/binder/client/src/deferred_video_processing_session_callback_proxy.cpp
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "deferred_video_processing_session_callback_proxy.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+ErrCode DeferredVideoProcessingSessionCallbackProxy::OnProcessVideoDone(
+    const std::string& videoId, const sptr<IPCFileDescriptor>& fd)
+{
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option(MessageOption::TF_SYNC);
+
+    if (!data.WriteInterfaceToken(GetDescriptor())) {
+        return ERR_INVALID_VALUE;
+    }
+
+    if (!data.WriteString16(Str8ToStr16(videoId))) {
+        return ERR_INVALID_DATA;
+    }
+    if (!data.WriteParcelable(fd)) {
+        return ERR_INVALID_DATA;
+    }
+    sptr<IRemoteObject> remote = Remote();
+    if (remote == nullptr) {
+        return ERR_INVALID_DATA;
+    }
+
+    int32_t result = remote->SendRequest(COMMAND_ON_PROCESS_VIDEO_DONE, data, reply, option);
+    if (FAILED(result)) {
+        return result;
+    }
+    ErrCode errCode = reply.ReadInt32();
+    if (FAILED(errCode)) {
+        return errCode;
+    }
+
+    return ERR_OK;
+}
+
+ErrCode DeferredVideoProcessingSessionCallbackProxy::OnError(
+    const std::string& videoId,
+    int32_t errorCode)
+{
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option(MessageOption::TF_SYNC);
+
+    if (!data.WriteInterfaceToken(GetDescriptor())) {
+        return ERR_INVALID_VALUE;
+    }
+
+    if (!data.WriteString16(Str8ToStr16(videoId))) {
+        return ERR_INVALID_DATA;
+    }
+    if (!data.WriteInt32(errorCode)) {
+        return ERR_INVALID_DATA;
+    }
+    sptr<IRemoteObject> remote = Remote();
+    if (remote == nullptr) {
+        return ERR_INVALID_DATA;
+    }
+
+    int32_t result = remote->SendRequest(COMMAND_ON_ERROR, data, reply, option);
+    if (FAILED(result)) {
+        return result;
+    }
+    ErrCode errCode = reply.ReadInt32();
+    if (FAILED(errCode)) {
+        return errCode;
+    }
+
+    return ERR_OK;
+}
+
+ErrCode DeferredVideoProcessingSessionCallbackProxy::OnStateChanged(
+    int32_t status)
+{
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option(MessageOption::TF_SYNC);
+
+    if (!data.WriteInterfaceToken(GetDescriptor())) {
+        return ERR_INVALID_VALUE;
+    }
+
+    if (!data.WriteInt32(status)) {
+        return ERR_INVALID_DATA;
+    }
+    sptr<IRemoteObject> remote = Remote();
+    if (remote == nullptr) {
+        return ERR_INVALID_DATA;
+    }
+
+    int32_t result = remote->SendRequest(COMMAND_ON_STATE_CHANGED, data, reply, option);
+    if (FAILED(result)) {
+        return result;
+    }
+    ErrCode errCode = reply.ReadInt32();
+    if (FAILED(errCode)) {
+        return errCode;
+    }
+
+    return ERR_OK;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
diff --git a/services/deferred_processing_service/binder/client/src/deferred_video_processing_session_proxy.cpp b/services/deferred_processing_service/binder/client/src/deferred_video_processing_session_proxy.cpp
new file mode 100644
index 000000000..9c5617ac2
--- /dev/null
+++ b/services/deferred_processing_service/binder/client/src/deferred_video_processing_session_proxy.cpp
@@ -0,0 +1,181 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "deferred_video_processing_session_proxy.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+ErrCode DeferredVideoProcessingSessionProxy::BeginSynchronize()
+{
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option(MessageOption::TF_SYNC);
+
+    if (!data.WriteInterfaceToken(GetDescriptor())) {
+        return ERR_INVALID_VALUE;
+    }
+
+    sptr<IRemoteObject> remote = Remote();
+    if (remote == nullptr) {
+        return ERR_INVALID_DATA;
+    }
+
+    int32_t result = remote->SendRequest(COMMAND_BEGIN_SYNCHRONIZE, data, reply, option);
+    if (FAILED(result)) {
+        return result;
+    }
+    ErrCode errCode = reply.ReadInt32();
+    if (FAILED(errCode)) {
+        return errCode;
+    }
+
+    return ERR_OK;
+}
+
+ErrCode DeferredVideoProcessingSessionProxy::EndSynchronize()
+{
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option(MessageOption::TF_SYNC);
+
+    if (!data.WriteInterfaceToken(GetDescriptor())) {
+        return ERR_INVALID_VALUE;
+    }
+
+    sptr<IRemoteObject> remote = Remote();
+    if (remote == nullptr) {
+        return ERR_INVALID_DATA;
+    }
+
+    int32_t result = remote->SendRequest(COMMAND_END_SYNCHRONIZE, data, reply, option);
+    if (FAILED(result)) {
+        return result;
+    }
+    ErrCode errCode = reply.ReadInt32();
+    if (FAILED(errCode)) {
+        return errCode;
+    }
+
+    return ERR_OK;
+}
+
+ErrCode DeferredVideoProcessingSessionProxy::AddVideo(
+    const std::string& videoId,
+    const sptr<IPCFileDescriptor>& srcFd,
+    const sptr<IPCFileDescriptor>& dstFd)
+{
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option(MessageOption::TF_SYNC);
+
+    if (!data.WriteInterfaceToken(GetDescriptor())) {
+        return ERR_INVALID_VALUE;
+    }
+
+    if (!data.WriteString16(Str8ToStr16(videoId))) {
+        return ERR_INVALID_DATA;
+    }
+    if (!data.WriteParcelable(srcFd)) {
+        return ERR_INVALID_DATA;
+    }
+    if (!data.WriteParcelable(dstFd)) {
+        return ERR_INVALID_DATA;
+    }
+    sptr<IRemoteObject> remote = Remote();
+    if (remote == nullptr) {
+        return ERR_INVALID_DATA;
+    }
+
+    int32_t result = remote->SendRequest(COMMAND_ADD_VIDEO, data, reply, option);
+    if (FAILED(result)) {
+        return result;
+    }
+    ErrCode errCode = reply.ReadInt32();
+    if (FAILED(errCode)) {
+        return errCode;
+    }
+
+    return ERR_OK;
+}
+
+ErrCode DeferredVideoProcessingSessionProxy::RemoveVideo(
+    const std::string& videoId,
+    bool restorable)
+{
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option(MessageOption::TF_SYNC);
+
+    if (!data.WriteInterfaceToken(GetDescriptor())) {
+        return ERR_INVALID_VALUE;
+    }
+
+    if (!data.WriteString16(Str8ToStr16(videoId))) {
+        return ERR_INVALID_DATA;
+    }
+    if (!data.WriteInt32(restorable ? 1 : 0)) {
+        return ERR_INVALID_DATA;
+    }
+    sptr<IRemoteObject> remote = Remote();
+    if (remote == nullptr) {
+        return ERR_INVALID_DATA;
+    }
+
+    int32_t result = remote->SendRequest(COMMAND_REMOVE_VIDEO, data, reply, option);
+    if (FAILED(result)) {
+        return result;
+    }
+    ErrCode errCode = reply.ReadInt32();
+    if (FAILED(errCode)) {
+        return errCode;
+    }
+
+    return ERR_OK;
+}
+
+ErrCode DeferredVideoProcessingSessionProxy::RestoreVideo(
+    const std::string& videoId)
+{
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option(MessageOption::TF_SYNC);
+
+    if (!data.WriteInterfaceToken(GetDescriptor())) {
+        return ERR_INVALID_VALUE;
+    }
+
+    if (!data.WriteString16(Str8ToStr16(videoId))) {
+        return ERR_INVALID_DATA;
+    }
+    sptr<IRemoteObject> remote = Remote();
+    if (remote == nullptr) {
+        return ERR_INVALID_DATA;
+    }
+
+    int32_t result = remote->SendRequest(COMMAND_RESTORE_VIDEO, data, reply, option);
+    if (FAILED(result)) {
+        return result;
+    }
+    ErrCode errCode = reply.ReadInt32();
+    if (FAILED(errCode)) {
+        return errCode;
+    }
+
+    return ERR_OK;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
diff --git a/services/deferred_processing_service/binder/server/include/deferred_video_processing_session_callback_stub.h b/services/deferred_processing_service/binder/server/include/deferred_video_processing_session_callback_stub.h
new file mode 100644
index 000000000..85336f1df
--- /dev/null
+++ b/services/deferred_processing_service/binder/server/include/deferred_video_processing_session_callback_stub.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERASTANDARD_DEFERREDPROCESSING_DEFERREDVIDEOPROCESSINGSESSIONCALLBACKSTUB_H
+#define OHOS_CAMERASTANDARD_DEFERREDPROCESSING_DEFERREDVIDEOPROCESSINGSESSIONCALLBACKSTUB_H
+
+#include "ideferred_video_processing_session_callback.h"
+#include <iremote_stub.h>
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class DeferredVideoProcessingSessionCallbackStub : public IRemoteStub<IDeferredVideoProcessingSessionCallback> {
+public:
+    int32_t OnRemoteRequest(
+        uint32_t code,
+        MessageParcel& data,
+        MessageParcel& reply,
+        MessageOption& option) override;
+
+private:
+    static constexpr int32_t COMMAND_ON_PROCESS_VIDEO_DONE = MIN_TRANSACTION_ID + 0;
+    static constexpr int32_t COMMAND_ON_ERROR = MIN_TRANSACTION_ID + 1;
+    static constexpr int32_t COMMAND_ON_STATE_CHANGED = MIN_TRANSACTION_ID + 2;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERASTANDARD_DEFERREDPROCESSING_DEFERREDVIDEOPROCESSINGSESSIONCALLBACKSTUB_H
+
diff --git a/services/deferred_processing_service/binder/server/include/deferred_video_processing_session_stub.h b/services/deferred_processing_service/binder/server/include/deferred_video_processing_session_stub.h
new file mode 100644
index 000000000..bc0e605bd
--- /dev/null
+++ b/services/deferred_processing_service/binder/server/include/deferred_video_processing_session_stub.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERASTANDARD_DEFERREDPROCESSING_DEFERREDVIDEOPROCESSINGSESSIONSTUB_H
+#define OHOS_CAMERASTANDARD_DEFERREDPROCESSING_DEFERREDVIDEOPROCESSINGSESSIONSTUB_H
+
+#include "ideferred_video_processing_session.h"
+#include <iremote_stub.h>
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class DeferredVideoProcessingSessionStub : public IRemoteStub<IDeferredVideoProcessingSession> {
+public:
+    int32_t OnRemoteRequest(
+        uint32_t code,
+        MessageParcel& data,
+        MessageParcel& reply,
+        MessageOption& option) override;
+
+private:
+    static constexpr int32_t COMMAND_BEGIN_SYNCHRONIZE = MIN_TRANSACTION_ID + 0;
+    static constexpr int32_t COMMAND_END_SYNCHRONIZE = MIN_TRANSACTION_ID + 1;
+    static constexpr int32_t COMMAND_ADD_VIDEO = MIN_TRANSACTION_ID + 2;
+    static constexpr int32_t COMMAND_REMOVE_VIDEO = MIN_TRANSACTION_ID + 3;
+    static constexpr int32_t COMMAND_RESTORE_VIDEO = MIN_TRANSACTION_ID + 4;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERASTANDARD_DEFERREDPROCESSING_DEFERREDVIDEOPROCESSINGSESSIONSTUB_H
+
diff --git a/services/deferred_processing_service/binder/server/src/deferred_photo_processing_session_callback_stub.cpp b/services/deferred_processing_service/binder/server/src/deferred_photo_processing_session_callback_stub.cpp
index 9489f380f..5af88f541 100644
--- a/services/deferred_processing_service/binder/server/src/deferred_photo_processing_session_callback_stub.cpp
+++ b/services/deferred_processing_service/binder/server/src/deferred_photo_processing_session_callback_stub.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
@@ -16,6 +16,7 @@
 #include "deferred_processing_service_ipc_interface_code.h"
 #include "dp_log.h"
 #include "picture.h"
+
 namespace OHOS {
 namespace CameraStandard {
 namespace DeferredProcessing {
@@ -25,7 +26,7 @@ int DeferredPhotoProcessingSessionCallbackStub::OnRemoteRequest(
 {
     int errCode = -1;
 
-    DP_CHECK_AND_RETURN_RET(data.ReadInterfaceToken() == GetDescriptor(), errCode);
+    DP_CHECK_RETURN_RET(data.ReadInterfaceToken() != GetDescriptor(), errCode);
     switch (code) {
         case static_cast<uint32_t>(
             DeferredProcessingServiceCallbackInterfaceCode::DPS_PHOTO_CALLBACK_PROCESS_IMAGE_DONE): {
diff --git a/services/deferred_processing_service/binder/server/src/deferred_photo_processing_session_stub.cpp b/services/deferred_processing_service/binder/server/src/deferred_photo_processing_session_stub.cpp
index 0df09366e..8e12b293f 100644
--- a/services/deferred_processing_service/binder/server/src/deferred_photo_processing_session_stub.cpp
+++ b/services/deferred_processing_service/binder/server/src/deferred_photo_processing_session_stub.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
@@ -35,7 +35,7 @@ int DeferredPhotoProcessingSessionStub::OnRemoteRequest(uint32_t code, MessagePa
     MessageParcel& reply, MessageOption& option)
 {
     int errCode = -1;
-    DP_CHECK_AND_RETURN_RET(data.ReadInterfaceToken() == GetDescriptor(), errCode);
+    DP_CHECK_RETURN_RET(data.ReadInterfaceToken() != GetDescriptor(), errCode);
     
     switch (code) {
         case static_cast<uint32_t>(DeferredProcessingServiceInterfaceCode::DPS_BEGIN_SYNCHRONIZE): {
diff --git a/services/deferred_processing_service/binder/server/src/deferred_video_processing_session_callback_stub.cpp b/services/deferred_processing_service/binder/server/src/deferred_video_processing_session_callback_stub.cpp
new file mode 100644
index 000000000..e32e6fa6c
--- /dev/null
+++ b/services/deferred_processing_service/binder/server/src/deferred_video_processing_session_callback_stub.cpp
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "deferred_video_processing_session_callback_stub.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+int32_t DeferredVideoProcessingSessionCallbackStub::OnRemoteRequest(
+    uint32_t code,
+    MessageParcel& data,
+    MessageParcel& reply,
+    MessageOption& option)
+{
+    std::u16string localDescriptor = GetDescriptor();
+    std::u16string remoteDescriptor = data.ReadInterfaceToken();
+    if (localDescriptor != remoteDescriptor) {
+        return ERR_TRANSACTION_FAILED;
+    }
+    switch (code) {
+        case COMMAND_ON_PROCESS_VIDEO_DONE: {
+            std::string videoId = Str16ToStr8(data.ReadString16());
+            sptr<IPCFileDescriptor> fd(data.ReadParcelable<IPCFileDescriptor>());
+            ErrCode errCode = OnProcessVideoDone(videoId, fd);
+            if (!reply.WriteInt32(errCode)) {
+                return ERR_INVALID_VALUE;
+            }
+            return ERR_NONE;
+        }
+        case COMMAND_ON_ERROR: {
+            std::string videoId = Str16ToStr8(data.ReadString16());
+            int32_t errorCode = data.ReadInt32();
+            ErrCode errCode = OnError(videoId, errorCode);
+            if (!reply.WriteInt32(errCode)) {
+                return ERR_INVALID_VALUE;
+            }
+            return ERR_NONE;
+        }
+        case COMMAND_ON_STATE_CHANGED: {
+            int32_t status = data.ReadInt32();
+            ErrCode errCode = OnStateChanged(status);
+            if (!reply.WriteInt32(errCode)) {
+                return ERR_INVALID_VALUE;
+            }
+            return ERR_NONE;
+        }
+        default:
+            return IPCObjectStub::OnRemoteRequest(code, data, reply, option);
+    }
+
+    return ERR_TRANSACTION_FAILED;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
diff --git a/services/deferred_processing_service/binder/server/src/deferred_video_processing_session_stub.cpp b/services/deferred_processing_service/binder/server/src/deferred_video_processing_session_stub.cpp
new file mode 100644
index 000000000..57c3f4f4b
--- /dev/null
+++ b/services/deferred_processing_service/binder/server/src/deferred_video_processing_session_stub.cpp
@@ -0,0 +1,90 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "deferred_video_processing_session_stub.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+int32_t DeferredVideoProcessingSessionStub::OnRemoteRequest(
+    uint32_t code,
+    MessageParcel& data,
+    MessageParcel& reply,
+    MessageOption& option)
+{
+    std::u16string localDescriptor = GetDescriptor();
+    std::u16string remoteDescriptor = data.ReadInterfaceToken();
+    if (localDescriptor != remoteDescriptor) {
+        return ERR_TRANSACTION_FAILED;
+    }
+    switch (code) {
+        case COMMAND_BEGIN_SYNCHRONIZE: {
+            ErrCode errCode = BeginSynchronize();
+            if (!reply.WriteInt32(errCode)) {
+                return ERR_INVALID_VALUE;
+            }
+            return ERR_NONE;
+        }
+        case COMMAND_END_SYNCHRONIZE: {
+            ErrCode errCode = EndSynchronize();
+            if (!reply.WriteInt32(errCode)) {
+                return ERR_INVALID_VALUE;
+            }
+            return ERR_NONE;
+        }
+        case COMMAND_ADD_VIDEO: {
+            std::string videoId = Str16ToStr8(data.ReadString16());
+            sptr<IPCFileDescriptor> srcFd(data.ReadParcelable<IPCFileDescriptor>());
+
+            if (!srcFd) {
+                return ERR_INVALID_DATA;
+            }
+            sptr<IPCFileDescriptor> dstFd(data.ReadParcelable<IPCFileDescriptor>());
+
+            if (!dstFd) {
+                return ERR_INVALID_DATA;
+            }
+            ErrCode errCode = AddVideo(videoId, srcFd, dstFd);
+            if (!reply.WriteInt32(errCode)) {
+                return ERR_INVALID_VALUE;
+            }
+            return ERR_NONE;
+        }
+        case COMMAND_REMOVE_VIDEO: {
+            std::string videoId = Str16ToStr8(data.ReadString16());
+            bool restorable = data.ReadInt32() == 1 ? true : false;
+            ErrCode errCode = RemoveVideo(videoId, restorable);
+            if (!reply.WriteInt32(errCode)) {
+                return ERR_INVALID_VALUE;
+            }
+            return ERR_NONE;
+        }
+        case COMMAND_RESTORE_VIDEO: {
+            std::string videoId = Str16ToStr8(data.ReadString16());
+            ErrCode errCode = RestoreVideo(videoId);
+            if (!reply.WriteInt32(errCode)) {
+                return ERR_INVALID_VALUE;
+            }
+            return ERR_NONE;
+        }
+        default:
+            return IPCObjectStub::OnRemoteRequest(code, data, reply, option);
+    }
+
+    return ERR_TRANSACTION_FAILED;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
diff --git a/services/deferred_processing_service/include/base/basic_definitions.h b/services/deferred_processing_service/include/base/basic_definitions.h
index 24f194f07..7f1083adc 100644
--- a/services/deferred_processing_service/include/base/basic_definitions.h
+++ b/services/deferred_processing_service/include/base/basic_definitions.h
@@ -13,21 +13,36 @@
  * limitations under the License.
  */
 
-#ifndef OHOS_DEFERRED_PROCESSING_SERVICE_BASIC_DEFINITIONS_H
-#define OHOS_DEFERRED_PROCESSING_SERVICE_BASIC_DEFINITIONS_H
+#ifndef OHOS_CAMERA_DPS_BASIC_DEFINITIONS_H
+#define OHOS_CAMERA_DPS_BASIC_DEFINITIONS_H
 
 #include <cstdint>
+#include <string>
 
 namespace OHOS {
 namespace CameraStandard {
 namespace DeferredProcessing {
+constexpr int32_t DEFAULT_OFFSET = 0;
+constexpr int32_t TOTAL_PROCESS_TIME = 10 * 60 * 1000;
+constexpr int32_t ONCE_PROCESS_TIME = 5 * 60 * 1000;
+constexpr uint32_t DELAY_TIME = 1000;
+const std::string PATH = "/data/service/el1/public/camera_service/";
+const std::string TEMP_TAG = "_vid_temp";
+const std::string OUT_TAG = "_vid";
+
 enum EventType : int32_t {
-    CAMERA_SESSION_STATUS_EVENT = 0,
-    HDI_STATUS_EVENT = 1,
-    MEDIA_LIBRARY_STATUS_EVENT = 2,
-    SYSTEM_PRESSURE_LEVEL_EVENT = 3,
-    USER_INITIATED_EVENT = 4,
-    AVAILABLE_CONCURRENT_EVENT = 5,
+    CAMERA_SESSION_STATUS_EVENT = 1,
+    HDI_STATUS_EVENT,
+    MEDIA_LIBRARY_STATUS_EVENT,
+    SCREEN_STATUS_EVENT,
+    CHARGING_STATUS_EVENT,
+    BATTERY_STATUS_EVENT,
+    BATTERY_LEVEL_STATUS_EVENT,
+    THERMAL_LEVEL_STATUS_EVENT,
+    PHOTO_PROCESS_STATUS_EVENT,
+    SYSTEM_PRESSURE_LEVEL_EVENT,
+    USER_INITIATED_EVENT,
+    AVAILABLE_CONCURRENT_EVENT,
 };
 
 enum CameraSessionStatus : int32_t {
@@ -51,6 +66,47 @@ enum MediaLibraryStatus : int32_t {
     MEDIA_LIBRARY_AVAILABLE,
 };
 
+enum ScreenStatus : int32_t {
+    SCREEN_ON = 0,
+    SCREEN_OFF,
+};
+
+enum ChargingStatus : int32_t {
+    DISCHARGING = 0,
+    CHARGING,
+};
+
+enum BatteryStatus : int32_t {
+    BATTERY_LOW = 0,
+    BATTERY_OKAY,
+};
+
+enum BatteryLevel : int32_t {
+    BATTERY_LEVEL_LOW = 0, // <= 50
+    BATTERY_LEVEL_OKAY,
+};
+
+enum PhotoProcessStatus : int32_t {
+    BUSY = 0, // > 0
+    IDLE,
+};
+
+enum ThermalLevel : int32_t {
+    LEVEL_0 = 0,
+    LEVEL_1,
+    LEVEL_2,
+    LEVEL_3,
+    LEVEL_4,
+    LEVEL_5,
+    LEVEL_6,
+    LEVEL_7
+};
+
+enum VideoThermalLevel : int8_t {
+    HOT = 0,
+    COOL
+};
+
 enum SystemPressureLevel : int32_t {
     NOMINAL = 0,
     FAIR,
@@ -82,6 +138,7 @@ enum ExceptionSource: int32_t {
 };
 
 enum DpsError : int32_t {
+    DPS_ERROR_UNKNOW = -1,
     // session specific error code
     DPS_ERROR_SESSION_SYNC_NEEDED = 0,
     DPS_ERROR_SESSION_NOT_READY_TEMPORARILY = 1,
@@ -93,6 +150,11 @@ enum DpsError : int32_t {
     DPS_ERROR_IMAGE_PROC_HIGH_TEMPERATURE = 5,
     DPS_ERROR_IMAGE_PROC_ABNORMAL = 6,
     DPS_ERROR_IMAGE_PROC_INTERRUPTED = 7,
+
+    DPS_ERROR_VIDEO_PROC_INVALID_VIDEO_ID = 8,
+    DPS_ERROR_VIDEO_PROC_FAILED = 9,
+    DPS_ERROR_VIDEO_PROC_TIMEOUT = 10,
+    DPS_ERROR_VIDEO_PROC_INTERRUPTED = 11,
 };
 
 enum DpsStatus : int32_t {
@@ -106,7 +168,48 @@ enum SessionType : int32_t {
     PHOTO_SESSION = 0,
     VDIIDEO_SESSION
 };
+
+enum ExecutionMode {
+    HIGH_PERFORMANCE = 0,
+    LOAD_BALANCE,
+    LOW_POWER,
+    DUMMY
+};
+
+enum ScheduleType : int32_t {
+    REMOVE = -1,
+    TRAILING_STATE = 0,
+    CAMERA_STATE,
+    HDI_STATE,
+    MEDIA_LIBRARY_STATE,
+    SCREEN_STATE,
+    CHARGING_STATE,
+    BATTERY_STATE,
+    BATTERY_LEVEL_STATE,
+    THERMAL_LEVEL_STATE,
+    PHOTO_PROCESS_STATE,
+    NORMAL_TIME_STATE
+};
+
+enum MediaManagerError : int32_t {
+    ERROR_NO_INITED = -2,
+    ERROR_FAIL = -1,
+    OK = 0,
+    EOS = 1,
+    RECOVER_EOS = 2,
+    PAUSE_RECEIVED = 3,
+    PAUSE_ABNORMAL = 4
+};
+
+enum MediaResult : int32_t {
+    FAIL = -1,
+    SUCCESS = 0,
+    PAUSE = 1
+};
+
+SystemPressureLevel MapEventThermalLevel(int32_t level);
+
 } // namespace DeferredProcessing
 } // namespace CameraStandard
 } // namespace OHOS
-#endif // OHOS_DEFERRED_PROCESSING_SERVICE_BASIC_DEFINITIONS_H
+#endif // OHOS_CAMERA_DPS_BASIC_DEFINITIONS_H
diff --git a/services/deferred_processing_service/include/base/buffer_info.h b/services/deferred_processing_service/include/base/buffer_info.h
index 71b82f7de..0bb3127e2 100644
--- a/services/deferred_processing_service/include/base/buffer_info.h
+++ b/services/deferred_processing_service/include/base/buffer_info.h
@@ -30,10 +30,23 @@ public:
     BufferInfo(const std::shared_ptr<SharedBuffer>& sharedBuffer, int32_t dataSize, bool isHighQuality,
         bool isCloudImageEnhanceSupported);
     ~BufferInfo();
+    
     sptr<IPCFileDescriptor> GetIPCFileDescriptor();
-    int32_t GetDataSize();
-    bool IsHighQuality();
-    bool IsCloudImageEnhanceSupported();
+
+    inline int32_t GetDataSize()
+    {
+        return dataSize_;
+    }
+
+    inline bool IsHighQuality()
+    {
+        return isHighQuality_;
+    }
+
+    inline bool IsCloudImageEnhanceSupported()
+    {
+        return isCloudImageEnhanceSupported_;
+    }
 
 private:
     std::shared_ptr<SharedBuffer> sharedBuffer_;
@@ -57,7 +70,7 @@ private:
     bool isHighQuality_;
     bool isCloudImageEnhanceSupported_;
 };
-} //namespace DeferredProcessing
+} // namespace DeferredProcessing
 } // namespace CameraStandard
 } // namespace OHOS
 #endif // OHOS_DEFERRED_PROCESSING_SERVICE_BUFFER_INFO_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/base/command_server/command.h b/services/deferred_processing_service/include/base/command_server/command.h
new file mode 100644
index 000000000..25d8eb6d7
--- /dev/null
+++ b/services/deferred_processing_service/include/base/command_server/command.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_COMMAND_H
+#define OHOS_CAMERA_DPS_COMMAND_H
+
+#include <cstdint>
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+
+#define DECLARE_CMD_CLASS(name) \
+    public:                     \
+        const char* GetCommandName() const override { return #name; }
+
+class Command {
+public:
+    Command();
+    virtual ~Command();
+
+    /**
+     * @brief Get Command Name
+     *
+     * @return Command Name
+     */
+    virtual const char* GetCommandName() const = 0;
+
+    /**
+     * @brief Provided for the invocation of Command by the CommandServer,
+     *        driving its operation.
+     *
+     * @return The DSP_OK status indicates successful execution of the command,
+     *         while other statuses indicate failure.
+     */
+    int32_t Do();
+
+protected:
+    /**
+     * @brief The action executed by Command needs to be overridden by a derived class.
+     *
+     * @return The DSP_OK status indicates successful execution of the command,
+     *         while other statuses indicate failure.
+     */
+    virtual int32_t Executing() = 0;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_COMMAND_H
diff --git a/services/deferred_processing_service/include/base/command_server/command_server.h b/services/deferred_processing_service/include/base/command_server/command_server.h
new file mode 100644
index 000000000..38c2acde8
--- /dev/null
+++ b/services/deferred_processing_service/include/base/command_server/command_server.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_COMMAND_SERVER_H
+#define OHOS_CAMERA_DPS_COMMAND_SERVER_H
+
+#include "command.h"
+#include "command_server_impl.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+using CmdSharedPtr = std::shared_ptr<Command>;
+class CommandServer {
+public:
+    CommandServer();
+    ~CommandServer();
+    
+    /**
+     * @brief Initialize
+     *
+     * Must be called before use
+     *
+     * @param [IN] cmdServerName
+     *
+     * @return The DSP_OK status indicates successful execution of the command,
+     *         while other statuses indicate failure.
+     */
+    int32_t Initialize(const std::string& cmdServerName = "DpsCmdServer");
+
+    /**
+     * @brief Send a command and execute it sequentially after it is added.
+     *
+     * @param [IN] cmd
+     *
+     * @return The DSP_OK status indicates successful execution of the command,
+     *         while other statuses indicate failure.
+     */
+    int32_t SendCommand(const CmdSharedPtr& cmd);
+
+    /**
+     * @brief Send an emergency command, and immediately invoke the command
+     *        after the execution of the command that is being executed.
+     *
+     * @param [IN] cmd
+     *
+     * @return The DSP_OK status indicates successful execution of the command,
+     *         while other statuses indicate failure.
+     */
+    int32_t SendUrgentCommand(const CmdSharedPtr& cmd);
+
+    /**
+     * @brief Set CommandServer priority
+     *
+     * @param [IN] priority
+     *
+     * @return void
+     *
+     */
+    void SetThreadPriority(int priority);
+
+    /**
+     * @brief Get CommandServer priority
+     *
+     * @return priority
+     *
+     */
+    int32_t GetThreadPriority() const;
+
+private:
+    std::shared_ptr<CommandServerImpl> server_;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_COMMAND_SERVER_H
diff --git a/services/deferred_processing_service/include/base/command_server/command_server_impl.h b/services/deferred_processing_service/include/base/command_server/command_server_impl.h
new file mode 100644
index 000000000..5a58b74dd
--- /dev/null
+++ b/services/deferred_processing_service/include/base/command_server/command_server_impl.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_COMMAND_SERVER_IMPL_H
+#define OHOS_CAMERA_DPS_COMMAND_SERVER_IMPL_H
+
+#include "command.h"
+#include "thread_pool.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+using CmdSharedPtr = std::shared_ptr<Command>;
+
+class CommandServerImpl
+    : public std::enable_shared_from_this<CommandServerImpl> {
+public:
+    explicit CommandServerImpl(const std::string& cmdServerName);
+    ~CommandServerImpl();
+
+    int32_t AddCommand(const CmdSharedPtr& cmd);
+    int32_t AddUrgentCommand(const CmdSharedPtr& cmd);
+
+    void SetThreadPriority(int priority);
+    int32_t GetThreadPriority() const;
+
+private:
+    std::string commandServerName_;
+    std::mutex mutexMsg_;
+    std::unique_ptr<ThreadPool> threadPool_;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_COMMAND_SERVER_IMPL_H
diff --git a/services/deferred_processing_service/include/base/dps.h b/services/deferred_processing_service/include/base/dps.h
new file mode 100644
index 000000000..ee64e94d3
--- /dev/null
+++ b/services/deferred_processing_service/include/base/dps.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_DPS_H
+#define OHOS_CAMERA_DPS_DPS_H
+
+#include "command_server.h"
+#include "session_manager.h"
+#include "scheduler_manager.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+int32_t DPS_Initialize();
+void DPS_Destory();
+
+std::shared_ptr<CommandServer> DPS_GetCommandServer();
+std::shared_ptr<SessionManager> DPS_GetSessionManager();
+std::shared_ptr<SchedulerManager> DPS_GetSchedulerManager();
+
+template <typename Command, typename Func, typename... Args>
+int32_t SendCommandHelp(Func&& func, Args&& ...args)
+{
+    auto cmd = std::make_shared<Command>(std::forward<Args>(args)...);
+    if (cmd) {
+        auto server = DPS_GetCommandServer();
+        if (server) {
+            return (server.get()->*func)(cmd);
+        }
+        return DP_NULL_POINTER;
+    }
+    return DP_SEND_COMMAND_FAILED;
+}
+
+/**
+ * @brief Create the cmd and send.
+ *
+ * @param [IN] args: Parameter list for cmd.
+ *
+ * @return The DSP_OK status indicates successful execution of the command,
+ *         while other statuses indicate failure.
+ */
+template <typename Command, typename... Args>
+int32_t DPS_SendCommand(Args&& ...args)
+{
+    return SendCommandHelp<Command>(&CommandServer::SendCommand, std::forward<Args>(args)...);
+}
+
+/**
+ * @brief Create the cmd and send it urgently.
+ *
+ * @param [IN] args: Parameter list for cmd.
+ *
+ * @return The DSP_OK status indicates successful execution of the command,
+ *         while other statuses indicate failure.
+ */
+template <typename Command, typename... Args>
+int32_t DPS_SendUrgentCommand(Args&& ...args)
+{
+    return SendCommandHelp<Command>(&CommandServer::SendUrgentCommand, std::forward<Args>(args)...);
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_DPS_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/base/iimage_process_callbacks.h b/services/deferred_processing_service/include/base/iimage_process_callbacks.h
index 723ad544c..13825b6c4 100644
--- a/services/deferred_processing_service/include/base/iimage_process_callbacks.h
+++ b/services/deferred_processing_service/include/base/iimage_process_callbacks.h
@@ -13,8 +13,8 @@
  * limitations under the License.
  */
 
-#ifndef OHOS_DEFERRED_PROCESSING_SERVICE_I_IMAGE_PROCESS_CALLBACKS_H
-#define OHOS_DEFERRED_PROCESSING_SERVICE_I_IMAGE_PROCESS_CALLBACKS_H
+#ifndef OHOS_CAMERA_DPS_I_IMAGE_PROCESS_CALLBACKS_H
+#define OHOS_CAMERA_DPS_I_IMAGE_PROCESS_CALLBACKS_H
 
 #include <cstdint>
 #include <string>
@@ -39,4 +39,4 @@ public:
 } // namespace DeferredProcessing
 } // namespace CameraStandard
 } // namespace OHOS
-#endif // OHOS_DEFERRED_PROCESSING_SERVICE_I_IMAGE_PROCESS_CALLBACKS_H
+#endif // OHOS_CAMERA_DPS_I_IMAGE_PROCESS_CALLBACKS_H
diff --git a/services/deferred_processing_service/include/base/ivideo_process_callbacks.h b/services/deferred_processing_service/include/base/ivideo_process_callbacks.h
new file mode 100644
index 000000000..844ce1663
--- /dev/null
+++ b/services/deferred_processing_service/include/base/ivideo_process_callbacks.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_I_VIDEO_PROCESS_CALLBACKS_H
+#define OHOS_CAMERA_DPS_I_VIDEO_PROCESS_CALLBACKS_H
+
+#include "basic_definitions.h"
+#include "buffer_info.h"
+#include "ipc_file_descriptor.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class IVideoProcessCallbacks {
+public:
+    virtual ~IVideoProcessCallbacks() = default;
+    virtual void OnProcessDone(const int32_t userId,
+        const std::string& videoId, const sptr<IPCFileDescriptor>& ipcFd) = 0;
+    virtual void OnError(const int32_t userId, const std::string& videoId, DpsError errorCode) = 0;
+    virtual void OnStateChanged(const int32_t userId, DpsStatus statusCode) = 0;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_I_VIDEO_PROCESS_CALLBACKS_H
diff --git a/services/deferred_processing_service/include/base/task_manager/thread_pool.h b/services/deferred_processing_service/include/base/task_manager/thread_pool.h
index fef49d481..787284dbf 100644
--- a/services/deferred_processing_service/include/base/task_manager/thread_pool.h
+++ b/services/deferred_processing_service/include/base/task_manager/thread_pool.h
@@ -1,90 +1,92 @@
-/*
- * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef OHOS_DEFERRED_PROCESSING_SERVICE_THREAD_POOL_H
-#define OHOS_DEFERRED_PROCESSING_SERVICE_THREAD_POOL_H
-
-#include <pthread.h>
-#include <atomic>
-#include <condition_variable>
-#include <cstdint>
-#include <functional>
-#include <mutex>
-#include <queue>
-#include <string>
-#include <thread>
-#include <vector>
-
-namespace OHOS {
-namespace CameraStandard {
-namespace DeferredProcessing {
-class ThreadPool {
-    using Task = std::function<void()>;
-
-public:
-    static std::unique_ptr<ThreadPool> Create(const std::string& name, uint32_t numThreads);
-    ~ThreadPool();
-    void BeginBackgroundTasks() const;
-    void EndBackgroundTasks() const;
-    bool HasPendingTasks() const;
-    bool Submit(Task func) const;
-
-private:
-    struct ThreadInfo {
-        std::string name;
-        mutable std::thread thread;
-
-        ThreadInfo(std::string name, std::function<void()> func)
-            : name(std::move(name)), thread(std::move(func))
-        {
-        }
-
-        ThreadInfo(ThreadInfo&& other)
-        {
-            name = std::move(other.name);
-            thread = std::move(other.thread);
-        }
-
-        ThreadInfo& operator=(ThreadInfo&& other)
-        {
-            if (this != &other) {
-                name = std::move(other.name);
-                thread = std::move(other.thread);
-            }
-            return *this;
-        }
-        ~ThreadInfo() = default;
-        /* data */
-    };
-
-    friend std::unique_ptr<ThreadPool> std::make_unique<ThreadPool>(const std::string&, uint32_t&);
-    ThreadPool(const std::string& name, uint32_t numThreads);
-    void Initialize();
-    void WorkerLoop(const std::string& threadName);
-    void PrintThreadInfo();
-    Task GetTask() const;
-
-    const std::string name_;
-    uint32_t numThreads_;
-    std::vector<ThreadInfo> workers_;
-    mutable std::atomic<bool> isStopped_;
-    mutable std::mutex mutex_;
-    mutable std::condition_variable taskCv_;
-    mutable std::queue<Task> tasks_;
-};
-} //namespace DeferredProcessing
-} // namespace CameraStandard
-} // namespace OHOS
-#endif // OHOS_DEFERRED_PROCESSING_SERVICE_THREAD_POOL_H
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_DEFERRED_PROCESSING_SERVICE_THREAD_POOL_H
+#define OHOS_DEFERRED_PROCESSING_SERVICE_THREAD_POOL_H
+
+#include <pthread.h>
+#include <atomic>
+#include <condition_variable>
+#include <cstdint>
+#include <functional>
+#include <mutex>
+#include <queue>
+#include <string>
+#include <thread>
+#include <vector>
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class ThreadPool {
+    using Task = std::function<void()>;
+
+public:
+    static std::unique_ptr<ThreadPool> Create(const std::string& name, uint32_t numThreads);
+    ~ThreadPool();
+    void BeginBackgroundTasks() const;
+    void EndBackgroundTasks() const;
+    void SetThreadPoolPriority(int priority);
+    int GetThreadPoolPriority() const;
+    bool HasPendingTasks() const;
+    bool Submit(Task func, bool isUrgent = false) const;
+
+private:
+    struct ThreadInfo {
+        std::string name;
+        mutable std::thread thread;
+
+        ThreadInfo(std::string name, std::function<void()> func)
+            : name(std::move(name)), thread(std::move(func))
+        {
+        }
+
+        ThreadInfo(ThreadInfo&& other)
+        {
+            name = std::move(other.name);
+            thread = std::move(other.thread);
+        }
+
+        ThreadInfo& operator=(ThreadInfo&& other)
+        {
+            if (this != &other) {
+                name = std::move(other.name);
+                thread = std::move(other.thread);
+            }
+            return *this;
+        }
+        ~ThreadInfo() = default;
+        /* data */
+    };
+
+    friend std::unique_ptr<ThreadPool> std::make_unique<ThreadPool>(const std::string&, uint32_t&);
+    ThreadPool(const std::string& name, uint32_t numThreads);
+    void Initialize();
+    void WorkerLoop(const std::string& threadName);
+    void PrintThreadInfo();
+    Task GetTask() const;
+
+    const std::string name_;
+    uint32_t numThreads_;
+    std::vector<ThreadInfo> workers_;
+    mutable std::atomic<bool> isStopped_;
+    mutable std::mutex mutex_;
+    mutable std::condition_variable taskCv_;
+    mutable std::deque<Task> tasks_;
+};
+} //namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_DEFERRED_PROCESSING_SERVICE_THREAD_POOL_H
diff --git a/services/deferred_processing_service/include/base/task_manager/thread_utils.h b/services/deferred_processing_service/include/base/task_manager/thread_utils.h
index 1899fad49..a6732ae80 100644
--- a/services/deferred_processing_service/include/base/task_manager/thread_utils.h
+++ b/services/deferred_processing_service/include/base/task_manager/thread_utils.h
@@ -1,35 +1,36 @@
-/*
- * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef OHOS_DEFERRED_PROCESSING_SERVICE_THREAD_UTILS_H
-#define OHOS_DEFERRED_PROCESSING_SERVICE_THREAD_UTILS_H
-
-#include <pthread.h>
-#include <string>
-
-namespace OHOS {
-namespace CameraStandard {
-namespace DeferredProcessing {
-enum {
-    PRIORITY_NORMAL = 0,
-    PRIORITY_BACKGROUND = 10
-};
-
-void SetThreadName(pthread_t tid, const std::string& name);
-void SetThreadPriority(pthread_t tid, int priority);
-} //namespace DeferredProcessing
-} // namespace CameraStandard
-} // namespace OHOS
-#endif // OHOS_DEFERRED_PROCESSING_SERVICE_THREAD_UTILS_H
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_DEFERRED_PROCESSING_SERVICE_THREAD_UTILS_H
+#define OHOS_DEFERRED_PROCESSING_SERVICE_THREAD_UTILS_H
+
+#include <pthread.h>
+#include <string>
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+enum {
+    PRIORITY_NORMAL = 0,
+    PRIORITY_BACKGROUND = 10
+};
+
+void SetThreadName(pthread_t tid, const std::string& name);
+void SetThreadPriority(pthread_t tid, int priority);
+int GetThreadPriority(pthread_t tid);
+} //namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_DEFERRED_PROCESSING_SERVICE_THREAD_UTILS_H
diff --git a/services/deferred_processing_service/include/deferred_processing_service.h b/services/deferred_processing_service/include/deferred_processing_service.h
index c6fcadea3..00bbfcdba 100644
--- a/services/deferred_processing_service/include/deferred_processing_service.h
+++ b/services/deferred_processing_service/include/deferred_processing_service.h
@@ -1,57 +1,59 @@
-/*
- * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef OHOS_CAMERA_DPS_DEFERRED_PROCESSING_SERVICE_H
-#define OHOS_CAMERA_DPS_DEFERRED_PROCESSING_SERVICE_H
-#define EXPORT_API __attribute__((visibility("default")))
-
-#include "session_manager.h"
-#include "scheduler_manager.h"
-#include "task_manager.h"
-namespace OHOS::Media {
-    class Picture;
-}
-namespace OHOS {
-namespace CameraStandard {
-namespace DeferredProcessing {
-class DeferredProcessingService : public RefBase {
-public:
-    EXPORT_API static DeferredProcessingService& GetInstance();
-    DeferredProcessingService(const DeferredProcessingService& other) = delete;
-    DeferredProcessingService& operator=(const DeferredProcessingService& other) = delete;
-    EXPORT_API void Initialize();
-    EXPORT_API void Start();
-    EXPORT_API void Stop();
-    EXPORT_API void NotifyLowQualityImage(const int32_t userId, const std::string& imageId,
-        std::shared_ptr<Media::Picture> picture);
-    ~DeferredProcessingService();
-    EXPORT_API sptr<IDeferredPhotoProcessingSession> CreateDeferredPhotoProcessingSession(const int32_t userId,
-        const sptr<IDeferredPhotoProcessingSessionCallback> callbacks);
-    EXPORT_API void NotifyCameraSessionStatus(const int32_t userId,
-        const std::string& cameraId, bool running, bool isSystemCamera);
-
-private:
-    DeferredProcessingService();
-    TaskManager* GetPhotoTaskManager(const int32_t userId);
-    std::atomic<bool> initialized_;
-    std::shared_ptr<SessionManager> sessionManager_;
-    std::unique_ptr<SchedulerManager> schedulerManager_;
-    std::unordered_map<int, std::shared_ptr<TaskManager>> photoTaskManagerMap_;
-    std::mutex taskManagerMutex_;
-};
-} // namespace DeferredProcessing
-} // namespace CameraStandard
-} // namespace OHOS
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_DEFERRED_PROCESSING_SERVICE_H
+#define OHOS_CAMERA_DPS_DEFERRED_PROCESSING_SERVICE_H
+#define EXPORT_API __attribute__((visibility("default")))
+
+#include "ideferred_photo_processing_session.h"
+#include "ideferred_photo_processing_session_callback.h"
+#include "ideferred_video_processing_session.h"
+#include "ideferred_video_processing_session_callback.h"
+#include "singleton.h"
+#include "task_manager.h"
+
+namespace OHOS::Media {
+    class Picture;
+}
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class EXPORT_API DeferredProcessingService : public RefBase, public Singleton<DeferredProcessingService> {
+    DECLARE_SINGLETON(DeferredProcessingService)
+
+public:
+    void Initialize();
+    void Start();
+    void Stop();
+    void NotifyLowQualityImage(const int32_t userId, const std::string& imageId,
+        std::shared_ptr<Media::Picture> picture);
+    sptr<IDeferredPhotoProcessingSession> CreateDeferredPhotoProcessingSession(const int32_t userId,
+        const sptr<IDeferredPhotoProcessingSessionCallback> callbacks);
+    sptr<IDeferredVideoProcessingSession> CreateDeferredVideoProcessingSession(const int32_t userId,
+        const sptr<IDeferredVideoProcessingSessionCallback> callbacks);
+    void NotifyCameraSessionStatus(const int32_t userId,
+        const std::string& cameraId, bool running, bool isSystemCamera);
+
+private:
+    TaskManager* GetPhotoTaskManager(const int32_t userId);
+
+    std::atomic<bool> initialized_ {false};
+    std::unordered_map<int, std::shared_ptr<TaskManager>> photoTaskManagerMap_;
+    std::mutex taskManagerMutex_;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
 #endif // OHOS_CAMERA_DPS_DEFERRED_PROCESSING_SERVICE_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/dfx/dps_video_report.h b/services/deferred_processing_service/include/dfx/dps_video_report.h
new file mode 100644
index 000000000..e1442440b
--- /dev/null
+++ b/services/deferred_processing_service/include/dfx/dps_video_report.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_VIDEO_REPORT_H
+#define OHOS_CAMERA_DPS_VIDEO_REPORT_H
+
+#include "dp_utils.h"
+#include "deferred_video_job.h"
+#include "singleton.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+const std::string EVENT_KEY_PNAMEID = "PNAMEID";
+const std::string EVENT_KEY_PVERSIONID = "PVERSIONID";
+const std::string EVENT_KEY_VIDEOID = "VIDEOID";
+const std::string EVENT_KEY_ABORTTYPE = "ABORTTYPE";
+const std::string EVENT_KEY_ABORTTIME = "ABORTTIME";
+const std::string EVENT_KEY_RECOVERTIME = "RECOVERTIME";
+const std::string EVENT_KEY_COMPLETETIME = "COMPLETETIME";
+const std::string EVENT_KEY_REALCOMPLETETIME = "REALCOMPLETETIME";
+
+struct VideoRecord {
+    std::string videoId;
+    std::string calleBundle;
+    std::string calleVersion;
+    uint64_t addTime = 0;
+    uint64_t processTime = 0;
+    uint64_t pauseStartTime = 0;
+    uint64_t pauseEndTime = 0;
+    uint64_t totlePauseTime = 0;
+    ~VideoRecord()
+    {}
+};
+
+class DfxVideoReport : public Singleton<DfxVideoReport> {
+    DECLARE_SINGLETON(DfxVideoReport)
+
+public:
+    void ReportAddVideoEvent(const std::string& videoId, DpsCallerInfo callerInfo);
+    void ReportRemoveVideoEvent(const std::string& videoId, DpsCallerInfo callerInfo);
+    void ReportPauseVideoEvent(const std::string& videoId, int32_t pauseReason);
+    void ReportResumeVideoEvent(const std::string& videoId);
+    void ReportCompleteVideoEvent(const std::string &videoId);
+
+private:
+    std::map<std::string, VideoRecord> processVideoInfo_;
+};
+} // namespace DeferredProcessingService
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_VIDEO_REPORT_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/event_monitor/base/events_strategy.h b/services/deferred_processing_service/include/event_monitor/base/events_strategy.h
new file mode 100644
index 000000000..4a6d9a1eb
--- /dev/null
+++ b/services/deferred_processing_service/include/event_monitor/base/events_strategy.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_EVENTS_STRATEGY_H
+#define OHOS_CAMERA_DPS_EVENTS_STRATEGY_H
+
+#include "common_event_manager.h"
+#include "dp_log.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class EventStrategy {
+public:
+    explicit EventStrategy()
+    {
+        DP_DEBUG_LOG("entered.");
+    }
+    
+    virtual ~EventStrategy()
+    {
+        DP_DEBUG_LOG("entered.");
+    }
+
+    virtual void handleEvent(const EventFwk::CommonEventData& data) = 0;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_EVENTS_STRATEGY_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/event_monitor/command/event_status_change_command.h b/services/deferred_processing_service/include/event_monitor/command/event_status_change_command.h
new file mode 100644
index 000000000..01d25e64f
--- /dev/null
+++ b/services/deferred_processing_service/include/event_monitor/command/event_status_change_command.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_EVENT_STATUS_CHANGE_COMMAND_H
+#define OHOS_CAMERA_DPS_EVENT_STATUS_CHANGE_COMMAND_H
+
+#include "basic_definitions.h"
+#include "command.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class EventStatusChangeCommand : public Command {
+    DECLARE_CMD_CLASS(EventStatusChangeCommand);
+
+public:
+    EventStatusChangeCommand(const int32_t userId, const EventType event, const int value);
+    ~EventStatusChangeCommand() override;
+
+protected:
+    int32_t Executing() override;
+
+private:
+    const int32_t userId_;
+    const EventType eventId_;
+    const int32_t value_;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_EVENT_STATUS_CHANGE_COMMAND_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/event_monitor/events_info.h b/services/deferred_processing_service/include/event_monitor/events_info.h
new file mode 100644
index 000000000..8af7faaf6
--- /dev/null
+++ b/services/deferred_processing_service/include/event_monitor/events_info.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_EVENTS_INFO_H
+#define OHOS_CAMERA_DPS_EVENTS_INFO_H
+
+#include "basic_definitions.h"
+#include "singleton.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class EventsInfo : public Singleton<EventsInfo> {
+    DECLARE_SINGLETON(EventsInfo);
+    
+public:
+    void Initialize();
+    ScreenStatus GetScreenState();
+    BatteryStatus GetBatteryState();
+    ChargingStatus GetChargingState();
+    BatteryLevel GetBatteryLevel();
+    SystemPressureLevel GetPhotoThermalLevel();
+    ThermalLevel GetThermalLevel();
+
+private:
+    std::mutex mutex_;
+    std::atomic_bool initialized_ {false};
+    ScreenStatus screenState_ {SCREEN_OFF};
+    BatteryStatus batteryState_ {BATTERY_LOW};
+    ChargingStatus chargingState_ {DISCHARGING};
+    BatteryLevel batteryLevel_ {BATTERY_LEVEL_LOW};
+    SystemPressureLevel photoThermalLevel_ {SEVERE};
+    ThermalLevel thermalLevel_ {LEVEL_0};
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_EVENTS_INFO_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/event_monitor/events_monitor.h b/services/deferred_processing_service/include/event_monitor/events_monitor.h
index 79651833e..1711529ba 100644
--- a/services/deferred_processing_service/include/event_monitor/events_monitor.h
+++ b/services/deferred_processing_service/include/event_monitor/events_monitor.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
@@ -13,70 +13,60 @@
  * limitations under the License.
  */
 
-#ifndef OHOS_DEFERRED_PROCESSING_SERVICE_EVENTS_MONITOR_H
-#define OHOS_DEFERRED_PROCESSING_SERVICE_EVENTS_MONITOR_H
+#ifndef OHOS_CAMERA_DPS_EVENTS_MONITOR_H
+#define OHOS_CAMERA_DPS_EVENTS_MONITOR_H
 
+#include "events_subscriber.h"
 #include "ievents_listener.h"
-#include "task_manager.h"
-#include "common_event_manager.h"
-#include "common_event_support.h"
-#ifdef CAMERA_USE_THERMAL
-#include "ithermal_srv.h"
-#endif
+#include "singleton.h"
+#include "system_ability_status_change_stub.h"
 
 namespace OHOS {
 namespace CameraStandard {
 namespace DeferredProcessing {
-class ThermalLevelSubscriber : public OHOS::EventFwk::CommonEventSubscriber {
+class CommonEventListener : public SystemAbilityStatusChangeStub {
 public:
-    explicit ThermalLevelSubscriber(const OHOS::EventFwk::CommonEventSubscribeInfo &subscriberInfo);
-    virtual ~ThermalLevelSubscriber();
-    void OnReceiveEvent(const OHOS::EventFwk::CommonEventData &data) override;
-    SystemPressureLevel MapEventLevel(int level);
+    void OnAddSystemAbility(int32_t systemAbilityId, const std::string& deviceId) override;
+    void OnRemoveSystemAbility(int32_t systemAbilityId, const std::string& deviceId) override;
+
+private:
+    std::shared_ptr<EventSubscriber> eventSubscriber_ {nullptr};
 };
 
-class EventsMonitor {
+class EventsMonitor : public Singleton<EventsMonitor> {
+    DECLARE_SINGLETON(EventsMonitor)
+
 public:
-    static EventsMonitor& GetInstance();
-    explicit EventsMonitor();
-    ~EventsMonitor();
     void Initialize();
     void NotifyCameraSessionStatus(const int32_t userId,
         const std::string& cameraId, bool running, bool isSystemCamera);
     void NotifyMediaLibraryStatus(bool available);
     void NotifyImageEnhanceStatus(int32_t status);
+    void NotifyScreenStatus(int32_t status);
+    void NotifyChargingStatus(int32_t status);
+    void NotifyBatteryStatus(int32_t status);
+    void NotifyBatteryLevel(int32_t level);
     void NotifySystemPressureLevel(SystemPressureLevel level);
-    void NotifyThermalLevel(int32_t level);
-    void NotifyEventToObervers(const int32_t userId, EventType event, int32_t value);
-    void RegisterTaskManager(const int32_t userId, TaskManager* taskManager);
-    void RegisterThermalLevel();
-    void UnRegisterThermalLevel();
-    void RegisterEventsListener(const int32_t userId, const std::vector<EventType>& events,
-        const std::shared_ptr<IEventsListener>& listener);
-    void UnRegisterListener(const int32_t userId, TaskManager* taskManager);
-    void SetRegisterThermalStatus(bool isHasRegistered);
-    void ScheduleRegisterThermalListener();
-    void NotifyObservers(EventType event, int value, int32_t userId = 0);
+    void NotifyThermalLevel(int level);
+    void NotifyPhotoProcessSize(int32_t size);
+    void NotifyEventToObervers(int userId, EventType event, int value);
+    void RegisterEventsListener(int userId, const std::vector<EventType>& events,
+        const std::weak_ptr<IEventsListener>& listener);
+    void NotifyObservers(EventType event, int value, int userId = 0);
 
 private:
-    class ThermalMgrDeathRecipient;
-    void NotifyObserversUnlocked(const int32_t userId, EventType event, int32_t value);
-    void ConnectThermalSvr();
+    void NotifyObserversUnlocked(int userId, EventType event, int value);
+    int32_t SubscribeSystemAbility();
+    int32_t UnSubscribeSystemAbility();
 
     std::mutex mutex_;
-    bool initialized_;
-    std::atomic<int> numActiveSessions_;
-    std::map<int32_t, std::vector<TaskManager*>> userIdToTaskManager;
-    std::map<int32_t, std::map<EventType, std::vector<std::weak_ptr<IEventsListener>>>> userIdToeventListeners_;
-    bool mIsRegistered;
-    sptr<IRemoteObject::DeathRecipient> deathRecipient_ = nullptr;
-    std::shared_ptr<ThermalLevelSubscriber> thermalLevelSubscriber_ = nullptr;
-    std::mutex thermalEventMutex;
-#ifdef CAMERA_USE_THERMAL
-    sptr<OHOS::PowerMgr::IThermalSrv> thermalSrv_ = nullptr;
-#endif
+    std::mutex eventMutex_;
+    std::atomic_bool initialized_ {false};
+    std::atomic<int> numActiveSessions_ {0};
+    std::map<int32_t, std::map<EventType, std::vector<std::weak_ptr<IEventsListener>>>> userIdToeventListeners_ {};
+    sptr<CommonEventListener> ceListener_ {nullptr};
 };
 } // namespace DeferredProcessing
 } // namespace CameraStandard
 } // namespace OHOS
-#endif // OHOS_DEFERRED_PROCESSING_SERVICE_EVENTS_MONITOR_H
+#endif // OHOS_CAMERA_DPS_EVENTS_MONITOR_H
diff --git a/services/deferred_processing_service/include/event_monitor/events_subscriber.h b/services/deferred_processing_service/include/event_monitor/events_subscriber.h
new file mode 100644
index 000000000..429bc5323
--- /dev/null
+++ b/services/deferred_processing_service/include/event_monitor/events_subscriber.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_EVENTS_SUBSCRIBER_H
+#define OHOS_CAMERA_DPS_EVENTS_SUBSCRIBER_H
+
+#include "events_strategy.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class EventSubscriber : public EventFwk::CommonEventSubscriber,
+    public std::enable_shared_from_this<EventSubscriber> {
+public:
+    virtual ~EventSubscriber();
+
+    static std::shared_ptr<EventSubscriber> Create();
+    void Initialize();
+    void Subcribe();
+    void UnSubscribe();
+    void OnReceiveEvent(const EventFwk::CommonEventData& data) override;
+
+protected:
+    explicit EventSubscriber(const EventFwk::CommonEventSubscribeInfo& subscriberInfo);
+
+private:
+    static const std::vector<std::string> events_;
+    std::unordered_map<std::string, std::shared_ptr<EventStrategy>> eventStrategy_ {};
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_EVENTS_SUBSCRIBER_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/event_monitor/ievents_listener.h b/services/deferred_processing_service/include/event_monitor/ievents_listener.h
index 7d1d8d613..3c4211310 100644
--- a/services/deferred_processing_service/include/event_monitor/ievents_listener.h
+++ b/services/deferred_processing_service/include/event_monitor/ievents_listener.h
@@ -13,11 +13,10 @@
  * limitations under the License.
  */
 
-#ifndef OHOS_DEFERRED_PROCESSING_SERVICE_IEVENTS_LISTENER_H
-#define OHOS_DEFERRED_PROCESSING_SERVICE_IEVENTS_LISTENER_H
+#ifndef OHOS_CAMERA_DPS_IEVENTS_LISTENER_H
+#define OHOS_CAMERA_DPS_IEVENTS_LISTENER_H
 
 #include "basic_definitions.h"
-#include "dp_log.h"
 
 namespace OHOS {
 namespace CameraStandard {
@@ -26,9 +25,10 @@ class IEventsListener {
 public:
     IEventsListener() = default;
     virtual ~IEventsListener() = default;
-    virtual void OnEventChange(EventType event, int value) = 0;
+
+    virtual void OnEventChange(EventType event, int32_t value) = 0;
 };
 } // namespace DeferredProcessing
 } // namespace CameraStandard
 } // namespace OHOS
-#endif // OHOS_DEFERRED_PROCESSING_SERVICE_IEVENTS_LISTENER_H
+#endif // OHOS_CAMERA_DPS_IEVENTS_LISTENER_H
diff --git a/services/deferred_processing_service/include/event_monitor/impl/battery_level_strategy.h b/services/deferred_processing_service/include/event_monitor/impl/battery_level_strategy.h
new file mode 100644
index 000000000..dcce52210
--- /dev/null
+++ b/services/deferred_processing_service/include/event_monitor/impl/battery_level_strategy.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_BATTERY_LEVEL_STRATEGY_H
+#define OHOS_CAMERA_DPS_BATTERY_LEVEL_STRATEGY_H
+
+#include "events_strategy.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class BatteryLevelStrategy : public EventStrategy {
+public:
+    explicit BatteryLevelStrategy();
+    ~BatteryLevelStrategy() override;
+
+    void handleEvent(const OHOS::EventFwk::CommonEventData& data) override;
+
+private:
+    int32_t preLevel_;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_BATTERY_LEVEL_STRATEGY_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/event_monitor/impl/battery_strategy.h b/services/deferred_processing_service/include/event_monitor/impl/battery_strategy.h
new file mode 100644
index 000000000..fad8d281f
--- /dev/null
+++ b/services/deferred_processing_service/include/event_monitor/impl/battery_strategy.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_BATTERY_STRATEGY_H
+#define OHOS_CAMERA_DPS_BATTERY_STRATEGY_H
+
+#include "events_strategy.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class BatteryStrategy : public EventStrategy {
+public:
+    explicit BatteryStrategy();
+    ~BatteryStrategy() override;
+
+    void handleEvent(const OHOS::EventFwk::CommonEventData& data) override;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_BATTERY_STRATEGY_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/event_monitor/impl/charging_strategy.h b/services/deferred_processing_service/include/event_monitor/impl/charging_strategy.h
new file mode 100644
index 000000000..2d5824f65
--- /dev/null
+++ b/services/deferred_processing_service/include/event_monitor/impl/charging_strategy.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_CHARGING_STRATEGY_H
+#define OHOS_CAMERA_DPS_CHARGING_STRATEGY_H
+
+#include "events_strategy.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class ChargingStrategy : public EventStrategy {
+public:
+    explicit ChargingStrategy();
+    ~ChargingStrategy() override;
+
+    void handleEvent(const OHOS::EventFwk::CommonEventData& data) override;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_CHARGING_STRATEGY_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/event_monitor/impl/screen_strategy.h b/services/deferred_processing_service/include/event_monitor/impl/screen_strategy.h
new file mode 100644
index 000000000..ee4889370
--- /dev/null
+++ b/services/deferred_processing_service/include/event_monitor/impl/screen_strategy.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_SCREEN_STRATEGY_H
+#define OHOS_CAMERA_DPS_SCREEN_STRATEGY_H
+
+#include "events_strategy.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class ScreenStrategy : public EventStrategy {
+public:
+    explicit ScreenStrategy();
+    ~ScreenStrategy() override;
+
+    void handleEvent(const OHOS::EventFwk::CommonEventData& data) override;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_SCREEN_STRATEGY_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/event_monitor/impl/thermal_strategy.h b/services/deferred_processing_service/include/event_monitor/impl/thermal_strategy.h
new file mode 100644
index 000000000..c0731f1f7
--- /dev/null
+++ b/services/deferred_processing_service/include/event_monitor/impl/thermal_strategy.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_THERMAL_STRATEGY_H
+#define OHOS_CAMERA_DPS_THERMAL_STRATEGY_H
+
+#include "events_strategy.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class ThermalStrategy : public EventStrategy {
+public:
+    explicit ThermalStrategy();
+    ~ThermalStrategy() override;
+
+    void handleEvent(const OHOS::EventFwk::CommonEventData& data) override;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_THERMAL_STRATEGY_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/media_manager/demuxer.h b/services/deferred_processing_service/include/media_manager/demuxer.h
new file mode 100644
index 000000000..ad3acad7d
--- /dev/null
+++ b/services/deferred_processing_service/include/media_manager/demuxer.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_DEMUXER_H
+#define OHOS_CAMERA_DPS_DEMUXER_H
+
+#include "avdemuxer.h"
+#include "basic_definitions.h"
+#include "track.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+using namespace MediaAVCodec;
+class Demuxer {
+public:
+    Demuxer() = default;
+    virtual ~Demuxer();
+
+    MediaManagerError Create(const std::shared_ptr<AVSource>& source,
+        const std::map<TrackType, const std::shared_ptr<Track>>& tracks);
+    MediaManagerError ReadStream(TrackType trackType, std::shared_ptr<AVBuffer>& sample);
+    MediaManagerError SeekToTime(int64_t lastPts);
+
+private:
+    MediaManagerError SeletctTrackByID(int32_t trackID);
+
+    std::shared_ptr<AVDemuxer> demuxer_ {nullptr};
+    int32_t videoTrackId_ {-1};
+    int32_t audioTrackId_ {-1};
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_DEMUXER_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/media_manager/media_format.h b/services/deferred_processing_service/include/media_manager/media_format.h
new file mode 100644
index 000000000..d375b0014
--- /dev/null
+++ b/services/deferred_processing_service/include/media_manager/media_format.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_MEDIA_FORMAT_H
+#define OHOS_CAMERA_DPS_MEDIA_FORMAT_H
+
+#include "meta_key.h"
+#include "mime_type.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+const std::string MINE_VIDEO_AVC = Media::Plugins::MimeType::VIDEO_AVC;
+const std::string MINE_VIDEO_HEVC = Media::Plugins::MimeType::VIDEO_HEVC;
+const std::string VIDEO_FRAME_COUNT = "com.openharmony.frame_num";
+const std::string RECORD_SYSTEM_TIMESTAMP = "com.openharmony.recorder.timestamp";
+
+enum class MediaInfoKey : uint32_t {
+    META_VALUE_TYPE_NONE,
+    META_VALUE_TYPE_INT32,
+    META_VALUE_TYPE_INT64,
+    META_VALUE_TYPE_FLOAT,
+    META_VALUE_TYPE_DOUBLE,
+    META_VALUE_TYPE_STRING,
+};
+
+enum class ColorRange {
+    COL_RANGE_NONE = -1,
+    COL_RANGE_UNSPECIFIED = 0,
+    COL_RANGE_MPEG = 1,
+    COL_RANGE_JPEG = 2,
+};
+
+enum class PixelFormat {
+    PIX_FMT_NONE    = -1,
+    PIX_FMT_YUV420P = 0,
+    PIX_FMT_YUVI420 = 1,
+    PIX_FMT_NV12 = 2,
+    PIX_FMT_YUV420P10LE = 62,
+};
+
+enum class ColorPrimaries {
+    COL_PRI_RESERVED0 = 0,
+    COL_PRI_BT709     = 1,
+    COL_PRI_BT2020    = 9, // hdr
+};
+
+enum class ColorTransferCharacteristic {
+    COL_TRC_RESERVED0 = 0,
+    COL_TRC_BT709     = 1,
+    COL_TRC_BT2020_10 = 14,
+    COL_TRC_BT2020_12 = 15,
+    COL_TRC_ARIB_STD_B67 = 18,  // colorPrimary  ARIB STD-B67, known as "Hybrid log-gamma"
+};
+
+enum class AVCProfile : int32_t {
+    AVC_PROFILE_BASELINE = 0,
+    AVC_PROFILE_HIGH = 4,
+    AVC_PROFILE_MAIN = 8,
+};
+
+struct CodecInfo {
+    std::string mimeType;
+    ColorRange colorRange;
+    PixelFormat pixelFormat;  // color space pixel format. e.g. YUV420P, NV12 etc.
+    ColorPrimaries colorPrimary;
+    ColorTransferCharacteristic colorTransferCharacter;
+    int32_t profile;
+    int32_t level;
+    int64_t bitRate;
+    int32_t fps;
+    int64_t duration;
+    int32_t numFrames;
+    int32_t width;
+    int32_t height;
+    int32_t rotation;
+    int32_t isHdrvivid;
+    int32_t bitMode;
+};
+
+struct MediaInfo {
+    int64_t recoverTime;
+    int32_t streamCount;
+    std::string creationTime;
+    float latitude;
+    float longitude;
+    CodecInfo codecInfo {};
+    std::string recorderTime;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_MEDIA_FORMAT_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/media_manager/media_manager.h b/services/deferred_processing_service/include/media_manager/media_manager.h
new file mode 100644
index 000000000..97f18e5bd
--- /dev/null
+++ b/services/deferred_processing_service/include/media_manager/media_manager.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_FILE_MANAGER_H
+#define OHOS_CAMERA_DPS_FILE_MANAGER_H
+
+#include <set>
+
+#include "reader.h"
+#include "writer.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class MediaManager {
+public:
+    MediaManager() = default;
+    virtual ~MediaManager() = default;
+
+    MediaManagerError Create(int32_t inFd, int32_t outFd, int32_t tempFd);
+    MediaManagerError Pause();
+    MediaManagerError Stop();
+    MediaManagerError ReadSample(TrackType type, std::shared_ptr<AVBuffer>& sample);
+    MediaManagerError WriteSample(TrackType type, const std::shared_ptr<AVBuffer>& sample);
+
+    inline void GetMediaInfo(std::shared_ptr<MediaInfo>& mediaInfo)
+    {
+        mediaInfo = mediaInfo_;
+    }
+
+private:
+    MediaManagerError InitReader();
+    MediaManagerError InitWriter();
+    MediaManagerError Recover(const int64_t size);
+    MediaManagerError CopyAudioTrack();
+    MediaManagerError InitRecoverReader(const int64_t size, int64_t& duration, int64_t& bitRate);
+    MediaManagerError GetRecoverInfo(const int64_t size);
+
+    int32_t inputFileFd_ {-1};
+    int32_t outputFileFd_ {-1};
+    int32_t tempFileFd_ {-1};
+    int32_t finalFrameNum_ {0};
+    int64_t resumePts_ {-1};
+    int64_t pausePts_ {-1};
+    int64_t curProcessPts_ {-1};
+    int64_t finalSyncPts_ {-1};
+    bool hasAudio_ {false};
+    bool started_ {false};
+    std::shared_ptr<Reader> inputReader_ {nullptr};
+    std::shared_ptr<Reader> recoverReader_ {nullptr};
+    std::shared_ptr<Writer> outputWriter_ {nullptr};
+    std::shared_ptr<MediaInfo> mediaInfo_ {nullptr};
+    std::set<int64_t> IFramePts_ {};
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_FILE_MANAGER_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/media_manager/mpeg_manager.h b/services/deferred_processing_service/include/media_manager/mpeg_manager.h
new file mode 100644
index 000000000..2aa12d1e7
--- /dev/null
+++ b/services/deferred_processing_service/include/media_manager/mpeg_manager.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_MPEG_MANAGER_H
+#define OHOS_CAMERA_DPS_MPEG_MANAGER_H
+
+#include "avcodec_video_encoder.h"
+#include "ipc_file_descriptor.h"
+#include "media_manager.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class MpegManager : public std::enable_shared_from_this<MpegManager> {
+public:
+    MpegManager();
+    ~MpegManager();
+    MpegManager(const MpegManager&) =delete;
+    MpegManager& operator=(const MpegManager&) = delete;
+    MpegManager(MediaManager&&) = delete;
+    MpegManager& operator=(MediaManager&&) = delete;
+
+    MediaManagerError Init(const std::string& requestId, const sptr<IPCFileDescriptor>& inputFd);
+    MediaManagerError UnInit(const MediaResult result);
+    sptr<Surface> GetSurface();
+    uint64_t GetProcessTimeStamp();
+    MediaManagerError NotifyEnd();
+    MediaManagerError ReleaseBuffer(uint32_t index);
+    sptr<IPCFileDescriptor> GetResultFd();
+
+private:
+    class VideoCodecCallback;
+
+    MediaManagerError InitVideoCodec();
+    void UnInitVideoCodec();
+    void OnBufferAvailable(uint32_t index, const std::shared_ptr<AVBuffer>& buffer);
+    sptr<IPCFileDescriptor> GetFileFd(const std::string& requestId, int flags, const std::string& tag);
+
+    std::unique_ptr<MediaManager> mediaManager_ {nullptr};
+    sptr<Surface> codecSurface_ {nullptr};
+    std::shared_ptr<AVCodecVideoEncoder> encoder_ {nullptr};
+    std::atomic_bool isRunning_ {false};
+    std::unique_ptr<std::thread> processThread_ {nullptr};
+    std::shared_ptr<MediaInfo> mediaInfo_ {nullptr};
+    std::string outPath_;
+    std::string tempPath_;
+    sptr<IPCFileDescriptor> outputFd_ {nullptr};
+    sptr<IPCFileDescriptor> tempFd_ {nullptr};
+    MediaResult result_ {FAIL};
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_MPEG_MANAGER_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/media_manager/mpeg_manager_factory.h b/services/deferred_processing_service/include/media_manager/mpeg_manager_factory.h
new file mode 100644
index 000000000..0bd1134ed
--- /dev/null
+++ b/services/deferred_processing_service/include/media_manager/mpeg_manager_factory.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_MPEG__MANAGER_FACTORY_H
+#define OHOS_CAMERA_DPS_MPEG__MANAGER_FACTORY_H
+
+#include "mpeg_manager.h"
+#include "singleton.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class MpegManagerFactory : public Singleton<MpegManagerFactory> {
+    DECLARE_SINGLETON(MpegManagerFactory)
+
+public:
+    std::shared_ptr<MpegManager> Acquire(const std::string& requestId, const sptr<IPCFileDescriptor>& inputFd);
+    void Release(std::shared_ptr<MpegManager>& mpegManager);
+
+private:
+    std::mutex mutex_;
+    std::string requestId_ {nullptr};
+    uint32_t refCount_ {0};
+    std::shared_ptr<MpegManager> mpegManager_ {nullptr};
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_MPEG__MANAGER_FACTORY_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/media_manager/muxer.h b/services/deferred_processing_service/include/media_manager/muxer.h
new file mode 100644
index 000000000..27f03379c
--- /dev/null
+++ b/services/deferred_processing_service/include/media_manager/muxer.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_MUXER_H
+#define OHOS_CAMERA_DPS_MUXER_H
+
+#include "avmuxer.h"
+#include "basic_definitions.h"
+#include "media_format.h"
+#include "track.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+using namespace MediaAVCodec;
+class Muxer {
+public:
+    Muxer() = default;
+    virtual ~Muxer();
+
+    MediaManagerError Create(int32_t outputFd, Plugins::OutputFormat format);
+    MediaManagerError AddTracks(const std::map<TrackType, const std::shared_ptr<Track>>& trackMap);
+    MediaManagerError WriteStream(TrackType trackType, const std::shared_ptr<AVBuffer>& sample);
+    MediaManagerError Start();
+    MediaManagerError Stop();
+    MediaManagerError AddMediaInfo(const std::shared_ptr<MediaInfo>& mediaInfo);
+
+private:
+    std::shared_ptr<AVMuxer> muxer_ {nullptr};
+    int32_t videoTrackId_ {-1};
+    int32_t audioTrackId_ {-1};
+};
+
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_MUXER_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/media_manager/reader.h b/services/deferred_processing_service/include/media_manager/reader.h
new file mode 100644
index 000000000..39487a51a
--- /dev/null
+++ b/services/deferred_processing_service/include/media_manager/reader.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef OHOS_CAMERA_DPS_READER_H
+#define OHOS_CAMERA_DPS_READER_H
+
+#include "basic_definitions.h"
+#include "demuxer.h"
+#include "track.h"
+#include "media_format.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+using namespace MediaAVCodec;
+class Reader {
+public:
+    Reader() = default;
+    virtual ~Reader();
+
+    MediaManagerError Create(int32_t inputFd);
+    MediaManagerError Read(TrackType trackType, std::shared_ptr<AVBuffer>& sample);
+    MediaManagerError GetMediaInfo(std::shared_ptr<MediaInfo>& mediaInfo);
+    MediaManagerError Reset(int64_t resetPts);
+
+    inline const std::map<TrackType, const std::shared_ptr<Track>>& GetTracks() const
+    {
+        return tracks_;
+    };
+
+private:
+    MediaManagerError GetSourceFormat();
+    void GetSourceMediaInfo(std::shared_ptr<MediaInfo>& mediaInfo) const;
+    MediaManagerError GetTrackMediaInfo(const TrackFormat& trackFormat, std::shared_ptr<MediaInfo>& mediaInfo) const;
+    MediaManagerError InitTracksAndDemuxer();
+    static int32_t FixFPS(const double fps);
+
+private:
+    std::shared_ptr<AVSource> source_ {nullptr};
+    std::shared_ptr<Format> sourceFormat_ {nullptr};
+    std::shared_ptr<Format> userFormat_ {nullptr};
+    std::shared_ptr<Demuxer> inputDemuxer_ {nullptr};
+    int32_t trackCount_ {0};
+    std::map<TrackType, const std::shared_ptr<Track>> tracks_ {};
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_READER_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/media_manager/track.h b/services/deferred_processing_service/include/media_manager/track.h
new file mode 100644
index 000000000..98c65e0d7
--- /dev/null
+++ b/services/deferred_processing_service/include/media_manager/track.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_TRACK_H
+#define OHOS_CAMERA_DPS_TRACK_H
+
+#include "av_common.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+using namespace MediaAVCodec;
+
+enum class TrackType : int32_t {
+    AV_KEY_DEFAULT_TYPE = -1,
+    AV_KEY_AUDIO_TYPE = 0,
+    AV_KEY_VIDEO_TYPE = 1
+};
+
+struct TrackFormat {
+    std::shared_ptr<Format> format;
+    int32_t trackId;
+};
+
+class Track {
+public:
+    Track() = default;
+    virtual ~Track();
+    const TrackFormat& GetFormat();
+    void SetFormat(const TrackFormat& format, TrackType type);
+    TrackType GetType()
+    {
+        return trackType_;
+    };
+
+private:
+    TrackFormat trackFormat_ {};
+    TrackType trackType_ {};
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_TRACK_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/media_manager/track_factory.h b/services/deferred_processing_service/include/media_manager/track_factory.h
new file mode 100644
index 000000000..6b6524ac1
--- /dev/null
+++ b/services/deferred_processing_service/include/media_manager/track_factory.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_TRACK_FACTORY_H
+#define OHOS_CAMERA_DPS_TRACK_FACTORY_H
+
+#include "avsource.h"
+#include "singleton.h"
+#include "track.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class TrackFactory : public Singleton<TrackFactory> {
+    DECLARE_SINGLETON(TrackFactory)
+public:
+    std::shared_ptr<Track> CreateTrack(const std::shared_ptr<AVSource>& source, int trackIndex);
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_TRACK_FACTORY_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/media_manager/writer.h b/services/deferred_processing_service/include/media_manager/writer.h
new file mode 100644
index 000000000..29b3fb643
--- /dev/null
+++ b/services/deferred_processing_service/include/media_manager/writer.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_WRITER_H
+#define OHOS_CAMERA_DPS_WRITER_H
+
+#include "muxer.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+using namespace MediaAVCodec;
+class Writer {
+public:
+    Writer() = default;
+    virtual ~Writer();
+
+    MediaManagerError Create(int32_t outputFd, const std::map<TrackType, const std::shared_ptr<Track>>& trackMap);
+    MediaManagerError Write(TrackType type, const std::shared_ptr<AVBuffer>& sample);
+    MediaManagerError Start();
+    MediaManagerError Stop();
+    MediaManagerError AddMediaInfo(const std::shared_ptr<MediaInfo>& mediaInfo);
+
+    inline void SetLastPause(int64_t lastPause)
+    {
+        lastPause_ = lastPause;
+    }
+
+private:
+    MediaManagerError CreateTracksAndMuxer();
+
+    std::shared_ptr<Muxer> outputMuxer_ {nullptr};
+    int64_t lastPause_ {-1};
+    int32_t outputFileFd_ {-1};
+    bool started_ {false};
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_WRITER_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/post_processor/command/service_died_command.h b/services/deferred_processing_service/include/post_processor/command/service_died_command.h
new file mode 100644
index 000000000..0c4edf40e
--- /dev/null
+++ b/services/deferred_processing_service/include/post_processor/command/service_died_command.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_SERVICE_DIED_COMMAND_H
+#define OHOS_CAMERA_DPS_SERVICE_DIED_COMMAND_H
+
+#include "command.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class ServiceDiedCommand : public Command {
+    DECLARE_CMD_CLASS(ServiceDiedCommand);
+public:
+    ServiceDiedCommand(const int32_t userId);
+    ~ServiceDiedCommand() override;
+
+protected:
+    int32_t Executing() override;
+
+    const int32_t userId_;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_SERVICE_DIED_COMMAND_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/post_processor/command/video_process_command.h b/services/deferred_processing_service/include/post_processor/command/video_process_command.h
new file mode 100644
index 000000000..102147c31
--- /dev/null
+++ b/services/deferred_processing_service/include/post_processor/command/video_process_command.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_VIDEO_PROCESS_COMMAND_H
+#define OHOS_CAMERA_DPS_VIDEO_PROCESS_COMMAND_H
+
+#include "command.h"
+#include "scheduler_manager.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class VidoeProcessCommand : public Command {
+public:
+    VidoeProcessCommand(const int32_t userId);
+    ~VidoeProcessCommand();
+
+protected:
+    int32_t Initialize();
+
+    const int32_t userId_;
+    std::atomic<bool> initialized_ {false};
+    std::shared_ptr<SchedulerManager> schedulerManager_ {nullptr};
+    std::shared_ptr<DeferredVideoController> controller_ {nullptr};
+};
+
+class VidoeProcessSuccessCommand : public VidoeProcessCommand {
+    DECLARE_CMD_CLASS(VidoeProcessSuccessCommand);
+public:
+    VidoeProcessSuccessCommand(const int32_t userId, const DeferredVideoWorkPtr& work);
+    ~VidoeProcessSuccessCommand() override;
+
+protected:
+    int32_t Executing() override;
+
+    DeferredVideoWorkPtr work_;
+};
+
+class VidoeProcessFailedCommand : public VidoeProcessCommand {
+    DECLARE_CMD_CLASS(VidoeProcessFailedCommand);
+public:
+    VidoeProcessFailedCommand(const int32_t userId, const DeferredVideoWorkPtr& work, DpsError errorCode);
+    ~VidoeProcessFailedCommand() override;
+
+protected:
+    int32_t Executing() override;
+
+    DeferredVideoWorkPtr work_;
+    DpsError error_;
+};
+
+class VidoeStateChangedCommand : public VidoeProcessCommand {
+    DECLARE_CMD_CLASS(VidoeStateChangedCommand);
+public:
+    VidoeStateChangedCommand(const int32_t userId, HdiStatus status)
+        : VidoeProcessCommand(userId), status_(status)
+    {
+        DP_DEBUG_LOG("entered.");
+    }
+    ~VidoeStateChangedCommand() override = default;
+
+protected:
+    int32_t Executing() override;
+
+    HdiStatus status_;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_VIDEO_PROCESS_COMMAND_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/post_processor/video_post_processor.h b/services/deferred_processing_service/include/post_processor/video_post_processor.h
new file mode 100644
index 000000000..3ed9329b4
--- /dev/null
+++ b/services/deferred_processing_service/include/post_processor/video_post_processor.h
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_VIDEO_POST_PROCESSOR_H
+#define OHOS_CAMERA_DPS_VIDEO_POST_PROCESSOR_H
+
+#include "basic_definitions.h"
+#include "deferred_video_job.h"
+#include "iservstat_listener_hdi.h"
+#include "mpeg_manager.h"
+#include "safe_map.h"
+#include "v1_3/ivideo_process_service.h"
+#include "v1_3/ivideo_process_session.h"
+#include "v1_3/ivideo_process_callback.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+using OHOS::HDI::Camera::V1_3::IVideoProcessSession;
+using OHOS::HDI::Camera::V1_3::StreamDescription;
+using OHOS::HDI::Camera::V1_1::StreamInfo_V1_1;
+using HDI::Camera::V1_0::BufferProducerSequenceable;
+
+class VideoPostProcessor : public std::enable_shared_from_this<VideoPostProcessor> {
+public:
+    ~VideoPostProcessor();
+
+    void Initialize();
+    bool GetPendingVideos(std::vector<std::string>& pendingVideos);
+    void SetExecutionMode(ExecutionMode executionMode);
+    void SetDefaultExecutionMode();
+    void ProcessRequest(const DeferredVideoWorkPtr& work);
+    void RemoveRequest(const std::string& videoId);
+    void PauseRequest(const std::string& videoId, const ScheduleType& type);
+
+protected:
+    explicit VideoPostProcessor(const int32_t userId);
+
+private:
+    class VideoServiceListener;
+    class SessionDeathRecipient;
+    class VideoProcessListener;
+
+    void ConnectService();
+    void DisconnectService();
+    bool PrepareStreams(const std::string& videoId, const int inputFd);
+    void CreateSurface(const std::string& name, const StreamDescription& stream, sptr<Surface>& surface);
+    void SetStreamInfo(const StreamDescription& stream, sptr<BufferProducerSequenceable>& producer);
+    bool StartMpeg(const std::string& videoId, const sptr<IPCFileDescriptor>& inputFd);
+    bool StopMpeg(const MediaResult result, const DeferredVideoWorkPtr& work);
+    void ReleaseMpeg();
+    void StartTimer(const std::string& videoId, const DeferredVideoWorkPtr& work);
+    void StopTimer(const std::string& videoId);
+    void OnTimerOut(const std::string& videoId);
+    void OnServiceChange(const HDI::ServiceManager::V1_0::ServiceStatus& status);
+    void OnSessionDied();
+    void OnProcessDone(const std::string& videoId);
+    void OnError(const std::string& videoId, DpsError errorCode);
+    void OnStateChanged(HdiStatus hdiStatus);
+    DeferredVideoWorkPtr GetRunningWork(const std::string& videoId);
+    void copyFileByFd(const int srcFd, const int dstFd);
+    DpsError MapHdiError(OHOS::HDI::Camera::V1_2::ErrorCode errorCode);
+
+    inline sptr<IVideoProcessSession> GetVideoSession()
+    {
+        std::lock_guard<std::mutex> lock(sessionMutex_);
+        return session_;
+    }
+
+    inline void SetVideoSession(const sptr<IVideoProcessSession>& session)
+    {
+        std::lock_guard<std::mutex> lock(sessionMutex_);
+        session_ = session;
+    }
+
+    std::mutex sessionMutex_;
+    const int32_t userId_;
+    int32_t timeoutCount_ {0};
+    sptr<IVideoProcessSession> session_ {nullptr};
+    std::shared_ptr<MpegManager> mpegManager_ {nullptr};
+    sptr<VideoServiceListener> serviceListener_;
+    sptr<SessionDeathRecipient> sessionDeathRecipient_;
+    sptr<VideoProcessListener> processListener_;
+    std::vector<StreamInfo_V1_1> allStreamInfo_ {};
+    SafeMap<std::string, DeferredVideoWorkPtr> videoId2Handle_ {};
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_VIDEO_POST_PROCESSOR_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/schedule/base/ischeduler_video_state.h b/services/deferred_processing_service/include/schedule/base/ischeduler_video_state.h
new file mode 100644
index 000000000..8d5eabe7c
--- /dev/null
+++ b/services/deferred_processing_service/include/schedule/base/ischeduler_video_state.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_I_SCHEDULER_STATE_H
+#define OHOS_CAMERA_DPS_I_SCHEDULER_STATE_H
+
+#include "basic_definitions.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+const std::string IGNORE_BATTERY_LEVEL = "ohos.dps.ignore_battery_level";
+const std::string IGNORE_BATTERY = "ohos.dps.ignore_battery";
+const std::string IGNORE_SCREEN = "ohos.dps.ignore_screen";
+const std::string IGNORE_TEMPERATURE = "ohos.dps.ignore_temperature";
+
+class ISchedulerVideoState {
+public:
+    struct VideoSchedulerInfo {
+        bool isNeedStop;
+        bool isCharging;
+
+        bool operator==(const VideoSchedulerInfo& info) const
+        {
+            return isNeedStop == info.isNeedStop && isCharging == info.isCharging;
+        }
+    };
+    
+    explicit ISchedulerVideoState(int32_t stateValue);
+    virtual ~ISchedulerVideoState();
+
+    int32_t Initialize();
+    VideoSchedulerInfo GetScheduleInfo(ScheduleType type);
+    bool UpdateSchedulerInfo(ScheduleType type, int32_t stateValue);
+
+protected:
+    virtual VideoSchedulerInfo ReevaluateSchedulerInfo() = 0;
+
+    int32_t stateValue_;
+    VideoSchedulerInfo scheduleInfo_;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_I_SCHEDULER_STATE_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/schedule/impl/video_battery_level_state.h b/services/deferred_processing_service/include/schedule/impl/video_battery_level_state.h
new file mode 100644
index 000000000..3de5b41cf
--- /dev/null
+++ b/services/deferred_processing_service/include/schedule/impl/video_battery_level_state.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_VIDEO_BATTERY_LEVEL_STATE_H
+#define OHOS_CAMERA_DPS_VIDEO_BATTERY_LEVEL_STATE_H
+
+#include "ischeduler_video_state.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class VideoBatteryLevelState : public ISchedulerVideoState {
+public:
+    explicit VideoBatteryLevelState(int32_t stateValue);
+    ~VideoBatteryLevelState() override;
+
+protected:
+    VideoSchedulerInfo ReevaluateSchedulerInfo() override;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_VIDEO_BATTERY_LEVEL_STATE_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/schedule/impl/video_battery_state.h b/services/deferred_processing_service/include/schedule/impl/video_battery_state.h
new file mode 100644
index 000000000..26b355b4b
--- /dev/null
+++ b/services/deferred_processing_service/include/schedule/impl/video_battery_state.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_VIDEO_BATTERY_STATE_H
+#define OHOS_CAMERA_DPS_VIDEO_BATTERY_STATE_H
+
+#include "ischeduler_video_state.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class VideoBatteryState : public ISchedulerVideoState {
+public:
+    explicit VideoBatteryState(int32_t stateValue);
+    ~VideoBatteryState() override;
+
+protected:
+    VideoSchedulerInfo ReevaluateSchedulerInfo() override;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_VIDEO_BATTERY_STATE_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/schedule/impl/video_camera_state.h b/services/deferred_processing_service/include/schedule/impl/video_camera_state.h
new file mode 100644
index 000000000..e8512ffc6
--- /dev/null
+++ b/services/deferred_processing_service/include/schedule/impl/video_camera_state.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_VIDEO_CAMERA_STATE_H
+#define OHOS_CAMERA_DPS_VIDEO_CAMERA_STATE_H
+
+#include "ischeduler_video_state.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class VideoCameraState : public ISchedulerVideoState {
+public:
+    explicit VideoCameraState(int32_t stateValue);
+    ~VideoCameraState() override;
+
+protected:
+    VideoSchedulerInfo ReevaluateSchedulerInfo() override;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_VIDEO_CAMERA_STATE_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/schedule/impl/video_charging_state.h b/services/deferred_processing_service/include/schedule/impl/video_charging_state.h
new file mode 100644
index 000000000..80b845b9c
--- /dev/null
+++ b/services/deferred_processing_service/include/schedule/impl/video_charging_state.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_VIDEO_CHARGING_STATE_H
+#define OHOS_CAMERA_DPS_VIDEO_CHARGING_STATE_H
+
+#include "ischeduler_video_state.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class VideoChargingState : public ISchedulerVideoState {
+public:
+    explicit VideoChargingState(int32_t stateValue);
+    ~VideoChargingState() override;
+
+protected:
+    VideoSchedulerInfo ReevaluateSchedulerInfo() override;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_VIDEO_CHARGING_STATE_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/schedule/impl/video_hal_state.h b/services/deferred_processing_service/include/schedule/impl/video_hal_state.h
new file mode 100644
index 000000000..1a55cbab6
--- /dev/null
+++ b/services/deferred_processing_service/include/schedule/impl/video_hal_state.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_VIDEO_HAL_STATE_H
+#define OHOS_CAMERA_DPS_VIDEO_HAL_STATE_H
+
+#include "ischeduler_video_state.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class VideoHalState : public ISchedulerVideoState {
+public:
+    explicit VideoHalState(int32_t stateValue);
+    ~VideoHalState() override;
+
+protected:
+    VideoSchedulerInfo ReevaluateSchedulerInfo() override;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_VIDEO_HAL_STATE_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/schedule/impl/video_media_library_state.h b/services/deferred_processing_service/include/schedule/impl/video_media_library_state.h
new file mode 100644
index 000000000..2e26b7d88
--- /dev/null
+++ b/services/deferred_processing_service/include/schedule/impl/video_media_library_state.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_VIDEO_MEDIA_LIBRARY_STATE_H
+#define OHOS_CAMERA_DPS_VIDEO_MEDIA_LIBRARY_STATE_H
+
+#include "ischeduler_video_state.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class VideoMediaLibraryState : public ISchedulerVideoState {
+public:
+    explicit VideoMediaLibraryState(int32_t stateValue);
+    ~VideoMediaLibraryState() override;
+
+protected:
+    VideoSchedulerInfo ReevaluateSchedulerInfo() override;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_VIDEO_MEDIA_LIBRARY_STATE_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/schedule/impl/video_photo_process_state.h b/services/deferred_processing_service/include/schedule/impl/video_photo_process_state.h
new file mode 100644
index 000000000..62eb30173
--- /dev/null
+++ b/services/deferred_processing_service/include/schedule/impl/video_photo_process_state.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_VIDEO_PHOTO_PROCESS_STATE_H
+#define OHOS_CAMERA_DPS_VIDEO_PHOTO_PROCESS_STATE_H
+
+#include "ischeduler_video_state.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class VideoPhotoProcessState : public ISchedulerVideoState {
+public:
+    explicit VideoPhotoProcessState(int32_t stateValue);
+    ~VideoPhotoProcessState() override;
+
+protected:
+    VideoSchedulerInfo ReevaluateSchedulerInfo() override;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_VIDEO_PHOTO_PROCESS_STATE_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/schedule/impl/video_screen_state.h b/services/deferred_processing_service/include/schedule/impl/video_screen_state.h
new file mode 100644
index 000000000..ffc8bf478
--- /dev/null
+++ b/services/deferred_processing_service/include/schedule/impl/video_screen_state.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_VIDEO_SCREEN_STATE_H
+#define OHOS_CAMERA_DPS_VIDEO_SCREEN_STATE_H
+
+#include "ischeduler_video_state.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class VideoScreenState : public ISchedulerVideoState {
+public:
+    explicit VideoScreenState(int32_t stateValue);
+    ~VideoScreenState() override;
+
+protected:
+    VideoSchedulerInfo ReevaluateSchedulerInfo() override;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_VIDEO_SCREEN_STATE_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/schedule/impl/video_temperature_state.h b/services/deferred_processing_service/include/schedule/impl/video_temperature_state.h
new file mode 100644
index 000000000..f3eed5bda
--- /dev/null
+++ b/services/deferred_processing_service/include/schedule/impl/video_temperature_state.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_VIDEO_TEMPERATURE_STATE_H
+#define OHOS_CAMERA_DPS_VIDEO_TEMPERATURE_STATE_H
+
+#include "ischeduler_video_state.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class VideoTemperatureState : public ISchedulerVideoState {
+public:
+    explicit VideoTemperatureState(int32_t stateValue);
+    ~VideoTemperatureState() override;
+
+protected:
+    VideoSchedulerInfo ReevaluateSchedulerInfo() override;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_VIDEO_TEMPERATURE_STATE_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/schedule/photo_processor/photo_job_repository/deferred_photo_job.h b/services/deferred_processing_service/include/schedule/photo_processor/photo_job_repository/deferred_photo_job.h
index 4a43731f5..0080b09f4 100644
--- a/services/deferred_processing_service/include/schedule/photo_processor/photo_job_repository/deferred_photo_job.h
+++ b/services/deferred_processing_service/include/schedule/photo_processor/photo_job_repository/deferred_photo_job.h
@@ -1,109 +1,102 @@
-/*
- * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef OHOS_CAMERA_DPS_DEFERRED_PHOTO_JOB_H
-#define OHOS_CAMERA_DPS_DEFERRED_PHOTO_JOB_H
-
-#include <map>
-#include <memory>
-#include <string>
-
-#include "basic_definitions.h"
-#include "foundation/multimedia/camera_framework/interfaces/inner_api/native/camera/include/utils/dps_metadata_info.h"
-
-namespace OHOS {
-namespace CameraStandard {
-namespace DeferredProcessing {
-enum class PhotoJobStatus {
-    NONE = 0,
-    PENDING,
-    RUNNING,
-    FAILED,
-    COMPLETED,
-    DELETED
-};
-
-enum class PhotoJobPriority {
-    NONE = 0,
-    LOW,
-    NORMAL,
-    HIGH,
-    DELETED
-};
-
-enum class PhotoJobType {
-    OFFLINE = 0,
-    BACKGROUND
-};
-
-enum ExecutionMode {
-    HIGH_PERFORMANCE = 0,
-    LOAD_BALANCE,
-    LOW_POWER,
-    DUMMY
-};
-
-class DeferredPhotoJob {
-public:
-    DeferredPhotoJob(const std::string& imageId, bool discardable, DpsMetadata& metadata);
-    ~DeferredPhotoJob();
-
-    PhotoJobPriority GetCurPriority();
-    PhotoJobPriority GetPrePriority();
-    PhotoJobPriority GetRunningPriority();
-    PhotoJobStatus GetCurStatus();
-    PhotoJobStatus GetPreStatus();
-    std::string& GetImageId();
-    int GetDeferredProcType();
-
-private:
-    friend class PhotoJobRepository;
-
-    bool SetJobStatus(PhotoJobStatus curStatus);
-    bool SetJobPriority(PhotoJobPriority priority);
-    void RecordJobRunningPriority();
-    void SetJobType(PhotoJobType photoJobType);
-    bool GetDiscardable();
-    int GetPhotoJobType();
-    void SetPhotoJobType(int photoJobType);
-
-    std::string imageId_;
-    bool discardable_;
-    DpsMetadata metadata_;
-    PhotoJobPriority prePriority_;
-    PhotoJobPriority curPriority_;
-    PhotoJobPriority runningPriority_;
-    PhotoJobStatus preStatus_;
-    PhotoJobStatus curStatus_;
-    int photoJobType_;
-};
-using DeferredPhotoJobPtr = std::shared_ptr<DeferredPhotoJob>;
-
-class DeferredPhotoWork {
-public:
-    DeferredPhotoWork(DeferredPhotoJobPtr jobPtr, ExecutionMode mode);
-    ~DeferredPhotoWork();
-    DeferredPhotoJobPtr GetDeferredPhotoJob();
-    ExecutionMode GetExecutionMode();
-
-private:
-    DeferredPhotoJobPtr jobPtr_;
-    ExecutionMode executionMode_;
-};
-using DeferredPhotoWorkPtr = std::shared_ptr<DeferredPhotoWork>;
-} // namespace DeferredProcessing
-} // namespace CameraStandard
-} // namespace OHOS
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_DEFERRED_PHOTO_JOB_H
+#define OHOS_CAMERA_DPS_DEFERRED_PHOTO_JOB_H
+
+#include <map>
+#include <memory>
+#include <string>
+
+#include "basic_definitions.h"
+#include "foundation/multimedia/camera_framework/interfaces/inner_api/native/camera/include/utils/dps_metadata_info.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+enum class PhotoJobStatus {
+    NONE = 0,
+    PENDING,
+    RUNNING,
+    FAILED,
+    COMPLETED,
+    DELETED
+};
+
+enum class PhotoJobPriority {
+    NONE = 0,
+    LOW,
+    NORMAL,
+    HIGH,
+    DELETED
+};
+
+enum class PhotoJobType {
+    OFFLINE = 0,
+    BACKGROUND
+};
+
+class DeferredPhotoJob {
+public:
+    DeferredPhotoJob(const std::string& imageId, bool discardable, DpsMetadata& metadata);
+    ~DeferredPhotoJob();
+
+    PhotoJobPriority GetCurPriority();
+    PhotoJobPriority GetPrePriority();
+    PhotoJobPriority GetRunningPriority();
+    PhotoJobStatus GetCurStatus();
+    PhotoJobStatus GetPreStatus();
+    std::string& GetImageId();
+    int GetDeferredProcType();
+
+private:
+    friend class PhotoJobRepository;
+
+    bool SetJobStatus(PhotoJobStatus curStatus);
+    bool SetJobPriority(PhotoJobPriority priority);
+    void RecordJobRunningPriority();
+    void SetJobType(PhotoJobType photoJobType);
+    bool GetDiscardable();
+    int GetPhotoJobType();
+    void SetPhotoJobType(int photoJobType);
+
+    std::string imageId_;
+    bool discardable_;
+    DpsMetadata metadata_;
+    PhotoJobPriority prePriority_;
+    PhotoJobPriority curPriority_;
+    PhotoJobPriority runningPriority_;
+    PhotoJobStatus preStatus_;
+    PhotoJobStatus curStatus_;
+    int photoJobType_;
+};
+using DeferredPhotoJobPtr = std::shared_ptr<DeferredPhotoJob>;
+
+class DeferredPhotoWork {
+public:
+    DeferredPhotoWork(DeferredPhotoJobPtr jobPtr, ExecutionMode mode);
+    ~DeferredPhotoWork();
+    DeferredPhotoJobPtr GetDeferredPhotoJob();
+    ExecutionMode GetExecutionMode();
+
+private:
+    DeferredPhotoJobPtr jobPtr_;
+    ExecutionMode executionMode_;
+};
+using DeferredPhotoWorkPtr = std::shared_ptr<DeferredPhotoWork>;
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
 #endif // OHOS_CAMERA_DPS_DEFERRED_PHOTO_JOB_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/schedule/scheduler_coordinator.h b/services/deferred_processing_service/include/schedule/scheduler_coordinator.h
index d4746b485..a54d251eb 100644
--- a/services/deferred_processing_service/include/schedule/scheduler_coordinator.h
+++ b/services/deferred_processing_service/include/schedule/scheduler_coordinator.h
@@ -1,45 +1,42 @@
-/*
- * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef OHOS_CAMERA_DPS_SCHEDULER_COORDINATOR_H
-#define OHOS_CAMERA_DPS_SCHEDULER_COORDINATOR_H
-
-#include <memory>
-#include <unordered_map>
-
-#include "deferred_photo_controller.h"
-#include "deferred_photo_processor.h"
-
-namespace OHOS {
-namespace CameraStandard {
-namespace DeferredProcessing {
-class SchedulerCoordinator {
-public:
-    SchedulerCoordinator();
-    ~SchedulerCoordinator();
-    void Initialize();
-    void UserRequestReceived(int userId);
-    void AttachController(int userId, std::shared_ptr<DeferredPhotoController>);
-    void DetachController(int userId);
-
-private:
-    void SwitchController();
-
-    std::map<int, std::shared_ptr<DeferredPhotoController>> photoControllers_;
-};
-} // namespace DeferredProcessing
-} // namespace CameraStandard
-} // namespace OHOS
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_SCHEDULER_COORDINATOR_H
+#define OHOS_CAMERA_DPS_SCHEDULER_COORDINATOR_H
+
+#include "deferred_photo_controller.h"
+#include "deferred_photo_processor.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class SchedulerCoordinator {
+public:
+    SchedulerCoordinator();
+    ~SchedulerCoordinator();
+    void Initialize();
+    void UserRequestReceived(int userId);
+    void AttachController(int userId, std::shared_ptr<DeferredPhotoController>);
+    void DetachController(int userId);
+
+private:
+    void SwitchController();
+
+    std::map<int, std::shared_ptr<DeferredPhotoController>> photoControllers_ {};
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
 #endif // OHOS_CAMERA_DPS_SCHEDULER_COORDINATOR_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/schedule/scheduler_manager.h b/services/deferred_processing_service/include/schedule/scheduler_manager.h
index db88dd2be..6b20f5ab8 100644
--- a/services/deferred_processing_service/include/schedule/scheduler_manager.h
+++ b/services/deferred_processing_service/include/schedule/scheduler_manager.h
@@ -16,9 +16,11 @@
 #ifndef OHOS_CAMERA_DPS_SCHEDULE_MANAGER_H
 #define OHOS_CAMERA_DPS_SCHEDULE_MANAGER_H
 
-#include "scheduler_coordinator.h"
 #include "deferred_photo_controller.h"
 #include "deferred_photo_processor.h"
+#include "deferred_video_controller.h"
+#include "deferred_video_processor.h"
+#include "scheduler_coordinator.h"
 
 namespace OHOS {
 namespace CameraStandard {
@@ -27,21 +29,26 @@ class SchedulerManager {
 public:
     SchedulerManager();
     ~SchedulerManager();
-    void Initialize();
+    int32_t Initialize();
 
     // 用于session获取对应的processor，如果有则直接返回 如果没有则创建后返回 这里的callback是sessioncoordinator对象
     // 创建任务仓库 processor  并把仓库传给processor，再创建processor对应的controller
     // controller向任务仓库注册任务监听（关注任务添加、任务running个数改变）+向事件监听模块注册监听
     std::shared_ptr<DeferredPhotoProcessor> GetPhotoProcessor(const int32_t userId,
         TaskManager* taskManager, std::shared_ptr<IImageProcessCallbacks> callbacks);
+    std::shared_ptr<DeferredVideoProcessor> GetVideoProcessor(const int32_t userId);
+    std::shared_ptr<DeferredVideoController> GetVideoController(const int32_t userId);
+    void CreateVideoProcessor(const int32_t userId, const std::shared_ptr<IVideoProcessCallbacks>& callbacks);
 
 private:
     void CreatePhotoProcessor(const int32_t userId,
         TaskManager* taskManager, std::shared_ptr<IImageProcessCallbacks> callbacks);
 
-    std::unordered_map<int32_t, std::shared_ptr<DeferredPhotoProcessor>> photoProcessors_;
-    std::unordered_map<int32_t, std::shared_ptr<DeferredPhotoController>> photoController_;
-    std::shared_ptr<SchedulerCoordinator> schedulerCoordinator_;
+    std::unordered_map<int32_t, std::shared_ptr<DeferredPhotoProcessor>> photoProcessors_ {};
+    std::unordered_map<int32_t, std::shared_ptr<DeferredPhotoController>> photoController_ {};
+    std::unordered_map<int32_t, std::shared_ptr<DeferredVideoProcessor>> videoProcessors_ {};
+    std::unordered_map<int32_t, std::shared_ptr<DeferredVideoController>> videoController_ {};
+    std::shared_ptr<SchedulerCoordinator> schedulerCoordinator_ {nullptr};
 };
 } // namespace DeferredProcessing
 } // namespace CameraStandard
diff --git a/services/deferred_processing_service/include/schedule/video_processor/deferred_video_controller.h b/services/deferred_processing_service/include/schedule/video_processor/deferred_video_controller.h
new file mode 100644
index 000000000..8868ed910
--- /dev/null
+++ b/services/deferred_processing_service/include/schedule/video_processor/deferred_video_controller.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_DEFERRED_VIDEO_CONTROLLER_H
+#define OHOS_CAMERA_DPS_DEFERRED_VIDEO_CONTROLLER_H
+
+#include "deferred_video_processor.h"
+#include "video_strategy_center.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class DeferredVideoController : public std::enable_shared_from_this<DeferredVideoController> {
+public:
+    ~DeferredVideoController();
+
+    void Initialize();
+    void HandleServiceDied();
+    void HandleSuccess(const int32_t userId, const DeferredVideoWorkPtr& work);
+    void HandleError(const int32_t userId, const DeferredVideoWorkPtr& work, DpsError errorCode);
+
+protected:
+    DeferredVideoController(const int32_t userId, std::shared_ptr<VideoJobRepository> repository,
+        std::shared_ptr<DeferredVideoProcessor> processor);
+
+private:
+    class StateListener;
+    class VideoJobRepositoryListener;
+
+    void OnSchedulerChanged(const ScheduleType& type, const ScheduleInfo& scheduleInfo);
+    void OnVideoJobChanged(const DeferredVideoJobPtr& jobPtr);
+    void TryDoSchedule();
+    void PauseRequests(const ScheduleType& type);
+    void PostProcess(const DeferredVideoWorkPtr& work);
+    void SetDefaultExecutionMode();
+    void StartSuspendLock();
+    void StopSuspendLock();
+    void HandleNormalSchedule(const DeferredVideoWorkPtr& work);
+    void OnTimerOut();
+
+    std::recursive_mutex mutex_;
+    const int32_t userId_;
+    uint32_t normalTimeId_ {0};
+    std::shared_ptr<DeferredVideoProcessor> videoProcessor_;
+    std::shared_ptr<VideoJobRepository> videoJobRepository_;
+    std::shared_ptr<VideoStrategyCenter> videoStrategyCenter_ {nullptr};
+    std::shared_ptr<StateListener> videoStateChangeListener_ {nullptr};
+    std::shared_ptr<VideoJobRepositoryListener> videoJobChangeListener_ {nullptr};
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_DEFERRED_VIDEO_CONTROLLER_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/schedule/video_processor/deferred_video_processor.h b/services/deferred_processing_service/include/schedule/video_processor/deferred_video_processor.h
new file mode 100644
index 000000000..91f9eaeb8
--- /dev/null
+++ b/services/deferred_processing_service/include/schedule/video_processor/deferred_video_processor.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_DEFERRED_VIDEO_PROCESSOR_H
+#define OHOS_CAMERA_DPS_DEFERRED_VIDEO_PROCESSOR_H
+
+#include "ivideo_process_callbacks.h"
+#include "video_post_processor.h"
+#include "video_job_repository.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class DeferredVideoProcessor : public IVideoProcessCallbacks {
+public:
+    DeferredVideoProcessor(const int32_t userId, std::shared_ptr<VideoJobRepository> repository,
+        std::shared_ptr<IVideoProcessCallbacks> callbacks);
+    ~DeferredVideoProcessor();
+    void Initialize();
+
+    void AddVideo(const std::string& videoId, const sptr<IPCFileDescriptor>& srcFd,
+        const sptr<IPCFileDescriptor>& dstFd);
+    void RemoveVideo(const std::string& videoId, bool restorable);
+    void RestoreVideo(const std::string& videoId);
+
+    void OnProcessDone(const int32_t userId, const std::string& videoId, const sptr<IPCFileDescriptor>& ipcFd) override;
+    void OnError(const int32_t userId, const std::string& videoId, DpsError errorCode) override;
+    void OnStateChanged(const int32_t userId, DpsStatus statusCode) override;
+
+    void PostProcess(const DeferredVideoWorkPtr& work);
+    void PauseRequest(const ScheduleType& type);
+    void SetDefaultExecutionMode();
+    bool GetPendingVideos(std::vector<std::string>& pendingVideos);
+
+private:
+    bool IsFatalError(DpsError errorCode);
+
+    const int32_t userId_;
+    std::shared_ptr<VideoJobRepository> repository_;
+    std::shared_ptr<IVideoProcessCallbacks> callbacks_;
+    std::shared_ptr<VideoPostProcessor> postProcessor_;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_DEFERRED_VIDEO_PROCESSOR_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/schedule/video_processor/strategy/ivideo_state_change_listener.h b/services/deferred_processing_service/include/schedule/video_processor/strategy/ivideo_state_change_listener.h
new file mode 100644
index 000000000..fae0c7124
--- /dev/null
+++ b/services/deferred_processing_service/include/schedule/video_processor/strategy/ivideo_state_change_listener.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_I_VIDEO_STATE_CHANGE_LISTENER_H
+#define OHOS_CAMERA_DPS_I_VIDEO_STATE_CHANGE_LISTENER_H
+
+#include "basic_definitions.h"
+#include "ischeduler_video_state.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+using ScheduleInfo = ISchedulerVideoState::VideoSchedulerInfo;
+
+class IVideoStateChangeListener {
+public:
+    IVideoStateChangeListener() = default;
+    virtual ~IVideoStateChangeListener() = default;
+    
+    virtual void OnSchedulerChanged(const ScheduleType& type, const ScheduleInfo& scheduleInfo) = 0;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_I_VIDEO_STATE_CHANGE_LISTENER_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/schedule/video_processor/strategy/ivideo_strategy.h b/services/deferred_processing_service/include/schedule/video_processor/strategy/ivideo_strategy.h
new file mode 100644
index 000000000..e1cf896de
--- /dev/null
+++ b/services/deferred_processing_service/include/schedule/video_processor/strategy/ivideo_strategy.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_I_VIDEO_STRATEGY_H
+#define OHOS_CAMERA_DPS_I_VIDEO_STRATEGY_H
+
+#include "basic_definitions.h"
+#include "deferred_video_job.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class IVideoStrategy {
+public:
+    IVideoStrategy() = default;
+    virtual ~IVideoStrategy() = default;
+    
+    virtual DeferredVideoWorkPtr GetWork();
+    virtual DeferredVideoJobPtr GetJob();
+    virtual ExecutionMode GetExecutionMode();
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_I_VIDEO_STRATEGY_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/schedule/video_processor/strategy/video_strategy_center.h b/services/deferred_processing_service/include/schedule/video_processor/strategy/video_strategy_center.h
new file mode 100644
index 000000000..212ae4302
--- /dev/null
+++ b/services/deferred_processing_service/include/schedule/video_processor/strategy/video_strategy_center.h
@@ -0,0 +1,116 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_VIDEO_STRATEGY_CENTER_H
+#define OHOS_CAMERA_DPS_VIDEO_STRATEGY_CENTER_H
+
+#include <functional>
+
+#include "basic_definitions.h"
+#include "ischeduler_video_state.h"
+#include "ivideo_state_change_listener.h"
+#include "video_job_repository.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+constexpr uint32_t TIME_OK = 0b0;
+using EventCallback = std::function<void(const int32_t)>;
+
+class VideoStrategyCenter : public std::enable_shared_from_this<VideoStrategyCenter> {
+public:
+    ~VideoStrategyCenter();
+
+    void Initialize();
+    void InitHandleEvent();
+    void InitScheduleState();
+    void RegisterStateChangeListener(const std::weak_ptr<IVideoStateChangeListener>& listener);
+    DeferredVideoWorkPtr GetWork();
+    DeferredVideoJobPtr GetJob();
+    ExecutionMode GetExecutionMode();
+    void UpdateSingleTime(bool isOk);
+    void UpdateAvailableTime(bool isNeedReset, int32_t useTime);
+
+    inline int32_t GetAvailableTime()
+    {
+        return availableTime_;
+    }
+
+    inline bool IsReady()
+    {
+        DP_INFO_LOG("isSchedulerOk is: %{public}d",  !isNeedStop_);
+        return !isNeedStop_;
+    }
+
+    inline bool IsTimeReady()
+    {
+        DP_INFO_LOG("isTimeOk is: 0x%{public}x", isTimeOk_);
+        return isTimeOk_ == TIME_OK;
+    }
+
+    inline bool isCharging()
+    {
+        DP_INFO_LOG("isCharging is: %{public}d", isCharging_);
+        return isCharging_;
+    }
+
+protected:
+    VideoStrategyCenter(const int32_t userId, const std::shared_ptr<VideoJobRepository>& repository);
+
+private:
+    class EventsListener;
+    
+    void HandleEventChanged(EventType event, int32_t value);
+    void HandleCameraEvent(int32_t value);
+    void HandleHalEvent(int32_t value);
+    void HandleMedialLibraryEvent(int32_t value);
+    void HandleScreenEvent(int32_t value);
+    void HandleChargingEvent(int32_t value);
+    void HandleBatteryEvent(int32_t value);
+    void HandleBatteryLevelEvent(int32_t value);
+    void HandleTemperatureEvent(int32_t value);
+    void HandlePhotoProcessEvent(int32_t value);
+    void UpdateValue(ScheduleType type, int32_t value);
+    ScheduleInfo ReevaluateSchedulerInfo();
+    ScheduleInfo GetScheduleInfo(ScheduleType type);
+    std::shared_ptr<ISchedulerVideoState> GetScheduleState(ScheduleType type);
+    
+    inline VideoThermalLevel ConvertThermalLevel(int32_t level)
+    {
+        DP_CHECK_RETURN_RET(level == ThermalLevel::LEVEL_0, VideoThermalLevel::COOL);
+        return VideoThermalLevel::HOT;
+    }
+
+    inline PhotoProcessStatus ConvertProcessState(int32_t size)
+    {
+        DP_CHECK_RETURN_RET(size > 0, PhotoProcessStatus::BUSY);
+        return PhotoProcessStatus::IDLE;
+    }
+
+    const int32_t userId_;
+    bool isCharging_ {false};
+    bool isNeedStop_ {true};
+    uint32_t isTimeOk_ {0};
+    int32_t availableTime_ {TOTAL_PROCESS_TIME};
+    std::shared_ptr<EventsListener> eventsListener_ {nullptr};
+    std::shared_ptr<VideoJobRepository> videoJobRepository_ {nullptr};
+    std::weak_ptr<IVideoStateChangeListener> videoStateChangeListener_;
+    std::unordered_map<EventType, EventCallback> eventHandlerList_ {};
+    std::unordered_map<ScheduleType, std::shared_ptr<ISchedulerVideoState>> scheduleStateList_ {};
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_VIDEO_STRATEGY_CENTER_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/schedule/video_processor/video_job_repository/deferred_video_job.h b/services/deferred_processing_service/include/schedule/video_processor/video_job_repository/deferred_video_job.h
new file mode 100644
index 000000000..e84693924
--- /dev/null
+++ b/services/deferred_processing_service/include/schedule/video_processor/video_job_repository/deferred_video_job.h
@@ -0,0 +1,149 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_DEFERRED_VIDEO_JOB_H
+#define OHOS_CAMERA_DPS_DEFERRED_VIDEO_JOB_H
+
+#include "basic_definitions.h"
+#include "dp_utils.h"
+#include "ipc_file_descriptor.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+enum class VideoJobStatus {
+    NONE = 0,
+    PAUSE = 1,
+    PENDING = 2,
+    FAILED = 3,
+    DELETED = 4,
+    RUNNING = 5,
+    COMPLETED = 6,
+    ERROR = 7,
+};
+
+class DeferredVideoJob {
+public:
+    DeferredVideoJob(const std::string& videoId, const sptr<IPCFileDescriptor>& srcFd,
+        const sptr<IPCFileDescriptor>& dstFd);
+    ~DeferredVideoJob();
+
+    inline VideoJobStatus GetCurStatus()
+    {
+        DP_DEBUG_LOG("videoId: %{public}s, current status: %{public}d, previous status: %{public}d",
+            videoId_.c_str(), curStatus_, preStatus_);
+        return curStatus_;
+    }
+
+    inline VideoJobStatus GetPreStatus()
+    {
+        DP_DEBUG_LOG("videoId: %{public}s, current status: %{public}d, previous status: %{public}d",
+            videoId_.c_str(), curStatus_, preStatus_);
+        return preStatus_;
+    }
+
+    inline std::string GetVideoId()
+    {
+        return videoId_;
+    }
+
+    inline sptr<IPCFileDescriptor> GetInputFd()
+    {
+        return srcFd_;
+    }
+
+    inline sptr<IPCFileDescriptor> GetOutputFd()
+    {
+        return dstFd_;
+    }
+
+    bool operator==(const DeferredVideoJob& other) const
+    {
+        return videoId_ == other.videoId_;
+    }
+
+    bool operator>(const DeferredVideoJob& other) const
+    {
+        if (curStatus_ == other.curStatus_) {
+            return createTime_ < other.createTime_;
+        }
+        return curStatus_ < other.curStatus_;
+    }
+
+private:
+    friend class VideoJobRepository;
+    bool SetJobStatus(VideoJobStatus curStatus);
+
+    const std::string videoId_;
+    sptr<IPCFileDescriptor> srcFd_;
+    sptr<IPCFileDescriptor> dstFd_;
+    VideoJobStatus preStatus_ {VideoJobStatus::NONE};
+    VideoJobStatus curStatus_ {VideoJobStatus::NONE};
+    SteadyTimePoint createTime_;
+};
+using DeferredVideoJobPtr = std::shared_ptr<DeferredVideoJob>;
+
+class DeferredVideoWork {
+public:
+    DeferredVideoWork(const DeferredVideoJobPtr& jobPtr, ExecutionMode mode, bool isAutoSuspend);
+    ~DeferredVideoWork();
+
+    inline DeferredVideoJobPtr GetDeferredVideoJob() const
+    {
+        return jobPtr_;
+    }
+
+    inline ExecutionMode GetExecutionMode() const
+    {
+        return executionMode_;
+    }
+
+    inline bool IsSuspend() const
+    {
+        return !isCharging_;
+    }
+
+    inline SteadyTimePoint GetStartTime() const
+    {
+        return startTime_;
+    }
+
+    inline uint32_t GetExecutionTime() const
+    {
+        return static_cast<uint32_t>(GetDiffTime<Milli>(GetStartTime()));
+    }
+
+    inline uint32_t GetTimeId() const
+    {
+        return timeId_;
+    }
+
+    inline void SetTimeId(const uint32_t timeId)
+    {
+        timeId_ = timeId;
+    }
+
+private:
+    DeferredVideoJobPtr jobPtr_;
+    ExecutionMode executionMode_;
+    SteadyTimePoint startTime_;
+    bool isCharging_;
+    uint32_t timeId_ {0};
+};
+using DeferredVideoWorkPtr = std::shared_ptr<DeferredVideoWork>;
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_DEFERRED_VIDEO_JOB_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/schedule/video_processor/video_job_repository/ivideo_job_repository_listener.h b/services/deferred_processing_service/include/schedule/video_processor/video_job_repository/ivideo_job_repository_listener.h
new file mode 100644
index 000000000..c350fae2e
--- /dev/null
+++ b/services/deferred_processing_service/include/schedule/video_processor/video_job_repository/ivideo_job_repository_listener.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_I_VIDEO_JOB_REPOSITORY_LISTENER_H
+#define OHOS_CAMERA_DPS_I_VIDEO_JOB_REPOSITORY_LISTENER_H
+
+#include "deferred_video_job.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class IVideoJobRepositoryListener {
+public:
+    IVideoJobRepositoryListener() = default;
+    virtual ~IVideoJobRepositoryListener() = default;
+    
+    virtual void OnVideoJobChanged(const DeferredVideoJobPtr& jobPtr);
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_I_VIDEO_JOB_REPOSITORY_LISTENER_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/schedule/video_processor/video_job_repository/video_job_queue.h b/services/deferred_processing_service/include/schedule/video_processor/video_job_repository/video_job_queue.h
new file mode 100644
index 000000000..619c52bf4
--- /dev/null
+++ b/services/deferred_processing_service/include/schedule/video_processor/video_job_repository/video_job_queue.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_VIDEO_JOB_QUEUE_H
+#define OHOS_CAMERA_DPS_VIDEO_JOB_QUEUE_H
+
+#include "deferred_video_job.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+constexpr int32_t DEFAULT = 0;
+class VideoJobQueue {
+public:
+    typedef std::function<bool(DeferredVideoJobPtr, DeferredVideoJobPtr)> Comparator;
+    explicit VideoJobQueue(Comparator comp);
+    ~VideoJobQueue();
+
+    bool Contains(DeferredVideoJobPtr obj) const;
+    DeferredVideoJobPtr Peek() const;
+    void Push(DeferredVideoJobPtr obj);
+    DeferredVideoJobPtr Pop();
+    void Remove(DeferredVideoJobPtr obj);
+    void Update(DeferredVideoJobPtr obj);
+    std::vector<DeferredVideoJobPtr> GetAllElements() const;
+    void Clear();
+
+    inline bool IsEmpty()
+    {
+        return size_ == DEFAULT;
+    }
+
+    inline int32_t GetSize()
+    {
+        DP_DEBUG_LOG("entered, size is %{public}d", size_);
+        return size_;
+    }
+
+private:
+    void HeapInsert(int32_t index);
+    void Heapify(int32_t index);
+    void Swap(int32_t x, int32_t y);
+
+    int32_t size_ {0};
+    Comparator comp_;
+    std::vector<DeferredVideoJobPtr> heap_ {};
+    std::unordered_map<DeferredVideoJobPtr, int32_t> indexMap_ {};
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_VIDEO_JOB_QUEUE_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/schedule/video_processor/video_job_repository/video_job_repository.h b/services/deferred_processing_service/include/schedule/video_processor/video_job_repository/video_job_repository.h
new file mode 100644
index 000000000..43ffc19a0
--- /dev/null
+++ b/services/deferred_processing_service/include/schedule/video_processor/video_job_repository/video_job_repository.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_VIDEO_JOB_REPOSITORY_H
+#define OHOS_CAMERA_DPS_VIDEO_JOB_REPOSITORY_H
+
+#include <unordered_set>
+
+#include "deferred_video_job.h"
+#include "ivideo_job_repository_listener.h"
+#include "video_job_queue.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class VideoJobRepository {
+public:
+    VideoJobRepository(const int32_t userId);
+    ~VideoJobRepository();
+    
+    void AddVideoJob(const std::string& videoId, const sptr<IPCFileDescriptor>& srcFd,
+        const sptr<IPCFileDescriptor>& dstFd);
+    bool RemoveVideoJob(const std::string& videoId, bool restorable);
+    void RestoreVideoJob(const std::string& videoId);
+    void SetJobPending(const std::string& videoId);
+    void SetJobRunning(const std::string& videoId);
+    void SetJobCompleted(const std::string& videoId);
+    void SetJobFailed(const std::string& videoId);
+    void SetJobPause(const std::string& videoId);
+    void SetJobError(const std::string& videoId);
+
+    DeferredVideoJobPtr GetJob();
+    int32_t GetRunningJobCounts();
+    void GetRunningJobList(std::vector<std::string>& list);
+    void RegisterJobListener(const std::weak_ptr<IVideoJobRepositoryListener>& listener);
+
+private:
+    void NotifyJobChangedUnLocked(bool statusChanged, DeferredVideoJobPtr jobPtr);
+    void UpdateRunningCountUnLocked(bool statusChanged, const DeferredVideoJobPtr& jobPtr);
+    DeferredVideoJobPtr GetJobUnLocked(const std::string& videoId);
+    void ClearCatch();
+
+    std::recursive_mutex mutex_;
+    const int32_t userId_;
+    std::shared_ptr<VideoJobQueue> jobQueue_ {nullptr};
+    std::unordered_map<std::string, DeferredVideoJobPtr> jobMap_ {};
+    std::unordered_set<std::string> runningSet_ {};
+    std::weak_ptr<IVideoJobRepositoryListener> jobListener_ ;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_VIDEO_JOB_REPOSITORY_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/session/command/session_command.h b/services/deferred_processing_service/include/session/command/session_command.h
new file mode 100644
index 000000000..4a050d304
--- /dev/null
+++ b/services/deferred_processing_service/include/session/command/session_command.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_SESSION_COMMAND_H
+#define OHOS_CAMERA_DPS_SESSION_COMMAND_H
+
+#include "command.h"
+#include "scheduler_manager.h"
+#include "session_manager.h"
+#include "video_session_info.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+
+class SessionCommand : public Command {
+public:
+    SessionCommand(const sptr<VideoSessionInfo>& sessionInfo);
+    ~SessionCommand() override;
+
+protected:
+    int32_t Initialize();
+
+    std::atomic<bool> initialized_ {false};
+    std::shared_ptr<SessionManager> sessionManager_ {nullptr};
+    sptr<VideoSessionInfo> sessionInfo_;
+};
+
+class AddVideoSessionCommand : public SessionCommand {
+    DECLARE_CMD_CLASS(AddVideoSessionCommand)
+public:
+    using SessionCommand::SessionCommand;
+
+protected:
+    int32_t Executing() override;
+};
+
+class DeleteVideoSessionCommand : public SessionCommand {
+    DECLARE_CMD_CLASS(DeleteVideoSessionCommand)
+public:
+    using SessionCommand::SessionCommand;
+
+protected:
+    int32_t Executing() override;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_SESSION_COMMAND_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/session/command/sync_command.h b/services/deferred_processing_service/include/session/command/sync_command.h
new file mode 100644
index 000000000..602d21f9f
--- /dev/null
+++ b/services/deferred_processing_service/include/session/command/sync_command.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_SYNC_COMMAND_H
+#define OHOS_CAMERA_DPS_SYNC_COMMAND_H
+
+#include "command.h"
+#include "deferred_video_processing_session.h"
+#include "scheduler_manager.h"
+#include "session_manager.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class SyncCommand : public Command {
+public:
+    SyncCommand(const int32_t userId);
+    ~SyncCommand();
+
+protected:
+    int32_t Initialize();
+
+    const int32_t userId_;
+    std::atomic_bool initialized_ {false};
+    std::shared_ptr<SessionManager> sessionManager_ {nullptr};
+    std::shared_ptr<SchedulerManager> schedulerManager_ {nullptr};
+    std::shared_ptr<DeferredVideoProcessor> processor_ {nullptr};
+};
+
+class VideoSyncCommand : public SyncCommand {
+    DECLARE_CMD_CLASS(VideoSyncCommand)
+public:
+    VideoSyncCommand(const int32_t userId,
+        const std::unordered_map<std::string, std::shared_ptr<DeferredVideoProcessingSession::VideoInfo>>& videoIds);
+
+protected:
+    int32_t Executing() override;
+
+    std::unordered_map<std::string, std::shared_ptr<DeferredVideoProcessingSession::VideoInfo>> videoIds_ {};
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_SYNC_COMMAND_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/session/command/video_command.h b/services/deferred_processing_service/include/session/command/video_command.h
new file mode 100644
index 000000000..ccf959aa4
--- /dev/null
+++ b/services/deferred_processing_service/include/session/command/video_command.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_VIDEO_COMMAND_H
+#define OHOS_CAMERA_DPS_VIDEO_COMMAND_H
+
+#include "command.h"
+#include "ipc_file_descriptor.h"
+#include "scheduler_manager.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class VideoCommand : public Command {
+public:
+    VideoCommand(const int32_t userId, const std::string& videoId);
+    ~VideoCommand();
+
+protected:
+    int32_t Initialize();
+
+    const int32_t userId_;
+    const std::string videoId_;
+    std::atomic<bool> initialized_ {false};
+    std::shared_ptr<SchedulerManager> schedulerManager_ {nullptr};
+    std::shared_ptr<DeferredVideoProcessor> processor_ {nullptr};
+};
+
+class AddVideoCommand : public VideoCommand {
+    DECLARE_CMD_CLASS(AddVideoCommand)
+public:
+    AddVideoCommand(const int32_t userId, const std::string& videoId,
+        const sptr<IPCFileDescriptor>& srcFd, const sptr<IPCFileDescriptor>& dstFd);
+
+protected:
+    int32_t Executing() override;
+
+    sptr<IPCFileDescriptor> srcFd_;
+    sptr<IPCFileDescriptor> dstFd_;
+};
+
+class RemoveVideoCommand : public VideoCommand {
+    DECLARE_CMD_CLASS(RemoveVideoCommand)
+public:
+    RemoveVideoCommand(const int32_t userId, const std::string& videoId, const bool restorable);
+
+protected:
+    int32_t Executing() override;
+
+    const bool restorable_;
+};
+
+class RestoreCommand : public VideoCommand {
+    DECLARE_CMD_CLASS(RestoreCommand)
+public:
+    using VideoCommand::VideoCommand;
+
+protected:
+    int32_t Executing() override;
+};
+
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_VIDEO_COMMAND_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/session/photo_session/deferred_photo_processing_session.h b/services/deferred_processing_service/include/session/photo_session/deferred_photo_processing_session.h
index 8921c2cf2..6df7a8185 100644
--- a/services/deferred_processing_service/include/session/photo_session/deferred_photo_processing_session.h
+++ b/services/deferred_processing_service/include/session/photo_session/deferred_photo_processing_session.h
@@ -1,66 +1,66 @@
-/*
- * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef OHOS_CAMERA_DPS_DEFERRED_PHOTO_PROCESSING_SESSION_H
-#define OHOS_CAMERA_DPS_DEFERRED_PHOTO_PROCESSING_SESSION_H
-#define EXPORT_API __attribute__((visibility("default")))
-
-#include "deferred_photo_processing_session_stub.h"
-#include "ideferred_photo_processing_session_callback.h"
-#include "task_manager.h"
-#include "deferred_photo_processor.h"
-
-namespace OHOS {
-namespace CameraStandard {
-namespace DeferredProcessing {
-
-class DeferredPhotoProcessingSession : public DeferredPhotoProcessingSessionStub {
-public:
-    class PhotoInfo {
-    public:
-        PhotoInfo(bool discardable, DpsMetadata metadata)
-            : discardable_(discardable), metadata_(metadata)
-        {}
-        ~PhotoInfo() = default;
-
-        bool discardable_;
-        DpsMetadata metadata_;
-    };
-    EXPORT_API DeferredPhotoProcessingSession(
-        const int32_t userId, std::shared_ptr<DeferredPhotoProcessor> deferredPhotoProcessor,
-        TaskManager* taskManager, sptr<IDeferredPhotoProcessingSessionCallback> callback);
-
-    ~DeferredPhotoProcessingSession();
-    int32_t BeginSynchronize() override;
-    int32_t EndSynchronize() override;
-    int32_t AddImage(const std::string imageId, DpsMetadata& metadata, bool discardable) override;
-    int32_t RemoveImage(const std::string imageId, bool restorable) override;
-    int32_t RestoreImage(const std::string imageId) override;
-    int32_t ProcessImage(const std::string appName, const std::string imageId) override;
-    int32_t CancelProcessImage(const std::string imageId) override;
-
-private:
-    void ReportEvent(const std::string& imageId, int32_t event);
-    const int32_t userId_;
-    std::atomic<bool> inSync_;
-    std::shared_ptr<DeferredPhotoProcessor> processor_;
-    TaskManager* taskManager_;
-    sptr<IDeferredPhotoProcessingSessionCallback> callback_;
-    std::unordered_map<std::string, std::shared_ptr<PhotoInfo>> imageIds_;
-};
-} // namespace DeferredProcessing
-} // namespace CameraStandard
-} // namespace OHOS
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_DEFERRED_PHOTO_PROCESSING_SESSION_H
+#define OHOS_CAMERA_DPS_DEFERRED_PHOTO_PROCESSING_SESSION_H
+#define EXPORT_API __attribute__((visibility("default")))
+
+#include "deferred_photo_processing_session_stub.h"
+#include "ideferred_photo_processing_session_callback.h"
+#include "task_manager.h"
+#include "deferred_photo_processor.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+
+class DeferredPhotoProcessingSession : public DeferredPhotoProcessingSessionStub {
+public:
+    class PhotoInfo {
+    public:
+        PhotoInfo(bool discardable, DpsMetadata metadata)
+            : discardable_(discardable), metadata_(metadata)
+        {}
+        ~PhotoInfo() = default;
+
+        bool discardable_;
+        DpsMetadata metadata_;
+    };
+    EXPORT_API DeferredPhotoProcessingSession(
+        const int32_t userId, std::shared_ptr<DeferredPhotoProcessor> deferredPhotoProcessor,
+        TaskManager* taskManager, sptr<IDeferredPhotoProcessingSessionCallback> callback);
+
+    ~DeferredPhotoProcessingSession();
+    int32_t BeginSynchronize() override;
+    int32_t EndSynchronize() override;
+    int32_t AddImage(const std::string& imageId, DpsMetadata& metadata, bool discardable) override;
+    int32_t RemoveImage(const std::string& imageId, bool restorable) override;
+    int32_t RestoreImage(const std::string& imageId) override;
+    int32_t ProcessImage(const std::string& appName, const std::string imageId) override;
+    int32_t CancelProcessImage(const std::string& imageId) override;
+
+private:
+    void ReportEvent(const std::string& imageId, int32_t event);
+    const int32_t userId_;
+    std::atomic<bool> inSync_;
+    std::shared_ptr<DeferredPhotoProcessor> processor_;
+    TaskManager* taskManager_;
+    sptr<IDeferredPhotoProcessingSessionCallback> callback_;
+    std::unordered_map<std::string, std::shared_ptr<PhotoInfo>> imageIds_;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
 #endif // OHOS_CAMERA_DPS_DEFERRED_PHOTO_PROCESSING_SESSION_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/session/session_coordinator.h b/services/deferred_processing_service/include/session/session_coordinator.h
index 6c0de8218..252211b26 100644
--- a/services/deferred_processing_service/include/session/session_coordinator.h
+++ b/services/deferred_processing_service/include/session/session_coordinator.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
@@ -17,16 +17,20 @@
 #define OHOS_CAMERA_DPS_SESSION_COORDINATOR_H
 
 #include "iimage_process_callbacks.h"
+#include "ivideo_process_callbacks.h"
 #include "ipc_file_descriptor.h"
 #include "ideferred_photo_processing_session_callback.h"
+#include "ideferred_video_processing_session_callback.h"
+#include "video_session_info.h"
 #include "task_manager.h"
+
 namespace OHOS::Media {
     class Picture;
 }
 namespace OHOS {
 namespace CameraStandard {
 namespace DeferredProcessing {
-class SessionCoordinator : public RefBase {
+class SessionCoordinator : public std::enable_shared_from_this<SessionCoordinator> {
 public:
     SessionCoordinator();
     ~SessionCoordinator();
@@ -45,8 +49,16 @@ public:
         TaskManager* taskManager);
     void NotifyCallbackDestroyed(const int32_t userId);
 
+    void AddSession(const sptr<VideoSessionInfo>& sessionInfo);
+    void DeleteSession(const int32_t userId);
+    void OnVideoProcessDone(const int32_t userId, const std::string& videoId, const sptr<IPCFileDescriptor>& ipcFd);
+    void OnVideoError(const int32_t userId, const std::string& videoId, DpsError errorCode);
+    void OnVideoStateChanged(const int32_t userId, DpsStatus statusCode);
+    std::shared_ptr<IVideoProcessCallbacks> GetVideoProcCallbacks();
+
 private:
     class ImageProcCallbacks;
+    class VideoProcCallbacks;
 
     enum struct CallbackType {
         ON_PROCESS_DONE,
@@ -74,11 +86,27 @@ private:
         DpsError errorCode;
         DpsStatus statusCode;
     };
+    
+    struct RequestResult {
+        CallbackType callbackType;
+        const int32_t userId;
+        const std::string requestId;
+        sptr<IPCFileDescriptor> ipcFd;
+        long dataSize;
+        DpsError errorCode;
+        DpsStatus statusCode;
+    };
 
     void ProcessPendingResults(sptr<IDeferredPhotoProcessingSessionCallback> callback);
+    void ProcessVideoResults(sptr<IDeferredVideoProcessingSessionCallback> callback);
+
+    std::mutex mutex_;
     std::shared_ptr<IImageProcessCallbacks> imageProcCallbacks_;
     std::map<int32_t, wptr<IDeferredPhotoProcessingSessionCallback>> remoteImageCallbacksMap_;
     std::deque<ImageResult> pendingImageResults_;
+    std::shared_ptr<IVideoProcessCallbacks> videoProcCallbacks_;
+    std::map<int32_t, wptr<IDeferredVideoProcessingSessionCallback>> remoteVideoCallbacksMap_;
+    std::deque<RequestResult> pendingRequestResults_;
 };
 } // namespace DeferredProcessing
 } // namespace CameraStandard
diff --git a/services/deferred_processing_service/include/session/session_manager.h b/services/deferred_processing_service/include/session/session_manager.h
index 4f82416d6..9ff35f6f5 100644
--- a/services/deferred_processing_service/include/session/session_manager.h
+++ b/services/deferred_processing_service/include/session/session_manager.h
@@ -1,52 +1,58 @@
-/*
- * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef OHOS_CAMERA_DPS_SESSION_MANAGER_H
-#define OHOS_CAMERA_DPS_SESSION_MANAGER_H
-
-#include "session_info.h"
-#include "session_coordinator.h"
-#include "task_manager.h"
-#include "deferred_photo_processor.h"
-
-namespace OHOS {
-namespace CameraStandard {
-namespace DeferredProcessing {
-class SessionManager : public RefBase {
-public:
-    static std::shared_ptr<SessionManager> Create();
-    SessionManager();
-    ~SessionManager();
-    void Initialize();
-    void Start();
-    void Stop();
-    sptr<IDeferredPhotoProcessingSession> CreateDeferredPhotoProcessingSession(
-        const int32_t userId, const sptr<IDeferredPhotoProcessingSessionCallback> callback,
-        std::shared_ptr<DeferredPhotoProcessor> processor, TaskManager* taskManager);
-    std::shared_ptr<IImageProcessCallbacks> GetImageProcCallbacks();
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_SESSION_MANAGER_H
+#define OHOS_CAMERA_DPS_SESSION_MANAGER_H
+
+#include "session_info.h"
+#include "session_coordinator.h"
+#include "task_manager.h"
+#include "video_session_info.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class SessionManager {
+public:
+    static std::shared_ptr<SessionManager> Create();
+    SessionManager();
+    ~SessionManager();
+    
+    void Initialize();
+    void Start();
+    void Stop();
+    sptr<IDeferredPhotoProcessingSession> CreateDeferredPhotoProcessingSession(
+        const int32_t userId, const sptr<IDeferredPhotoProcessingSessionCallback> callback,
+        std::shared_ptr<DeferredPhotoProcessor> processor, TaskManager* taskManager);
+    std::shared_ptr<IImageProcessCallbacks> GetImageProcCallbacks();
     sptr<IDeferredPhotoProcessingSessionCallback> GetCallback(const int32_t userId);
-    sptr<IDeferredPhotoProcessingSession> GetDeferredPhotoProcessingSession();
-    void OnCallbackDied(const int32_t userId);
-
-private:
-    std::mutex mutex_;
-    std::atomic<bool> initialized_;
-    std::unordered_map<int32_t, sptr<SessionInfo>> photoSessionInfos_;
-    std::unique_ptr<SessionCoordinator> coordinator_;
-};
-} // namespace DeferredProcessing
-} // namespace CameraStandard
-} // namespace OHOS
+    sptr<IDeferredPhotoProcessingSession> GetDeferredPhotoProcessingSession();
+    sptr<IDeferredVideoProcessingSession> CreateDeferredVideoProcessingSession(const int32_t userId,
+        const sptr<IDeferredVideoProcessingSessionCallback> callback);
+    std::shared_ptr<SessionCoordinator> GetSessionCoordinator();
+    sptr<VideoSessionInfo> GetSessionInfo(const int32_t userId);
+    void OnCallbackDied(const int32_t userId);
+
+private:
+    std::mutex mutex_;
+    std::atomic<bool> initialized_;
+    std::unordered_map<int32_t, sptr<SessionInfo>> photoSessionInfos_;
+    SafeMap<int32_t, sptr<VideoSessionInfo>> videoSessionInfos_;
+    std::shared_ptr<SessionCoordinator> coordinator_;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
 #endif // OHOS_CAMERA_DPS_SESSION_MANAGER_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/session/video_session/deferred_video_processing_session.h b/services/deferred_processing_service/include/session/video_session/deferred_video_processing_session.h
new file mode 100644
index 000000000..df4ef33f6
--- /dev/null
+++ b/services/deferred_processing_service/include/session/video_session/deferred_video_processing_session.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_DEFERRED_VIDEO_PROCESSING_SESSION_H
+#define OHOS_CAMERA_DPS_DEFERRED_VIDEO_PROCESSING_SESSION_H
+
+#include "deferred_video_processing_session_stub.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class DeferredVideoProcessingSession : public DeferredVideoProcessingSessionStub {
+public:
+    class VideoInfo {
+    public:
+        VideoInfo(const sptr<IPCFileDescriptor>& srcFd, const sptr<IPCFileDescriptor>& dstFd)
+            : srcFd_(srcFd), dstFd_(dstFd)
+        {}
+
+        ~VideoInfo()
+        {
+            srcFd_ = nullptr;
+            dstFd_ = nullptr;
+        }
+
+        sptr<IPCFileDescriptor> srcFd_;
+        sptr<IPCFileDescriptor> dstFd_;
+    };
+
+    DeferredVideoProcessingSession(const int32_t userId);
+    ~DeferredVideoProcessingSession();
+    
+    int32_t BeginSynchronize() override;
+    int32_t EndSynchronize() override;
+    int32_t AddVideo(const std::string& videoId, const sptr<IPCFileDescriptor>& srcFd,
+        const sptr<IPCFileDescriptor>& dstFd) override;
+    int32_t RemoveVideo(const std::string& videoId, bool restorable) override;
+    int32_t RestoreVideo(const std::string& videoId) override;
+
+private:
+    std::mutex mutex_;
+    const int32_t userId_;
+    std::atomic<bool> inSync_ {false};
+    std::unordered_map<std::string, std::shared_ptr<VideoInfo>> videoIds_ {};
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_DEFERRED_VIDEO_PROCESSING_SESSION_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/session/video_session/video_session_info.h b/services/deferred_processing_service/include/session/video_session/video_session_info.h
new file mode 100644
index 000000000..8ff25581a
--- /dev/null
+++ b/services/deferred_processing_service/include/session/video_session/video_session_info.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_VIDEO_SESSION_INFO_H
+#define OHOS_CAMERA_DPS_VIDEO_SESSION_INFO_H
+
+#include "ideferred_video_processing_session_callback.h"
+#include "ideferred_video_processing_session.h"
+#include "ivideo_process_callbacks.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class VideoSessionInfo : public RefBase {
+public:
+    VideoSessionInfo(const int32_t userId, const sptr<IDeferredVideoProcessingSessionCallback>& callback);
+    virtual ~VideoSessionInfo();
+
+    int32_t Initialize();
+    sptr<IDeferredVideoProcessingSession> GetDeferredVideoProcessingSession();
+    sptr<IDeferredVideoProcessingSessionCallback> GetRemoteCallback();
+    int32_t GetUserId() const;
+    void OnCallbackDied();
+    void SetCallback(const sptr<IDeferredVideoProcessingSessionCallback>& callback);
+
+private:
+    class CallbackDeathRecipient;
+
+    const int32_t userId_;
+    sptr<IDeferredVideoProcessingSession> session_ {nullptr};
+    sptr<IDeferredVideoProcessingSessionCallback> callback_;
+    sptr<CallbackDeathRecipient> deathRecipient_;
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_VIDEO_SESSION_INFO_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/utils/dp_catch.h b/services/deferred_processing_service/include/utils/dp_catch.h
new file mode 100644
index 000000000..2071789f3
--- /dev/null
+++ b/services/deferred_processing_service/include/utils/dp_catch.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_CATCH_H
+#define OHOS_CAMERA_DPS_CATCH_H
+
+#define ERROR_CODE() __catch_error_code
+#define ERROR_LINE() __catch_error_line
+#define ERROR_PROSS() __catch_error_line = __LINE__
+
+#define PROSS                                       \
+    uint32_t __catch_error_code = 0x7FFFFFCC;       \
+    uint32_t __catch_error_line = 0xFFFFFFFF;       \
+    {
+#define END_PROSS                                   \
+    }                                               \
+    __tabErrorCode:
+
+#define THROW(err)                                  \
+    do {                                            \
+        __catch_error_code = (err);                 \
+        ERROR_PROSS();                              \
+        goto __tabErrorCode;                        \
+    } while (0)
+
+#define EXEC(func)                                  \
+    {                                               \
+        if (DP_OK != (__catch_error_code = (func))) \
+            THROW(__catch_error_code);              \
+    }
+
+#define JUDEG(err, expr)                            \
+    {                                               \
+        if (!(expr)) {                              \
+            THROW(err);                             \
+        }                                           \
+    }
+
+#define CATCH_ERROR                                 \
+    {
+#define END_CATCH_ERROR }
+
+#endif // OHOS_CAMERA_DPS_CATCH_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/utils/dp_log.h b/services/deferred_processing_service/include/utils/dp_log.h
index 1c1df051f..66867dddc 100644
--- a/services/deferred_processing_service/include/utils/dp_log.h
+++ b/services/deferred_processing_service/include/utils/dp_log.h
@@ -46,24 +46,27 @@
 #define CAMERA_DP_SYNC_TRACE HITRACE_METER_NAME(HITRACE_TAG_ZCAMERA, __PRETTY_FUNCTION__)
 
 #define DP_OK 0
-#define DP_ERR (-1)
-#define DP_INVALID_PARAM (-2)
-#define DP_INIT_FAIL (-3)
-#define DP_PERMISSION_DENIED (-4)
-#define DP_MEM_MAP_FAILED (-5)
-#define DP_INSUFFICIENT_RESOURCES (-6)
+#define DP_ERR (1)
+#define DP_INVALID_PARAM (2)
+#define DP_INIT_FAIL (3)
+#define DP_PERMISSION_DENIED (4)
+#define DP_MEM_MAP_FAILED (5)
+#define DP_INSUFFICIENT_RESOURCES (6)
+#define DP_NULL_POINTER (7)
+#define DP_SEND_COMMAND_FAILED (8)
+#define DP_NOT_AVAILABLE (9)
 
-#define DP_CHECK_AND_RETURN_RET_LOG(cond, ret, fmt, ...)    \
+#define DP_CHECK_ERROR_RETURN_RET_LOG(cond, ret, fmt, ...)  \
     do {                                                    \
-        if (!(cond)) {                                      \
+        if (cond) {                                         \
             DP_ERR_LOG(fmt, ##__VA_ARGS__);                 \
             return ret;                                     \
         }                                                   \
     } while (0)
 
-#define DP_CHECK_AND_RETURN_LOG(cond, fmt, ...)             \
+#define DP_CHECK_ERROR_RETURN_LOG(cond, fmt, ...)           \
     do {                                                    \
-        if (!(cond)) {                                      \
+        if (cond) {                                         \
             DP_ERR_LOG(fmt, ##__VA_ARGS__);                 \
             return;                                         \
         }                                                   \
@@ -71,22 +74,69 @@
 
 #define DP_CHECK_ERROR_PRINT_LOG(cond, fmt, ...)            \
     do {                                                    \
-        if (cond) {                                      \
+        if (cond) {                                         \
             DP_ERR_LOG(fmt, ##__VA_ARGS__);                 \
         }                                                   \
     } while (0)
 
-#define DP_CHECK_AND_RETURN_RET(cond, ret)                  \
+#define DP_CHECK_ERROR_BREAK_LOG(cond, fmt, ...)            \
     do {                                                    \
-        if (!(cond)) {                                      \
+        if (cond) {                                         \
+            DP_ERR_LOG(fmt, ##__VA_ARGS__);                 \
+            break;                                          \
+        }                                                   \
+    } while (0)
+
+#define DP_CHECK_RETURN_RET(cond, ret)                      \
+    do {                                                    \
+        if (cond) {                                         \
             return ret;                                     \
         }                                                   \
     } while (0)
 
-#define DP_CHECK_ERROR_RETURN_RET(cond, ret)                \
+#define DP_CHECK_EXECUTE(cond, cmd)                         \
     do {                                                    \
-        if (cond) {                                      \
+        if (cond) {                                         \
+            cmd;                                            \
+        }                                                   \
+    } while (0)
+
+#define DP_CHECK_RETURN(cond)                               \
+    do {                                                    \
+        if (cond) {                                         \
+            return;                                         \
+        }                                                   \
+    } while (0)
+
+#define DP_CHECK_RETURN_RET_LOG(cond, ret, fmt, ...)        \
+    do {                                                    \
+        if (cond) {                                         \
+            DP_INFO_LOG(fmt, ##__VA_ARGS__);                \
             return ret;                                     \
         }                                                   \
     } while (0)
+
+#define DP_CHECK_RETURN_LOG(cond, fmt, ...)                 \
+    do {                                                    \
+        if (cond) {                                         \
+            DP_INFO_LOG(fmt, ##__VA_ARGS__);                \
+            return;                                         \
+        }                                                   \
+    } while (0)
+
+#define DP_CHECK_BREAK_LOG(cond, fmt, ...)                  \
+    if (1) {                                                \
+        if (cond) {                                         \
+            DP_INFO_LOG(fmt, ##__VA_ARGS__);                \
+            break;                                          \
+        }                                                   \
+    } else void (0)
+
+#define DP_CHECK_CONTINUE_LOG(cond, fmt, ...)               \
+    if (1) {                                                \
+        if (cond) {                                         \
+            DP_INFO_LOG(fmt, ##__VA_ARGS__);                \
+            continue;                                       \
+        }                                                   \
+    } else void (0)
 #endif // OHOS_CAMERA_DPS_LOG_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/utils/dp_power_manager.h b/services/deferred_processing_service/include/utils/dp_power_manager.h
new file mode 100644
index 000000000..1de320e34
--- /dev/null
+++ b/services/deferred_processing_service/include/utils/dp_power_manager.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_POWER_MANAGER_H
+#define OHOS_CAMERA_DPS_POWER_MANAGER_H
+
+#include "singleton.h"
+#ifdef CAMERA_USE_POWER
+#include "power_mgr_client.h"
+#include "running_lock.h"
+#endif
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class DPSProwerManager : public Singleton<DPSProwerManager> {
+    DECLARE_SINGLETON(DPSProwerManager)
+
+public:
+    void Initialize();
+    void SetAutoSuspend(bool isAutoSuspend, uint32_t time = 0);
+
+private:
+    void EnableAutoSuspend();
+    void DisableAutoSuspend(uint32_t time);
+
+    std::mutex mutex_;
+    std::atomic<bool> initialized_ {false};
+    bool isSuspend_ {false};
+    std::shared_ptr<PowerMgr::RunningLock> wakeLock_ {nullptr};
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_DPS_POWER_MANAGER_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/utils/dp_timer.h b/services/deferred_processing_service/include/utils/dp_timer.h
new file mode 100644
index 000000000..0cce1911f
--- /dev/null
+++ b/services/deferred_processing_service/include/utils/dp_timer.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_TIMER_H
+#define OHOS_CAMERA_DPS_TIMER_H
+
+#include "commonlibrary/c_utils/base/include/timer.h"
+#include "singleton.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+constexpr uint32_t INVALID_TIMEID = 0;
+
+class DpsTimer : public Singleton<DpsTimer> {
+    DECLARE_SINGLETON(DpsTimer)
+
+public:
+    using TimerCallback = std::function<void()>;
+
+    uint32_t StartTimer(const TimerCallback& callback, uint32_t interval);
+    void StopTimer(uint32_t& timerId);
+
+private:
+    std::unique_ptr<Utils::Timer> timer_ {nullptr};
+};
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
+#endif  // OHOS_CAMERA_DPS_TIMER_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/include/utils/dp_utils.h b/services/deferred_processing_service/include/utils/dp_utils.h
index 201961a9c..de167bde0 100644
--- a/services/deferred_processing_service/include/utils/dp_utils.h
+++ b/services/deferred_processing_service/include/utils/dp_utils.h
@@ -1,68 +1,125 @@
-/*
- * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef OHOS_CAMERA_DPS_UTILS_H
-#define OHOS_CAMERA_DPS_UTILS_H
-
-#include <memory>
-#include "watch_dog.h"
-
-namespace OHOS {
-namespace CameraStandard {
-namespace DeferredProcessing {
-template <typename U>
-constexpr U AlignUp(U num, U alignment)
-{
-    return alignment ? ((num + alignment - 1) & (~(alignment - 1))) : num;
-}
-
-template <typename T, typename... Args>
-struct MakeSharedHelper : public T {
-    explicit MakeSharedHelper(Args&&... args) : T(std::forward<Args>(args)...)
-    {
-    }
-};
-
-template <typename T, typename... Args>
-std::shared_ptr<T> CreateShared(Args&&... args)
-{
-    return std::move(std::make_shared<MakeSharedHelper<T, Args &&...>>(std::forward<Args>(args)...));
-}
-
-template <typename T, typename... Args>
-struct MakeUniqueHelper : public T {
-    explicit MakeUniqueHelper(Args&&... args) : T(std::forward<Args>(args)...)
-    {
-    }
-};
-
-template <typename T, typename... Args>
-std::unique_ptr<T> CreateUnique(Args&&... args)
-{
-    return std::move(std::make_unique<MakeUniqueHelper<T, Args &&...>>(std::forward<Args>(args)...));
-}
-
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_DPS_UTILS_H
+#define OHOS_CAMERA_DPS_UTILS_H
+
+#include <unistd.h>
+
+#include "watch_dog.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+using SteadyTimePoint = std::chrono::steady_clock::time_point;
+using Nano = std::chrono::nanoseconds;
+using Micro = std::chrono::microseconds;
+using Milli = std::chrono::milliseconds;
+using Seconds = std::chrono::seconds;
+
+inline SteadyTimePoint GetSteadyNow()
+{
+    return SteadyTimePoint::clock::now();
+}
+
+template <typename Duration, typename TimePoint>
+inline auto GetDiffTime(TimePoint begin, TimePoint end)
+{
+    if (begin > end) {
+        return static_cast<typename Duration::rep>(0);
+    }
+    return std::chrono::duration_cast<Duration>(end - begin).count();
+}
+
+template <typename Duration, typename TimePoint>
+inline auto GetDiffTime(TimePoint begin)
+{
+    return GetDiffTime<Duration>(begin, TimePoint::clock::now());
+}
+
+inline bool IsFileEmpty(int fd)
+{
+    off_t fileSize = lseek(fd, 0, SEEK_END);
+    if (fileSize == (off_t)-1) {
+        return false;
+    }
+    return fileSize == 0;
+}
+
+inline bool ClearFileContent(int fd)
+{
+    if (ftruncate(fd, 0) != 0) {
+        return false;
+    }
+    if (lseek(fd, 0, SEEK_SET) == (off_t)-1) {
+        return false;
+    }
+    return true;
+}
+
+template <typename U>
+constexpr U AlignUp(U num, U alignment)
+{
+    return alignment ? ((num + alignment - 1) & (~(alignment - 1))) : num;
+}
+
+template <typename T, typename... Args>
+struct MakeSharedHelper : public T {
+    explicit MakeSharedHelper(Args&&... args) : T(std::forward<Args>(args)...)
+    {
+    }
+};
+
+template <typename T, typename... Args>
+std::shared_ptr<T> CreateShared(Args&&... args)
+{
+    return std::move(std::make_shared<MakeSharedHelper<T, Args &&...>>(std::forward<Args>(args)...));
+}
+
+template <typename T, typename... Args>
+struct MakeUniqueHelper : public T {
+    explicit MakeUniqueHelper(Args&&... args) : T(std::forward<Args>(args)...)
+    {
+    }
+};
+
+template <typename T, typename... Args>
+std::unique_ptr<T> CreateUnique(Args&&... args)
+{
+    return std::move(std::make_unique<MakeUniqueHelper<T, Args &&...>>(std::forward<Args>(args)...));
+}
+
 inline int32_t GetVersionId(uint32_t major, uint32_t minor)
 {
     const uint32_t offset = 8;
     return static_cast<int32_t>((major << offset) | minor);
 }
 
-Watchdog& GetGlobalWatchdog();
+Watchdog& GetGlobalWatchdog();
 float TransExifOrientationToDegree(const std::string& orientation);
-} // namespace DeferredProcessing
-} // namespace CameraStandard
-} // namespace OHOS
+
+struct DpsCallerInfo {
+    int32_t pid;
+    int32_t uid;
+    uint32_t tokenID;
+    std::string bundleName;
+    std::string version;
+};
+
+DpsCallerInfo GetDpsCallerInfo();
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
 #endif // OHOS_CAMERA_DPS_UTILS_H
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/base/basic_definitions.cpp b/services/deferred_processing_service/src/base/basic_definitions.cpp
new file mode 100644
index 000000000..6ae46a138
--- /dev/null
+++ b/services/deferred_processing_service/src/base/basic_definitions.cpp
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "basic_definitions.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+
+SystemPressureLevel MapEventThermalLevel(int32_t level)
+{
+    if (level < LEVEL_0 || level > LEVEL_5) {
+        return SystemPressureLevel::SEVERE;
+    }
+    SystemPressureLevel eventLevel;
+    switch (level) {
+        case LEVEL_0:
+        case LEVEL_1:
+            eventLevel = SystemPressureLevel::NOMINAL;
+            break;
+        case LEVEL_2:
+        case LEVEL_3:
+        case LEVEL_4:
+            eventLevel = SystemPressureLevel::FAIR;
+            break;
+        default:
+            eventLevel = SystemPressureLevel::SEVERE;
+            break;
+    }
+    return eventLevel;
+}
+
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
diff --git a/services/deferred_processing_service/src/base/buffer_info.cpp b/services/deferred_processing_service/src/base/buffer_info.cpp
index a18a47e46..642b131ef 100644
--- a/services/deferred_processing_service/src/base/buffer_info.cpp
+++ b/services/deferred_processing_service/src/base/buffer_info.cpp
@@ -14,10 +14,11 @@
  */
 
 #include "buffer_info.h"
-#include "dp_log.h"
 
 #include <unistd.h>
 
+#include "dp_log.h"
+
 namespace OHOS {
 namespace CameraStandard {
 namespace DeferredProcessing {
@@ -44,16 +45,6 @@ sptr<IPCFileDescriptor> BufferInfo::GetIPCFileDescriptor()
     return sptr<IPCFileDescriptor>::MakeSptr(fd);
 }
 
-int32_t BufferInfo::GetDataSize()
-{
-    return dataSize_;
-}
-
-bool BufferInfo::IsHighQuality()
-{
-    return isHighQuality_;
-}
-
 BufferInfoExt::BufferInfoExt(std::shared_ptr<Media::Picture> picture, long dataSize, bool isHighQuality,
     bool isCloudImageEnhanceSupported)
     : picture_(picture),
@@ -88,12 +79,6 @@ bool BufferInfoExt::IsCloudImageEnhanceSupported()
 {
     return isCloudImageEnhanceSupported_;
 }
-
-bool BufferInfo::IsCloudImageEnhanceSupported()
-{
-    return isCloudImageEnhanceSupported_;
-}
-
-} //namespace DeferredProcessing
+} // namespace DeferredProcessing
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/services/deferred_processing_service/src/base/buffer_manager/shared_buffer.cpp b/services/deferred_processing_service/src/base/buffer_manager/shared_buffer.cpp
index f5ad433f2..884041c51 100644
--- a/services/deferred_processing_service/src/base/buffer_manager/shared_buffer.cpp
+++ b/services/deferred_processing_service/src/base/buffer_manager/shared_buffer.cpp
@@ -50,14 +50,14 @@ int64_t SharedBuffer::GetSize()
 
 int32_t SharedBuffer::CopyFrom(uint8_t* address, int64_t bytes)
 {
-    DP_CHECK_AND_RETURN_RET_LOG(bytes <= capacity_, DP_INVALID_PARAM,
+    DP_CHECK_ERROR_RETURN_RET_LOG(bytes > capacity_, DP_INVALID_PARAM,
         "buffer failed due to invalid size: %{public}ld, capacity: %{public}ld",
         static_cast<long>(bytes), static_cast<long>(capacity_));
-    DP_CHECK_AND_RETURN_RET_LOG(ashmem_ != nullptr, DP_INIT_FAIL, "ashmem is nullptr.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(ashmem_ == nullptr, DP_INIT_FAIL, "ashmem is nullptr.");
     DP_DEBUG_LOG("capacity: %{public}ld, bytes: %{public}ld",
         static_cast<long>(capacity_), static_cast<long>(bytes));
     auto ret = ashmem_->WriteToAshmem(address, bytes, 0);
-    DP_CHECK_AND_RETURN_RET_LOG(ret, DP_ERR, "copy failed.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(!ret, DP_ERR, "copy failed.");
     return DP_OK;
 }
 
@@ -72,12 +72,12 @@ int32_t SharedBuffer::AllocateAshmemUnlocked()
 {
     std::string_view name = "DPS ShareMemory";
     ashmem_ = Ashmem::CreateAshmem(name.data(), capacity_);
-    DP_CHECK_AND_RETURN_RET_LOG(ashmem_ != nullptr, DP_INIT_FAIL,
+    DP_CHECK_ERROR_RETURN_RET_LOG(ashmem_ == nullptr, DP_INIT_FAIL,
         "buffer create ashmem failed. capacity: %{public}ld", static_cast<long>(capacity_));
     int fd = ashmem_->GetAshmemFd();
     DP_DEBUG_LOG("size: %{public}ld, fd: %{public}d", static_cast<long>(capacity_), fd);
     auto ret = ashmem_->MapReadAndWriteAshmem();
-    DP_CHECK_AND_RETURN_RET_LOG(ret, DP_MEM_MAP_FAILED, "mmap failed.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(!ret, DP_MEM_MAP_FAILED, "mmap failed.");
     return DP_OK;
 }
 
diff --git a/services/deferred_processing_service/src/base/command_server/command.cpp b/services/deferred_processing_service/src/base/command_server/command.cpp
new file mode 100644
index 000000000..ccce3f72d
--- /dev/null
+++ b/services/deferred_processing_service/src/base/command_server/command.cpp
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "command.h"
+
+#include "dp_log.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+Command::Command()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+Command::~Command()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+int32_t Command::Do()
+{
+    auto name = GetCommandName();
+    DP_INFO_LOG("call CommandName: %{public}s", name);
+    auto timeStart = std::chrono::steady_clock::now();
+    auto ret = Executing();
+    auto timeEnd = std::chrono::steady_clock::now();
+    auto commandTimeCost = std::chrono::duration_cast<std::chrono::microseconds>(timeEnd - timeStart).count();
+    DP_DEBUG_LOG("CommandName: %{public}s Executing time (%{public}lld µs)", name, commandTimeCost);
+    return ret;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/base/command_server/command_server.cpp b/services/deferred_processing_service/src/base/command_server/command_server.cpp
new file mode 100644
index 000000000..27166b973
--- /dev/null
+++ b/services/deferred_processing_service/src/base/command_server/command_server.cpp
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "command_server.h"
+
+#include "dp_log.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+CommandServer::CommandServer() : server_(nullptr)
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+CommandServer::~CommandServer()
+{
+    DP_DEBUG_LOG("entered.");
+    server_ = nullptr;
+}
+
+int32_t CommandServer::Initialize(const std::string& cmdServerName)
+{
+    if (server_ == nullptr) {
+        server_ = std::make_shared<CommandServerImpl>(cmdServerName);
+    }
+    return DP_OK;
+}
+
+int32_t CommandServer::SendCommand(const CmdSharedPtr& cmd)
+{
+    DP_CHECK_RETURN_RET(server_ != nullptr, server_->AddCommand(cmd));
+    return DP_INIT_FAIL;
+}
+
+int32_t CommandServer::SendUrgentCommand(const CmdSharedPtr& cmd)
+{
+    DP_CHECK_RETURN_RET(server_ != nullptr, server_->AddUrgentCommand(cmd));
+    return DP_INIT_FAIL;
+}
+
+void CommandServer::SetThreadPriority(int priority)
+{
+    DP_CHECK_EXECUTE(server_ != nullptr, server_->SetThreadPriority(priority));
+}
+
+int32_t CommandServer::GetThreadPriority() const
+{
+    DP_CHECK_RETURN_RET(server_ != nullptr, server_->GetThreadPriority());
+    return DP_INIT_FAIL;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/base/command_server/command_server_impl.cpp b/services/deferred_processing_service/src/base/command_server/command_server_impl.cpp
new file mode 100644
index 000000000..da347aa25
--- /dev/null
+++ b/services/deferred_processing_service/src/base/command_server/command_server_impl.cpp
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "command_server_impl.h"
+
+#include "dp_log.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+const int MAX_THREAD_NUM = 1;
+
+CommandServerImpl::CommandServerImpl(const std::string& cmdServerName)
+    : commandServerName_(cmdServerName)
+{
+    DP_DEBUG_LOG("entered.");
+    threadPool_ = ThreadPool::Create(commandServerName_, MAX_THREAD_NUM);
+}
+
+CommandServerImpl::~CommandServerImpl()
+{
+    DP_DEBUG_LOG("entered.");
+    threadPool_.reset();
+}
+
+int32_t CommandServerImpl::AddCommand(const CmdSharedPtr& cmd)
+{
+    if (threadPool_->Submit([cmd]() {cmd->Do();})) {
+        return DP_OK;
+    }
+    DP_ERR_LOG("dps command server not start.");
+    return DP_NOT_AVAILABLE;
+}
+
+int32_t CommandServerImpl::AddUrgentCommand(const CmdSharedPtr& cmd)
+{
+    if (threadPool_->Submit([cmd]() {cmd->Do();}, true)) {
+        return DP_OK;
+    }
+    DP_ERR_LOG("dps command server not start.");
+    return DP_NOT_AVAILABLE;
+}
+
+void CommandServerImpl::SetThreadPriority(int32_t priority)
+{
+    threadPool_->SetThreadPoolPriority(priority);
+}
+
+int32_t CommandServerImpl::GetThreadPriority() const
+{
+    return threadPool_->GetThreadPoolPriority();
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/base/dps.cpp b/services/deferred_processing_service/src/base/dps.cpp
new file mode 100644
index 000000000..6755888f8
--- /dev/null
+++ b/services/deferred_processing_service/src/base/dps.cpp
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "dps.h"
+
+#include "dp_catch.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+struct DpsInfo {
+    std::atomic<bool> initialized_{false};
+    std::mutex mutex{};
+    std::shared_ptr<CommandServer> server;
+    std::shared_ptr<SessionManager> session;
+    std::shared_ptr<SchedulerManager> scheduler;
+};
+
+DpsInfo g_dpsInfo;
+
+int32_t DPS_Initialize()
+{
+PROSS
+    std::unique_lock<std::mutex> lock(g_dpsInfo.mutex);
+    if (g_dpsInfo.initialized_) {
+        DP_DEBUG_LOG("Already initialized.");
+        return DP_OK;
+    }
+    DP_DEBUG_LOG("entered.");
+    g_dpsInfo.server = std::make_shared<CommandServer>();
+    g_dpsInfo.session = SessionManager::Create();
+    g_dpsInfo.scheduler = std::make_shared<SchedulerManager>();
+    JUDEG(DP_NULL_POINTER, g_dpsInfo.server != nullptr);
+    JUDEG(DP_NULL_POINTER, g_dpsInfo.session != nullptr);
+    JUDEG(DP_NULL_POINTER, g_dpsInfo.scheduler != nullptr);
+    EXEC(g_dpsInfo.server->Initialize());
+    EXEC(g_dpsInfo.scheduler->Initialize());
+    g_dpsInfo.initialized_ = true;
+    DP_INFO_LOG("DPS_Initialize success.");
+    return DP_OK;
+END_PROSS
+CATCH_ERROR
+    DPS_Destory();
+    DP_ERR_LOG("DPS_Initialize failed, line: %{public}u, error: %{public}u.", ERROR_LINE(), ERROR_CODE());
+    return ERROR_CODE();
+END_CATCH_ERROR
+}
+
+void DPS_Destory()
+{
+    std::unique_lock<std::mutex> lock(g_dpsInfo.mutex);
+    DP_DEBUG_LOG("entered.");
+    if (!g_dpsInfo.initialized_) {
+        return;
+    }
+    g_dpsInfo.server.reset();
+    g_dpsInfo.initialized_ = false;
+    DP_INFO_LOG("DPS_Destory success.");
+    return;
+}
+
+std::shared_ptr<CommandServer> DPS_GetCommandServer()
+{
+    std::unique_lock<std::mutex> lock(g_dpsInfo.mutex);
+    if (g_dpsInfo.server) {
+        return g_dpsInfo.server;
+    }
+    return nullptr;
+}
+
+std::shared_ptr<SessionManager> DPS_GetSessionManager()
+{
+    std::unique_lock<std::mutex> lock(g_dpsInfo.mutex);
+    if (g_dpsInfo.session) {
+        return g_dpsInfo.session;
+    }
+    return nullptr;
+}
+
+std::shared_ptr<SchedulerManager> DPS_GetSchedulerManager()
+{
+    std::unique_lock<std::mutex> lock(g_dpsInfo.mutex);
+    if (g_dpsInfo.scheduler) {
+        return g_dpsInfo.scheduler;
+    }
+    return nullptr;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/base/task_manager/thread_pool.cpp b/services/deferred_processing_service/src/base/task_manager/thread_pool.cpp
index 87696fbac..c6437f156 100644
--- a/services/deferred_processing_service/src/base/task_manager/thread_pool.cpp
+++ b/services/deferred_processing_service/src/base/task_manager/thread_pool.cpp
@@ -1,153 +1,170 @@
-/*
- * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "thread_pool.h"
-#include <sys/time.h>
-#include <algorithm>
-#include "thread_utils.h"
-#include "dp_log.h"
-
-namespace OHOS {
-namespace CameraStandard {
-namespace DeferredProcessing {
-std::unique_ptr<ThreadPool> ThreadPool::Create(const std::string& name, uint32_t numThreads)
-{
-    auto pool = std::make_unique<ThreadPool>(name, numThreads);
-    if (pool) {
-        pool->Initialize();
-    }
-    return pool;
-}
-
-ThreadPool::ThreadPool(const std::string& name, uint32_t numThreads)
-    : name_(name), numThreads_(numThreads), workers_(), isStopped_(false), mutex_(), taskCv_(), tasks_()
-{
-    if (numThreads_ == 0) {
-        numThreads_ = 1;
-    }
-    numThreads_ = std::min(numThreads_, static_cast<uint32_t>(std::thread::hardware_concurrency()));
-    DP_DEBUG_LOG("name: %s, numThreads, orig: %u, new: %u.", name.c_str(), numThreads, numThreads_);
-}
-
-ThreadPool::~ThreadPool()
-{
-    CAMERA_DP_SYNC_TRACE;
-    DP_DEBUG_LOG("name: %s.", name_.c_str());
-    isStopped_ = true;
-    taskCv_.notify_all();
-    for (auto& threadInfo : workers_) {
-        if (threadInfo.thread.joinable()) {
-            DP_DEBUG_LOG("joining thread (%s).", threadInfo.name.c_str());
-            threadInfo.thread.join();
-        }
-    }
-}
-
-void ThreadPool::Initialize()
-{
-    DP_DEBUG_LOG("entered.");
-    workers_.reserve(numThreads_);
-    std::string threadNamePrefix = "DPS_Worker_";
-    for (uint32_t i = 0; i < numThreads_; ++i) {
-        auto threadName = threadNamePrefix + std::to_string(i);
-        workers_.emplace_back(threadName, [this, threadName]() { WorkerLoop(threadName); });
-        SetThreadName(workers_.back().thread.native_handle(), workers_.back().name);
-    }
-    PrintThreadInfo();
-}
-
-void ThreadPool::WorkerLoop(const std::string& threadName)
-{
-    DP_DEBUG_LOG("(%s) entered.", threadName.c_str());
-    while (!isStopped_.load()) {
-        DP_DEBUG_LOG("(%s) task excute start entered.", threadName.c_str());
-        auto task = GetTask();
-        if (task) {
-            DP_DEBUG_LOG("(%s) task excuting entered.", threadName.c_str());
-            task();
-        } else {
-            DP_DEBUG_LOG("empty task.");
-        }
-    }
-    DP_DEBUG_LOG("(%s) exited.", threadName.c_str());
-}
-
-void ThreadPool::BeginBackgroundTasks() const
-{
-    DP_DEBUG_LOG("entered.");
-    for (auto& workerInfo : workers_) {
-        SetThreadPriority(workerInfo.thread.native_handle(), PRIORITY_BACKGROUND);
-    }
-}
-
-void ThreadPool::EndBackgroundTasks() const
-{
-    DP_DEBUG_LOG("entered.");
-    for (auto& workerInfo : workers_) {
-        SetThreadPriority(workerInfo.thread.native_handle(), PRIORITY_NORMAL);
-    }
-}
-
-void ThreadPool::PrintThreadInfo()
-{
-    struct sched_param sch;
-    int policy = -1;
-    for (auto& workerInfo : workers_) {
-        int ret = pthread_getschedparam(workerInfo.thread.native_handle(), &policy, &sch);
-        if (ret == 0) {
-            DP_DEBUG_LOG("thread (%s) priority: %{public}d, policy = %{public}d(0:OTHER, 1:FIFO, 2:RR)",
-                workerInfo.name.c_str(), sch.sched_priority, policy);
-        } else {
-            DP_DEBUG_LOG("thread (%s) pthread_getschedparam failed, ret = %{public}d.", workerInfo.name.c_str(), ret);
-        }
-    }
-}
-
-ThreadPool::Task ThreadPool::GetTask() const
-{
-    std::unique_lock<std::mutex> lock(mutex_);
-    taskCv_.wait(lock, [this] { return isStopped_.load() || !tasks_.empty(); });
-    if (isStopped_.load()) {
-        return {};
-    }
-    auto task = std::move(tasks_.front());
-    tasks_.pop();
-    return task;
-}
-
-bool ThreadPool::HasPendingTasks() const
-{
-    std::unique_lock<std::mutex> lock(mutex_);
-    return !tasks_.empty();
-}
-
-bool ThreadPool::Submit(Task func) const
-{
-    DP_DEBUG_LOG("entered.");
-    if (!isStopped_.load()) {
-        {
-            std::unique_lock<std::mutex> lock(mutex_);
-            tasks_.emplace([task = std::move(func)] { task(); });
-        }
-        taskCv_.notify_one();
-    } else {
-        DP_ERR_LOG("failed due to thread pool has been stopped.");
-        return false;
-    }
-    return true;
-}
-} //namespace DeferredProcessing
-} // namespace CameraStandard
-} // namespace OHOS
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "thread_pool.h"
+#include <sys/time.h>
+#include <algorithm>
+#include "thread_utils.h"
+#include "dp_log.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+std::unique_ptr<ThreadPool> ThreadPool::Create(const std::string& name, uint32_t numThreads)
+{
+    auto pool = std::make_unique<ThreadPool>(name, numThreads);
+    if (pool) {
+        pool->Initialize();
+    }
+    return pool;
+}
+
+ThreadPool::ThreadPool(const std::string& name, uint32_t numThreads)
+    : name_(name), numThreads_(numThreads), workers_(), isStopped_(false), mutex_(), taskCv_(), tasks_()
+{
+    if (numThreads_ == 0) {
+        numThreads_ = 1;
+    }
+    numThreads_ = std::min(numThreads_, static_cast<uint32_t>(std::thread::hardware_concurrency()));
+    DP_DEBUG_LOG("name: %s, numThreads, orig: %u, new: %u.", name.c_str(), numThreads, numThreads_);
+}
+
+ThreadPool::~ThreadPool()
+{
+    CAMERA_DP_SYNC_TRACE;
+    DP_DEBUG_LOG("name: %s.", name_.c_str());
+    isStopped_ = true;
+    taskCv_.notify_all();
+    for (auto& threadInfo : workers_) {
+        if (threadInfo.thread.joinable()) {
+            DP_DEBUG_LOG("joining thread (%s).", threadInfo.name.c_str());
+            threadInfo.thread.join();
+        }
+    }
+}
+
+void ThreadPool::Initialize()
+{
+    DP_DEBUG_LOG("entered.");
+    workers_.reserve(numThreads_);
+    std::string threadNamePrefix = "DPS_Worker_";
+    for (uint32_t i = 0; i < numThreads_; ++i) {
+        auto threadName = threadNamePrefix + std::to_string(i);
+        workers_.emplace_back(threadName, [this, threadName]() { WorkerLoop(threadName); });
+        SetThreadName(workers_.back().thread.native_handle(), workers_.back().name);
+    }
+    PrintThreadInfo();
+}
+
+void ThreadPool::WorkerLoop(const std::string& threadName)
+{
+    DP_DEBUG_LOG("(%s) entered.", threadName.c_str());
+    while (!isStopped_.load()) {
+        DP_DEBUG_LOG("(%s) task excute start entered.", threadName.c_str());
+        auto task = GetTask();
+        if (task) {
+            DP_DEBUG_LOG("(%s) task excuting entered.", threadName.c_str());
+            task();
+        } else {
+            DP_DEBUG_LOG("empty task.");
+        }
+    }
+    DP_DEBUG_LOG("(%s) exited.", threadName.c_str());
+}
+
+void ThreadPool::BeginBackgroundTasks() const
+{
+    DP_DEBUG_LOG("entered.");
+    for (auto& workerInfo : workers_) {
+        SetThreadPriority(workerInfo.thread.native_handle(), PRIORITY_BACKGROUND);
+    }
+}
+
+void ThreadPool::EndBackgroundTasks() const
+{
+    DP_DEBUG_LOG("entered.");
+    for (auto& workerInfo : workers_) {
+        SetThreadPriority(workerInfo.thread.native_handle(), PRIORITY_NORMAL);
+    }
+}
+
+void ThreadPool::SetThreadPoolPriority(int priority)
+{
+    DP_DEBUG_LOG("entered.");
+    for (auto& workerInfo : workers_) {
+        SetThreadPriority(workerInfo.thread.native_handle(), priority);
+    }
+}
+
+int ThreadPool::GetThreadPoolPriority() const
+{
+    return GetThreadPriority(workers_[0].thread.native_handle());
+}
+
+void ThreadPool::PrintThreadInfo()
+{
+    struct sched_param sch;
+    int policy = -1;
+    for (auto& workerInfo : workers_) {
+        int ret = pthread_getschedparam(workerInfo.thread.native_handle(), &policy, &sch);
+        if (ret == 0) {
+            DP_DEBUG_LOG("thread (%s) priority: %{public}d, policy = %{public}d(0:OTHER, 1:FIFO, 2:RR)",
+                workerInfo.name.c_str(), sch.sched_priority, policy);
+        } else {
+            DP_DEBUG_LOG("thread (%s) pthread_getschedparam failed, ret = %{public}d.", workerInfo.name.c_str(), ret);
+        }
+    }
+}
+
+ThreadPool::Task ThreadPool::GetTask() const
+{
+    std::unique_lock<std::mutex> lock(mutex_);
+    taskCv_.wait(lock, [this] { return isStopped_.load() || !tasks_.empty(); });
+    if (isStopped_.load()) {
+        return {};
+    }
+    auto task = std::move(tasks_.front());
+    tasks_.pop_front();
+    return task;
+}
+
+bool ThreadPool::HasPendingTasks() const
+{
+    std::unique_lock<std::mutex> lock(mutex_);
+    return !tasks_.empty();
+}
+
+bool ThreadPool::Submit(Task func, bool isUrgent) const
+{
+    DP_DEBUG_LOG("entered.");
+    if (!isStopped_.load()) {
+        {
+            std::unique_lock<std::mutex> lock(mutex_);
+            if (isUrgent) {
+                tasks_.emplace_front([task = std::move(func)] { task(); });
+            } else {
+                tasks_.emplace_back([task = std::move(func)] { task(); });
+            }
+        }
+        taskCv_.notify_one();
+    } else {
+        DP_ERR_LOG("failed due to thread pool has been stopped.");
+        return false;
+    }
+    return true;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
diff --git a/services/deferred_processing_service/src/base/task_manager/thread_utils.cpp b/services/deferred_processing_service/src/base/task_manager/thread_utils.cpp
index d07f41f23..520f79024 100644
--- a/services/deferred_processing_service/src/base/task_manager/thread_utils.cpp
+++ b/services/deferred_processing_service/src/base/task_manager/thread_utils.cpp
@@ -1,54 +1,60 @@
-/*
- * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "thread_utils.h"
-#include <sys/resource.h>
-#include "dp_log.h"
-
-namespace OHOS {
-namespace CameraStandard {
-namespace DeferredProcessing {
-extern "C" pid_t __attribute__((weak)) pthread_gettid_np(pthread_t threadId);
-
-void SetThreadName(pthread_t tid, const std::string& name)
-{
-    constexpr int threadNameMaxSize = 15;
-    auto threadName = name.size() > threadNameMaxSize ? name.substr(0, threadNameMaxSize).c_str() : name;
-    if (name.size() > threadNameMaxSize) {
-        DP_DEBUG_LOG("task name %s exceed max size: %{public}d", name.c_str(), threadNameMaxSize);
-    }
-    int ret = pthread_setname_np(tid, threadName.c_str());
-    DP_DEBUG_LOG("threadId: %ld, threadName: %s, pthread_setname_np ret = %{public}d.",
-        static_cast<long>(pthread_gettid_np(tid)), threadName.c_str(), ret);
-}
-
-void SetThreadPriority(pthread_t handle, int priority)
-{
-    pid_t tid = pthread_gettid_np(handle);
-    int currPri = getpriority(PRIO_PROCESS, tid);
-    if (currPri == priority) {
-        return;
-    }
-    int ret = setpriority(PRIO_PROCESS, tid, priority);
-    if (ret == 0) {
-        DP_DEBUG_LOG("succeed for tid (%ld) with priority (%{public}d).", static_cast<long>(tid), priority);
-    } else {
-        DP_DEBUG_LOG("failed for tid (%ld) with priority (%{public}d), ret = %{public}d.",
-            static_cast<long>(tid), priority, ret);
-    }
-}
-} //namespace DeferredProcessing
-} // namespace CameraStandard
-} // namespace OHOS
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "thread_utils.h"
+#include <sys/resource.h>
+#include "dp_log.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+extern "C" pid_t __attribute__((weak)) pthread_gettid_np(pthread_t threadId);
+
+void SetThreadName(pthread_t tid, const std::string& name)
+{
+    constexpr int threadNameMaxSize = 15;
+    auto threadName = name.size() > threadNameMaxSize ? name.substr(0, threadNameMaxSize).c_str() : name;
+    if (name.size() > threadNameMaxSize) {
+        DP_DEBUG_LOG("task name %s exceed max size: %{public}d", name.c_str(), threadNameMaxSize);
+    }
+    int ret = pthread_setname_np(tid, threadName.c_str());
+    DP_DEBUG_LOG("threadId: %ld, threadName: %s, pthread_setname_np ret = %{public}d.",
+        static_cast<long>(pthread_gettid_np(tid)), threadName.c_str(), ret);
+}
+
+void SetThreadPriority(pthread_t handle, int priority)
+{
+    pid_t tid = pthread_gettid_np(handle);
+    int currPri = getpriority(PRIO_PROCESS, tid);
+    if (currPri == priority) {
+        return;
+    }
+    int ret = setpriority(PRIO_PROCESS, tid, priority);
+    if (ret == 0) {
+        DP_DEBUG_LOG("succeed for tid (%ld) with priority (%{public}d).", static_cast<long>(tid), priority);
+    } else {
+        DP_DEBUG_LOG("failed for tid (%ld) with priority (%{public}d), ret = %{public}d.",
+            static_cast<long>(tid), priority, ret);
+    }
+}
+
+int GetThreadPriority(pthread_t handle)
+{
+    pid_t tid = pthread_gettid_np(handle);
+    return getpriority(PRIO_PROCESS, tid);
+}
+} //namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
diff --git a/services/deferred_processing_service/src/deferred_processing_service.cpp b/services/deferred_processing_service/src/deferred_processing_service.cpp
index fa0f7079b..b17a7a49f 100644
--- a/services/deferred_processing_service/src/deferred_processing_service.cpp
+++ b/services/deferred_processing_service/src/deferred_processing_service.cpp
@@ -15,69 +15,56 @@
 
 #include "deferred_processing_service.h"
 
-#include "dp_log.h"
+#include "events_info.h"
 #include "events_monitor.h"
+#include "dp_log.h"
+#include "dps.h"
 
 namespace OHOS {
 namespace CameraStandard {
 namespace DeferredProcessing {
-DeferredProcessingService& DeferredProcessingService::GetInstance()
-{
-    static DeferredProcessingService dpsService;
-    return dpsService;
-}
-
 DeferredProcessingService::DeferredProcessingService()
-    : initialized_(false),
-      sessionManager_(nullptr),
-      schedulerManager_(nullptr),
-      photoTaskManagerMap_()
 {
-    DP_DEBUG_LOG("enter.");
+    DP_DEBUG_LOG("entered.");
 }
 
 DeferredProcessingService::~DeferredProcessingService()
 {
-    DP_DEBUG_LOG("enter.");
-    if (!initialized_) {
-        return;
-    }
-    initialized_ = false;
-    sessionManager_ = nullptr;
-    schedulerManager_ = nullptr;
+    DP_DEBUG_LOG("entered.");
+    DP_CHECK_RETURN(!initialized_.load());
+
     photoTaskManagerMap_.clear();
+    DPS_Destory();
 }
 
 void DeferredProcessingService::Initialize()
 {
-    if (initialized_) {
-        DP_DEBUG_LOG("already initialized.");
-        return;
-    }
     DP_DEBUG_LOG("entered.");
-    sessionManager_ = SessionManager::Create();
-    schedulerManager_ = std::make_unique<SchedulerManager>();
-    schedulerManager_->Initialize();
+    DP_CHECK_RETURN(initialized_.load());
+
+    DPS_Initialize();
     EventsMonitor::GetInstance().Initialize();
-    initialized_ = true;
+    EventsInfo::GetInstance().Initialize();
+    initialized_.store(true);
 }
 
 void DeferredProcessingService::Start()
 {
-    DP_INFO_LOG("entered.");
+    DP_DEBUG_LOG("entered.");
 }
 
 void DeferredProcessingService::Stop()
 {
-    DP_INFO_LOG("entered.");
+    DP_DEBUG_LOG("entered.");
 }
 
 void DeferredProcessingService::NotifyLowQualityImage(const int32_t userId, const std::string& imageId,
     std::shared_ptr<Media::Picture> picture)
 {
     DP_INFO_LOG("entered.");
-    if (sessionManager_ != nullptr && sessionManager_->GetCallback(userId) != nullptr) {
-        sessionManager_->GetCallback(userId)->OnDeliveryLowQualityImage(imageId, picture);
+    auto sessionManager = DPS_GetSessionManager();
+    if (sessionManager != nullptr && sessionManager->GetCallback(userId) != nullptr) {
+        sessionManager->GetCallback(userId)->OnDeliveryLowQualityImage(imageId, picture);
     } else {
         DP_INFO_LOG("DeferredPhotoProcessingSessionCallback::NotifyLowQualityImage not set!, Discarding callback");
     }
@@ -89,14 +76,30 @@ sptr<IDeferredPhotoProcessingSession> DeferredProcessingService::CreateDeferredP
     DP_INFO_LOG("DeferredProcessingService::CreateDeferredPhotoProcessingSession create session, userId: %{public}d",
         userId);
     TaskManager* taskManager = GetPhotoTaskManager(userId);
-    std::shared_ptr<IImageProcessCallbacks> sessionImageProcCallbacks = sessionManager_->GetImageProcCallbacks();
-    auto processor = schedulerManager_->GetPhotoProcessor(userId, taskManager, sessionImageProcCallbacks);
-    sptr<IDeferredPhotoProcessingSession> session = sessionManager_->CreateDeferredPhotoProcessingSession(userId,
+    auto schedulerManager = DPS_GetSchedulerManager();
+    auto sessionManager = DPS_GetSessionManager();
+    if (schedulerManager == nullptr || sessionManager == nullptr) {
+        DP_ERR_LOG("schedulerManager or sessionManager is nullptr.");
+        return nullptr;
+    }
+    std::shared_ptr<IImageProcessCallbacks> sessionImageProcCallbacks = sessionManager->GetImageProcCallbacks();
+    auto processor = schedulerManager->GetPhotoProcessor(userId, taskManager, sessionImageProcCallbacks);
+    sptr<IDeferredPhotoProcessingSession> session = sessionManager->CreateDeferredPhotoProcessingSession(userId,
         callbacks, processor, taskManager);
     return session;
 }
 
-TaskManager* DeferredProcessingService::GetPhotoTaskManager(int userId)
+sptr<IDeferredVideoProcessingSession> DeferredProcessingService::CreateDeferredVideoProcessingSession(
+    const int32_t userId, const sptr<IDeferredVideoProcessingSessionCallback> callbacks)
+{
+    DP_INFO_LOG("create video session, userId: %{public}d", userId);
+    auto sessionManager = DPS_GetSessionManager();
+    DP_CHECK_ERROR_RETURN_RET_LOG(sessionManager == nullptr, nullptr,
+        "SessionManager is null, userId: %{public}d", userId);
+    return sessionManager->CreateDeferredVideoProcessingSession(userId, callbacks);
+}
+
+TaskManager* DeferredProcessingService::GetPhotoTaskManager(const int32_t userId)
 {
     std::lock_guard<std::mutex> lock(taskManagerMutex_);
     DP_INFO_LOG("entered, userId: %{public}d", userId);
@@ -105,7 +108,6 @@ TaskManager* DeferredProcessingService::GetPhotoTaskManager(int userId)
         std::shared_ptr<TaskManager> taskManager =
             std::make_shared<TaskManager>("PhotoProcTaskManager_userid_" + std::to_string(userId),
             numThreads, true);
-        EventsMonitor::GetInstance().RegisterTaskManager(userId, taskManager.get());
         photoTaskManagerMap_[userId] = taskManager;
     }
     return photoTaskManagerMap_[userId].get();
diff --git a/services/deferred_processing_service/src/dfx/dps_video_report.cpp b/services/deferred_processing_service/src/dfx/dps_video_report.cpp
new file mode 100644
index 000000000..ec4437d61
--- /dev/null
+++ b/services/deferred_processing_service/src/dfx/dps_video_report.cpp
@@ -0,0 +1,170 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2024. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "dps_video_report.h"
+
+#include "dp_log.h"
+#include "hisysevent.h"
+#include "steady_clock.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+static constexpr char CAMERA_FWK_UE[] = "CAMERA_FWK_UE";
+
+DfxVideoReport::DfxVideoReport()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+DfxVideoReport::~DfxVideoReport()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+void DfxVideoReport::ReportAddVideoEvent(const std::string &videoId, DpsCallerInfo callerInfo)
+{
+    DP_DEBUG_LOG("ReportAddVideoEvent enter.");
+    VideoRecord videoRecord{
+        .videoId = videoId,
+        .calleBundle = callerInfo.bundleName,
+        .calleVersion = callerInfo.version,
+        .addTime = SteadyClock::GetTimestampMilli(),
+    };
+    auto iter = processVideoInfo_.find(videoId);
+    if (iter == processVideoInfo_.end()) {
+        processVideoInfo_.emplace(videoId, videoRecord);
+    } else {
+        DP_ERR_LOG("ReportAddVideoEvent video has been added.");
+    }
+
+    HiSysEventWrite(CAMERA_FWK_UE,
+        "DPS_ADD_VIDEO",
+        HiviewDFX::HiSysEvent::EventType::BEHAVIOR,
+        EVENT_KEY_PNAMEID, callerInfo.bundleName,
+        EVENT_KEY_PVERSIONID, callerInfo.pid,
+        EVENT_KEY_VIDEOID, videoId);
+}
+
+void DfxVideoReport::ReportRemoveVideoEvent(const std::string &videoId, DpsCallerInfo callerInfo)
+{
+    DP_DEBUG_LOG("ReportRemoveVideoEvent enter.");
+    auto iter = processVideoInfo_.find(videoId);
+    if (iter != processVideoInfo_.end()) {
+        processVideoInfo_.erase(videoId);
+    }
+
+    HiSysEventWrite(CAMERA_FWK_UE,
+        "DPS_REMOVE_VIDEO",
+        HiviewDFX::HiSysEvent::EventType::BEHAVIOR,
+        EVENT_KEY_PNAMEID, callerInfo.bundleName,
+        EVENT_KEY_PVERSIONID, callerInfo.pid,
+        EVENT_KEY_VIDEOID, videoId);
+}
+
+void DfxVideoReport::ReportPauseVideoEvent(const std::string& videoId, int32_t pauseReason)
+{
+    DP_DEBUG_LOG("ReportPauseVideoEvent enter.");
+    uint64_t processToPauseCost = 0;
+    std::string bundleName;
+    std::string version;
+    auto iter = processVideoInfo_.find(videoId);
+    if (iter != processVideoInfo_.end()) {
+        DP_DEBUG_LOG("ReportPauseVideoEvent videoId found.");
+        VideoRecord vr = iter->second;
+        vr.pauseStartTime = SteadyClock::GetTimestampMilli();
+        processToPauseCost = vr.pauseStartTime - vr.processTime;
+        bundleName = vr.calleBundle;
+        version = vr.calleVersion;
+    } else {
+        DP_DEBUG_LOG("ReportPauseVideoEvent videoId not found.");
+    }
+
+    HiSysEventWrite(CAMERA_FWK_UE,
+        "DPS_PAUSE_VIDEO",
+        HiviewDFX::HiSysEvent::EventType::BEHAVIOR,
+        EVENT_KEY_PNAMEID, bundleName,
+        EVENT_KEY_PVERSIONID, version,
+        EVENT_KEY_VIDEOID, videoId,
+        EVENT_KEY_ABORTTYPE, pauseReason,
+        EVENT_KEY_ABORTTIME, processToPauseCost);
+}
+
+void DfxVideoReport::ReportResumeVideoEvent(const std::string &videoId)
+{
+    DP_DEBUG_LOG("ReportResumeVideoEvent enter.");
+    uint64_t pauseToResumeCost = 0;
+    std::string bundleName;
+    std::string version;
+    auto iter = processVideoInfo_.find(videoId);
+    if (iter != processVideoInfo_.end()) {
+        DP_DEBUG_LOG("ReportResumeVideoEvent videoId found.");
+        VideoRecord vr = iter->second;
+        if (vr.processTime == 0) {
+            // 首次开始分段式任务
+            DP_DEBUG_LOG("ReportResumeVideoEvent first process videoId:%{public}s", videoId.c_str());
+            vr.processTime = SteadyClock::GetTimestampMilli();
+        } else {
+            // 中断后再次开始分段式任务
+            vr.pauseEndTime = SteadyClock::GetTimestampMilli();
+            pauseToResumeCost = vr.pauseEndTime - vr.pauseStartTime;
+            vr.totlePauseTime += pauseToResumeCost;
+            bundleName = vr.calleBundle;
+            version = vr.calleVersion;
+            HiSysEventWrite(
+                CAMERA_FWK_UE,
+                "DPS_RESUME_VIDEO",
+                HiviewDFX::HiSysEvent::EventType::BEHAVIOR,
+                EVENT_KEY_PNAMEID, bundleName,
+                EVENT_KEY_PVERSIONID, version,
+                EVENT_KEY_VIDEOID, videoId,
+                EVENT_KEY_RECOVERTIME, pauseToResumeCost);
+        }
+    } else {
+        DP_DEBUG_LOG("ReportPauseVideoEvent videoId not found.");
+    }
+}
+
+void DfxVideoReport::ReportCompleteVideoEvent(const std::string &videoId)
+{
+    DP_DEBUG_LOG("ReportCompleteVideoEvent enter.");
+    uint64_t completeTime = 0;
+    uint64_t realCompleteTime = 0;
+    std::string bundleName;
+    std::string version;
+    auto iter = processVideoInfo_.find(videoId);
+    if (iter != processVideoInfo_.end()) {
+        DP_DEBUG_LOG("ReportCompleteVideoEvent videoId found.");
+        VideoRecord vr = iter->second;
+        completeTime = SteadyClock::GetTimestampMilli() - vr.processTime;
+        realCompleteTime = completeTime - vr.totlePauseTime;
+        bundleName = vr.calleBundle;
+        version = vr.calleVersion;
+    } else {
+        DP_DEBUG_LOG("ReportCompleteVideoEvent videoId not found.");
+    }
+
+    HiSysEventWrite(CAMERA_FWK_UE,
+        "DPS_COMPLETE_VIDEO",
+        HiviewDFX::HiSysEvent::EventType::BEHAVIOR,
+        EVENT_KEY_PNAMEID, bundleName,
+        EVENT_KEY_PVERSIONID, version,
+        EVENT_KEY_VIDEOID, videoId,
+        EVENT_KEY_COMPLETETIME, completeTime,
+        EVENT_KEY_REALCOMPLETETIME, realCompleteTime);
+}
+}  // namespace DeferredProcessing
+}  // namespace CameraStandard
+}  // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/event_monitor/command/event_status_change_command.cpp b/services/deferred_processing_service/src/event_monitor/command/event_status_change_command.cpp
new file mode 100644
index 000000000..34d35cbcc
--- /dev/null
+++ b/services/deferred_processing_service/src/event_monitor/command/event_status_change_command.cpp
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "event_status_change_command.h"
+
+#include "dp_log.h"
+#include "events_monitor.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+EventStatusChangeCommand::EventStatusChangeCommand(const int32_t userId, const EventType event, const int value)
+    : userId_(userId), eventId_(event), value_(value)
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+EventStatusChangeCommand::~EventStatusChangeCommand()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+int32_t EventStatusChangeCommand::Executing()
+{
+    DP_DEBUG_LOG("event status change, userId: %{public}d, event: %{public}d, value: %{public}d",
+        userId_, eventId_, value_);
+    EventsMonitor::GetInstance().NotifyEventToObervers(userId_, eventId_, value_);
+    return DP_OK;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/event_monitor/events_info.cpp b/services/deferred_processing_service/src/event_monitor/events_info.cpp
new file mode 100644
index 000000000..ff428254e
--- /dev/null
+++ b/services/deferred_processing_service/src/event_monitor/events_info.cpp
@@ -0,0 +1,145 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "events_info.h"
+
+#include "basic_definitions.h"
+#include "dp_log.h"
+#ifdef CAMERA_USE_BATTERY
+#include "battery_srv_client.h"
+#include "battery_info.h"
+#endif
+#ifdef CAMERA_USE_THERMAL
+#include "thermal_mgr_client.h"
+#endif
+#ifdef CAMERA_USE_POWER
+#include "power_mgr_client.h"
+#endif
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+namespace {
+    constexpr int32_t BATTERY_THRESHOLD = 50;
+}
+
+EventsInfo::EventsInfo()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+EventsInfo::~EventsInfo()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+void EventsInfo::Initialize()
+{
+    DP_DEBUG_LOG("Initialize enter.");
+    std::lock_guard<std::mutex> lock(mutex_);
+    DP_CHECK_RETURN(initialized_.load());
+    initialized_ = true;
+}
+
+ScreenStatus EventsInfo::GetScreenState()
+{
+#ifdef CAMERA_USE_POWER
+    auto& power = PowerMgr::PowerMgrClient::GetInstance();
+    if (power.IsScreenOn()) {
+        screenState_ = ScreenStatus::SCREEN_ON;
+    } else {
+        screenState_ = ScreenStatus::SCREEN_OFF;
+    }
+#endif
+    return screenState_;
+}
+
+BatteryStatus EventsInfo::GetBatteryState()
+{
+#ifdef CAMERA_USE_BATTERY
+    auto& bettery = PowerMgr::BatterySrvClient::GetInstance();
+    auto level = bettery.GetCapacityLevel();
+    DP_INFO_LOG("GetBatteryState: %{public}d", level);
+    switch (level) {
+        case PowerMgr::BatteryCapacityLevel::LEVEL_NORMAL:
+        case PowerMgr::BatteryCapacityLevel::LEVEL_HIGH:
+        case PowerMgr::BatteryCapacityLevel::LEVEL_FULL:
+            batteryState_ = BatteryStatus::BATTERY_OKAY;
+            break;
+        default:
+            batteryState_ = BatteryStatus::BATTERY_LOW;
+            break;
+    }
+#endif
+    return batteryState_;
+}
+
+ChargingStatus EventsInfo::GetChargingState()
+{
+#ifdef CAMERA_USE_BATTERY
+    auto& bettery = PowerMgr::BatterySrvClient::GetInstance();
+    auto status = bettery.GetChargingStatus();
+    DP_INFO_LOG("GetChargingState: %{public}d", status);
+    switch (status) {
+        case PowerMgr::BatteryChargeState::CHARGE_STATE_ENABLE:
+        case PowerMgr::BatteryChargeState::CHARGE_STATE_FULL:
+            chargingState_ = ChargingStatus::CHARGING;
+            break;
+        default:
+            chargingState_ = ChargingStatus::DISCHARGING;
+            break;
+    }
+#endif
+    return chargingState_;
+}
+
+BatteryLevel EventsInfo::GetBatteryLevel()
+{
+#ifdef CAMERA_USE_BATTERY
+    auto& bettery = PowerMgr::BatterySrvClient::GetInstance();
+    auto capacity = bettery.GetCapacity();
+    DP_INFO_LOG("GetBatteryLevel: %{public}d", capacity);
+    if (capacity <= BATTERY_THRESHOLD) {
+        batteryLevel_ = BatteryLevel::BATTERY_LEVEL_LOW;
+    } else {
+        batteryLevel_ = BatteryLevel::BATTERY_LEVEL_OKAY;
+    }
+#endif
+    return batteryLevel_;
+}
+
+SystemPressureLevel EventsInfo::GetPhotoThermalLevel()
+{
+#ifdef CAMERA_USE_THERMAL
+    auto& thermal = OHOS::PowerMgr::ThermalMgrClient::GetInstance();
+    auto level = thermal.GetThermalLevel();
+    photoThermalLevel_ = MapEventThermalLevel(static_cast<int32_t>(level));
+    DP_INFO_LOG("GetPhotoThermalLevel: %{public}d", photoThermalLevel_);
+#endif
+    return photoThermalLevel_;
+}
+
+ThermalLevel EventsInfo::GetThermalLevel()
+{
+#ifdef CAMERA_USE_THERMAL
+    auto& thermal = OHOS::PowerMgr::ThermalMgrClient::GetInstance();
+    thermalLevel_ = static_cast<ThermalLevel>(thermal.GetThermalLevel());
+    DP_INFO_LOG("GetThermalLevel: %{public}d", thermalLevel_);
+#endif
+    return thermalLevel_;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/event_monitor/events_monitor.cpp b/services/deferred_processing_service/src/event_monitor/events_monitor.cpp
index e7c008178..7fa59e1af 100644
--- a/services/deferred_processing_service/src/event_monitor/events_monitor.cpp
+++ b/services/deferred_processing_service/src/event_monitor/events_monitor.cpp
@@ -12,82 +12,43 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
- 
-#include "events_monitor.h"
 
-#include <securec.h>
+#include "events_monitor.h"
 
 #include "dp_log.h"
 #include "dp_utils.h"
-#ifdef CAMERA_USE_THERMAL
-#include "thermal_mgr_client.h"
-#endif
 #include "dps_event_report.h"
+#include "dps.h"
+#include "event_status_change_command.h"
+#include "events_info.h"
+#include "iservice_registry.h"
+#include "system_ability_definition.h"
 
 namespace OHOS {
 namespace CameraStandard {
-
-namespace {
-    constexpr int32_t LEVEL_0 = 0;
-    constexpr int32_t LEVEL_1 = 1;
-    constexpr int32_t LEVEL_2 = 2;
-    constexpr int32_t LEVEL_3 = 3;
-    constexpr int32_t LEVEL_4 = 4;
-    constexpr int32_t LEVEL_5 = 5;
-}
-
 namespace DeferredProcessing {
-class EventsMonitor::ThermalMgrDeathRecipient : public IRemoteObject::DeathRecipient {
-public:
-    explicit ThermalMgrDeathRecipient(EventsMonitor *eventMonitor) : eventMonitor_(eventMonitor)
-    {}
-    ~ThermalMgrDeathRecipient() = default;
-    void OnRemoteDied(const wptr<IRemoteObject>& remote) override
-    {
-        (void)(remote);
-        if (eventMonitor_) {
-            eventMonitor_->SetRegisterThermalStatus(false);
-            eventMonitor_->ScheduleRegisterThermalListener();
-        }
-    }
-
-private:
-    EventsMonitor *eventMonitor_;
-};
-
-EventsMonitor &EventsMonitor::GetInstance()
+EventsMonitor::EventsMonitor()
 {
-    static EventsMonitor instance;
-    return instance;
-}
-
-EventsMonitor::EventsMonitor() : initialized_(false), numActiveSessions_(0), mIsRegistered(false)
-{
-    DP_DEBUG_LOG("EventsMonitor enter.");
+    DP_DEBUG_LOG("entered.");
 }
 
 EventsMonitor::~EventsMonitor()
 {
-    DP_DEBUG_LOG("~EventsMonitor enter.");
-    numActiveSessions_ = 0;
-    initialized_ = false;
-    UnRegisterThermalLevel();
+    DP_DEBUG_LOG("entered.");
+    UnSubscribeSystemAbility();
 }
 
 void EventsMonitor::Initialize()
 {
-    DP_DEBUG_LOG("Initialize enter.");
+    DP_DEBUG_LOG("entered.");
     std::lock_guard<std::mutex> lock(mutex_);
-    if (initialized_) {
-        return;
-    }
-    RegisterThermalLevel();
-    ScheduleRegisterThermalListener();
+    DP_CHECK_RETURN(initialized_.load());
+    DP_CHECK_RETURN(SubscribeSystemAbility() != DP_OK);
     initialized_ = true;
 }
 
-void EventsMonitor::RegisterEventsListener(const int32_t userId, const std::vector<EventType> &events,
-    const std::shared_ptr<IEventsListener> &listener)
+void EventsMonitor::RegisterEventsListener(const int32_t userId, const std::vector<EventType>& events,
+    const std::weak_ptr<IEventsListener>& listener)
 {
     DP_INFO_LOG("RegisterEventsListener enter.");
     std::lock_guard<std::mutex> lock(mutex_);
@@ -101,64 +62,25 @@ void EventsMonitor::RegisterEventsListener(const int32_t userId, const std::vect
     userIdToeventListeners_[userId] = eventListeners_;
 }
 
-void EventsMonitor::RegisterTaskManager(const int32_t userId, TaskManager *taskManager)
-{
-    DP_INFO_LOG("RegisterTaskManager enter.");
-    auto taskIter = userIdToTaskManager.find(userId);
-    if (taskIter != userIdToTaskManager.end()) {
-        (taskIter->second).push_back(taskManager);
-    } else {
-        std::vector<TaskManager*> taskVector;
-        taskVector.push_back(taskManager);
-        userIdToTaskManager[userId] = taskVector;
-    }
-}
-
-void EventsMonitor::SetRegisterThermalStatus(bool isHasRegistered)
-{
-    mIsRegistered = isHasRegistered;
-}
-
-void EventsMonitor::UnRegisterListener(const int32_t userId, TaskManager *taskManager)
-{
-    DP_INFO_LOG("UnRegisterListener enter.");
-    auto taskIter = userIdToTaskManager.find(userId);
-    if (taskIter != userIdToTaskManager.end()) {
-        std::vector<TaskManager*>::iterator itVect = (taskIter->second).begin();
-        for (; itVect != (taskIter->second).end(); ++itVect) {
-            if (*itVect == taskManager) {
-                break;
-            }
-        }
-        (taskIter->second).erase(itVect);
-    }
-    if (userIdToTaskManager[userId].size() == 0) {
-        userIdToTaskManager.erase(userId);
-    }
-}
-
 void EventsMonitor::NotifyThermalLevel(int32_t level)
 {
     std::lock_guard<std::mutex> lock(mutex_);
     DP_INFO_LOG("notify : %{public}d.", level);
-    if (!initialized_) {
-        DP_INFO_LOG("uninitialized events monitor!");
-        return;
-    }
+    DP_CHECK_ERROR_RETURN_LOG(!initialized_.load(), "uninitialized events monitor!");
+
     for (auto it = userIdToeventListeners_.begin(); it != userIdToeventListeners_.end(); ++it) {
-        NotifyObserversUnlocked(it->first, EventType::SYSTEM_PRESSURE_LEVEL_EVENT, level);
+        NotifyObserversUnlocked(it->first, EventType::THERMAL_LEVEL_STATUS_EVENT, level);
     }
 }
 
 void EventsMonitor::NotifyCameraSessionStatus(const int32_t userId,
-    const std::string &cameraId, bool running, bool isSystemCamera)
+    const std::string& cameraId, bool running, bool isSystemCamera)
 {
+    std::lock_guard<std::mutex> lock(mutex_);
     DP_INFO_LOG("entered, userId: %{public}d, cameraId: %s, running: %{public}d, isSystemCamera: %{public}d: ",
         userId, cameraId.c_str(), running, isSystemCamera);
-    std::lock_guard<std::mutex> lock(mutex_);
-    if (!initialized_) {
-        return;
-    }
+    DP_CHECK_ERROR_RETURN_LOG(!initialized_.load(), "uninitialized events monitor!");
+
     CameraSessionStatus cameraSessionStatus;
     running ? numActiveSessions_++ : numActiveSessions_--;
     DP_INFO_LOG("numActiveSessions_: %{public}d", static_cast<int>(numActiveSessions_.load()));
@@ -173,17 +95,16 @@ void EventsMonitor::NotifyCameraSessionStatus(const int32_t userId,
             CameraSessionStatus::NORMAL_CAMERA_CLOSED;
     }
     NotifyObserversUnlocked(userId, EventType::CAMERA_SESSION_STATUS_EVENT, cameraSessionStatus);
-    ConnectThermalSvr();
+    auto level = EventsInfo::GetInstance().GetPhotoThermalLevel();
+    DPSEventReport::GetInstance().SetTemperatureLevel(static_cast<int>(level));
 }
 
 void EventsMonitor::NotifyMediaLibraryStatus(bool available)
 {
     std::lock_guard<std::mutex> lock(mutex_);
     DP_INFO_LOG("mediaLibrary available: %{public}d.", available);
-    if (!initialized_) {
-        DP_INFO_LOG("uninitialized events monitor!");
-        return;
-    }
+    DP_CHECK_ERROR_RETURN_LOG(!initialized_.load(), "uninitialized events monitor!");
+
     for (auto it = userIdToeventListeners_.begin(); it != userIdToeventListeners_.end(); ++it) {
         NotifyObserversUnlocked(it->first, EventType::MEDIA_LIBRARY_STATUS_EVENT, available);
     }
@@ -191,52 +112,89 @@ void EventsMonitor::NotifyMediaLibraryStatus(bool available)
 
 void EventsMonitor::NotifyImageEnhanceStatus(int32_t status)
 {
-    DP_INFO_LOG("entered: %{public}d.", status);
     std::lock_guard<std::mutex> lock(mutex_);
-    if (!initialized_) {
-        DP_INFO_LOG("uninitialized events monitor!");
-        return;
-    }
+    DP_INFO_LOG("entered: %{public}d.", status);
+    DP_CHECK_ERROR_RETURN_LOG(!initialized_.load(), "uninitialized events monitor!");
 
     for (auto it = userIdToeventListeners_.begin(); it != userIdToeventListeners_.end(); ++it) {
         NotifyObserversUnlocked(it->first, EventType::HDI_STATUS_EVENT, status);
     }
 }
 
+void EventsMonitor::NotifyScreenStatus(int32_t status)
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    DP_INFO_LOG("entered: %{public}d.", status);
+    DP_CHECK_ERROR_RETURN_LOG(!initialized_.load(), "uninitialized events monitor!");
+
+    for (auto it = userIdToeventListeners_.begin(); it != userIdToeventListeners_.end(); ++it) {
+        NotifyObserversUnlocked(it->first, EventType::SCREEN_STATUS_EVENT, status);
+    }
+}
+
+void EventsMonitor::NotifyChargingStatus(int32_t status)
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    DP_INFO_LOG("entered: %{public}d.", status);
+    DP_CHECK_ERROR_RETURN_LOG(!initialized_.load(), "uninitialized events monitor!");
+
+    for (auto it = userIdToeventListeners_.begin(); it != userIdToeventListeners_.end(); ++it) {
+        NotifyObserversUnlocked(it->first, EventType::CHARGING_STATUS_EVENT, status);
+    }
+}
+
+void EventsMonitor::NotifyBatteryStatus(int32_t status)
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    DP_INFO_LOG("entered: %{public}d.", status);
+    DP_CHECK_ERROR_RETURN_LOG(!initialized_.load(), "uninitialized events monitor!");
+
+    for (auto it = userIdToeventListeners_.begin(); it != userIdToeventListeners_.end(); ++it) {
+        NotifyObserversUnlocked(it->first, EventType::BATTERY_STATUS_EVENT, status);
+    }
+}
+
+void EventsMonitor::NotifyBatteryLevel(int32_t level)
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    DP_INFO_LOG("entered: %{public}d.", level);
+    DP_CHECK_ERROR_RETURN_LOG(!initialized_.load(), "uninitialized events monitor!");
+
+    for (auto it = userIdToeventListeners_.begin(); it != userIdToeventListeners_.end(); ++it) {
+        NotifyObserversUnlocked(it->first, EventType::BATTERY_LEVEL_STATUS_EVENT, level);
+    }
+}
+
 void EventsMonitor::NotifySystemPressureLevel(SystemPressureLevel level)
 {
-    DP_INFO_LOG("entered: %{public}d.", level);
     std::lock_guard<std::mutex> lock(mutex_);
-    if (!initialized_) {
-        DP_INFO_LOG("uninitialized events monitor!");
-        return;
-    }
+    DP_INFO_LOG("entered: %{public}d.", level);
+    DP_CHECK_ERROR_RETURN_LOG(!initialized_.load(), "uninitialized events monitor!");
 
     for (auto it = userIdToeventListeners_.begin(); it != userIdToeventListeners_.end(); ++it) {
         NotifyObserversUnlocked(it->first, EventType::SYSTEM_PRESSURE_LEVEL_EVENT, level);
     }
 }
+void EventsMonitor::NotifyPhotoProcessSize(int32_t size)
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    DP_INFO_LOG("entered, image job size: %{public}d.", size);
+    DP_CHECK_ERROR_RETURN_LOG(!initialized_.load(), "uninitialized events monitor!");
+
+    for (auto it = userIdToeventListeners_.begin(); it != userIdToeventListeners_.end(); ++it) {
+        NotifyObserversUnlocked(it->first, EventType::PHOTO_PROCESS_STATUS_EVENT, size);
+    }
+}
 
 void EventsMonitor::NotifyObserversUnlocked(const int32_t userId, EventType event, int32_t value)
 {
-    DP_INFO_LOG("entered.");
-    auto taskIter = userIdToTaskManager.find(userId);
-    DP_CHECK_AND_RETURN_LOG(taskIter != userIdToTaskManager.end(), "notify failed because no match userId");
-    
-    std::vector<TaskManager*> taskvect = userIdToTaskManager[userId];
-    for (auto it = taskvect.begin(); it != taskvect.end();) {
-        if (*it) {
-            (*it)->SubmitTask([userId, event, value]() {
-                EventsMonitor::GetInstance().NotifyEventToObervers(userId, event, value);
-            });
-        }
-        ++it;
-    }
+    int32_t ret = DPS_SendCommand<EventStatusChangeCommand>(userId, event, value);
+    DP_CHECK_ERROR_PRINT_LOG(ret != DP_OK, "send command fail, ret: %{public}d", ret);
 }
 
 void EventsMonitor::NotifyEventToObervers(const int32_t userId, EventType event, int32_t value)
 {
-    DP_INFO_LOG("entered.");
+    DP_DEBUG_LOG("entered.");
     auto eventListeners = userIdToeventListeners_.find(userId);
     if (eventListeners != userIdToeventListeners_.end()) {
         std::map<EventType, std::vector<std::weak_ptr<IEventsListener>>> eventListenersVect;
@@ -254,115 +212,55 @@ void EventsMonitor::NotifyEventToObervers(const int32_t userId, EventType event,
     }
 }
 
-void EventsMonitor::ScheduleRegisterThermalListener()
-{
-    DP_INFO_LOG("entered.");
-    uint32_t callbackHandle;
-    constexpr uint32_t delayMilli = 10 * 1000;
-    DeferredProcessing::GetGlobalWatchdog().StartMonitor(callbackHandle, delayMilli, [this](uint32_t handle) {
-        DP_INFO_LOG("PhotoPostProcessor-ProcessImage-Watchdog executed, handle: %{public}d", static_cast<int>(handle));
-        this->RegisterThermalLevel();
-    });
-}
-
 void EventsMonitor::NotifyObservers(EventType event, int value, int32_t userId)
 {
-    DP_INFO_LOG("entered.");
+    DP_DEBUG_LOG("entered.");
     std::lock_guard<std::mutex> lock(mutex_);
     NotifyObserversUnlocked(userId, event, value);
 }
 
-void EventsMonitor::RegisterThermalLevel()
+void CommonEventListener::OnAddSystemAbility(int32_t systemAbilityId, const std::string& deviceId)
 {
-    std::unique_lock<std::mutex> lock(thermalEventMutex);
-    if (thermalLevelSubscriber_) {
-        return;
-    }
-    ConnectThermalSvr();
-    OHOS::EventFwk::MatchingSkills matchingSkills;
-    matchingSkills.AddEvent(OHOS::EventFwk::CommonEventSupport::COMMON_EVENT_THERMAL_LEVEL_CHANGED);
-    EventFwk::CommonEventSubscribeInfo subscriberInfo(matchingSkills);
-    thermalLevelSubscriber_ = std::make_shared<ThermalLevelSubscriber>(subscriberInfo);
-    if (!EventFwk::CommonEventManager::SubscribeCommonEvent(thermalLevelSubscriber_)) {
-        DP_INFO_LOG("THERMAL_LEVEL_CHANGED SubscribeCommonEvent() failed");
-    } else {
-        DP_INFO_LOG("THERMAL_LEVEL_CHANGED SubscribeCommonEvent() OK");
-    }
+    DP_CHECK_RETURN(eventSubscriber_ != nullptr);
+    DP_DEBUG_LOG("saId: %{public}d", systemAbilityId);
+    eventSubscriber_ = EventSubscriber::Create();
+    DP_CHECK_ERROR_RETURN_LOG(eventSubscriber_ == nullptr, "RegisterEventStatus failed, eventSubscriber is nullptr");
+    eventSubscriber_->Subcribe();
 }
 
-void EventsMonitor::UnRegisterThermalLevel()
+void CommonEventListener::OnRemoveSystemAbility(int32_t systemAbilityId, const std::string& deviceId)
 {
-    std::unique_lock<std::mutex> lock(thermalEventMutex);
-    if (!thermalLevelSubscriber_) {
-        return;
-    }
-    if (!EventFwk::CommonEventManager::UnSubscribeCommonEvent(thermalLevelSubscriber_)) {
-        DP_INFO_LOG("THERMAL_LEVEL_CHANGED UnSubscribeCommonEvent() failed");
-    } else {
-        DP_INFO_LOG("THERMAL_LEVEL_CHANGED UnSubscribeCommonEvent() OK");
-    }
+    DP_CHECK_RETURN(eventSubscriber_ == nullptr);
+    DP_DEBUG_LOG("saId: %{public}d", systemAbilityId);
+    DP_CHECK_ERROR_RETURN_LOG(eventSubscriber_ == nullptr, "UnRegisterEventStatus failed, eventSubscriber is nullptr");
+    eventSubscriber_->UnSubscribe();
 }
 
-void EventsMonitor::ConnectThermalSvr()
+int32_t EventsMonitor::SubscribeSystemAbility()
 {
-#ifdef CAMERA_USE_THERMAL
-    DP_INFO_LOG("thermalSrv_ enter");
-    auto& thermalMgrClient = OHOS::PowerMgr::ThermalMgrClient::GetInstance();
-    OHOS::PowerMgr::ThermalLevel level = thermalMgrClient.GetThermalLevel();
-    DP_DEBUG_LOG("ThermalMgrClient is level %{public}d", level);
-    DPSEventReport::GetInstance().SetTemperatureLevel(static_cast<int>(level));
-#endif
+    auto samgr = SystemAbilityManagerClient::GetInstance().GetSystemAbilityManager();
+    DP_CHECK_ERROR_RETURN_RET_LOG(samgr == nullptr, DP_NULL_POINTER, "failed to get system ability manager");
 
-    DP_INFO_LOG("Connecting ThermalMgrService success.");
+    ceListener_ = sptr<CommonEventListener>::MakeSptr();
+    DP_CHECK_ERROR_RETURN_RET_LOG(ceListener_ == nullptr, DP_NULL_POINTER, "ceListener is nullptr.");
+
+    int32_t ret = samgr->SubscribeSystemAbility(COMMON_EVENT_SERVICE_ID, ceListener_);
+    DP_INFO_LOG("SubscribeSystemAbility ret = %{public}d", ret);
+    return ret == DP_OK ? DP_OK : DP_ERR;
 }
 
-ThermalLevelSubscriber::ThermalLevelSubscriber(const OHOS::EventFwk::CommonEventSubscribeInfo &subscriberInfo)
-    : CommonEventSubscriber(subscriberInfo)
+int32_t EventsMonitor::UnSubscribeSystemAbility()
 {
-    DP_INFO_LOG("ThermalLevelSubscriber enter");
-}
+    DP_CHECK_RETURN_RET(ceListener_ == nullptr, DP_OK);
 
-ThermalLevelSubscriber::~ThermalLevelSubscriber()
-{
-    DP_INFO_LOG("~ThermalLevelSubscriber enter");
+    auto samgr = SystemAbilityManagerClient::GetInstance().GetSystemAbilityManager();
+    DP_CHECK_ERROR_RETURN_RET_LOG(samgr == nullptr, DP_NULL_POINTER, "failed to get System ability manager");
+    
+    int32_t ret = samgr->UnSubscribeSystemAbility(COMMON_EVENT_SERVICE_ID, ceListener_);
+    DP_INFO_LOG("UnSubscribeSystemAbility ret = %{public}d", ret);
+    ceListener_ = nullptr;
+    return ret == DP_OK ? DP_OK : DP_ERR;
 }
-
-void ThermalLevelSubscriber::OnReceiveEvent(const OHOS::EventFwk::CommonEventData &data)
-{
-    std::string action = data.GetWant().GetAction();
-    DP_INFO_LOG("ThermalLevelSubscriber::OnReceiveEvent: %{public}s.", action.c_str());
-    if (action == OHOS::EventFwk::CommonEventSupport::COMMON_EVENT_THERMAL_LEVEL_CHANGED) {
-        static const std::string THERMAL_EVENT_ID = "0";
-        int level = data.GetWant().GetIntParam(THERMAL_EVENT_ID, 0);
-        DPSEventReport::GetInstance().SetTemperatureLevel(level);
-        DP_INFO_LOG("OnThermalLevelChanged level:%{public}d", static_cast<int>(level));
-        EventsMonitor::GetInstance().NotifySystemPressureLevel(MapEventLevel(level));
-        DP_INFO_LOG("ThermalLevelSubscriber SetThermalLevel: %{public}d.", level);
-    }
-}
-
-SystemPressureLevel ThermalLevelSubscriber::MapEventLevel(int level)
-{
-    if (level < LEVEL_0 || level > LEVEL_5) {
-        return SystemPressureLevel::SEVERE;
-    }
-    SystemPressureLevel eventLevel;
-    switch (level) {
-        case LEVEL_0:
-        case LEVEL_1:
-            eventLevel = SystemPressureLevel::NOMINAL;
-            break;
-        case LEVEL_2:
-        case LEVEL_3:
-        case LEVEL_4:
-            eventLevel = SystemPressureLevel::FAIR;
-            break;
-        default:
-            eventLevel = SystemPressureLevel::SEVERE;
-            break;
-    }
-    return eventLevel;
-}
-} // namsespace DeferredProcessingService
+} // namespace DeferredProcessing
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/services/deferred_processing_service/src/event_monitor/events_subscriber.cpp b/services/deferred_processing_service/src/event_monitor/events_subscriber.cpp
new file mode 100644
index 000000000..ca3b6a69b
--- /dev/null
+++ b/services/deferred_processing_service/src/event_monitor/events_subscriber.cpp
@@ -0,0 +1,120 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "events_subscriber.h"
+
+#include "battery_level_strategy.h"
+#include "battery_strategy.h"
+#include "common_event_subscribe_info.h"
+#include "common_event_subscriber.h"
+#include "common_event_support.h"
+#include "charging_strategy.h"
+#include "dp_utils.h"
+#include "screen_strategy.h"
+#include "thermal_strategy.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+const std::vector<std::string> EventSubscriber::events_ = {
+    OHOS::EventFwk::CommonEventSupport::COMMON_EVENT_THERMAL_LEVEL_CHANGED,
+    OHOS::EventFwk::CommonEventSupport::COMMON_EVENT_SCREEN_ON,
+    OHOS::EventFwk::CommonEventSupport::COMMON_EVENT_SCREEN_OFF,
+    OHOS::EventFwk::CommonEventSupport::COMMON_EVENT_CHARGING,
+    OHOS::EventFwk::CommonEventSupport::COMMON_EVENT_DISCHARGING,
+    OHOS::EventFwk::CommonEventSupport::COMMON_EVENT_BATTERY_OKAY,
+    OHOS::EventFwk::CommonEventSupport::COMMON_EVENT_BATTERY_LOW,
+    OHOS::EventFwk::CommonEventSupport::COMMON_EVENT_BATTERY_CHANGED,
+};
+
+EventSubscriber::EventSubscriber(const OHOS::EventFwk::CommonEventSubscribeInfo& subscriberInfo)
+    : CommonEventSubscriber(subscriberInfo)
+{
+    DP_DEBUG_LOG("entered.");
+    Initialize();
+}
+
+EventSubscriber::~EventSubscriber()
+{
+    DP_DEBUG_LOG("entered.");
+    eventStrategy_.clear();
+}
+
+std::shared_ptr<EventSubscriber> EventSubscriber::Create()
+{
+    DP_DEBUG_LOG("entered.");
+    OHOS::EventFwk::MatchingSkills matchingSkills;
+    for (auto event : events_) {
+        matchingSkills.AddEvent(event);
+    }
+    EventFwk::CommonEventSubscribeInfo subscriberInfo(matchingSkills);
+    return CreateShared<EventSubscriber>(subscriberInfo);
+}
+
+void EventSubscriber::Initialize()
+{
+    DP_DEBUG_LOG("entered.");
+    eventStrategy_[OHOS::EventFwk::CommonEventSupport::COMMON_EVENT_THERMAL_LEVEL_CHANGED]
+        = std::make_shared<ThermalStrategy>();
+    auto screen = std::make_shared<ScreenStrategy>();
+    eventStrategy_[OHOS::EventFwk::CommonEventSupport::COMMON_EVENT_SCREEN_ON]
+        = screen;
+    eventStrategy_[OHOS::EventFwk::CommonEventSupport::COMMON_EVENT_SCREEN_OFF]
+        = screen;
+    auto charging = std::make_shared<ChargingStrategy>();
+    eventStrategy_[OHOS::EventFwk::CommonEventSupport::COMMON_EVENT_CHARGING]
+        = charging;
+    eventStrategy_[OHOS::EventFwk::CommonEventSupport::COMMON_EVENT_DISCHARGING]
+        = charging;
+    auto batteryState = std::make_shared<BatteryStrategy>();
+    eventStrategy_[OHOS::EventFwk::CommonEventSupport::COMMON_EVENT_BATTERY_OKAY]
+        = batteryState;
+    eventStrategy_[OHOS::EventFwk::CommonEventSupport::COMMON_EVENT_BATTERY_LOW]
+        = batteryState;
+    eventStrategy_[OHOS::EventFwk::CommonEventSupport::COMMON_EVENT_BATTERY_CHANGED]
+        = std::make_shared<BatteryLevelStrategy>();
+}
+
+void EventSubscriber::Subcribe()
+{
+    DP_CHECK_ERROR_RETURN_LOG(!EventFwk::CommonEventManager::SubscribeCommonEvent(shared_from_this()),
+        "SubscribeCommonEvent failed");
+    DP_INFO_LOG("SubscribeCommonEvent OK");
+}
+
+void EventSubscriber::UnSubscribe()
+{
+    DP_CHECK_ERROR_RETURN_LOG(!EventFwk::CommonEventManager::UnSubscribeCommonEvent(shared_from_this()),
+        "UnSubscribeCommonEvent failed");
+    DP_INFO_LOG("UnSubscribeCommonEvent OK");
+}
+
+void EventSubscriber::OnReceiveEvent(const OHOS::EventFwk::CommonEventData& data)
+{
+    AAFwk::Want want = data.GetWant();
+    auto action = want.GetAction();
+    DP_INFO_LOG("EventSubscriber::OnReceiveEvent: %{public}s.", action.c_str());
+    auto entry = eventStrategy_.find(action);
+    if (entry != eventStrategy_.end()) {
+        auto strategy = entry->second;
+        if (strategy != nullptr) {
+            strategy->handleEvent(data);
+        }
+    }
+    DP_DEBUG_LOG("EventSubscriber::OnReceiveEvent: end");
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/event_monitor/impl/battery_level_strategy.cpp b/services/deferred_processing_service/src/event_monitor/impl/battery_level_strategy.cpp
new file mode 100644
index 000000000..bf2a54070
--- /dev/null
+++ b/services/deferred_processing_service/src/event_monitor/impl/battery_level_strategy.cpp
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "battery_level_strategy.h"
+
+#ifdef CAMERA_USE_BATTERY
+#include "battery_info.h"
+#endif
+#include "events_monitor.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+namespace {
+    constexpr int32_t DEFAULT_CAPACITY = -1;
+    constexpr int32_t BATTERY_THRESHOLD = 50;
+    const std::string KEY_CAPACITY = "soc";
+}
+
+BatteryLevelStrategy::BatteryLevelStrategy() : preLevel_(BATTERY_LEVEL_LOW)
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+BatteryLevelStrategy::~BatteryLevelStrategy()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+void BatteryLevelStrategy::handleEvent(const EventFwk::CommonEventData& data)
+{
+    int32_t capacity = data.GetWant().GetIntParam(KEY_CAPACITY, DEFAULT_CAPACITY);
+    DP_CHECK_RETURN(capacity == DEFAULT_CAPACITY);
+    int32_t batteryLevel = BatteryLevel::BATTERY_LEVEL_LOW;
+    if (capacity >= BATTERY_THRESHOLD) {
+        batteryLevel = BatteryLevel::BATTERY_LEVEL_OKAY;
+    }
+    DP_CHECK_RETURN(batteryLevel == preLevel_);
+
+    preLevel_ = batteryLevel;
+    DP_INFO_LOG("OnBatteryLevelChanged level:%{public}d", preLevel_);
+    EventsMonitor::GetInstance().NotifyBatteryLevel(preLevel_);
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/event_monitor/impl/battery_strategy.cpp b/services/deferred_processing_service/src/event_monitor/impl/battery_strategy.cpp
new file mode 100644
index 000000000..bca309d0e
--- /dev/null
+++ b/services/deferred_processing_service/src/event_monitor/impl/battery_strategy.cpp
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "battery_strategy.h"
+
+#include "basic_definitions.h"
+#include "common_event_support.h"
+#include "events_monitor.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+BatteryStrategy::BatteryStrategy()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+BatteryStrategy::~BatteryStrategy()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+void BatteryStrategy::handleEvent(const EventFwk::CommonEventData& data)
+{
+    auto action = data.GetWant().GetAction();
+    int32_t batteryState = BatteryStatus::BATTERY_LOW;
+    if (action == EventFwk::CommonEventSupport::COMMON_EVENT_BATTERY_LOW) {
+        batteryState = BatteryStatus::BATTERY_LOW;
+    } else if (action == EventFwk::CommonEventSupport::COMMON_EVENT_BATTERY_OKAY) {
+        batteryState = BatteryStatus::BATTERY_OKAY;
+    }
+    DP_INFO_LOG("OnBatteryStatusChanged state:%{public}d", batteryState);
+    EventsMonitor::GetInstance().NotifyBatteryStatus(batteryState);
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/event_monitor/impl/charging_strategy.cpp b/services/deferred_processing_service/src/event_monitor/impl/charging_strategy.cpp
new file mode 100644
index 000000000..b4c7eee49
--- /dev/null
+++ b/services/deferred_processing_service/src/event_monitor/impl/charging_strategy.cpp
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "charging_strategy.h"
+
+#include "basic_definitions.h"
+#include "common_event_support.h"
+#include "events_monitor.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+ChargingStrategy::ChargingStrategy()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+ChargingStrategy::~ChargingStrategy()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+void ChargingStrategy::handleEvent(const EventFwk::CommonEventData& data)
+{
+    auto action = data.GetWant().GetAction();
+    int32_t chargeState = ChargingStatus::DISCHARGING;
+    if (action == EventFwk::CommonEventSupport::COMMON_EVENT_CHARGING) {
+        chargeState = ChargingStatus::CHARGING;
+    } else if (action == EventFwk::CommonEventSupport::COMMON_EVENT_DISCHARGING) {
+        chargeState = ChargingStatus::DISCHARGING;
+    }
+    DP_INFO_LOG("OnChargingStatusChanged state:%{public}d", chargeState);
+    EventsMonitor::GetInstance().NotifyChargingStatus(chargeState);
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/event_monitor/impl/screen_strategy.cpp b/services/deferred_processing_service/src/event_monitor/impl/screen_strategy.cpp
new file mode 100644
index 000000000..095785649
--- /dev/null
+++ b/services/deferred_processing_service/src/event_monitor/impl/screen_strategy.cpp
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "screen_strategy.h"
+
+#include "basic_definitions.h"
+#include "common_event_support.h"
+#include "events_monitor.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+ScreenStrategy::ScreenStrategy()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+ScreenStrategy::~ScreenStrategy()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+void ScreenStrategy::handleEvent(const EventFwk::CommonEventData& data)
+{
+    auto action = data.GetWant().GetAction();
+    int32_t screenState = ScreenStatus::SCREEN_OFF;
+    if (action == EventFwk::CommonEventSupport::COMMON_EVENT_SCREEN_ON) {
+        screenState = ScreenStatus::SCREEN_ON;
+    } else if (action == EventFwk::CommonEventSupport::COMMON_EVENT_SCREEN_OFF) {
+        screenState = ScreenStatus::SCREEN_OFF;
+    }
+    DP_INFO_LOG("OnScreenStatusChanged state:%{public}d", screenState);
+    EventsMonitor::GetInstance().NotifyScreenStatus(screenState);
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/event_monitor/impl/thermal_strategy.cpp b/services/deferred_processing_service/src/event_monitor/impl/thermal_strategy.cpp
new file mode 100644
index 000000000..30304e6fe
--- /dev/null
+++ b/services/deferred_processing_service/src/event_monitor/impl/thermal_strategy.cpp
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "thermal_strategy.h"
+
+#include "dps_event_report.h"
+#include "events_monitor.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+ThermalStrategy::ThermalStrategy()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+ThermalStrategy::~ThermalStrategy()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+void ThermalStrategy::handleEvent(const EventFwk::CommonEventData& data)
+{
+    AAFwk::Want want = data.GetWant();
+    static const std::string THERMAL_EVENT_ID = "0";
+    int level = want.GetIntParam(THERMAL_EVENT_ID, 0);
+    DPSEventReport::GetInstance().SetTemperatureLevel(level);
+    DP_INFO_LOG("OnThermalLevelChanged level:%{public}d", level);
+    // 需要整改归一化图片和视频接收到温度事件的出来
+    EventsMonitor::GetInstance().NotifySystemPressureLevel(MapEventThermalLevel(level));
+    EventsMonitor::GetInstance().NotifyThermalLevel(level);
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/media_manager/demuxer.cpp b/services/deferred_processing_service/src/media_manager/demuxer.cpp
new file mode 100644
index 000000000..4dfd4f600
--- /dev/null
+++ b/services/deferred_processing_service/src/media_manager/demuxer.cpp
@@ -0,0 +1,95 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "demuxer.h"
+
+#include "dp_log.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+namespace {
+    constexpr int32_t INVALID_TRACK_ID = -1;
+}
+
+Demuxer::~Demuxer()
+{
+    DP_DEBUG_LOG("entered.");
+    demuxer_ = nullptr;
+}
+
+MediaManagerError Demuxer::Create(const std::shared_ptr<AVSource>& source,
+    const std::map<TrackType, const std::shared_ptr<Track>>& tracks)
+{
+    DP_CHECK_ERROR_RETURN_RET_LOG(source == nullptr, ERROR_FAIL, "source is nullptr.");
+
+    demuxer_ = AVDemuxerFactory::CreateWithSource(source);
+    DP_CHECK_ERROR_RETURN_RET_LOG(demuxer_ == nullptr, ERROR_FAIL, "create demuxer failed.");
+
+    auto ret = OK;
+    DP_INFO_LOG("tracks size: %{public}d", static_cast<int32_t>(tracks.size()));
+    auto iter = tracks.cbegin();
+    for (; iter != tracks.cend(); ++iter) {
+        auto trackFormat = iter->second->GetFormat();
+        if (iter->first == TrackType::AV_KEY_AUDIO_TYPE) {
+            audioTrackId_ = trackFormat.trackId;
+        }
+        if (iter->first == TrackType::AV_KEY_VIDEO_TYPE) {
+            videoTrackId_ = trackFormat.trackId;
+        }
+        DP_DEBUG_LOG("track id: %{public}d, track type: %{public}d", trackFormat.trackId, iter->first);
+        ret = SeletctTrackByID(trackFormat.trackId);
+        DP_CHECK_ERROR_BREAK_LOG(ret != OK, "select track by id failed, track type: %{public}d", iter->first);
+    }
+    return ret;
+}
+
+MediaManagerError Demuxer::ReadStream(TrackType trackType, std::shared_ptr<AVBuffer>& sample)
+{
+    DP_DEBUG_LOG("entered.");
+    int32_t trackId = INVALID_TRACK_ID;
+    if (trackType == TrackType::AV_KEY_VIDEO_TYPE) {
+        trackId = videoTrackId_;
+    }
+    if (trackType == TrackType::AV_KEY_AUDIO_TYPE) {
+        trackId = audioTrackId_;
+    }
+
+    DP_CHECK_ERROR_RETURN_RET_LOG(trackId == INVALID_TRACK_ID, ERROR_FAIL, "invalid track id.");
+    auto ret = demuxer_->ReadSampleBuffer(trackId, sample);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != static_cast<int32_t>(OK), ERROR_FAIL, "read sample failed.");
+    DP_CHECK_RETURN_RET_LOG(sample->flag_ == AVCODEC_BUFFER_FLAG_EOS, EOS, "track(%{public}d) is end.", trackId);
+    return OK;
+}
+
+MediaManagerError Demuxer::SeekToTime(int64_t lastPts)
+{
+    DP_DEBUG_LOG("entered.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(lastPts < 0, ERROR_FAIL, "don't need to seek, demuxer from start.");
+    auto ret = demuxer_->SeekToTime(lastPts / 1000, SeekMode::SEEK_PREVIOUS_SYNC);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != static_cast<int32_t>(OK), ERROR_FAIL, "failed to seek.");
+    return OK;
+}
+
+MediaManagerError Demuxer::SeletctTrackByID(int32_t trackId)
+{
+    DP_DEBUG_LOG("entered.");
+    auto ret = demuxer_->SelectTrackByID(trackId);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != static_cast<int32_t>(OK), ERROR_FAIL, "select track by id failed.");
+    return OK;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
diff --git a/services/deferred_processing_service/src/media_manager/media_manager.cpp b/services/deferred_processing_service/src/media_manager/media_manager.cpp
new file mode 100644
index 000000000..752b9ec91
--- /dev/null
+++ b/services/deferred_processing_service/src/media_manager/media_manager.cpp
@@ -0,0 +1,267 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "media_manager.h"
+
+#include "dp_log.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+namespace {
+    const std::string TEMP_PTS_TAG = "tempPTS:";
+    constexpr int32_t TEMP_PTS_SIZE = 50;
+    constexpr int32_t DEFAULT_CHANNEL_COUNT = 1;
+    constexpr int32_t DEFAULT_AUDIO_INPUT_SIZE = 1024 * DEFAULT_CHANNEL_COUNT * sizeof(short);
+}
+
+MediaManagerError MediaManager::Create(int32_t inFd, int32_t outFd, int32_t tempFd)
+{
+    DP_DEBUG_LOG("entered.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(inFd == INVALID_FD || outFd == INVALID_FD, ERROR_FAIL,
+        "fd is invalid: inFd(%{public}d), outFd(%{public}d).", inFd, outFd);
+    
+    mediaInfo_ = std::make_shared<MediaInfo>();
+    inputFileFd_ = inFd;
+    outputFileFd_ = outFd;
+    int64_t tempSize = -1;
+    int64_t tempDuration = -1;
+    int64_t tempBitRate = 0;
+    if (tempFd != INVALID_FD) {
+        tempFileFd_ = tempFd;
+        tempSize = lseek(tempFileFd_, DEFAULT_OFFSET, SEEK_END);
+        DP_CHECK_RETURN_RET(tempSize > 0 && InitRecoverReader(tempSize, tempDuration, tempBitRate) != OK, ERROR_FAIL);
+    }
+
+    lseek(inputFileFd_, DEFAULT_OFFSET, SEEK_SET);
+    auto ret = InitReader();
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != OK, ERROR_FAIL, "init reader failed.");
+
+    ret = InitWriter();
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != OK, ERROR_FAIL, "init writer failed.");
+
+    if (tempFileFd_ > 0 && tempSize > 0) {
+        ret = Recover(tempSize);
+        DP_CHECK_ERROR_RETURN_RET_LOG(ret != OK, ERROR_FAIL, "recover failed.");
+    }
+
+    mediaInfo_->recoverTime = pausePts_;
+    mediaInfo_->codecInfo.numFrames = mediaInfo_->codecInfo.numFrames - finalFrameNum_;
+    return OK;
+}
+
+MediaManagerError MediaManager::Pause()
+{
+    DP_DEBUG_LOG("entered.");
+    if (!started_) {
+        ftruncate(outputFileFd_, 0);
+        DP_WARNING_LOG("stop failed, state is not started.");
+        return PAUSE_RECEIVED;
+    }
+
+    DP_CHECK_ERROR_RETURN_RET_LOG(outputWriter_->Stop() == ERROR_FAIL, ERROR_FAIL, "stop writer failed.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(resumePts_ < pausePts_, PAUSE_ABNORMAL, "pause abnormal, will reprocess recover.");
+
+    if (finalSyncPts_ == -1) {
+        finalSyncPts_ = pausePts_;
+    }
+    
+    std::string lastPts = TEMP_PTS_TAG + std::to_string(finalSyncPts_);
+    DP_INFO_LOG("lastPts: %{public}s", lastPts.c_str());
+    lseek(outputFileFd_, 0, SEEK_END);
+    auto ret = write(outputFileFd_, lastPts.c_str(), lastPts.size());
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret == static_cast<long>(ERROR_FAIL), ERROR_FAIL, "write temp final pts failed.");
+    return PAUSE_RECEIVED;
+}
+
+MediaManagerError MediaManager::Stop()
+{
+    DP_DEBUG_LOG("entered.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(!started_, ERROR_FAIL, "stop failed, state is not started.");
+
+    if (hasAudio_) {
+        DP_INFO_LOG("start copy audio track.");
+        DP_CHECK_ERROR_RETURN_RET_LOG(CopyAudioTrack() == ERROR_FAIL, ERROR_FAIL, "read audio track failed.");
+    }
+
+    DP_CHECK_ERROR_RETURN_RET_LOG(outputWriter_->Stop() == ERROR_FAIL, ERROR_FAIL, "stop writer failed.");
+    started_ = false;
+    return OK;
+}
+
+MediaManagerError MediaManager::ReadSample(TrackType type, std::shared_ptr<AVBuffer>& sample)
+{
+    DP_DEBUG_LOG("entered.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(inputReader_ == nullptr, ERROR_FAIL, "reader is nullptr.");
+
+    auto ret = inputReader_->Read(type, sample);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret == ERROR_FAIL, ERROR_FAIL, "read sample failed.");
+    DP_CHECK_RETURN_RET_LOG(ret == EOS, EOS, "read sample finished.");
+    return OK;
+}
+
+MediaManagerError MediaManager::WriteSample(TrackType type, const std::shared_ptr<AVBuffer>& sample)
+{
+    DP_DEBUG_LOG("entered, track type: %{public}d", type);
+    DP_CHECK_ERROR_RETURN_RET_LOG(outputWriter_ == nullptr, ERROR_FAIL, "writer is nullptr.");
+    if (!started_) {
+        auto ret = outputWriter_->Start();
+        DP_CHECK_ERROR_RETURN_RET_LOG(ret != OK, ERROR_FAIL, "start writer failed.");
+        started_ = true;
+    }
+
+    auto ret = outputWriter_->Write(type, sample);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret == ERROR_FAIL, ERROR_FAIL, "writer sample failed.");
+    if (sample->flag_ == AVCODEC_BUFFER_FLAG_SYNC_FRAME) {
+        finalSyncPts_ = sample->pts_;
+    }
+
+    curProcessPts_ = sample->pts_;
+    DP_DEBUG_LOG("process sync pts: %{public}lld, finalSyncPts_: %{public}lld",
+        static_cast<long long>(curProcessPts_), static_cast<long long>(finalSyncPts_));
+    return OK;
+}
+
+MediaManagerError MediaManager::Recover(const int64_t size)
+{
+    DP_DEBUG_LOG("entered.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(recoverReader_ == nullptr, ERROR_FAIL, "recover reader is nullptr.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(outputWriter_ == nullptr, ERROR_FAIL, "recover writer is nullptr.");
+
+    auto ret = outputWriter_->Start();
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret == ERROR_FAIL, ERROR_FAIL, "start recovering failed.");
+
+    started_ = true;
+    int32_t frameNum = 0;
+    AVBufferConfig config;
+    config.size = size;
+    config.memoryType = MemoryType::SHARED_MEMORY;
+    auto sample = AVBuffer::CreateAVBuffer(config);
+    DP_CHECK_ERROR_RETURN_RET_LOG(sample == nullptr, ERROR_FAIL, "create avbuffer failed.");
+    while (true) {
+        ret = recoverReader_->Read(TrackType::AV_KEY_VIDEO_TYPE, sample);
+        DP_CHECK_ERROR_RETURN_RET_LOG(ret == ERROR_FAIL, ERROR_FAIL, "read temp data failed.");
+        DP_CHECK_BREAK_LOG(sample->pts_ == pausePts_, "recovering finished.");
+
+        if (sample->flag_ == AVCODEC_BUFFER_FLAG_SYNC_FRAME) {
+            resumePts_ = sample->pts_;
+            finalFrameNum_ = frameNum;
+        }
+
+        ++frameNum;
+        DP_DEBUG_LOG("pts: %{public}lld, frame-num(%{public}d)", static_cast<long long>(sample->pts_), frameNum);
+        ret = outputWriter_->Write(TrackType::AV_KEY_VIDEO_TYPE, sample);
+        DP_CHECK_ERROR_RETURN_RET_LOG(ret == ERROR_FAIL, ERROR_FAIL, "write temp data failed.");
+    }
+    DP_INFO_LOG("recover sync end, process total num: %{public}d, resume pts: %{public}lld",
+        finalFrameNum_, static_cast<long long>(resumePts_));
+    outputWriter_->SetLastPause(pausePts_);
+    return OK;
+}
+
+MediaManagerError MediaManager::CopyAudioTrack()
+{
+    DP_CHECK_ERROR_RETURN_RET_LOG(inputReader_ == nullptr, ERROR_FAIL, "copy reader is nullptr.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(outputWriter_ == nullptr, ERROR_FAIL, "copy writer is nullptr.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(inputReader_->Reset(0) != OK, ERROR_FAIL, "reset reader failed.");
+
+    AVBufferConfig config;
+    config.size = DEFAULT_AUDIO_INPUT_SIZE;
+    config.memoryType = MemoryType::SHARED_MEMORY;
+    auto sample = AVBuffer::CreateAVBuffer(config);
+    DP_CHECK_ERROR_RETURN_RET_LOG(sample == nullptr, ERROR_FAIL, "create avbuffer failed.");
+
+    while (true) {
+        auto ret = inputReader_->Read(TrackType::AV_KEY_AUDIO_TYPE, sample);
+        DP_CHECK_ERROR_RETURN_RET_LOG(ret == ERROR_FAIL, ERROR_FAIL, "read audio data failed.");
+        DP_CHECK_BREAK_LOG(ret == EOS, "read audio data finished.");
+
+        ret = outputWriter_->Write(TrackType::AV_KEY_AUDIO_TYPE, sample);
+        DP_CHECK_ERROR_RETURN_RET_LOG(ret == ERROR_FAIL, ERROR_FAIL, "write audio data failed.");
+    }
+    return OK;
+}
+
+MediaManagerError MediaManager::InitReader()
+{
+    DP_DEBUG_LOG("entered.");
+    inputReader_ = std::make_shared<Reader>();
+    auto ret = inputReader_->Create(inputFileFd_);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != OK, ERROR_FAIL, "open the video source failed, cannot demux data.");
+
+    ret = inputReader_->GetMediaInfo(mediaInfo_);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != OK, ERROR_FAIL, "get meta info failed, cannot demux data.");
+    return OK;
+}
+
+MediaManagerError MediaManager::InitWriter()
+{
+    DP_DEBUG_LOG("entered.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(inputReader_ == nullptr, ERROR_FAIL, "input reader is nullptr.");
+
+    auto tracks = inputReader_->GetTracks();
+    hasAudio_ = tracks.find(TrackType::AV_KEY_AUDIO_TYPE) == tracks.end() ? false : true;
+    outputWriter_ = std::make_shared<Writer>();
+    auto ret = outputWriter_->Create(outputFileFd_, tracks);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != OK, ERROR_FAIL, "cannot create mux data.");
+
+    ret = outputWriter_->AddMediaInfo(mediaInfo_);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != OK, ERROR_FAIL, "add metadata to writer failed.");
+    return OK;
+}
+
+MediaManagerError MediaManager::InitRecoverReader(const int64_t size, int64_t& duration, int64_t& bitRate)
+{
+    DP_DEBUG_LOG("entered.");
+    recoverReader_ = std::make_shared<Reader>();
+    DP_CHECK_ERROR_RETURN_RET_LOG(recoverReader_ == nullptr, ERROR_FAIL, "init recover reader failed.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(GetRecoverInfo(size) != OK, ERROR_FAIL, "invalid final info.");
+
+    auto ret = recoverReader_->Create(tempFileFd_);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret == ERROR_FAIL, ERROR_FAIL, "open recover source failed, cannot demux data.");
+
+    auto recover = std::make_shared<MediaInfo>();
+    ret = recoverReader_->GetMediaInfo(recover);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret == ERROR_FAIL, ERROR_FAIL, "get recover media info failed.");
+
+    duration = recover->codecInfo.duration;
+    bitRate = recover->codecInfo.bitRate;
+    return OK;
+}
+
+MediaManagerError MediaManager::GetRecoverInfo(const int64_t size)
+{
+    DP_DEBUG_LOG("entered.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(size < TEMP_PTS_SIZE, ERROR_FAIL, "invalid recover file size.");
+
+    auto off = lseek(tempFileFd_, size - TEMP_PTS_SIZE, SEEK_SET);
+    DP_CHECK_ERROR_RETURN_RET_LOG(off == static_cast<int32_t>(ERROR_FAIL), ERROR_FAIL, "lseek recover failed.");
+
+    std::vector<uint8_t> tempTail(TEMP_PTS_SIZE);
+    auto ret = read(tempFileFd_, tempTail.data(), TEMP_PTS_SIZE);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret == static_cast<int32_t>(ERROR_FAIL), ERROR_FAIL, "read recover pts failed.");
+
+    std::vector<uint8_t> tag2search(TEMP_PTS_TAG.begin(), TEMP_PTS_TAG.end());
+    auto findTag = std::search(tempTail.begin(), tempTail.end(), tag2search.begin(), tag2search.end());
+    DP_CHECK_ERROR_RETURN_RET_LOG(findTag == tempTail.end(), ERROR_FAIL, "cannot find temp pts tag.");
+
+    std::string pauseTime(findTag + TEMP_PTS_TAG.size(), tempTail.end());
+    pausePts_ = std::stol(pauseTime);
+    lseek(tempFileFd_, 0, SEEK_SET);
+    return OK;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/media_manager/mpeg_manager.cpp b/services/deferred_processing_service/src/media_manager/mpeg_manager.cpp
new file mode 100644
index 000000000..cb6621dd3
--- /dev/null
+++ b/services/deferred_processing_service/src/media_manager/mpeg_manager.cpp
@@ -0,0 +1,242 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "mpeg_manager.h"
+
+#include <fcntl.h>
+
+#include "dp_log.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+constexpr int64_t DEFAULT_TIME_TAMP = 0;
+
+class MpegManager::VideoCodecCallback : public MediaCodecCallback {
+public:
+    explicit VideoCodecCallback(const std::weak_ptr<MpegManager>& mpegManager) : mpegManager_(mpegManager)
+    {
+        DP_DEBUG_LOG("entered.");
+    }
+
+    ~VideoCodecCallback()
+    {
+        DP_DEBUG_LOG("entered.");
+    }
+
+    void OnError(AVCodecErrorType errorType, int32_t errorCode) override;
+    void OnOutputFormatChanged(const Format &format) override;
+    void OnInputBufferAvailable(uint32_t index, std::shared_ptr<AVBuffer> buffer) override;
+    void OnOutputBufferAvailable(uint32_t index, std::shared_ptr<AVBuffer> buffer) override;
+
+private:
+    std::weak_ptr<MpegManager> mpegManager_;
+};
+
+void MpegManager::VideoCodecCallback::OnError(AVCodecErrorType errorType, int32_t errorCode)
+{
+    DP_ERR_LOG("entered, errorType: %{public}d, errorCode: %{public}d", errorType, errorCode);
+}
+
+void MpegManager::VideoCodecCallback::OnOutputFormatChanged(const Format &format)
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+void MpegManager::VideoCodecCallback::OnInputBufferAvailable(uint32_t index, std::shared_ptr<AVBuffer> buffer)
+{
+    DP_DEBUG_LOG("entered.");
+    (void)index;
+}
+
+void MpegManager::VideoCodecCallback::OnOutputBufferAvailable(uint32_t index, std::shared_ptr<AVBuffer> buffer)
+{
+    DP_CHECK_ERROR_RETURN_LOG(buffer == nullptr, "OutputBuffer is null");
+    auto manager = mpegManager_.lock();
+    if (manager != nullptr) {
+        manager->OnBufferAvailable(index, buffer);
+    }
+}
+
+MpegManager::MpegManager()
+{
+    DP_DEBUG_LOG("entered.");
+    mediaManager_ = std::make_unique<MediaManager>();
+}
+
+MpegManager::~MpegManager()
+{
+    DP_DEBUG_LOG("entered.");
+    mediaManager_ = nullptr;
+    codecSurface_ = nullptr;
+    processThread_ = nullptr;
+    mediaInfo_ = nullptr;
+    outputFd_ = nullptr;
+    tempFd_ = nullptr;
+    remove(tempPath_.c_str());
+    if (result_ == MediaResult::PAUSE) {
+        int ret = rename(outPath_.c_str(), tempPath_.c_str());
+        if (ret != 0) {
+            DP_ERR_LOG("rename %{public}s to %{public}s failde, ret: %{public}d",
+                outPath_.c_str(), tempPath_.c_str(), ret);
+        } else {
+            DP_INFO_LOG("rename %{public}s to %{public}s success.", outPath_.c_str(), tempPath_.c_str());
+        }
+    }
+}
+
+MediaManagerError MpegManager::Init(const std::string& requestId, const sptr<IPCFileDescriptor>& inputFd)
+{
+    DP_DEBUG_LOG("entered.");
+    outputFd_ = GetFileFd(requestId, O_CREAT | O_RDWR, OUT_TAG);
+    DP_CHECK_ERROR_RETURN_RET_LOG(outputFd_ == nullptr, ERROR_FAIL, "output video create failde.");
+
+    tempFd_ = GetFileFd(requestId, O_RDONLY, TEMP_TAG);
+    DP_CHECK_ERROR_RETURN_RET_LOG(tempFd_ == nullptr, ERROR_FAIL, "temp video create failde.");
+
+    auto ret = mediaManager_->Create(inputFd->GetFd(), outputFd_->GetFd(), tempFd_->GetFd());
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != OK, ERROR_FAIL, "media manager create failde.");
+
+    mediaManager_->GetMediaInfo(mediaInfo_);
+    DP_CHECK_ERROR_RETURN_RET_LOG(InitVideoCodec() != OK, ERROR_FAIL, "init video codec failde.");
+
+    isRunning_.store(true);
+    return OK;
+}
+
+MediaManagerError MpegManager::UnInit(const MediaResult result)
+{
+    DP_DEBUG_LOG("entered.");
+    DP_CHECK_RETURN_RET(!isRunning_.load(), OK);
+    result_ = result;
+    if (result == MediaResult::PAUSE) {
+        if (mediaManager_->Pause() == PAUSE_ABNORMAL) {
+            remove(outPath_.c_str());
+        }
+    } else {
+        mediaManager_->Stop();
+    }
+    UnInitVideoCodec();
+    isRunning_.store(false);
+    return OK;
+}
+
+sptr<Surface> MpegManager::GetSurface()
+{
+    return codecSurface_;
+}
+
+uint64_t MpegManager::GetProcessTimeStamp()
+{
+    DP_CHECK_RETURN_RET(mediaInfo_->recoverTime < DEFAULT_TIME_TAMP, DEFAULT_TIME_TAMP);
+    return static_cast<uint64_t>(mediaInfo_->recoverTime);
+}
+
+MediaManagerError MpegManager::NotifyEnd()
+{
+    auto ret = encoder_->NotifyEos();
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != static_cast<int32_t>(OK), ERROR_FAIL, "video codec notify end failde.");
+    return OK;
+}
+
+MediaManagerError MpegManager::ReleaseBuffer(uint32_t index)
+{
+    auto ret = encoder_->ReleaseOutputBuffer(index);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != static_cast<int32_t>(OK), ERROR_FAIL, "video codec release buffer failde.");
+    return OK;
+}
+
+sptr<IPCFileDescriptor> MpegManager::GetResultFd()
+{
+    return outputFd_;
+}
+
+MediaManagerError MpegManager::InitVideoCodec()
+{
+    DP_INFO_LOG("entered.");
+    auto codecInfo = mediaInfo_->codecInfo;
+    encoder_ = VideoEncoderFactory::CreateByMime(codecInfo.mimeType);
+    DP_CHECK_ERROR_RETURN_RET_LOG(encoder_ == nullptr, ERROR_FAIL, "video codec create failde.");
+
+    auto callback = std::make_shared<VideoCodecCallback>(weak_from_this());
+    auto ret = encoder_->SetCallback(callback);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != static_cast<int32_t>(OK), ERROR_FAIL, "video codec set callback failde.");
+
+    Format videoFormat;
+    if (codecInfo.mimeType == MINE_VIDEO_HEVC) {
+        videoFormat.PutIntValue(Tag::VIDEO_COLOR_RANGE, static_cast<int32_t>(codecInfo.colorRange));
+        videoFormat.PutIntValue(Tag::VIDEO_COLOR_PRIMARIES, static_cast<int32_t>(codecInfo.colorPrimary));
+        videoFormat.PutIntValue(Tag::VIDEO_COLOR_TRC, static_cast<int32_t>(codecInfo.colorTransferCharacter));
+        videoFormat.PutIntValue(Tag::MEDIA_LEVEL, codecInfo.level);
+        videoFormat.PutIntValue(Tag::MEDIA_PROFILE, codecInfo.profile);
+    }
+    videoFormat.PutIntValue(Tag::VIDEO_ENCODE_BITRATE_MODE, codecInfo.bitMode);
+    videoFormat.PutIntValue(Tag::VIDEO_PIXEL_FORMAT, static_cast<int32_t>(PixelFormat::PIX_FMT_NV12));
+    videoFormat.PutStringValue(Tag::MIME_TYPE, codecInfo.mimeType);
+    videoFormat.PutLongValue(Tag::MEDIA_BITRATE, codecInfo.bitRate);
+    videoFormat.PutDoubleValue(Tag::VIDEO_FRAME_RATE, codecInfo.fps);
+    videoFormat.PutIntValue(Tag::VIDEO_WIDTH, codecInfo.width);
+    videoFormat.PutIntValue(Tag::VIDEO_HEIGHT, codecInfo.height);
+    videoFormat.PutIntValue(Tag::VIDEO_ROTATION, codecInfo.rotation);
+    videoFormat.PutLongValue(Tag::MEDIA_DURATION, codecInfo.duration);
+
+    ret = encoder_->Configure(videoFormat);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != static_cast<int32_t>(OK), ERROR_FAIL,
+        "video codec configure failde, ret: %{public}d.", ret);
+
+    codecSurface_ = encoder_->CreateInputSurface();
+    ret = encoder_->Prepare();
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != static_cast<int32_t>(OK), ERROR_FAIL, "video codec prepare failde.");
+
+    ret = encoder_->Start();
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != static_cast<int32_t>(OK), ERROR_FAIL, "video codec start failde.");
+
+    return OK;
+}
+
+void MpegManager::UnInitVideoCodec()
+{
+    DP_DEBUG_LOG("entered.");
+    if (isRunning_) {
+        encoder_->Stop();
+    }
+    encoder_->Release();
+    encoder_ = nullptr;
+}
+
+void MpegManager::OnBufferAvailable(uint32_t index, const std::shared_ptr<AVBuffer>& buffer)
+{
+    DP_DEBUG_LOG("OnBufferAvailable: dts: %{public}ld, duration: %{public}ld", buffer->dts_, buffer->duration_);
+    auto ret = mediaManager_->WriteSample(TrackType::AV_KEY_VIDEO_TYPE, buffer);
+    DP_CHECK_ERROR_RETURN_LOG(ret != OK, "video codec write failde.");
+    ret = ReleaseBuffer(index);
+    DP_CHECK_ERROR_RETURN_LOG(ret != OK, "video codec release buffer failde.");
+}
+
+sptr<IPCFileDescriptor> MpegManager::GetFileFd(const std::string& requestId, int flags, const std::string& tag)
+{
+    std::string path = PATH + requestId + tag;
+    if (tag == TEMP_TAG) {
+        tempPath_ = path;
+    } else {
+        outPath_ = path;
+    }
+    DP_DEBUG_LOG("GetFileFd path: %{public}s", path.c_str());
+    int fd = open(path.c_str(), flags, S_IRUSR | S_IWUSR);
+    return sptr<IPCFileDescriptor>::MakeSptr(fd);
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/media_manager/mpeg_manager_factory.cpp b/services/deferred_processing_service/src/media_manager/mpeg_manager_factory.cpp
new file mode 100644
index 000000000..25ef58c88
--- /dev/null
+++ b/services/deferred_processing_service/src/media_manager/mpeg_manager_factory.cpp
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "mpeg_manager_factory.h"
+
+#include "dp_log.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+MpegManagerFactory::MpegManagerFactory()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+MpegManagerFactory::~MpegManagerFactory()
+{
+    DP_DEBUG_LOG("entered.");
+    mpegManager_ = nullptr;
+}
+
+std::shared_ptr<MpegManager> MpegManagerFactory::Acquire(const std::string& requestId,
+    const sptr<IPCFileDescriptor>& inputFd)
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    if (mpegManager_ != nullptr) {
+        if (requestId == requestId_) {
+            refCount_++;
+            return mpegManager_;
+        }
+        DP_DEBUG_LOG("requestId changed, reinitializing MpegManager.");
+        mpegManager_.reset();
+    }
+    DP_CHECK_ERROR_RETURN_RET_LOG(inputFd == nullptr, nullptr, "inputFd is nullptr.");
+
+    mpegManager_ = std::make_shared<MpegManager>();
+    if (mpegManager_->Init(requestId, inputFd) != OK) {
+        DP_ERR_LOG("Failed to initialize MpegManager.");
+        mpegManager_.reset();
+        return nullptr;
+    }
+
+    DP_INFO_LOG("Initialized MpegManager successfully.");
+    requestId_ = requestId;
+    refCount_ = 1;
+    return mpegManager_;
+}
+
+void MpegManagerFactory::Release(std::shared_ptr<MpegManager>& mpegManager)
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    DP_CHECK_ERROR_RETURN_LOG(mpegManager != mpegManager_, "MpegManager does not match, release failed.");
+
+    if (--refCount_ == 0) {
+        DP_INFO_LOG("Destroying mpegManager.");
+        if (mpegManager_ != nullptr) {
+            mpegManager_->UnInit(MediaResult::FAIL);
+        }
+        mpegManager_.reset();
+    }
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/media_manager/muxer.cpp b/services/deferred_processing_service/src/media_manager/muxer.cpp
new file mode 100644
index 000000000..d1973f5a6
--- /dev/null
+++ b/services/deferred_processing_service/src/media_manager/muxer.cpp
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "muxer.h"
+
+#include "dp_log.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+namespace {
+    constexpr int32_t INVALID_TRACK_ID = -1;
+}
+
+Muxer::~Muxer()
+{
+    DP_DEBUG_LOG("entered.");
+    muxer_ = nullptr;
+}
+
+MediaManagerError Muxer::Create(int32_t outputFd, Plugins::OutputFormat format)
+{
+    DP_DEBUG_LOG("entered.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(outputFd == INVALID_FD, ERROR_FAIL, "outputFd is invalid: %{public}d.", outputFd);
+
+    muxer_ = AVMuxerFactory::CreateAVMuxer(outputFd, format);
+    DP_CHECK_ERROR_RETURN_RET_LOG(muxer_ == nullptr, ERROR_FAIL, "create avmuxer failed.");
+
+    return OK;
+}
+
+MediaManagerError Muxer::AddTracks(const std::map<TrackType, const std::shared_ptr<Track>>& trackMap)
+{
+    DP_DEBUG_LOG("entered.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(trackMap.empty(), ERROR_FAIL, "finvalid track map.");
+
+    auto video = trackMap.at(TrackType::AV_KEY_VIDEO_TYPE);
+    auto ret = muxer_->AddTrack(videoTrackId_, video->GetFormat().format->GetMeta());
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != static_cast<int32_t>(OK), ERROR_FAIL, "add video track failed.");
+
+    auto audio = trackMap.at(TrackType::AV_KEY_AUDIO_TYPE);
+    ret = muxer_->AddTrack(audioTrackId_, audio->GetFormat().format->GetMeta());
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != static_cast<int32_t>(OK), ERROR_FAIL, "add audio track failed.");
+
+    return OK;
+}
+
+MediaManagerError Muxer::WriteStream(TrackType trackType, const std::shared_ptr<AVBuffer>& sample)
+{
+    DP_DEBUG_LOG("entered.");
+    int32_t trackId = INVALID_TRACK_ID;
+    if (trackType == TrackType::AV_KEY_VIDEO_TYPE) {
+        trackId = videoTrackId_;
+    }
+    if (trackType == TrackType::AV_KEY_AUDIO_TYPE) {
+        trackId = audioTrackId_;
+    }
+    DP_CHECK_ERROR_RETURN_RET_LOG(trackId == INVALID_TRACK_ID, ERROR_FAIL, "invalid track id.");
+
+    auto ret = muxer_->WriteSample(trackId, sample);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != static_cast<int32_t>(OK), ERROR_FAIL, "write sample failed.");
+
+    return OK;
+}
+
+MediaManagerError Muxer::Start()
+{
+    DP_DEBUG_LOG("entered.");
+    auto ret = muxer_->Start();
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != static_cast<int32_t>(OK), ERROR_FAIL,
+        "failed to start, ret: %{public}d", ret);
+
+    return OK;
+}
+
+MediaManagerError Muxer::Stop()
+{
+    DP_DEBUG_LOG("entered.");
+    auto ret = muxer_->Stop();
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != static_cast<int32_t>(OK), ERROR_FAIL, "failed to stop, ret: %{public}d", ret);
+
+    return OK;
+}
+MediaManagerError Muxer::AddMediaInfo(const std::shared_ptr<MediaInfo>& mediaInfo)
+{
+    auto param = std::make_shared<Meta>();
+    int32_t rotation = mediaInfo->codecInfo.rotation == -1 ? 0 : mediaInfo->codecInfo.rotation;
+    param->Set<Tag::VIDEO_ROTATION>(static_cast<Plugins::VideoRotation>(rotation));
+    param->Set<Tag::MEDIA_CREATION_TIME>(mediaInfo->creationTime);
+    param->Set<Tag::MEDIA_LATITUDE>(mediaInfo->latitude);
+    param->Set<Tag::MEDIA_LONGITUDE>(mediaInfo->longitude);
+    auto ret = muxer_->SetParameter(param);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != static_cast<int32_t>(OK), ERROR_FAIL,
+        "add param failed, ret: %{public}d", ret);
+
+    auto userMeta = std::make_shared<Meta>();
+    userMeta->SetData(VIDEO_FRAME_COUNT, mediaInfo->codecInfo.numFrames);
+    userMeta->SetData(RECORD_SYSTEM_TIMESTAMP, mediaInfo->recorderTime);
+    ret = muxer_->SetUserMeta(userMeta);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != static_cast<int32_t>(OK), ERROR_FAIL,
+        "add userMeta failed, ret: %{public}d", ret);
+
+    return OK;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
diff --git a/services/deferred_processing_service/src/media_manager/reader.cpp b/services/deferred_processing_service/src/media_manager/reader.cpp
new file mode 100644
index 000000000..9ad61e6a0
--- /dev/null
+++ b/services/deferred_processing_service/src/media_manager/reader.cpp
@@ -0,0 +1,212 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "reader.h"
+
+#include "dp_log.h"
+#include "track_factory.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+namespace {
+    constexpr int32_t DEFAULT_INT_VAL = 0;
+    constexpr double DEFAULT_DOUBLE_VAL = 0.0;
+    constexpr int32_t FPS_30 = 30;
+    constexpr int32_t FPS_60 = 60;
+    constexpr double FACTOR = 1.1;
+}
+
+Reader::~Reader()
+{
+    source_ = nullptr;
+    sourceFormat_ = nullptr;
+    userFormat_ = nullptr;
+    inputDemuxer_ = nullptr;
+    tracks_.clear();
+}
+
+MediaManagerError Reader::Create(int32_t inputFd)
+{
+    DP_DEBUG_LOG("entered.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(inputFd == INVALID_FD, ERROR_FAIL, "inputFd is invalid: %{public}d.", inputFd);
+
+    auto size = lseek(inputFd, DEFAULT_OFFSET, SEEK_END);
+    source_ = MediaAVCodec::AVSourceFactory::CreateWithFD(inputFd, DEFAULT_OFFSET, size);
+    DP_CHECK_ERROR_RETURN_RET_LOG(source_ == nullptr, ERROR_FAIL, "create avsource failed.");
+
+    auto ret = GetSourceFormat();
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != OK, ERROR_FAIL, "get avsource format failed.");
+
+    ret = InitTracksAndDemuxer();
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != OK, ERROR_FAIL, "init tracks and demuxer failed.");
+    return OK;
+}
+
+MediaManagerError Reader::GetSourceFormat()
+{
+    DP_DEBUG_LOG("entered.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(source_ == nullptr, ERROR_FAIL, "avsource is nullptr.");
+
+    Format sourceFormat;
+    auto ret = source_->GetSourceFormat(sourceFormat);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != static_cast<int32_t>(OK), ERROR_FAIL, "get avsource format failed.");
+    sourceFormat_ = std::make_shared<Format>(sourceFormat);
+
+    Format userMeta;
+    ret = source_->GetUserMeta(userMeta);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != static_cast<int32_t>(OK), ERROR_FAIL, "get avsource user meta failed.");
+    userFormat_ = std::make_shared<Format>(userMeta);
+    return OK;
+}
+
+MediaManagerError Reader::InitTracksAndDemuxer()
+{
+    DP_DEBUG_LOG("entered.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(!sourceFormat_->GetIntValue(Tag::MEDIA_TRACK_COUNT, trackCount_), ERROR_FAIL,
+        "get track count failed.");
+
+    for (int32_t index = 0; index < trackCount_; ++index) {
+        auto track = TrackFactory::GetInstance().CreateTrack(source_, index);
+        DP_DEBUG_LOG("track type: %{public}d", track->GetType());
+        tracks_.insert(std::pair(track->GetType(), track));
+    }
+    DP_DEBUG_LOG("trackCount num: %{public}d, trackMap size: %{public}d",
+        trackCount_, static_cast<int32_t>(tracks_.size()));
+    inputDemuxer_ = std::make_shared<Demuxer>();
+    auto ret = inputDemuxer_->Create(source_, tracks_);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != OK, ERROR_FAIL, "audio demuxer init failed.");
+    return OK;
+}
+
+MediaManagerError Reader::Read(TrackType trackType, std::shared_ptr<AVBuffer>& sample)
+{
+    DP_CHECK_ERROR_RETURN_RET_LOG(inputDemuxer_ == nullptr, ERROR_FAIL, "demuxer is nullptr.");
+    auto ret = inputDemuxer_->ReadStream(trackType, sample);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret == ERROR_FAIL, ERROR_FAIL,
+        "read sample failed, track type: %{public}d", trackType);
+    DP_CHECK_RETURN_RET_LOG(ret == EOS, EOS, "reading finished.");
+    return ret;
+}
+
+MediaManagerError Reader::GetMediaInfo(std::shared_ptr<MediaInfo>& mediaInfo)
+{
+    GetSourceMediaInfo(mediaInfo);
+    mediaInfo->streamCount = trackCount_;
+
+    auto it = tracks_.find(TrackType::AV_KEY_VIDEO_TYPE);
+    DP_CHECK_ERROR_RETURN_RET_LOG(it == tracks_.end(), ERROR_FAIL, "no video track.");
+    
+    auto videoFormat = it->second->GetFormat();
+    GetTrackMediaInfo(videoFormat, mediaInfo);
+    return OK;
+}
+
+MediaManagerError Reader::Reset(int64_t resetPts)
+{
+    DP_DEBUG_LOG("entered.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(resetPts < 0, ERROR_FAIL, "invalid reset pts.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(inputDemuxer_ == nullptr, ERROR_FAIL, "demuxer is null.");
+
+    auto ret = inputDemuxer_->SeekToTime(resetPts);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != OK, ERROR_FAIL, "reset pts failed.");
+    return OK;
+}
+
+void Reader::GetSourceMediaInfo(std::shared_ptr<MediaInfo>& mediaInfo) const
+{
+    DP_DEBUG_LOG("entered.");
+    auto ret = sourceFormat_->GetStringValue(Tag::MEDIA_CREATION_TIME, mediaInfo->creationTime);
+    DP_CHECK_ERROR_PRINT_LOG(!ret, "cannot get %{public}s", Tag::MEDIA_CREATION_TIME);
+    ret = sourceFormat_->GetLongValue(Tag::MEDIA_DURATION, mediaInfo->codecInfo.duration);
+    DP_CHECK_ERROR_PRINT_LOG(!ret, "cannot get %{public}s", Tag::MEDIA_DURATION);
+    ret = sourceFormat_->GetStringValue(RECORD_SYSTEM_TIMESTAMP, mediaInfo->recorderTime);
+    DP_CHECK_ERROR_PRINT_LOG(!ret, "cannot get %{public}s", RECORD_SYSTEM_TIMESTAMP.c_str());
+    ret = sourceFormat_->GetFloatValue(Tag::MEDIA_LATITUDE, mediaInfo->latitude);
+    DP_CHECK_ERROR_PRINT_LOG(!ret, "cannot get %{public}s", Tag::MEDIA_LATITUDE);
+    ret = sourceFormat_->GetFloatValue(Tag::MEDIA_LONGITUDE, mediaInfo->longitude);
+    DP_CHECK_ERROR_PRINT_LOG(!ret, "cannot get %{public}s", Tag::MEDIA_LONGITUDE);
+}
+
+MediaManagerError Reader::GetTrackMediaInfo(const TrackFormat& trackFormat,
+    std::shared_ptr<MediaInfo>& mediaInfo) const
+{
+    DP_DEBUG_LOG("entered.");
+    auto& format = trackFormat.format;
+    auto ret = format->GetStringValue(Tag::MIME_TYPE, mediaInfo->codecInfo.mimeType);
+    DP_CHECK_ERROR_PRINT_LOG(!ret, "cannot get %{public}s", Tag::MIME_TYPE);
+
+    int32_t intVal {DEFAULT_INT_VAL};
+    ret = format->GetIntValue(Tag::VIDEO_COLOR_RANGE, intVal);
+    DP_CHECK_ERROR_PRINT_LOG(!ret, "cannot get %{public}s", Tag::VIDEO_COLOR_RANGE);
+    if (intVal != DEFAULT_INT_VAL) {
+        mediaInfo->codecInfo.colorRange = static_cast<ColorRange>(intVal);
+    }
+    ret = format->GetIntValue(Tag::VIDEO_PIXEL_FORMAT, intVal);
+    DP_CHECK_ERROR_PRINT_LOG(!ret, "cannot get %{public}s", Tag::VIDEO_PIXEL_FORMAT);
+    if (intVal != DEFAULT_INT_VAL) {
+        mediaInfo->codecInfo.pixelFormat = static_cast<PixelFormat>(intVal);
+    }
+    ret = format->GetIntValue(Tag::VIDEO_COLOR_PRIMARIES, intVal);
+    DP_CHECK_ERROR_PRINT_LOG(!ret, "cannot get %{public}s", Tag::VIDEO_COLOR_PRIMARIES);
+    if (intVal != DEFAULT_INT_VAL) {
+        mediaInfo->codecInfo.colorPrimary = static_cast<ColorPrimaries>(intVal);
+    }
+    ret = format->GetIntValue(Tag::VIDEO_COLOR_TRC, intVal);
+    DP_CHECK_ERROR_PRINT_LOG(!ret, "cannot get %{public}s", Tag::VIDEO_COLOR_TRC);
+    if (intVal != DEFAULT_INT_VAL) {
+        mediaInfo->codecInfo.colorTransferCharacter = static_cast<ColorTransferCharacteristic>(intVal);
+    }
+    ret = format->GetIntValue(Tag::VIDEO_IS_HDR_VIVID,  mediaInfo->codecInfo.isHdrvivid);
+    DP_CHECK_ERROR_PRINT_LOG(!ret, "cannot get %{public}s", Tag::VIDEO_IS_HDR_VIVID);
+    ret = format->GetIntValue(Tag::MEDIA_PROFILE, mediaInfo->codecInfo.profile);
+    DP_CHECK_ERROR_PRINT_LOG(!ret, "cannot get %{public}s", Tag::MEDIA_PROFILE);
+    ret = format->GetIntValue(Tag::MEDIA_LEVEL, mediaInfo->codecInfo.level);
+    DP_CHECK_ERROR_PRINT_LOG(!ret, "cannot get %{public}s", Tag::MEDIA_LEVEL);
+    ret = format->GetIntValue(Tag::VIDEO_WIDTH, mediaInfo->codecInfo.width);
+    DP_CHECK_ERROR_PRINT_LOG(!ret, "cannot get %{public}s", Tag::VIDEO_WIDTH);
+    ret = format->GetIntValue(Tag::VIDEO_HEIGHT, mediaInfo->codecInfo.height);
+    DP_CHECK_ERROR_PRINT_LOG(!ret, "cannot get %{public}s", Tag::VIDEO_HEIGHT);
+    ret = format->GetIntValue(Tag::VIDEO_ROTATION, mediaInfo->codecInfo.rotation);
+    DP_CHECK_ERROR_PRINT_LOG(!ret, "cannot get %{public}s", Tag::VIDEO_ROTATION);
+    ret = format->GetIntValue(Tag::VIDEO_ENCODE_BITRATE_MODE, mediaInfo->codecInfo.bitMode);
+    DP_CHECK_ERROR_PRINT_LOG(!ret, "cannot get %{public}s", Tag::VIDEO_ENCODE_BITRATE_MODE);
+    ret = format->GetLongValue(Tag::MEDIA_BITRATE, mediaInfo->codecInfo.bitRate);
+    DP_CHECK_ERROR_PRINT_LOG(!ret, "cannot get %{public}s", Tag::MEDIA_BITRATE);
+
+    double doubleVal {DEFAULT_DOUBLE_VAL};
+    ret = format->GetDoubleValue(Tag::VIDEO_FRAME_RATE, doubleVal);
+    DP_CHECK_ERROR_PRINT_LOG(!ret, "cannot get %{public}s", Tag::VIDEO_FRAME_RATE);
+    if (doubleVal !=DEFAULT_DOUBLE_VAL) {
+        mediaInfo->codecInfo.fps = FixFPS(doubleVal);
+    }
+
+    DP_DEBUG_LOG("colorRange: %{public}d, pixelFormat: %{public}d, colorPrimary: %{public}d, "
+        "transfer: %{public}d, profile: %{public}d, level: %{public}d, bitRate: %{public}lld, "
+        "fps: %{public}d, rotation: %{public}d, frame count: %{public}d, mime: %{public}s, isHdrvivid: %{public}d",
+        mediaInfo->codecInfo.colorRange, mediaInfo->codecInfo.pixelFormat, mediaInfo->codecInfo.colorPrimary,
+        mediaInfo->codecInfo.colorTransferCharacter, mediaInfo->codecInfo.profile, mediaInfo->codecInfo.level,
+        static_cast<long long>(mediaInfo->codecInfo.bitRate), mediaInfo->codecInfo.fps, mediaInfo->codecInfo.rotation,
+        mediaInfo->codecInfo.numFrames, mediaInfo->codecInfo.mimeType.c_str(), mediaInfo->codecInfo.isHdrvivid);
+    return OK;
+}
+
+inline int32_t Reader::FixFPS(const double fps)
+{
+    return fps < static_cast<double>(FPS_30) * FACTOR ? FPS_30 : FPS_60;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
diff --git a/services/deferred_processing_service/src/media_manager/track.cpp b/services/deferred_processing_service/src/media_manager/track.cpp
new file mode 100644
index 000000000..a5bf4993c
--- /dev/null
+++ b/services/deferred_processing_service/src/media_manager/track.cpp
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "track.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+void Track::SetFormat(const TrackFormat &format, TrackType type)
+{
+    trackFormat_ = format;
+    trackType_ = type;
+}
+
+const TrackFormat& Track::GetFormat()
+{
+    return trackFormat_;
+}
+
+Track::~Track()
+{
+    if (trackFormat_.format != nullptr) {
+        trackFormat_.format = nullptr;
+    }
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
diff --git a/services/deferred_processing_service/src/media_manager/track_factory.cpp b/services/deferred_processing_service/src/media_manager/track_factory.cpp
new file mode 100644
index 000000000..b03f1d192
--- /dev/null
+++ b/services/deferred_processing_service/src/media_manager/track_factory.cpp
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "track_factory.h"
+
+#include "basic_definitions.h"
+#include "dp_log.h"
+#include "media_format.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+TrackFactory::TrackFactory()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+TrackFactory::~TrackFactory()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+std::shared_ptr<Track> TrackFactory::CreateTrack(const std::shared_ptr<AVSource>& source, int trackIndex)
+{
+    DP_DEBUG_LOG("entered.");
+    Format trackFormat;
+    int32_t trackType = -1;
+    auto ret = source->GetTrackFormat(trackFormat, trackIndex);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != static_cast<int32_t>(OK), nullptr, "get track format failed.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(!trackFormat.GetIntValue(Media::Tag::MEDIA_TYPE, trackType),
+        nullptr, "get track type failed.");
+
+    auto track = std::make_shared<Track>();
+    if (static_cast<TrackType>(trackType) == TrackType::AV_KEY_AUDIO_TYPE ||
+        static_cast<TrackType>(trackType) == TrackType::AV_KEY_VIDEO_TYPE) {
+        TrackFormat formatOfIndex;
+        formatOfIndex.format = std::make_shared<Format>(trackFormat);
+        formatOfIndex.trackId = trackIndex;
+        DP_INFO_LOG("track type: %{public}d", trackType);
+        track->SetFormat(formatOfIndex, static_cast<TrackType>(trackType));
+    }
+    return track;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
diff --git a/services/deferred_processing_service/src/media_manager/writer.cpp b/services/deferred_processing_service/src/media_manager/writer.cpp
new file mode 100644
index 000000000..74550e93b
--- /dev/null
+++ b/services/deferred_processing_service/src/media_manager/writer.cpp
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "writer.h"
+
+#include "dp_log.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+Writer::~Writer()
+{
+    outputMuxer_ = nullptr;
+}
+
+MediaManagerError Writer::Create(int32_t outputFd, const std::map<TrackType, const std::shared_ptr<Track>>& trackMap)
+{
+    DP_CHECK_ERROR_RETURN_RET_LOG(outputFd == INVALID_FD, ERROR_FAIL, "outputFd is invalid: %{public}d.", outputFd);
+    DP_CHECK_ERROR_RETURN_RET_LOG(trackMap.empty(), ERROR_FAIL, "finvalid track map.");
+
+    outputFileFd_ = outputFd;
+    outputMuxer_ = std::make_shared<Muxer>();
+    DP_DEBUG_LOG("outputFd: %{public}d, track size: %{public}d",
+        outputFileFd_, static_cast<int32_t>(trackMap.size()));
+    auto ret = outputMuxer_->Create(outputFileFd_, Plugins::OutputFormat::MPEG_4);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != OK, ERROR_FAIL, "create muxer failed.");
+
+    ret = outputMuxer_->AddTracks(trackMap);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != OK, ERROR_FAIL, "add track failed.");
+
+    return ret;
+}
+
+MediaManagerError Writer::Write(TrackType type, const std::shared_ptr<AVBuffer>& sample)
+{
+    DP_DEBUG_LOG("pts: %{public}lld, flag: %{public}d", static_cast<long long>(sample->pts_), sample->flag_);
+    if (sample->memory_ != nullptr) {
+        DP_DEBUG_LOG("sample size: %{public}d", sample->memory_->GetSize());
+    }
+    
+    DP_CHECK_RETURN_RET_LOG(sample->pts_ < lastPause_ && type == TrackType::AV_KEY_VIDEO_TYPE,
+        OK, "drop feame pts: %{public}lld", static_cast<long long>(sample->pts_));
+
+    auto ret = outputMuxer_->WriteStream(type, sample);
+    DP_CHECK_RETURN_RET_LOG(ret != OK, ERROR_FAIL,
+        "write sample failed, type: %{public}d", static_cast<int32_t>(type));
+    return OK;
+}
+
+MediaManagerError Writer::Start()
+{
+    DP_DEBUG_LOG("entered.");
+    DP_CHECK_RETURN_RET(started_, OK);
+    DP_CHECK_ERROR_RETURN_RET_LOG(outputMuxer_ == nullptr, ERROR_FAIL, "failed to start, muxer is nullptr.");
+
+    auto ret = outputMuxer_->Start();
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != OK, ERROR_FAIL, "start failed, ret: %{public}d", ret);
+
+    started_ = true;
+    return OK;
+}
+
+MediaManagerError Writer::Stop()
+{
+    DP_DEBUG_LOG("entered.");
+    auto ret = outputMuxer_->Stop();
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != OK, ERROR_FAIL, "stop failed, ret: %{public}d", ret);
+
+    started_ = false;
+    return OK;
+}
+
+MediaManagerError Writer::AddMediaInfo(const std::shared_ptr<MediaInfo>& mediaInfo)
+{
+    DP_DEBUG_LOG("entered.");
+    auto ret = outputMuxer_->AddMediaInfo(mediaInfo);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != OK, ERROR_FAIL, "add media info failed.");
+    return OK;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
diff --git a/services/deferred_processing_service/src/post_processor/command/service_died_command.cpp b/services/deferred_processing_service/src/post_processor/command/service_died_command.cpp
new file mode 100644
index 000000000..4e8c66e9e
--- /dev/null
+++ b/services/deferred_processing_service/src/post_processor/command/service_died_command.cpp
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "service_died_command.h"
+
+#include "basic_definitions.h"
+#include "dps.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+
+ServiceDiedCommand::ServiceDiedCommand(const int32_t userId) : userId_(userId)
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+ServiceDiedCommand::~ServiceDiedCommand()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+int32_t ServiceDiedCommand::Executing()
+{
+    auto schedulerManager = DPS_GetSchedulerManager();
+    DP_CHECK_ERROR_RETURN_RET_LOG(schedulerManager == nullptr, DP_NULL_POINTER, "SchedulerManager is nullptr.");
+
+    auto controller = schedulerManager->GetVideoController(userId_);
+    controller->HandleServiceDied();
+    return DP_OK;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/post_processor/command/video_process_command.cpp b/services/deferred_processing_service/src/post_processor/command/video_process_command.cpp
new file mode 100644
index 000000000..28a748dad
--- /dev/null
+++ b/services/deferred_processing_service/src/post_processor/command/video_process_command.cpp
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "video_process_command.h"
+
+#include "basic_definitions.h"
+#include "dp_utils.h"
+#include "dps.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+VidoeProcessCommand::VidoeProcessCommand(const int32_t userId) : userId_(userId)
+{
+    DP_DEBUG_LOG("entered. userId: %{public}d", userId_);
+}
+
+VidoeProcessCommand::~VidoeProcessCommand()
+{
+    DP_DEBUG_LOG("entered.");
+    schedulerManager_ = nullptr;
+    controller_ = nullptr;
+}
+
+int32_t VidoeProcessCommand::Initialize()
+{
+    DP_CHECK_RETURN_RET(initialized_.load(), DP_OK);
+    schedulerManager_ = DPS_GetSchedulerManager();
+    DP_CHECK_ERROR_RETURN_RET_LOG(schedulerManager_ == nullptr, DP_NULL_POINTER, "SchedulerManager is nullptr.");
+
+    controller_ = schedulerManager_->GetVideoController(userId_);
+    DP_CHECK_ERROR_RETURN_RET_LOG(controller_ == nullptr, DP_NULL_POINTER, "VideoController is nullptr.");
+    initialized_.store(true);
+    return DP_OK;
+}
+
+VidoeProcessSuccessCommand::VidoeProcessSuccessCommand(const int32_t userId, const DeferredVideoWorkPtr& work)
+    : VidoeProcessCommand(userId),
+      work_(work)
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+VidoeProcessSuccessCommand::~VidoeProcessSuccessCommand()
+{
+    DP_DEBUG_LOG("entered.");
+    work_ = nullptr;
+}
+
+int32_t VidoeProcessSuccessCommand::Executing()
+{
+    if (int32_t ret = Initialize() != DP_OK) {
+        return ret;
+    }
+
+    controller_->HandleSuccess(userId_, work_);
+    return DP_OK;
+}
+
+VidoeProcessFailedCommand::VidoeProcessFailedCommand(const int32_t userId,
+    const DeferredVideoWorkPtr& work, DpsError errorCode)
+    : VidoeProcessCommand(userId),
+      work_(work),
+      error_(errorCode)
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+VidoeProcessFailedCommand::~VidoeProcessFailedCommand()
+{
+    DP_DEBUG_LOG("entered.");
+    work_ = nullptr;
+}
+
+int32_t VidoeProcessFailedCommand::Executing()
+{
+    if (int32_t ret = Initialize() != DP_OK) {
+        return ret;
+    }
+
+    controller_->HandleError(userId_, work_, error_);
+    return DP_OK;
+}
+
+int32_t VidoeStateChangedCommand::Executing()
+{
+    return DP_OK;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/post_processor/photo_post_processor.cpp b/services/deferred_processing_service/src/post_processor/photo_post_processor.cpp
index 3ae0d2f94..291841ac4 100644
--- a/services/deferred_processing_service/src/post_processor/photo_post_processor.cpp
+++ b/services/deferred_processing_service/src/post_processor/photo_post_processor.cpp
@@ -158,7 +158,7 @@ int32_t PhotoPostProcessor::PhotoProcessListener::processBufferInfo(const std::s
     const OHOS::HDI::Camera::V1_2::ImageBufferInfo& buffer)
 {
     auto bufferHandle = buffer.imageHandle->GetBufferHandle();
-    DP_CHECK_AND_RETURN_RET_LOG(bufferHandle != nullptr, DPS_ERROR_IMAGE_PROC_FAILED, "bufferHandle is nullptr.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(bufferHandle == nullptr, DPS_ERROR_IMAGE_PROC_FAILED, "bufferHandle is nullptr.");
 
     int32_t size = bufferHandle->size;
     int32_t isDegradedImage = 0;
@@ -176,11 +176,11 @@ int32_t PhotoPostProcessor::PhotoProcessListener::processBufferInfo(const std::s
     DP_INFO_LOG("bufferHandle param, size: %{public}d, dataSize: %{public}d, isDegradedImage: %{public}d",
         size, static_cast<int>(dataSize), isDegradedImage);
     auto bufferPtr = std::make_shared<SharedBuffer>(dataSize);
-    DP_CHECK_AND_RETURN_RET_LOG(bufferPtr->Initialize() == DP_OK, DPS_ERROR_IMAGE_PROC_FAILED,
+    DP_CHECK_ERROR_RETURN_RET_LOG(bufferPtr->Initialize() != DP_OK, DPS_ERROR_IMAGE_PROC_FAILED,
         "failed to initialize shared buffer.");
 
     auto addr = mmap(nullptr, dataSize, PROT_READ | PROT_WRITE, MAP_SHARED, bufferHandle->fd, 0);
-    DP_CHECK_AND_RETURN_RET_LOG(addr != MAP_FAILED, DPS_ERROR_IMAGE_PROC_FAILED, "failed to mmap shared buffer.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(addr == MAP_FAILED, DPS_ERROR_IMAGE_PROC_FAILED, "failed to mmap shared buffer.");
 
     if (bufferPtr->CopyFrom(static_cast<uint8_t*>(addr), dataSize) == DP_OK) {
         DP_INFO_LOG("bufferPtr fd: %{public}d, fd: %{public}d", bufferHandle->fd, bufferPtr->GetFd());
@@ -372,13 +372,13 @@ std::shared_ptr<Media::Picture> PhotoPostProcessor::PhotoProcessListener::Assemb
             retExifDataSize, exifDataSize);
     }
     auto imageBuffer = TransBufferHandleToSurfaceBuffer(buffer.imageHandle->GetBufferHandle());
-    DP_CHECK_AND_RETURN_RET_LOG(imageBuffer != nullptr, nullptr, "bufferHandle is nullptr.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(imageBuffer == nullptr, nullptr, "bufferHandle is nullptr.");
     DP_INFO_LOG("AssemblePicture ImageBufferInfoExt valid: gainMap(%{public}d), depthMap(%{public}d), "
         "unrefocusMap(%{public}d), linearMap(%{public}d), exif(%{public}d), makeInfo(%{public}d)",
         buffer.isGainMapValid, buffer.isDepthMapValid, buffer.isUnrefocusImageValid,
         buffer.isHighBitDepthLinearImageValid, buffer.isExifValid, buffer.isMakerInfoValid);
     std::shared_ptr<Media::Picture> picture = Media::Picture::Create(imageBuffer);
-    DP_CHECK_AND_RETURN_RET_LOG(picture != nullptr, nullptr, "picture is nullptr.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(picture == nullptr, nullptr, "picture is nullptr.");
     if (buffer.isExifValid) {
         auto exifBuffer = TransBufferHandleToSurfaceBuffer(buffer.exifHandle->GetBufferHandle());
         sptr<BufferExtraData> extraData = new BufferExtraDataImpl();
@@ -429,12 +429,12 @@ int32_t PhotoPostProcessor::PhotoProcessListener::OnProcessDoneExt(
         photoPostProcessor_->OnProcessDoneExt(imageId, bufferInfo);
     } else {
         auto bufferPtr = std::make_shared<SharedBuffer>(dataSize);
-        DP_CHECK_AND_RETURN_RET_LOG(bufferPtr->Initialize() == DP_OK, DPS_ERROR_IMAGE_PROC_FAILED,
+        DP_CHECK_ERROR_RETURN_RET_LOG(bufferPtr->Initialize() != DP_OK, DPS_ERROR_IMAGE_PROC_FAILED,
             "failed to initialize shared buffer.");
 
         auto addr = mmap(nullptr, dataSize, PROT_READ | PROT_WRITE, MAP_SHARED, imageBufferHandle->fd, 0);
-        DP_CHECK_AND_RETURN_RET_LOG(
-            addr != MAP_FAILED, DPS_ERROR_IMAGE_PROC_FAILED, "failed to mmap shared buffer.");
+        DP_CHECK_ERROR_RETURN_RET_LOG(
+            addr == MAP_FAILED, DPS_ERROR_IMAGE_PROC_FAILED, "failed to mmap shared buffer.");
 
         if (bufferPtr->CopyFrom(static_cast<uint8_t*>(addr), dataSize) == DP_OK) {
             DP_INFO_LOG("bufferPtr fd: %{public}d, fd: %{public}d", imageBufferHandle->fd, bufferPtr->GetFd());
@@ -597,7 +597,7 @@ void PhotoPostProcessor::ProcessImage(std::string imageId)
     }
 
     std::lock_guard<std::mutex> lock(mutex_);
-    DP_CHECK_AND_RETURN_LOG(session_ != nullptr, "PhotoPostProcessor::ProcessImage imageProcessSession is nullptr");
+    DP_CHECK_ERROR_RETURN_LOG(session_ == nullptr, "PhotoPostProcessor::ProcessImage imageProcessSession is nullptr");
     int32_t ret = session_->ProcessImage(imageId);
     DP_INFO_LOG("processImage, ret: %{public}d", ret);
     uint32_t callbackHandle;
@@ -770,7 +770,7 @@ bool PhotoPostProcessor::ConnectServiceIfNecessary()
     removeNeededList_.clear();
     const sptr<IRemoteObject>& remote =
         OHOS::HDI::hdi_objcast<OHOS::HDI::Camera::V1_2::IImageProcessSession>(session_);
-    DP_CHECK_AND_RETURN_RET_LOG(remote->AddDeathRecipient(sessionDeathRecipient_),
+    DP_CHECK_ERROR_RETURN_RET_LOG(!remote->AddDeathRecipient(sessionDeathRecipient_),
         false, "AddDeathRecipient for ImageProcessSession failed.");
     OnStateChanged(HdiStatus::HDI_READY);
     return true;
@@ -779,7 +779,7 @@ bool PhotoPostProcessor::ConnectServiceIfNecessary()
 void PhotoPostProcessor::DisconnectServiceIfNecessary()
 {
     std::lock_guard<std::mutex> lock(mutex_);
-    DP_CHECK_AND_RETURN_LOG(session_ != nullptr, "imageProcessSession is nullptr");
+    DP_CHECK_ERROR_RETURN_LOG(session_ == nullptr, "imageProcessSession is nullptr");
     const sptr<IRemoteObject> &remote =
         OHOS::HDI::hdi_objcast<OHOS::HDI::Camera::V1_2::IImageProcessSession>(session_);
     DP_CHECK_ERROR_PRINT_LOG(!remote->RemoveDeathRecipient(sessionDeathRecipient_),
@@ -807,7 +807,7 @@ void PhotoPostProcessor::ScheduleConnectService()
 void PhotoPostProcessor::StopTimer(const std::string& imageId)
 {
     uint32_t callbackHandle;
-    DP_CHECK_AND_RETURN_LOG(imageId2Handle_.Find(imageId, callbackHandle),
+    DP_CHECK_ERROR_RETURN_LOG(!imageId2Handle_.Find(imageId, callbackHandle),
         "stoptimer failed not find imageId: %{public}s", imageId.c_str());
     imageId2Handle_.Erase(imageId);
     GetGlobalWatchdog().StopMonitor(callbackHandle);
diff --git a/services/deferred_processing_service/src/post_processor/video_post_processor.cpp b/services/deferred_processing_service/src/post_processor/video_post_processor.cpp
new file mode 100644
index 000000000..c20383350
--- /dev/null
+++ b/services/deferred_processing_service/src/post_processor/video_post_processor.cpp
@@ -0,0 +1,479 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "video_post_processor.h"
+
+#include <sys/sendfile.h>
+#include <sys/stat.h>
+
+#include "dp_log.h"
+#include "dp_timer.h"
+#include "dps.h"
+#include "dps_event_report.h"
+#include "events_monitor.h"
+#include "hdf_device_class.h"
+#include "iproxy_broker.h"
+#include "iservmgr_hdi.h"
+#include "mpeg_manager_factory.h"
+#include "service_died_command.h"
+#include "video_process_command.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+namespace {
+    const std::string VIDEO_SERVICE_NAME = "camera_video_process_service";
+    constexpr uint32_t MAX_PROC_TIME_MS = 20 * 60 * 1000;
+}
+
+class VideoPostProcessor::VideoServiceListener : public HDI::ServiceManager::V1_0::ServStatListenerStub {
+public:
+    using StatusCallback = std::function<void(const HDI::ServiceManager::V1_0::ServiceStatus&)>;
+    explicit VideoServiceListener(const std::weak_ptr<VideoPostProcessor>& processor) : processor_(processor)
+    {
+    }
+
+    void OnReceive(const HDI::ServiceManager::V1_0::ServiceStatus& status)
+    {
+        auto process = processor_.lock();
+        DP_CHECK_ERROR_RETURN_LOG(process == nullptr, "post process is nullptr.");
+        process->OnServiceChange(status);
+    }
+
+private:
+    std::weak_ptr<VideoPostProcessor> processor_;
+};
+
+class VideoPostProcessor::SessionDeathRecipient : public IRemoteObject::DeathRecipient {
+public:
+    explicit SessionDeathRecipient(const std::weak_ptr<VideoPostProcessor>& processor) : processor_(processor)
+    {
+    }
+
+    void OnRemoteDied(const wptr<IRemoteObject> &remote) override
+    {
+        DP_ERR_LOG("Remote died.");
+        auto process = processor_.lock();
+        DP_CHECK_ERROR_RETURN_LOG(process == nullptr, "post process is nullptr.");
+        process->OnSessionDied();
+    }
+
+private:
+    std::weak_ptr<VideoPostProcessor> processor_;
+};
+
+class VideoPostProcessor::VideoProcessListener : public OHOS::HDI::Camera::V1_3::IVideoProcessCallback {
+public:
+    explicit VideoProcessListener(const std::weak_ptr<VideoPostProcessor>& processor) : processor_(processor)
+    {
+    }
+
+    int32_t OnStatusChanged(OHOS::HDI::Camera::V1_2::SessionStatus status) override;
+    int32_t OnProcessDone(const std::string& videoId) override;
+    int32_t OnError(const std::string& videoId, OHOS::HDI::Camera::V1_2::ErrorCode errorCode) override;
+    void ReportEvent(const std::string& videoId);
+
+private:
+    std::weak_ptr<VideoPostProcessor> processor_;
+};
+
+int32_t VideoPostProcessor::VideoProcessListener::OnStatusChanged(OHOS::HDI::Camera::V1_2::SessionStatus status)
+{
+    DP_DEBUG_LOG("entered");
+    auto process = processor_.lock();
+    DP_CHECK_ERROR_RETURN_RET_LOG(process == nullptr, DP_ERR, "post process is nullptr.");
+    return DP_OK;
+}
+
+int32_t VideoPostProcessor::VideoProcessListener::OnProcessDone(const std::string& videoId)
+{
+    DP_INFO_LOG("entered, videoId: %{public}s", videoId.c_str());
+    auto process = processor_.lock();
+    DP_CHECK_ERROR_RETURN_RET_LOG(process == nullptr, DP_ERR, "post process is nullptr.");
+    process->OnProcessDone(videoId);
+    return DP_OK;
+}
+
+int32_t VideoPostProcessor::VideoProcessListener::OnError(const std::string& videoId,
+    OHOS::HDI::Camera::V1_2::ErrorCode errorCode)
+{
+    DP_INFO_LOG("entered, videoId: %{public}s, error: %{public}d", videoId.c_str(), errorCode);
+    auto process = processor_.lock();
+    DP_CHECK_ERROR_RETURN_RET_LOG(process == nullptr, DP_ERR, "post process is nullptr.");
+    process->OnError(videoId, process->MapHdiError(errorCode));
+    return DP_OK;
+}
+
+VideoPostProcessor::VideoPostProcessor(const int32_t userId)
+    : userId_(userId), serviceListener_(nullptr), sessionDeathRecipient_(nullptr), processListener_(nullptr)
+{
+    DP_DEBUG_LOG("entered");
+}
+
+VideoPostProcessor::~VideoPostProcessor()
+{
+    DP_DEBUG_LOG("entered");
+    DisconnectService();
+    SetVideoSession(nullptr);
+    mpegManager_ = nullptr;
+    serviceListener_ = nullptr;
+    sessionDeathRecipient_ = nullptr;
+    processListener_ = nullptr;
+    allStreamInfo_.clear();
+    videoId2Handle_.Clear();
+}
+
+void VideoPostProcessor::Initialize()
+{
+    DP_DEBUG_LOG("entered");
+    sessionDeathRecipient_ = sptr<SessionDeathRecipient>::MakeSptr(weak_from_this());
+    processListener_ = sptr<VideoProcessListener>::MakeSptr(weak_from_this());
+    ConnectService();
+}
+
+bool VideoPostProcessor::GetPendingVideos(std::vector<std::string>& pendingVideos)
+{
+    auto session = GetVideoSession();
+    DP_CHECK_ERROR_RETURN_RET_LOG(session == nullptr, false, "video session is nullptr.");
+    int32_t ret = session->GetPendingVideos(pendingVideos);
+    DP_INFO_LOG("GetPendingVideos size: %{public}d, ret: %{public}d",
+        static_cast<int32_t>(pendingVideos.size()), ret);
+    return ret == DP_OK;
+}
+
+void VideoPostProcessor::SetExecutionMode(ExecutionMode executionMode)
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+void VideoPostProcessor::SetDefaultExecutionMode()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+void VideoPostProcessor::ProcessRequest(const DeferredVideoWorkPtr& work)
+{
+    auto session = GetVideoSession();
+    auto videoId = work->GetDeferredVideoJob()->GetVideoId();
+    if (session == nullptr) {
+        DP_ERR_LOG("failed to process videoId: %{public}s, video session is nullptr", videoId.c_str());
+        OnError(videoId, DpsError::DPS_ERROR_SESSION_NOT_READY_TEMPORARILY);
+        return;
+    }
+
+    auto inFd = work->GetDeferredVideoJob()->GetInputFd();
+    DP_CHECK_ERROR_RETURN_LOG(!StartMpeg(videoId, inFd), "mpeg start failed.");
+    DP_CHECK_ERROR_RETURN_LOG(!PrepareStreams(videoId, inFd->GetFd()), "prepaer video failed.");
+
+    StartTimer(videoId, work);
+    auto startTime = mpegManager_->GetProcessTimeStamp();
+    auto ret = session->ProcessVideo(videoId, startTime);
+    DP_INFO_LOG("process video to ive, videoId: %{public}s, startTime: %{public}lu, ret: %{public}d",
+        videoId.c_str(), startTime, ret);
+}
+
+void VideoPostProcessor::RemoveRequest(const std::string& videoId)
+{
+    auto session = GetVideoSession();
+    DP_CHECK_ERROR_RETURN_LOG(session == nullptr,
+        "remove videoId: %{public}s failed, video session is nullptr.", videoId.c_str());
+    std::string path = PATH + videoId + OUT_TAG;
+    DP_CHECK_ERROR_PRINT_LOG(remove(path.c_str()) != 0, "Failed to remove file at path: %{public}s", path.c_str());
+    auto ret = session->RemoveVideo(videoId);
+    DP_INFO_LOG("remove video to ive, videoId: %{public}s, ret: %{public}d", videoId.c_str(), ret);
+    // DPSEventReport::GetInstance().UpdateRemoveTime(imageId, userId_);
+}
+
+void VideoPostProcessor::PauseRequest(const std::string& videoId, const ScheduleType& type)
+{
+    auto session = GetVideoSession();
+    DP_CHECK_ERROR_RETURN_LOG(session == nullptr, "video session is nullptr.");
+
+    int32_t ret = session->Interrupt();
+    DP_INFO_LOG("interrupt video to ive, videoId: %{public}s, ret: %{public}d", videoId.c_str(), ret);
+    // DPSEventReport::GetInstance().UpdateRemoveTime(imageId, userId_);
+}
+
+bool VideoPostProcessor::PrepareStreams(const std::string& videoId, const int inputFd)
+{
+    auto session = GetVideoSession();
+    DP_CHECK_ERROR_RETURN_RET_LOG(session == nullptr, false, "video session is nullptr.");
+    allStreamInfo_.clear();
+    std::vector<StreamDescription> streamDescs;
+    auto ret = session->Prepare(videoId, inputFd, streamDescs);
+    DP_INFO_LOG("prepare videoId: %{public}s, stream size: %{public}d, ret: %{public}d", videoId.c_str(),
+        static_cast<int32_t>(streamDescs.size()), ret);
+    for (const auto& stream : streamDescs) {
+        DP_INFO_LOG("streamId: %{public}d, stream type: %{public}d", stream.streamId, stream.type);
+        if (stream.type == 0) {
+            auto producer = sptr<BufferProducerSequenceable>::MakeSptr(mpegManager_->GetSurface()->GetProducer());
+            SetStreamInfo(stream, producer);
+        }
+    }
+
+    DP_INFO_LOG("prepare videoId: %{public}s, allStreamInfo size: %{public}d", videoId.c_str(),
+        static_cast<int32_t>(allStreamInfo_.size()));
+    DP_CHECK_ERROR_RETURN_RET_LOG(allStreamInfo_.empty(), false, "allStreamInfo is null.");
+    ret = session->CreateStreams(allStreamInfo_);
+    DP_INFO_LOG("create streams videoId: %{public}s, ret: %{public}d", videoId.c_str(), ret);
+    std::vector<uint8_t> modeSetting;
+    ret = session->CommitStreams(modeSetting);
+    DP_INFO_LOG("commit streams videoId: %{public}s, ret: %{public}d", videoId.c_str(), ret);
+    return true;
+}
+
+void VideoPostProcessor::CreateSurface(const std::string& name, const StreamDescription& stream,
+    sptr<Surface>& surface)
+{
+    DP_INFO_LOG("entered, create %{public}s surface.", name.c_str());
+    surface = Surface::CreateSurfaceAsConsumer(name);
+    surface->SetDefaultUsage(BUFFER_USAGE_VIDEO_ENCODER);
+    surface->SetDefaultWidthAndHeight(stream.width, stream.height);
+    auto producer = sptr<BufferProducerSequenceable>::MakeSptr(surface->GetProducer());
+    SetStreamInfo(stream, producer);
+}
+
+void VideoPostProcessor::SetStreamInfo(const StreamDescription& stream, sptr<BufferProducerSequenceable>& producer)
+{
+    StreamInfo_V1_1 streamInfo;
+    streamInfo.v1_0.intent_ = HDI::Camera::V1_0::VIDEO;
+    streamInfo.v1_0.tunneledMode_ = true;
+    streamInfo.v1_0.streamId_ = stream.streamId;
+    streamInfo.v1_0.width_ = stream.width;
+    streamInfo.v1_0.height_ = stream.height;
+    streamInfo.v1_0.format_ = stream.pixelFormat;
+    streamInfo.v1_0.dataspace_ = stream.dataspace;
+    streamInfo.v1_0.bufferQueue_ = producer;
+    allStreamInfo_.emplace_back(streamInfo);
+}
+
+bool VideoPostProcessor::StartMpeg(const std::string& videoId, const sptr<IPCFileDescriptor>& inputFd)
+{
+    mpegManager_ = MpegManagerFactory::GetInstance().Acquire(videoId, inputFd);
+    DP_CHECK_ERROR_RETURN_RET_LOG(mpegManager_ == nullptr, false, "mpeg manager is nullptr.");
+    return true;
+}
+
+bool VideoPostProcessor::StopMpeg(const MediaResult result, const DeferredVideoWorkPtr& work)
+{
+    DP_CHECK_ERROR_RETURN_RET_LOG(mpegManager_ == nullptr, false, "mpeg manager is nullptr.");
+    mpegManager_->UnInit(result);
+
+    bool ret = true;
+    if (result == MediaResult::SUCCESS) {
+        auto tempFd = mpegManager_->GetResultFd()->GetFd();
+        auto outFd = work->GetDeferredVideoJob()->GetOutputFd()->GetFd();
+        auto videoId = work->GetDeferredVideoJob()->GetVideoId();
+        DP_INFO_LOG("video process done, videoId: %{public}s, tempFd: %{public}d, outFd: %{public}d",
+            videoId.c_str(), tempFd, outFd);
+        copyFileByFd(tempFd, outFd);
+        if (IsFileEmpty(outFd)) {
+            DP_ERR_LOG("videoId: %{public}s size is empty.", videoId.c_str());
+            OnError(videoId, DPS_ERROR_VIDEO_PROC_FAILED);
+            ret = false;
+        }
+    }
+    ReleaseMpeg();
+    return ret;
+}
+
+void VideoPostProcessor::ReleaseMpeg()
+{
+    MpegManagerFactory::GetInstance().Release(mpegManager_);
+    mpegManager_.reset();
+    DP_INFO_LOG("release mpeg success.");
+}
+
+void VideoPostProcessor::StartTimer(const std::string& videoId, const DeferredVideoWorkPtr& work)
+{
+    uint32_t timeId = DpsTimer::GetInstance().StartTimer([&, videoId]() {OnTimerOut(videoId);}, MAX_PROC_TIME_MS);
+    work->SetTimeId(timeId);
+    DP_INFO_LOG("DpsTimer start, videoId: %{public}s, timeId: %{public}u", videoId.c_str(), timeId);
+    videoId2Handle_.Insert(videoId, work);
+}
+
+void VideoPostProcessor::StopTimer(const std::string& videoId)
+{
+    DeferredVideoWorkPtr work;
+    DP_CHECK_RETURN(!videoId2Handle_.Find(videoId, work));
+    
+    auto timeId = work->GetTimeId();
+    DP_INFO_LOG("DpsTimer stop, videoId: %{public}s, timeId: %{public}u", videoId.c_str(), timeId);
+    DpsTimer::GetInstance().StopTimer(timeId);
+    auto session = GetVideoSession();
+    DP_CHECK_ERROR_RETURN_LOG(session == nullptr,
+        "release videoId: %{public}s failed, video session is nullptr.", videoId.c_str());
+
+    auto ret = session->ReleaseStreams(allStreamInfo_);
+    allStreamInfo_.clear();
+    DP_INFO_LOG("release streams videoId: %{public}s, ret: %{public}d", videoId.c_str(), ret);
+}
+
+DeferredVideoWorkPtr VideoPostProcessor::GetRunningWork(const std::string& videoId)
+{
+    DeferredVideoWorkPtr work;
+    videoId2Handle_.Find(videoId, work);
+    return work;
+}
+
+void VideoPostProcessor::OnSessionDied()
+{
+    DP_ERR_LOG("entered, session died!");
+    SetVideoSession(nullptr);
+
+    std::vector<std::string> crashJobs;
+    videoId2Handle_.Iterate([&](const std::string& videoId, const DeferredVideoWorkPtr& work) {
+        crashJobs.emplace_back(work->GetDeferredVideoJob()->GetVideoId());
+    });
+    for (const auto& id : crashJobs) {
+        OnError(id, DPS_ERROR_VIDEO_PROC_INTERRUPTED);
+    }
+    crashJobs.clear();
+    auto ret = DPS_SendCommand<ServiceDiedCommand>(userId_);
+    DP_CHECK_ERROR_PRINT_LOG(ret != DP_OK, "failed. ret: %{public}d", ret);
+}
+
+void VideoPostProcessor::OnProcessDone(const std::string& videoId)
+{
+    auto work = GetRunningWork(videoId);
+    DP_CHECK_ERROR_RETURN_LOG(work == nullptr, "not find running video work.");
+    StopTimer(videoId);
+    DP_CHECK_ERROR_RETURN_LOG(!StopMpeg(MediaResult::SUCCESS, work), "success: mpeg stop failed.");
+    
+    auto ret = DPS_SendCommand<VidoeProcessSuccessCommand>(userId_, work);
+    DP_CHECK_ERROR_RETURN_LOG(ret != DP_OK,
+        "process success videoId: %{public}s failed. ret: %{public}d", videoId.c_str(), ret);
+    videoId2Handle_.Erase(videoId);
+}
+
+void VideoPostProcessor::OnError(const std::string& videoId, DpsError errorCode)
+{
+    auto work = GetRunningWork(videoId);
+    StopTimer(videoId);
+    DP_CHECK_ERROR_RETURN_LOG(work == nullptr, "no running video work.");
+
+    if (errorCode == DPS_ERROR_VIDEO_PROC_INTERRUPTED) {
+        DP_CHECK_ERROR_RETURN_LOG(!StopMpeg(MediaResult::PAUSE, work), "pause: mpeg stop failed.");
+    } else {
+        DP_CHECK_ERROR_RETURN_LOG(!StopMpeg(MediaResult::FAIL, work), "error or outtime: mpeg stop failed.");
+    }
+
+    DP_INFO_LOG("video process error, videoId: %{public}s, error: %{public}d", videoId.c_str(), errorCode);
+    auto ret = DPS_SendCommand<VidoeProcessFailedCommand>(userId_, work, errorCode);
+    DP_CHECK_ERROR_RETURN_LOG(ret != DP_OK,
+        "process error videoId: %{public}s failed. ret: %{public}d", videoId.c_str(), ret);
+    videoId2Handle_.Erase(videoId);
+}
+
+void VideoPostProcessor::OnStateChanged(HdiStatus hdiStatus)
+{
+    DP_INFO_LOG("entered, HdiStatus: %{public}d", hdiStatus);
+    EventsMonitor::GetInstance().NotifyImageEnhanceStatus(hdiStatus);
+}
+
+void VideoPostProcessor::OnTimerOut(const std::string& videoId)
+{
+    DP_INFO_LOG("DpsTimer executed, videoId: %{public}s", videoId.c_str());
+    OnError(videoId, DpsError::DPS_ERROR_IMAGE_PROC_TIMEOUT);
+}
+
+void VideoPostProcessor::ConnectService()
+{
+    auto svcMgr = HDI::ServiceManager::V1_0::IServiceManager::Get();
+    DP_CHECK_ERROR_RETURN_LOG(svcMgr == nullptr, "IServiceManager init failed.");
+
+    serviceListener_ = sptr<VideoServiceListener>::MakeSptr(weak_from_this());
+    auto ret  = svcMgr->RegisterServiceStatusListener(serviceListener_, DEVICE_CLASS_DEFAULT);
+    DP_CHECK_ERROR_RETURN_LOG(ret != 0, "RegisterServiceStatusListener failed.");
+}
+
+void VideoPostProcessor::DisconnectService()
+{
+    auto session = GetVideoSession();
+    DP_CHECK_ERROR_PRINT_LOG(session == nullptr, "video session is nullptr.");
+
+    const sptr<IRemoteObject> &remote = OHOS::HDI::hdi_objcast<IVideoProcessSession>(session);
+    bool result = remote->RemoveDeathRecipient(sessionDeathRecipient_);
+    DP_CHECK_ERROR_PRINT_LOG(!result, "remove DeathRecipient for VideoProcessSession failed.");
+
+    auto svcMgr = HDI::ServiceManager::V1_0::IServiceManager::Get();
+    DP_CHECK_ERROR_RETURN_LOG(svcMgr == nullptr, "IServiceManager init failed.");
+
+    auto ret  = svcMgr->UnregisterServiceStatusListener(serviceListener_);
+    DP_CHECK_ERROR_RETURN_LOG(ret != 0, "RegisterServiceStatusListener failed.");
+}
+
+void VideoPostProcessor::OnServiceChange(const HDI::ServiceManager::V1_0::ServiceStatus& status)
+{
+    DP_CHECK_RETURN(status.serviceName != VIDEO_SERVICE_NAME);
+    DP_CHECK_RETURN_LOG(status.status != HDI::ServiceManager::V1_0::SERVIE_STATUS_START,
+        "video service state: %{public}d", status.status);
+    DP_CHECK_RETURN(GetVideoSession() != nullptr);
+    
+    sptr<HDI::Camera::V1_3::IVideoProcessService> proxy =
+        HDI::Camera::V1_3::IVideoProcessService::Get(status.serviceName);
+    DP_CHECK_ERROR_RETURN_LOG(proxy == nullptr, "get VideoProcessService failed.");
+
+    sptr<IVideoProcessSession> session;
+    proxy->CreateVideoProcessSession(userId_, processListener_, session);
+    DP_CHECK_ERROR_RETURN_LOG(session == nullptr, "get VideoProcessSession failed.");
+
+    const sptr<IRemoteObject> &remote = OHOS::HDI::hdi_objcast<IVideoProcessSession>(session);
+    bool result = remote->AddDeathRecipient(sessionDeathRecipient_);
+    DP_CHECK_ERROR_RETURN_LOG(!result, "add DeathRecipient for VideoProcessSession failed.");
+    
+    SetVideoSession(session);
+    OnStateChanged(HdiStatus::HDI_READY);
+}
+
+void VideoPostProcessor::copyFileByFd(const int srcFd, const int dstFd)
+{
+    struct stat buffer;
+    DP_CHECK_ERROR_RETURN_LOG(fstat(srcFd, &buffer) == -1,
+        "get out fd status failed, err: %{public}s", std::strerror(errno));
+
+    off_t offset = 0;
+    ssize_t bytesSent;
+    while (offset < buffer.st_size) {
+        bytesSent = sendfile(dstFd, srcFd, &offset, buffer.st_size - offset);
+        DP_CHECK_ERROR_RETURN_LOG(bytesSent == -1, "copy file failed, err: %{public}s", std::strerror(errno));
+    }
+}
+
+DpsError VideoPostProcessor::MapHdiError(OHOS::HDI::Camera::V1_2::ErrorCode errorCode)
+{
+    DpsError code = DpsError::DPS_ERROR_UNKNOW;
+    switch (errorCode) {
+        case OHOS::HDI::Camera::V1_2::ErrorCode::ERROR_INVALID_ID:
+            code = DpsError::DPS_ERROR_VIDEO_PROC_INVALID_VIDEO_ID;
+            break;
+        case OHOS::HDI::Camera::V1_2::ErrorCode::ERROR_PROCESS:
+            code = DpsError::DPS_ERROR_VIDEO_PROC_FAILED;
+            break;
+        case OHOS::HDI::Camera::V1_2::ErrorCode::ERROR_TIMEOUT:
+            code = DpsError::DPS_ERROR_VIDEO_PROC_TIMEOUT;
+            break;
+        case OHOS::HDI::Camera::V1_2::ErrorCode::ERROR_ABORT:
+            code = DpsError::DPS_ERROR_VIDEO_PROC_INTERRUPTED;
+            break;
+        default:
+            DP_ERR_LOG("unexpected error code: %{public}d.", errorCode);
+            break;
+    }
+    return code;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/schedule/base/ischeduler_video_state.cpp b/services/deferred_processing_service/src/schedule/base/ischeduler_video_state.cpp
new file mode 100644
index 000000000..e17a4f878
--- /dev/null
+++ b/services/deferred_processing_service/src/schedule/base/ischeduler_video_state.cpp
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "ischeduler_video_state.h"
+
+#include "dp_log.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+ISchedulerVideoState::ISchedulerVideoState(int32_t stateValue)
+    : stateValue_(stateValue),
+      scheduleInfo_({true, false})
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+ISchedulerVideoState::~ISchedulerVideoState()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+int32_t ISchedulerVideoState::Initialize()
+{
+    DP_DEBUG_LOG("entered.");
+    scheduleInfo_ = ReevaluateSchedulerInfo();
+    return DP_OK;
+}
+
+ISchedulerVideoState::VideoSchedulerInfo ISchedulerVideoState::GetScheduleInfo(ScheduleType type)
+{
+    return scheduleInfo_;
+}
+
+bool ISchedulerVideoState::UpdateSchedulerInfo(ScheduleType type, int32_t stateValue)
+{
+    int32_t preStateValue = stateValue_;
+    stateValue_ = stateValue;
+    auto info = ReevaluateSchedulerInfo();
+    DP_CHECK_ERROR_RETURN_RET_LOG(scheduleInfo_ == info, false,
+        "VideoSchedulerInfo(%{public}d) state : %{public}d is not change.", type, stateValue);
+
+    DP_INFO_LOG("VideoSchedulerInfo(%{public}d) state from %{public}d to %{public}d", type, preStateValue, stateValue);
+    scheduleInfo_ = info;
+    return true;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/schedule/impl/video_battery_level_state.cpp b/services/deferred_processing_service/src/schedule/impl/video_battery_level_state.cpp
new file mode 100644
index 000000000..f5de8fc7c
--- /dev/null
+++ b/services/deferred_processing_service/src/schedule/impl/video_battery_level_state.cpp
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "video_battery_level_state.h"
+
+#include "dp_log.h"
+#include "parameters.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+VideoBatteryLevelState::VideoBatteryLevelState(int32_t stateValue) : ISchedulerVideoState(stateValue)
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+VideoBatteryLevelState::~VideoBatteryLevelState()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+VideoBatteryLevelState::VideoSchedulerInfo VideoBatteryLevelState::ReevaluateSchedulerInfo()
+{
+    bool ignore = system::GetBoolParameter(IGNORE_BATTERY_LEVEL, false);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ignore, {false}, "ignore VideoBatteryLevelState: %{public}d", stateValue_);
+
+    DP_INFO_LOG("entered, VideoBatteryLevelState: %{public}d", stateValue_);
+    bool isNeedStop = stateValue_ == BatteryLevel::BATTERY_LEVEL_LOW;
+    return {isNeedStop, true};
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/schedule/impl/video_battery_state.cpp b/services/deferred_processing_service/src/schedule/impl/video_battery_state.cpp
new file mode 100644
index 000000000..a210d494f
--- /dev/null
+++ b/services/deferred_processing_service/src/schedule/impl/video_battery_state.cpp
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "video_battery_state.h"
+
+#include "dp_log.h"
+#include "parameters.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+VideoBatteryState::VideoBatteryState(int32_t stateValue) : ISchedulerVideoState(stateValue)
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+VideoBatteryState::~VideoBatteryState()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+VideoBatteryState::VideoSchedulerInfo VideoBatteryState::ReevaluateSchedulerInfo()
+{
+    bool ignore = system::GetBoolParameter(IGNORE_BATTERY, false);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ignore, {false}, "ignore VideoBatteryState: %{public}d", stateValue_);
+
+    DP_INFO_LOG("entered, VideoBatteryState: %{public}d", stateValue_);
+    bool isNeedStop = stateValue_ == BatteryStatus::BATTERY_LOW;
+    return {isNeedStop, false};
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/schedule/impl/video_camera_state.cpp b/services/deferred_processing_service/src/schedule/impl/video_camera_state.cpp
new file mode 100644
index 000000000..13b02288d
--- /dev/null
+++ b/services/deferred_processing_service/src/schedule/impl/video_camera_state.cpp
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "video_camera_state.h"
+
+#include "dp_log.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+VideoCameraState::VideoCameraState(int32_t stateValue) : ISchedulerVideoState(stateValue)
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+VideoCameraState::~VideoCameraState()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+VideoCameraState::VideoSchedulerInfo VideoCameraState::ReevaluateSchedulerInfo()
+{
+    DP_INFO_LOG("entered, VideoCameraState: %{public}d", stateValue_);
+    bool isNeedStop = (
+        stateValue_ == CameraSessionStatus::SYSTEM_CAMERA_OPEN ||
+        stateValue_ == CameraSessionStatus::NORMAL_CAMERA_OPEN);
+    return {isNeedStop, false};
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/schedule/impl/video_charging_state.cpp b/services/deferred_processing_service/src/schedule/impl/video_charging_state.cpp
new file mode 100644
index 000000000..842c7fecb
--- /dev/null
+++ b/services/deferred_processing_service/src/schedule/impl/video_charging_state.cpp
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "video_charging_state.h"
+
+#include "dp_log.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+VideoChargingState::VideoChargingState(int32_t stateValue) : ISchedulerVideoState(stateValue)
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+VideoChargingState::~VideoChargingState()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+VideoChargingState::VideoSchedulerInfo VideoChargingState::ReevaluateSchedulerInfo()
+{
+    DP_INFO_LOG("entered, VideoChargingState: %{public}d", stateValue_);
+    bool isCharging = stateValue_ == ChargingStatus::CHARGING;
+    return {true, isCharging};
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/schedule/impl/video_hal_state.cpp b/services/deferred_processing_service/src/schedule/impl/video_hal_state.cpp
new file mode 100644
index 000000000..fb872868e
--- /dev/null
+++ b/services/deferred_processing_service/src/schedule/impl/video_hal_state.cpp
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "video_hal_state.h"
+
+#include "dp_log.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+VideoHalState::VideoHalState(int32_t stateValue) : ISchedulerVideoState(stateValue)
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+VideoHalState::~VideoHalState()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+VideoHalState::VideoSchedulerInfo VideoHalState::ReevaluateSchedulerInfo()
+{
+    DP_INFO_LOG("entered, VideoHalState: %{public}d", stateValue_);
+    bool isNeedStop = !(
+        stateValue_ == HdiStatus::HDI_READY ||
+        stateValue_ == HdiStatus::HDI_READY_SPACE_LIMIT_REACHED);
+    return {isNeedStop, false};
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/schedule/impl/video_media_library_state.cpp b/services/deferred_processing_service/src/schedule/impl/video_media_library_state.cpp
new file mode 100644
index 000000000..ab21da49f
--- /dev/null
+++ b/services/deferred_processing_service/src/schedule/impl/video_media_library_state.cpp
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "video_media_library_state.h"
+
+#include "dp_log.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+VideoMediaLibraryState::VideoMediaLibraryState(int32_t stateValue) : ISchedulerVideoState(stateValue)
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+VideoMediaLibraryState::~VideoMediaLibraryState()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+VideoMediaLibraryState::VideoSchedulerInfo VideoMediaLibraryState::ReevaluateSchedulerInfo()
+{
+    DP_INFO_LOG("entered, VideoMediaLibraryState: %{public}d", stateValue_);
+    bool isNeedStop = stateValue_ == MediaLibraryStatus::MEDIA_LIBRARY_DISCONNECTED;
+    return {isNeedStop, false};
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/schedule/impl/video_photo_process_state.cpp b/services/deferred_processing_service/src/schedule/impl/video_photo_process_state.cpp
new file mode 100644
index 000000000..43f68ba7a
--- /dev/null
+++ b/services/deferred_processing_service/src/schedule/impl/video_photo_process_state.cpp
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "video_photo_process_state.h"
+
+#include "dp_log.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+VideoPhotoProcessState::VideoPhotoProcessState(int32_t stateValue) : ISchedulerVideoState(stateValue)
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+VideoPhotoProcessState::~VideoPhotoProcessState()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+VideoPhotoProcessState::VideoSchedulerInfo VideoPhotoProcessState::ReevaluateSchedulerInfo()
+{
+    DP_INFO_LOG("entered, VideoPhotoProcessState: %{public}d", stateValue_);
+    bool isNeedStop = stateValue_ == PhotoProcessStatus::BUSY;
+    return {isNeedStop, false};
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/schedule/impl/video_screen_state.cpp b/services/deferred_processing_service/src/schedule/impl/video_screen_state.cpp
new file mode 100644
index 000000000..17b3569d9
--- /dev/null
+++ b/services/deferred_processing_service/src/schedule/impl/video_screen_state.cpp
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "video_screen_state.h"
+
+#include "dp_log.h"
+#include "parameters.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+VideoScreenState::VideoScreenState(int32_t stateValue) : ISchedulerVideoState(stateValue)
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+VideoScreenState::~VideoScreenState()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+VideoScreenState::VideoSchedulerInfo VideoScreenState::ReevaluateSchedulerInfo()
+{
+    bool ignore = system::GetBoolParameter(IGNORE_SCREEN, false);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ignore, {false}, "ignore VideoScreenState: %{public}d", stateValue_);
+
+    DP_INFO_LOG("entered, VideoScreenState: %{public}d", stateValue_);
+    bool isNeedStop = stateValue_ == ScreenStatus::SCREEN_ON;
+    return {isNeedStop, false};
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/schedule/impl/video_temperature_state.cpp b/services/deferred_processing_service/src/schedule/impl/video_temperature_state.cpp
new file mode 100644
index 000000000..62bccd0d8
--- /dev/null
+++ b/services/deferred_processing_service/src/schedule/impl/video_temperature_state.cpp
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "video_temperature_state.h"
+
+#include "dp_log.h"
+#include "parameters.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+VideoTemperatureState::VideoTemperatureState(int32_t stateValue) : ISchedulerVideoState(stateValue)
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+VideoTemperatureState::~VideoTemperatureState()
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+VideoTemperatureState::VideoSchedulerInfo VideoTemperatureState::ReevaluateSchedulerInfo()
+{
+    bool ignore = system::GetBoolParameter(IGNORE_TEMPERATURE, false);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ignore, {false}, "ignore VideoTemperatureState: %{public}d", stateValue_);
+
+    DP_INFO_LOG("entered, VideoTemperatureState: %{public}d", stateValue_);
+    bool isNeedStop = stateValue_ == VideoThermalLevel::HOT;
+    return {isNeedStop, false};
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/schedule/photo_processor/deferred_photo_controller.cpp b/services/deferred_processing_service/src/schedule/photo_processor/deferred_photo_controller.cpp
index fb48e9d71..4c5937f27 100644
--- a/services/deferred_processing_service/src/schedule/photo_processor/deferred_photo_controller.cpp
+++ b/services/deferred_processing_service/src/schedule/photo_processor/deferred_photo_controller.cpp
@@ -19,6 +19,7 @@
 #include "dp_log.h"
 #include "events_monitor.h"
 #include "dps_event_report.h"
+#include <cstdint>
 
 namespace OHOS {
 namespace CameraStandard {
@@ -42,7 +43,7 @@ public:
         controller_ = nullptr;
     }
 
-    void OnEventChange(EventType event, int value) override
+    void OnEventChange(EventType event, int32_t value) override
     {
         DP_INFO_LOG("entered, event: %{public}d", event);
         switch (event) {
diff --git a/services/deferred_processing_service/src/schedule/photo_processor/photo_job_repository/photo_job_repository.cpp b/services/deferred_processing_service/src/schedule/photo_processor/photo_job_repository/photo_job_repository.cpp
index ad19af16c..3c3352599 100644
--- a/services/deferred_processing_service/src/schedule/photo_processor/photo_job_repository/photo_job_repository.cpp
+++ b/services/deferred_processing_service/src/schedule/photo_processor/photo_job_repository/photo_job_repository.cpp
@@ -17,7 +17,9 @@
 
 #include "dp_log.h"
 #include "dps_event_report.h"
+#include "events_monitor.h"
 #include "steady_clock.h"
+#include <cstdint>
 
 namespace OHOS {
 namespace CameraStandard {
@@ -63,6 +65,7 @@ void PhotoJobRepository::AddDeferredJob(const std::string& imageId, bool discard
         DP_INFO_LOG("add offline job, imageId: %s", imageId.c_str());
         offlineJobList_.push_back(jobPtr);
         offlineJobMap_.emplace(imageId, jobPtr);
+        EventsMonitor::GetInstance().NotifyPhotoProcessSize(offlineJobList_.size());
     }
     jobPtr->SetPhotoJobType(type);
     bool priorityChanged = jobPtr->SetJobPriority(PhotoJobPriority::NORMAL);
@@ -71,7 +74,8 @@ void PhotoJobRepository::AddDeferredJob(const std::string& imageId, bool discard
     NotifyJobChangedUnLocked(priorityChanged, statusChanged, jobPtr);
 
     ReportEvent(jobPtr, DeferredProcessingServiceInterfaceCode::DPS_ADD_IMAGE);
-    return;
+    int32_t imageSize = static_cast<int32_t>(offlineJobList_.size() + backgroundJobMap_.size());
+    EventsMonitor::GetInstance().NotifyPhotoProcessSize(imageSize);
 }
 
 void PhotoJobRepository::RemoveDeferredJob(const std::string& imageId, bool restorable)
@@ -111,7 +115,8 @@ void PhotoJobRepository::RemoveDeferredJob(const std::string& imageId, bool rest
     UpdateRunningCountUnLocked(statusChanged, jobPtr);
     NotifyJobChangedUnLocked(priorityChanged, statusChanged, jobPtr);
     ReportEvent(jobPtr, DeferredProcessingServiceInterfaceCode::DPS_REMOVE_IMAGE);
-    return;
+    int32_t imageSize = static_cast<int32_t>(offlineJobList_.size() + backgroundJobMap_.size());
+    EventsMonitor::GetInstance().NotifyPhotoProcessSize(imageSize);
 }
 
 bool PhotoJobRepository::RequestJob(const std::string& imageId)
diff --git a/services/deferred_processing_service/src/schedule/scheduler_coordinator.cpp b/services/deferred_processing_service/src/schedule/scheduler_coordinator.cpp
index b13544288..c8e1c7fa2 100644
--- a/services/deferred_processing_service/src/schedule/scheduler_coordinator.cpp
+++ b/services/deferred_processing_service/src/schedule/scheduler_coordinator.cpp
@@ -14,6 +14,7 @@
  */
 
 #include "scheduler_coordinator.h"
+
 #include "dp_log.h"
 
 namespace OHOS {
diff --git a/services/deferred_processing_service/src/schedule/scheduler_manager.cpp b/services/deferred_processing_service/src/schedule/scheduler_manager.cpp
index ef3efb8bd..e2d775438 100644
--- a/services/deferred_processing_service/src/schedule/scheduler_manager.cpp
+++ b/services/deferred_processing_service/src/schedule/scheduler_manager.cpp
@@ -15,42 +15,39 @@
 
 #include "scheduler_manager.h"
 
-#include "dp_log.h"
+#include "dp_utils.h"
 
 namespace OHOS {
 namespace CameraStandard {
 namespace DeferredProcessing {
 SchedulerManager::SchedulerManager()
-    : photoProcessors_(),
-      photoController_(),
-      schedulerCoordinator_(nullptr)
 {
-    DP_DEBUG_LOG("entered");
+    DP_DEBUG_LOG("entered.");
 }
 
 SchedulerManager::~SchedulerManager()
 {
-    DP_DEBUG_LOG("entered");
+    DP_DEBUG_LOG("entered.");
     photoController_.clear();
     photoProcessors_.clear();
+    videoController_.clear();
+    videoProcessors_.clear();
     schedulerCoordinator_ = nullptr;
 }
 
-void SchedulerManager::Initialize()
+int32_t SchedulerManager::Initialize()
 {
-    DP_DEBUG_LOG("entered");
+    DP_DEBUG_LOG("entered.");
     schedulerCoordinator_ = std::make_unique<SchedulerCoordinator>();
     schedulerCoordinator_->Initialize();
-    return;
+    return DP_OK;
 }
 
 std::shared_ptr<DeferredPhotoProcessor> SchedulerManager::GetPhotoProcessor(const int32_t userId,
     TaskManager* taskManager, std::shared_ptr<IImageProcessCallbacks> callbacks)
 {
-    DP_INFO_LOG("entered");
-    if (photoProcessors_.count(userId) == 0) {
-        CreatePhotoProcessor(userId, taskManager, callbacks);
-    }
+    DP_DEBUG_LOG("entered.");
+    DP_CHECK_EXECUTE(photoProcessors_.count(userId) == 0, CreatePhotoProcessor(userId, taskManager, callbacks));
     return photoProcessors_[userId];
 }
 
@@ -69,6 +66,34 @@ void SchedulerManager::CreatePhotoProcessor(const int32_t userId, TaskManager* t
     return;
 }
 
+std::shared_ptr<DeferredVideoProcessor> SchedulerManager::GetVideoProcessor(const int32_t userId)
+{
+    DP_DEBUG_LOG("entered.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(videoProcessors_.count(userId) == 0, nullptr,
+        "VideoProcessors is nullptr.");
+    return videoProcessors_[userId];
+}
+
+std::shared_ptr<DeferredVideoController> SchedulerManager::GetVideoController(const int32_t userId)
+{
+    DP_DEBUG_LOG("entered.");
+    DP_CHECK_ERROR_RETURN_RET_LOG(videoController_.count(userId) == 0, nullptr,
+        "VideoController is nullptr.");
+    return videoController_[userId];
+}
+
+void SchedulerManager::CreateVideoProcessor(const int32_t userId,
+    const std::shared_ptr<IVideoProcessCallbacks>& callbacks)
+{
+    DP_DEBUG_LOG("entered.");
+    auto videoRepository = std::make_shared<VideoJobRepository>(userId);
+    auto videoProcessor = std::make_shared<DeferredVideoProcessor>(userId, videoRepository, callbacks);
+    auto videoController = CreateShared<DeferredVideoController>(userId, videoRepository, videoProcessor);
+    videoController->Initialize();
+    videoProcessor->Initialize();
+    videoProcessors_[userId] = videoProcessor;
+    videoController_[userId] = videoController;
+}
 } // namespace DeferredProcessing
 } // namespace CameraStandard
 } // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/schedule/video_processor/deferred_video_controller.cpp b/services/deferred_processing_service/src/schedule/video_processor/deferred_video_controller.cpp
new file mode 100644
index 000000000..a039f04fb
--- /dev/null
+++ b/services/deferred_processing_service/src/schedule/video_processor/deferred_video_controller.cpp
@@ -0,0 +1,220 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "deferred_video_controller.h"
+
+#include "dp_power_manager.h"
+#include "dp_timer.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class DeferredVideoController::StateListener : public IVideoStateChangeListener {
+public:
+    explicit StateListener(const std::weak_ptr<DeferredVideoController>& controller) : controller_(controller)
+    {
+        DP_DEBUG_LOG("entered.");
+    }
+
+    ~StateListener() override
+    {
+        DP_DEBUG_LOG("entered.");
+    }
+
+    void OnSchedulerChanged(const ScheduleType& type, const ScheduleInfo& scheduleInfo) override
+    {
+        auto controller = controller_.lock();
+        DP_CHECK_ERROR_RETURN_LOG(controller == nullptr, "video controller is nullptr.");
+        controller->OnSchedulerChanged(type, scheduleInfo);
+    }
+
+private:
+    std::weak_ptr<DeferredVideoController> controller_;
+};
+
+class DeferredVideoController::VideoJobRepositoryListener : public IVideoJobRepositoryListener {
+public:
+    explicit VideoJobRepositoryListener(const std::weak_ptr<DeferredVideoController>& controller)
+        : controller_(controller)
+    {
+        DP_DEBUG_LOG("entered.");
+    }
+
+    ~VideoJobRepositoryListener()
+    {
+        DP_DEBUG_LOG("entered.");
+    }
+
+    void OnVideoJobChanged(const DeferredVideoJobPtr& jobPtr) override
+    {
+        auto controller = controller_.lock();
+        DP_CHECK_ERROR_RETURN_LOG(controller == nullptr, "video controller is nullptr.");
+        controller->OnVideoJobChanged(jobPtr);
+    }
+
+private:
+    std::weak_ptr<DeferredVideoController> controller_;
+};
+
+DeferredVideoController::DeferredVideoController(const int32_t userId, std::shared_ptr<VideoJobRepository> repository,
+    std::shared_ptr<DeferredVideoProcessor> processor)
+    : userId_(userId),
+      videoProcessor_(processor),
+      videoJobRepository_(repository)
+{
+    DP_DEBUG_LOG("entered, userid: %{public}d", userId_);
+}
+
+DeferredVideoController::~DeferredVideoController()
+{
+    DP_DEBUG_LOG("entered.");
+    videoProcessor_ = nullptr;
+    videoJobRepository_ = nullptr;
+    videoStrategyCenter_ = nullptr;
+    videoStateChangeListener_ = nullptr;
+    videoJobChangeListener_ = nullptr;
+    StopSuspendLock();
+}
+
+void DeferredVideoController::Initialize()
+{
+    DP_DEBUG_LOG("entered.");
+    videoJobChangeListener_ = std::make_shared<VideoJobRepositoryListener>(weak_from_this());
+    videoJobRepository_->RegisterJobListener(videoJobChangeListener_);
+    videoStrategyCenter_ = CreateShared<VideoStrategyCenter>(userId_, videoJobRepository_);
+    
+    videoStrategyCenter_->Initialize();
+    videoStateChangeListener_ = std::make_shared<StateListener>(weak_from_this());
+    videoStrategyCenter_->RegisterStateChangeListener(videoStateChangeListener_);
+}
+
+void DeferredVideoController::HandleServiceDied()
+{
+    DP_DEBUG_LOG("entered.");
+    std::vector<std::string> errorTasks;
+    videoJobRepository_->GetRunningJobList(errorTasks);
+    if (!errorTasks.empty()) {
+        StopSuspendLock();
+    }
+}
+
+void DeferredVideoController::HandleSuccess(const int32_t userId, const DeferredVideoWorkPtr& work)
+{
+    auto videoId = work->GetDeferredVideoJob()->GetVideoId();
+    auto out = work->GetDeferredVideoJob()->GetOutputFd();
+    DP_INFO_LOG("handle success, videoId: %{public}s, outFd: %{public}d", videoId.c_str(), out->GetFd());
+    HandleNormalSchedule(work);
+    videoProcessor_->OnProcessDone(userId, videoId, out);
+}
+
+void DeferredVideoController::HandleError(const int32_t userId, const DeferredVideoWorkPtr& work, DpsError errorCode)
+{
+    auto videoId = work->GetDeferredVideoJob()->GetVideoId();
+    DP_INFO_LOG("handle error videoId: %{public}s", videoId.c_str());
+    if (errorCode == DpsError::DPS_ERROR_VIDEO_PROC_INTERRUPTED) {
+        StopSuspendLock();
+    }
+    HandleNormalSchedule(work);
+    videoProcessor_->OnError(userId, videoId, errorCode);
+}
+
+void DeferredVideoController::OnVideoJobChanged(const DeferredVideoJobPtr& jobPtr)
+{
+    DP_INFO_LOG("entered, videoId: %{public}s", jobPtr->GetVideoId().c_str());
+    TryDoSchedule();
+}
+
+void DeferredVideoController::OnSchedulerChanged(const ScheduleType& type, const ScheduleInfo& scheduleInfo)
+{
+    DP_INFO_LOG("video schedule isNeedStop: %{public}d, isCharging: %{public}d",
+        scheduleInfo.isNeedStop, scheduleInfo.isCharging);
+    if (scheduleInfo.isNeedStop) {
+        PauseRequests(type);
+    } else {
+        TryDoSchedule();
+    }
+}
+
+void DeferredVideoController::TryDoSchedule()
+{
+    DP_DEBUG_LOG("entered.");
+    std::lock_guard<std::recursive_mutex> lock(mutex_);
+    auto work = videoStrategyCenter_->GetWork();
+    DP_INFO_LOG("strategy get work: %{public}d", work != nullptr);
+    if (work == nullptr) {
+        StopSuspendLock();
+        return;
+    }
+    
+    DP_CHECK_EXECUTE(work->IsSuspend(), StartSuspendLock());
+    PostProcess(work);
+}
+
+void DeferredVideoController::PauseRequests(const ScheduleType& type)
+{
+    DP_CHECK_RETURN(videoJobRepository_->GetRunningJobCounts() == 0);
+    videoProcessor_->PauseRequest(type);
+}
+
+void DeferredVideoController::PostProcess(const DeferredVideoWorkPtr& work)
+{
+    DP_DEBUG_LOG("entered");
+    videoProcessor_->PostProcess(work);
+}
+
+void DeferredVideoController::SetDefaultExecutionMode()
+{
+    DP_DEBUG_LOG("entered");
+    videoProcessor_->SetDefaultExecutionMode();
+}
+
+void DeferredVideoController::StartSuspendLock()
+{
+    DP_CHECK_RETURN(normalTimeId_ != INVALID_TIMEID);
+    uint32_t processTime = static_cast<uint32_t>(
+        std::min(videoStrategyCenter_->GetAvailableTime(), ONCE_PROCESS_TIME));
+    normalTimeId_ = DpsTimer::GetInstance().StartTimer([&]() {OnTimerOut();}, processTime);
+    DPSProwerManager::GetInstance().SetAutoSuspend(false, processTime + DELAY_TIME);
+    DP_INFO_LOG("DpsTimer start: normal schedule timeId: %{public}d, processTime: %{public}d.",
+        static_cast<int32_t>(normalTimeId_), processTime);
+}
+
+void DeferredVideoController::StopSuspendLock()
+{
+    DPSProwerManager::GetInstance().SetAutoSuspend(true);
+    DP_CHECK_RETURN(normalTimeId_ == INVALID_TIMEID);
+    DP_INFO_LOG("DpsTimer stop: normal schedule timeId: %{public}d.", normalTimeId_);
+    DpsTimer::GetInstance().StopTimer(normalTimeId_);
+}
+
+void DeferredVideoController::HandleNormalSchedule(const DeferredVideoWorkPtr& work)
+{
+    DP_CHECK_RETURN(!work->IsSuspend());
+
+    DP_DEBUG_LOG("handle normal schedule videoId: %{public}s", work->GetDeferredVideoJob()->GetVideoId().c_str());
+    auto usedTime = static_cast<int32_t>(work->GetExecutionTime());
+    videoStrategyCenter_->UpdateAvailableTime(false, usedTime);
+}
+
+void DeferredVideoController::OnTimerOut()
+{
+    DP_INFO_LOG("DpsTimer executed: normal schedule time out.");
+    normalTimeId_ = INVALID_TIMEID;
+    videoStrategyCenter_->UpdateSingleTime(false);
+    PauseRequests(NORMAL_TIME_STATE);
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/schedule/video_processor/deferred_video_processor.cpp b/services/deferred_processing_service/src/schedule/video_processor/deferred_video_processor.cpp
new file mode 100644
index 000000000..9add01e89
--- /dev/null
+++ b/services/deferred_processing_service/src/schedule/video_processor/deferred_video_processor.cpp
@@ -0,0 +1,142 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "deferred_video_processor.h"
+
+#include "dps_video_report.h"
+#include "dp_utils.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+DeferredVideoProcessor::DeferredVideoProcessor(const int32_t userId, std::shared_ptr<VideoJobRepository> repository,
+    std::shared_ptr<IVideoProcessCallbacks> callbacks)
+    : userId_(userId),
+      repository_(repository),
+      callbacks_(callbacks),
+      postProcessor_(nullptr)
+{
+    DP_DEBUG_LOG("entered.");
+    postProcessor_ = CreateShared<VideoPostProcessor>(userId_);
+}
+
+DeferredVideoProcessor::~DeferredVideoProcessor()
+{
+    DP_DEBUG_LOG("entered.");
+    repository_ = nullptr;
+    callbacks_ = nullptr;
+    postProcessor_ = nullptr;
+}
+
+void DeferredVideoProcessor::Initialize()
+{
+    DP_DEBUG_LOG("entered.");
+    postProcessor_->Initialize();
+}
+
+void DeferredVideoProcessor::AddVideo(const std::string& videoId,
+    const sptr<IPCFileDescriptor>& srcFd, const sptr<IPCFileDescriptor>& dstFd)
+{
+    DP_DEBUG_LOG("entered, videoId: %{public}s", videoId.c_str());
+    repository_->AddVideoJob(videoId, srcFd, dstFd);
+}
+
+void DeferredVideoProcessor::RemoveVideo(const std::string& videoId, bool restorable)
+{
+    bool isNeedStop = repository_->RemoveVideoJob(videoId, restorable);
+    DP_DEBUG_LOG("entered, videoId: %{public}s, isNeedStop: %{public}d, restorable: %{public}d",
+        videoId.c_str(), isNeedStop, restorable);
+    DP_CHECK_EXECUTE(isNeedStop, postProcessor_->PauseRequest(videoId, ScheduleType::REMOVE));
+    DP_CHECK_EXECUTE(!restorable, postProcessor_->RemoveRequest(videoId));
+}
+
+void DeferredVideoProcessor::RestoreVideo(const std::string& videoId)
+{
+    DP_DEBUG_LOG("entered, videoId: %{public}s", videoId.c_str());
+    repository_->RestoreVideoJob(videoId);
+}
+
+void DeferredVideoProcessor::OnProcessDone(const int32_t userId,
+    const std::string& videoId, const sptr<IPCFileDescriptor>& ipcFd)
+{
+    DP_DEBUG_LOG("entered, videoId: %{public}s, fd: %{public}d", videoId.c_str(), ipcFd->GetFd());
+    repository_->SetJobCompleted(videoId);
+    callbacks_->OnProcessDone(userId, videoId, ipcFd);
+    DfxVideoReport::GetInstance().ReportCompleteVideoEvent(videoId);
+}
+
+void DeferredVideoProcessor::OnError(const int32_t userId, const std::string& videoId, DpsError errorCode)
+{
+    DP_DEBUG_LOG("entered, videoId: %{public}s, error: %{public}d", videoId.c_str(), errorCode);
+    DP_CHECK_EXECUTE(IsFatalError(errorCode), callbacks_->OnError(userId, videoId, errorCode));
+    if (errorCode == DpsError::DPS_ERROR_VIDEO_PROC_INTERRUPTED) {
+        repository_->SetJobPause(videoId);
+    } else if (errorCode == DpsError::DPS_ERROR_VIDEO_PROC_INVALID_VIDEO_ID) {
+        repository_->SetJobError(videoId);
+    } else {
+        repository_->SetJobFailed(videoId);
+    }
+}
+
+void DeferredVideoProcessor::OnStateChanged(const int32_t userId, DpsStatus statusCode)
+{
+    DP_DEBUG_LOG("entered, userId: %{public}d, status: %{public}d", userId, statusCode);
+}
+
+void DeferredVideoProcessor::PostProcess(const DeferredVideoWorkPtr& work)
+{
+    DP_DEBUG_LOG("entered.");
+    auto videoId = work->GetDeferredVideoJob()->GetVideoId();
+    repository_->SetJobRunning(videoId);
+    postProcessor_->ProcessRequest(work);
+    DfxVideoReport::GetInstance().ReportResumeVideoEvent(videoId);
+}
+
+void DeferredVideoProcessor::PauseRequest(const ScheduleType& type)
+{
+    DP_DEBUG_LOG("entered.");
+    std::vector<std::string> runningList;
+    repository_->GetRunningJobList(runningList);
+    for (const auto& videoId: runningList) {
+        repository_->SetJobPause(videoId);
+        postProcessor_->PauseRequest(videoId, type);
+        DfxVideoReport::GetInstance().ReportPauseVideoEvent(videoId, type);
+    }
+}
+
+void DeferredVideoProcessor::SetDefaultExecutionMode()
+{
+    DP_DEBUG_LOG("entered.");
+    postProcessor_->SetDefaultExecutionMode();
+}
+
+bool DeferredVideoProcessor::GetPendingVideos(std::vector<std::string>& pendingVideos)
+{
+    DP_DEBUG_LOG("entered.");
+    return postProcessor_->GetPendingVideos(pendingVideos);
+}
+
+bool DeferredVideoProcessor::IsFatalError(DpsError errorCode)
+{
+    DP_INFO_LOG("entered, code: %{public}d", errorCode);
+    if (errorCode == DpsError::DPS_ERROR_VIDEO_PROC_FAILED ||
+        errorCode == DpsError::DPS_ERROR_VIDEO_PROC_INVALID_VIDEO_ID) {
+        return true;
+    }
+    return false;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/schedule/video_processor/strategy/video_strategy_center.cpp b/services/deferred_processing_service/src/schedule/video_processor/strategy/video_strategy_center.cpp
new file mode 100644
index 000000000..e3e28d80a
--- /dev/null
+++ b/services/deferred_processing_service/src/schedule/video_processor/strategy/video_strategy_center.cpp
@@ -0,0 +1,339 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "video_strategy_center.h"
+
+#include "battery_level_strategy.h"
+#include "dp_log.h"
+#include "dps_event_report.h"
+#include "events_info.h"
+#include "events_monitor.h"
+#include "ivideo_state_change_listener.h"
+#include "video_battery_level_state.h"
+#include "video_battery_state.h"
+#include "video_camera_state.h"
+#include "video_charging_state.h"
+#include "video_hal_state.h"
+#include "video_media_library_state.h"
+#include "video_photo_process_state.h"
+#include "video_screen_state.h"
+#include "video_temperature_state.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+namespace {
+    constexpr uint32_t SINGLE_TIME_LIMIT = 0b1;
+    constexpr uint32_t TOTAL_TIME_LIMIT = 0b10;
+    constexpr int32_t DEFAULT_TIME = 0;
+}
+
+class VideoStrategyCenter::EventsListener : public IEventsListener {
+public:
+    explicit EventsListener(const std::weak_ptr<VideoStrategyCenter>& strategyCenter)
+        : strategyCenter_(strategyCenter)
+    {
+        DP_DEBUG_LOG("entered");
+    }
+
+    ~EventsListener()
+    {
+        DP_DEBUG_LOG("entered");
+    }
+
+    void OnEventChange(EventType event, int32_t value) override
+    {
+        DP_DEBUG_LOG("entered, event: %{public}d", event);
+        auto strategy = strategyCenter_.lock();
+        DP_CHECK_ERROR_RETURN_LOG(strategy == nullptr, "VideoStrategyCenter is nullptr.");
+        strategy->HandleEventChanged(event, value);
+        DPSEventReport::GetInstance().SetEventType(event);
+    }
+
+private:
+    std::weak_ptr<VideoStrategyCenter> strategyCenter_;
+};
+
+VideoStrategyCenter::VideoStrategyCenter(const int32_t userId, const std::shared_ptr<VideoJobRepository>& repository)
+    : userId_(userId), videoJobRepository_(repository)
+{
+    DP_INFO_LOG("entered");
+}
+
+VideoStrategyCenter::~VideoStrategyCenter()
+{
+    DP_INFO_LOG("entered");
+    eventsListener_ = nullptr;
+    eventHandlerList_.clear();
+    scheduleStateList_.clear();
+    videoJobRepository_ = nullptr;
+}
+
+void VideoStrategyCenter::Initialize()
+{
+    DP_INFO_LOG("entered");
+    InitHandleEvent();
+    InitScheduleState();
+    eventsListener_ = std::make_shared<EventsListener>(weak_from_this());
+    EventsMonitor::GetInstance().RegisterEventsListener(userId_, {
+        EventType::CAMERA_SESSION_STATUS_EVENT,
+        EventType::HDI_STATUS_EVENT,
+        EventType::MEDIA_LIBRARY_STATUS_EVENT,
+        EventType::THERMAL_LEVEL_STATUS_EVENT,
+        EventType::SCREEN_STATUS_EVENT,
+        EventType::BATTERY_STATUS_EVENT,
+        EventType::BATTERY_LEVEL_STATUS_EVENT,
+        EventType::CHARGING_STATUS_EVENT,
+        EventType::PHOTO_PROCESS_STATUS_EVENT},
+        eventsListener_);
+}
+
+void VideoStrategyCenter::InitHandleEvent()
+{
+    DP_INFO_LOG("entered");
+    eventHandlerList_.insert({CAMERA_SESSION_STATUS_EVENT, [this](int32_t value){HandleCameraEvent(value);}});
+    eventHandlerList_.insert({HDI_STATUS_EVENT, [this](int32_t value){HandleHalEvent(value);}});
+    eventHandlerList_.insert({MEDIA_LIBRARY_STATUS_EVENT, [this](int32_t value){HandleMedialLibraryEvent(value);}});
+    eventHandlerList_.insert({SCREEN_STATUS_EVENT, [this](int32_t value){HandleScreenEvent(value);}});
+    eventHandlerList_.insert({CHARGING_STATUS_EVENT, [this](int32_t value){HandleChargingEvent(value);}});
+    eventHandlerList_.insert({BATTERY_STATUS_EVENT, [this](int32_t value){HandleBatteryEvent(value);}});
+    eventHandlerList_.insert({BATTERY_LEVEL_STATUS_EVENT, [this](int32_t value){HandleBatteryLevelEvent(value);}});
+    eventHandlerList_.insert({THERMAL_LEVEL_STATUS_EVENT, [this](int32_t value){HandleTemperatureEvent(value);}});
+    eventHandlerList_.insert({PHOTO_PROCESS_STATUS_EVENT, [this](int32_t value){HandlePhotoProcessEvent(value);}});
+}
+
+void VideoStrategyCenter::InitScheduleState()
+{
+    DP_INFO_LOG("entered");
+    auto state = EventsInfo::GetInstance().GetChargingState();
+    isCharging_ = state == ChargingStatus::CHARGING;
+    scheduleStateList_.insert({CAMERA_STATE,
+        std::make_shared<VideoCameraState>(CameraSessionStatus::SYSTEM_CAMERA_CLOSED)});
+    scheduleStateList_.insert({HDI_STATE,
+        std::make_shared<VideoHalState>(HdiStatus::HDI_READY)});
+    scheduleStateList_.insert({MEDIA_LIBRARY_STATE,
+        std::make_shared<VideoMediaLibraryState>(MediaLibraryStatus::MEDIA_LIBRARY_AVAILABLE)});
+    scheduleStateList_.insert({SCREEN_STATE,
+        std::make_shared<VideoScreenState>(EventsInfo::GetInstance().GetScreenState())});
+    scheduleStateList_.insert({CHARGING_STATE,
+        std::make_shared<VideoChargingState>(state)});
+    scheduleStateList_.insert({BATTERY_STATE,
+        std::make_shared<VideoBatteryState>(EventsInfo::GetInstance().GetBatteryState())});
+    scheduleStateList_.insert({BATTERY_LEVEL_STATE,
+        std::make_shared<VideoBatteryLevelState>(EventsInfo::GetInstance().GetBatteryLevel())});
+    scheduleStateList_.insert({THERMAL_LEVEL_STATE,
+        std::make_shared<VideoTemperatureState>(ConvertThermalLevel(EventsInfo::GetInstance().GetThermalLevel()))});
+    scheduleStateList_.insert({PHOTO_PROCESS_STATE,
+        std::make_shared<VideoPhotoProcessState>(PhotoProcessStatus::IDLE)});
+    for (auto item : scheduleStateList_) {
+        if (item.second == nullptr) {
+            DP_ERR_LOG("schedule state init failed, type: %{public}d", item.first);
+            continue;
+        }
+        item.second->Initialize();
+    }
+}
+
+void VideoStrategyCenter::HandleEventChanged(EventType event, int32_t value)
+{
+    DP_INFO_LOG("entered, eventType: %{public}d, value: %{public}d", event, value);
+    auto item = eventHandlerList_.find(event);
+    if (item != eventHandlerList_.end()) {
+        item->second(value);
+    } else {
+        DP_WARNING_LOG("not support handle event: %{public}d", event);
+    }
+}
+
+void VideoStrategyCenter::RegisterStateChangeListener(const std::weak_ptr<IVideoStateChangeListener>& listener)
+{
+    videoStateChangeListener_ = listener;
+}
+
+DeferredVideoWorkPtr VideoStrategyCenter::GetWork()
+{
+    auto jobPtr = GetJob();
+    ExecutionMode mode = GetExecutionMode();
+    if ((jobPtr != nullptr) && (mode != ExecutionMode::DUMMY)) {
+        return std::make_shared<DeferredVideoWork>(jobPtr, mode, isCharging_);
+    }
+    return nullptr;
+}
+
+DeferredVideoJobPtr VideoStrategyCenter::GetJob()
+{
+    return videoJobRepository_->GetJob();
+}
+
+ExecutionMode VideoStrategyCenter::GetExecutionMode()
+{
+    if (isCharging_) {
+        DP_CHECK_RETURN_RET(IsReady(), ExecutionMode::LOAD_BALANCE);
+    } else {
+        DP_CHECK_RETURN_RET(IsReady() && IsTimeReady(), ExecutionMode::LOAD_BALANCE);
+    }
+    return ExecutionMode::DUMMY;
+}
+
+void VideoStrategyCenter::HandleCameraEvent(int32_t value)
+{
+    DP_DEBUG_LOG("CameraEvent value: %{public}d", value);
+    UpdateValue(ScheduleType::CAMERA_STATE, value);
+}
+
+void VideoStrategyCenter::HandleHalEvent(int32_t value)
+{
+    DP_DEBUG_LOG("HalEvent value: %{public}d", value);
+    UpdateValue(ScheduleType::HDI_STATE, value);
+}
+
+void VideoStrategyCenter::HandleMedialLibraryEvent(int32_t value)
+{
+    DP_DEBUG_LOG("MedialLibraryEvent value: %{public}d", value);
+    UpdateValue(ScheduleType::MEDIA_LIBRARY_STATE, value);
+}
+
+void VideoStrategyCenter::HandleScreenEvent(int32_t value)
+{
+    DP_DEBUG_LOG("ScreenEvent value: %{public}d", value);
+    DP_CHECK_EXECUTE(value == ScreenStatus::SCREEN_ON, UpdateSingleTime(true));
+    UpdateValue(ScheduleType::SCREEN_STATE, value);
+}
+
+void VideoStrategyCenter::HandleChargingEvent(int32_t value)
+{
+    DP_DEBUG_LOG("ChargingEvent value: %{public}d", value);
+    isCharging_ = value == ChargingStatus::CHARGING;
+    DP_CHECK_EXECUTE(isCharging_, UpdateAvailableTime(true, DEFAULT_TIME));
+    UpdateValue(ScheduleType::CHARGING_STATE, value);
+}
+void VideoStrategyCenter::HandleBatteryEvent(int32_t value)
+{
+    DP_DEBUG_LOG("BatteryEvent value: %{public}d", value);
+    UpdateValue(ScheduleType::BATTERY_STATE, value);
+}
+
+void VideoStrategyCenter::HandleBatteryLevelEvent(int32_t value)
+{
+    DP_DEBUG_LOG("BatteryLevelEvent value: %{public}d", value);
+    UpdateValue(ScheduleType::BATTERY_LEVEL_STATE, value);
+}
+
+void VideoStrategyCenter::HandleTemperatureEvent(int32_t value)
+{
+    DP_DEBUG_LOG("TemperatureEvent value: %{public}d", value);
+    auto level = ConvertThermalLevel(value);
+    UpdateValue(ScheduleType::THERMAL_LEVEL_STATE, level);
+}
+
+void VideoStrategyCenter::HandlePhotoProcessEvent(int32_t value)
+{
+    DP_DEBUG_LOG("PhotoProcessEvent value: %{public}d", value);
+    auto state = ConvertProcessState(value);
+    UpdateValue(ScheduleType::PHOTO_PROCESS_STATE, state);
+}
+
+void VideoStrategyCenter::UpdateValue(ScheduleType type, int32_t value)
+{
+    auto scheduleState = GetScheduleState(type);
+    DP_CHECK_ERROR_RETURN_LOG(scheduleState == nullptr, "UpdateValue failed.");
+    if (scheduleState->UpdateSchedulerInfo(type, value)) {
+        auto info = ReevaluateSchedulerInfo();
+        isNeedStop_ = info.isNeedStop;
+        auto listener = videoStateChangeListener_.lock();
+        DP_CHECK_ERROR_RETURN_LOG(listener == nullptr, "VideoStateChangeListener is nullptr.");
+        listener->OnSchedulerChanged(type, info);
+    }
+}
+
+void VideoStrategyCenter::UpdateSingleTime(bool isOk)
+{
+    if (isOk) {
+        isTimeOk_ &= ~SINGLE_TIME_LIMIT;
+    } else {
+        isTimeOk_ |= SINGLE_TIME_LIMIT;
+    }
+    DP_INFO_LOG("process time type: 0x%{public}x", isTimeOk_);
+}
+
+void VideoStrategyCenter::UpdateAvailableTime(bool isNeedReset, int32_t useTime)
+{
+    if (isNeedReset) {
+        availableTime_ = TOTAL_PROCESS_TIME;
+    } else {
+        availableTime_ -= useTime;
+    }
+
+    if (availableTime_ > 0) {
+        isTimeOk_ &= ~TOTAL_TIME_LIMIT;
+    } else {
+        availableTime_ = 0;
+        isTimeOk_ |= TOTAL_TIME_LIMIT;
+    }
+    DP_INFO_LOG("available process time: %{public}d, type: 0x%{public}x", availableTime_, isTimeOk_);
+}
+
+ScheduleInfo VideoStrategyCenter::ReevaluateSchedulerInfo()
+{
+    ScheduleInfo cameraInfo = GetScheduleInfo(ScheduleType::CAMERA_STATE);
+    ScheduleInfo halInfo = GetScheduleInfo(ScheduleType::HDI_STATE);
+    ScheduleInfo mediaLibraryInfo = GetScheduleInfo(ScheduleType::MEDIA_LIBRARY_STATE);
+    ScheduleInfo screenInfo = GetScheduleInfo(ScheduleType::SCREEN_STATE);
+    ScheduleInfo temperatureInfo = GetScheduleInfo(ScheduleType::THERMAL_LEVEL_STATE);
+    ScheduleInfo photoProcessInfo = GetScheduleInfo(ScheduleType::PHOTO_PROCESS_STATE);
+    ScheduleInfo chargingInfo = GetScheduleInfo(ScheduleType::CHARGING_STATE);
+    if (cameraInfo.isNeedStop || halInfo.isNeedStop || mediaLibraryInfo.isNeedStop ||
+        screenInfo.isNeedStop || temperatureInfo.isNeedStop || photoProcessInfo.isNeedStop) {
+        DP_INFO_LOG("video stop schedule, hdi : %{public}d, mediaLibrary: %{public}d, camear: %{public}d, "
+            "screen: %{public}d, temperatureInfo: %{public}d, photoProcessInfo: %{public}d",
+            halInfo.isNeedStop, mediaLibraryInfo.isNeedStop, cameraInfo.isNeedStop,
+            screenInfo.isNeedStop, temperatureInfo.isNeedStop, photoProcessInfo.isNeedStop);
+        return {true, chargingInfo.isCharging};
+    }
+
+    if (chargingInfo.isCharging) {
+        DP_CHECK_RETURN_RET_LOG(videoJobRepository_->GetRunningJobCounts() > 0,
+            chargingInfo, "has video job running.");
+        
+        DP_INFO_LOG("video try schedule in charging.");
+        return GetScheduleInfo(ScheduleType::BATTERY_LEVEL_STATE);
+    }
+
+    DP_INFO_LOG("video try schedule in normal.");
+    return GetScheduleInfo(ScheduleType::BATTERY_STATE);
+}
+
+ScheduleInfo VideoStrategyCenter::GetScheduleInfo(ScheduleType type)
+{
+    ScheduleInfo defaultInfo = {true, false};
+    auto scheduleState = GetScheduleState(type);
+    DP_CHECK_ERROR_RETURN_RET_LOG(scheduleState == nullptr, defaultInfo, "not find schedule type: %{public}d", type);
+    return scheduleState->GetScheduleInfo(type);
+}
+
+std::shared_ptr<ISchedulerVideoState> VideoStrategyCenter::GetScheduleState(ScheduleType type)
+{
+    auto item = scheduleStateList_.find(type);
+    DP_CHECK_ERROR_RETURN_RET_LOG(item == scheduleStateList_.end(), nullptr,
+        "can not find ScheduleState by ScheduleType: %{public}d", type);
+
+    auto scheduleState = item->second;
+    DP_CHECK_ERROR_PRINT_LOG(scheduleState == nullptr, "ScheduleState get by EventType: %{public}d is nullptr", type);
+    return scheduleState;
+}
+
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/schedule/video_processor/video_job_repository/deferred_video_job.cpp b/services/deferred_processing_service/src/schedule/video_processor/video_job_repository/deferred_video_job.cpp
new file mode 100644
index 000000000..599b04294
--- /dev/null
+++ b/services/deferred_processing_service/src/schedule/video_processor/video_job_repository/deferred_video_job.cpp
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "deferred_video_job.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+
+
+DeferredVideoWork::DeferredVideoWork(const DeferredVideoJobPtr& jobPtr, ExecutionMode mode, bool isCharging)
+    : jobPtr_(jobPtr),
+      executionMode_(mode),
+      startTime_(GetSteadyNow()),
+      isCharging_(isCharging)
+{
+    DP_DEBUG_LOG("entered");
+}
+
+DeferredVideoWork::~DeferredVideoWork()
+{
+    DP_DEBUG_LOG("entered");
+    jobPtr_ = nullptr;
+}
+
+DeferredVideoJob::DeferredVideoJob(const std::string& videoId, const sptr<IPCFileDescriptor>& srcFd,
+    const sptr<IPCFileDescriptor>& dstFd)
+    : videoId_(videoId),
+      srcFd_(srcFd),
+      dstFd_(dstFd),
+      createTime_(GetSteadyNow())
+{
+    DP_DEBUG_LOG("videoId: %{public}s, srcFd: %{public}d, dstFd: %{public}d",
+        videoId_.c_str(), srcFd_->GetFd(), dstFd_->GetFd());
+}
+
+DeferredVideoJob::~DeferredVideoJob()
+{
+    DP_DEBUG_LOG("entered");
+    srcFd_ = nullptr;
+    dstFd_ = nullptr;
+}
+
+bool DeferredVideoJob::SetJobStatus(VideoJobStatus status)
+{
+    DP_DEBUG_LOG("videoId: %{public}s, current status: %{public}d, previous status: %{public}d, "
+        "status to set: %{public}d", videoId_.c_str(), curStatus_, preStatus_, status);
+    DP_CHECK_RETURN_RET(curStatus_ == status, false);
+    
+    preStatus_ = curStatus_;
+    curStatus_ = status;
+    return true;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/schedule/video_processor/video_job_repository/video_job_queue.cpp b/services/deferred_processing_service/src/schedule/video_processor/video_job_repository/video_job_queue.cpp
new file mode 100644
index 000000000..1265702af
--- /dev/null
+++ b/services/deferred_processing_service/src/schedule/video_processor/video_job_repository/video_job_queue.cpp
@@ -0,0 +1,130 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "video_job_queue.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+VideoJobQueue::VideoJobQueue(Comparator comp)
+    : comp_(comp)
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+VideoJobQueue::~VideoJobQueue()
+{
+    DP_DEBUG_LOG("entered.");
+    comp_ = nullptr;
+}
+
+bool VideoJobQueue::Contains(DeferredVideoJobPtr obj) const
+{
+    return indexMap_.find(obj) != indexMap_.end();
+}
+
+DeferredVideoJobPtr VideoJobQueue::Peek() const
+{
+    DP_CHECK_RETURN_RET(size_ == DEFAULT, nullptr);
+    return heap_.front();
+}
+
+void VideoJobQueue::Push(DeferredVideoJobPtr obj)
+{
+    heap_.push_back(obj);
+    indexMap_[obj] = size_;
+    HeapInsert(size_++);
+}
+
+DeferredVideoJobPtr VideoJobQueue::Pop()
+{
+    DP_CHECK_RETURN_RET(size_ == DEFAULT, nullptr);
+    DeferredVideoJobPtr ans = heap_.front();
+    Swap(DEFAULT, size_ - 1);
+    indexMap_.erase(ans);
+    heap_.pop_back();
+    --size_;
+    Heapify(DEFAULT);
+    return ans;
+}
+
+void VideoJobQueue::Remove(DeferredVideoJobPtr obj)
+{
+    auto it = indexMap_.find(obj);
+    DP_CHECK_RETURN(it == indexMap_.end());
+
+    int32_t index = it->second;
+    DeferredVideoJobPtr replace = heap_.back();
+    indexMap_.erase(obj);
+    heap_.pop_back();
+    --size_;
+    if (obj == replace) {
+        return;
+    }
+    heap_[index] = replace;
+    indexMap_[replace] = index;
+    Update(replace);
+}
+
+void VideoJobQueue::Update(DeferredVideoJobPtr obj)
+{
+    int32_t index = indexMap_[obj];
+    HeapInsert(index);
+    Heapify(index);
+}
+
+std::vector<DeferredVideoJobPtr> VideoJobQueue::GetAllElements() const
+{
+    return heap_;
+}
+
+void VideoJobQueue::HeapInsert(int32_t index)
+{
+    while (index > 0 && comp_(heap_[index], heap_[(index - 1) >> 1])) {
+        Swap(index, (index - 1) >> 1);
+        index = (index - 1) >> 1;
+    }
+}
+
+void VideoJobQueue::Heapify(int32_t index)
+{
+    int32_t left = (index << 1) + 1;
+    while (left < size_) {
+        int32_t best = (left + 1 < size_ && comp_(heap_[left + 1], heap_[left])) ? left + 1 : left;
+        best = comp_(heap_[best], heap_[index]) ? best : index;
+        if (best == index) {
+            break;
+        }
+        Swap(best, index);
+        index = best;
+        left = (index << 1) + 1;
+    }
+}
+
+void VideoJobQueue::Swap(int32_t x, int32_t y)
+{
+    std::swap(heap_[x], heap_[y]);
+    indexMap_[heap_[x]] = x;
+    indexMap_[heap_[y]] = y;
+}
+
+void VideoJobQueue::Clear()
+{
+    heap_.clear();
+    indexMap_.clear();
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/schedule/video_processor/video_job_repository/video_job_repository.cpp b/services/deferred_processing_service/src/schedule/video_processor/video_job_repository/video_job_repository.cpp
new file mode 100644
index 000000000..6950568f6
--- /dev/null
+++ b/services/deferred_processing_service/src/schedule/video_processor/video_job_repository/video_job_repository.cpp
@@ -0,0 +1,231 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "video_job_repository.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+VideoJobRepository::VideoJobRepository(const int32_t userId) : userId_(userId)
+{
+    DP_DEBUG_LOG("entered, userid: %{public}d", userId_);
+    jobQueue_ = std::make_shared<VideoJobQueue>([] (DeferredVideoJobPtr a, DeferredVideoJobPtr b) {return *a > *b;});
+}
+
+VideoJobRepository::~VideoJobRepository()
+{
+    DP_DEBUG_LOG("entered, userid: %{public}d", userId_);
+    ClearCatch();
+}
+
+void VideoJobRepository::AddVideoJob(const std::string& videoId,
+    const sptr<IPCFileDescriptor>& srcFd, const sptr<IPCFileDescriptor>& dstFd)
+{
+    std::lock_guard<std::recursive_mutex> lock(mutex_);
+    DeferredVideoJobPtr jobPtrFind = GetJobUnLocked(videoId);
+    DP_CHECK_RETURN_LOG(jobPtrFind != nullptr, "already existed, videoId: %{public}s", videoId.c_str());
+
+    DeferredVideoJobPtr jobPtr = std::make_shared<DeferredVideoJob>(videoId, srcFd, dstFd);
+    jobPtr->SetJobStatus(VideoJobStatus::PENDING);
+    jobMap_.emplace(videoId, jobPtr);
+    jobQueue_->Push(jobPtr);
+    DP_INFO_LOG("add video job size: %{public}d, videoId: %{public}s, srcFd: %{public}d",
+        static_cast<int>(jobQueue_->GetSize()), videoId.c_str(), srcFd->GetFd());
+}
+
+bool VideoJobRepository::RemoveVideoJob(const std::string& videoId, bool restorable)
+{
+    DP_INFO_LOG("entered, videoId: %{public}s, restorable: %{public}d", videoId.c_str(), restorable);
+    std::lock_guard<std::recursive_mutex> lock(mutex_);
+    DeferredVideoJobPtr jobPtrFind = GetJobUnLocked(videoId);
+    bool isNeedStop = false;
+    DP_CHECK_RETURN_RET_LOG(jobPtrFind == nullptr, isNeedStop,
+        "does not existed, videoId: %{public}s", videoId.c_str());
+
+    isNeedStop = jobPtrFind->GetCurStatus() == VideoJobStatus::RUNNING;
+    if (!restorable) {
+        DP_INFO_LOG("remove video job size: %{public}d, videoId: %{public}s",
+            static_cast<int>(jobQueue_->GetSize()), videoId.c_str());
+        jobMap_.erase(videoId);
+        jobQueue_->Remove(jobPtrFind);
+    }
+    bool statusChanged = jobPtrFind->SetJobStatus(VideoJobStatus::DELETED);
+    UpdateRunningCountUnLocked(statusChanged, jobPtrFind);
+    return isNeedStop;
+}
+
+void VideoJobRepository::RestoreVideoJob(const std::string& videoId)
+{
+    DP_INFO_LOG("entered, videoId: %{public}s", videoId.c_str());
+    std::lock_guard<std::recursive_mutex> lock(mutex_);
+    DeferredVideoJobPtr jobPtrFind = GetJobUnLocked(videoId);
+    DP_CHECK_RETURN_LOG(jobPtrFind == nullptr, "does not existed, videoId: %{public}s", videoId.c_str());
+
+    bool statusChanged = jobPtrFind->SetJobStatus(VideoJobStatus::PENDING);
+    DP_CHECK_EXECUTE(statusChanged, jobQueue_->Update(jobPtrFind));
+}
+
+void VideoJobRepository::SetJobPending(const std::string& videoId)
+{
+    DP_INFO_LOG("entered, videoId: %{public}s", videoId.c_str());
+    std::lock_guard<std::recursive_mutex> lock(mutex_);
+    DeferredVideoJobPtr jobPtrFind = GetJobUnLocked(videoId);
+    DP_CHECK_RETURN_LOG(jobPtrFind == nullptr, "does not existed, videoId: %{public}s", videoId.c_str());
+
+    bool statusChanged = jobPtrFind->SetJobStatus(VideoJobStatus::PENDING);
+    UpdateRunningCountUnLocked(statusChanged, jobPtrFind);
+    NotifyJobChangedUnLocked(statusChanged, jobPtrFind);
+}
+
+void VideoJobRepository::SetJobRunning(const std::string& videoId)
+{
+    DP_INFO_LOG("entered, videoId: %{public}s", videoId.c_str());
+    std::lock_guard<std::recursive_mutex> lock(mutex_);
+    DeferredVideoJobPtr jobPtrFind = GetJobUnLocked(videoId);
+    DP_CHECK_RETURN_LOG(jobPtrFind == nullptr, "does not existed, videoId: %{public}s", videoId.c_str());
+
+    bool statusChanged = jobPtrFind->SetJobStatus(VideoJobStatus::RUNNING);
+    UpdateRunningCountUnLocked(statusChanged, jobPtrFind);
+}
+
+void VideoJobRepository::SetJobCompleted(const std::string& videoId)
+{
+    DP_INFO_LOG("entered, videoId: %{public}s", videoId.c_str());
+    std::lock_guard<std::recursive_mutex> lock(mutex_);
+    DeferredVideoJobPtr jobPtrFind = GetJobUnLocked(videoId);
+    DP_CHECK_RETURN_LOG(jobPtrFind == nullptr, "does not existed, videoId: %{public}s", videoId.c_str());
+
+    bool statusChanged = jobPtrFind->SetJobStatus(VideoJobStatus::COMPLETED);
+    UpdateRunningCountUnLocked(statusChanged, jobPtrFind);
+    NotifyJobChangedUnLocked(statusChanged, jobPtrFind);
+}
+
+void VideoJobRepository::SetJobFailed(const std::string& videoId)
+{
+    DP_INFO_LOG("entered, videoId: %{public}s", videoId.c_str());
+    std::lock_guard<std::recursive_mutex> lock(mutex_);
+    DeferredVideoJobPtr jobPtrFind = GetJobUnLocked(videoId);
+    DP_CHECK_RETURN_LOG(jobPtrFind == nullptr, "does not existed, videoId: %{public}s", videoId.c_str());
+
+    bool statusChanged = jobPtrFind->SetJobStatus(VideoJobStatus::FAILED);
+    UpdateRunningCountUnLocked(statusChanged, jobPtrFind);
+    NotifyJobChangedUnLocked(statusChanged, jobPtrFind);
+}
+
+void VideoJobRepository::SetJobPause(const std::string& videoId)
+{
+    DP_INFO_LOG("entered, videoId: %{public}s", videoId.c_str());
+    std::lock_guard<std::recursive_mutex> lock(mutex_);
+    DeferredVideoJobPtr jobPtrFind = GetJobUnLocked(videoId);
+    DP_CHECK_RETURN_LOG(jobPtrFind == nullptr, "does not existed, videoId: %{public}s", videoId.c_str());
+
+    bool statusChanged = jobPtrFind->SetJobStatus(VideoJobStatus::PAUSE);
+    UpdateRunningCountUnLocked(statusChanged, jobPtrFind);
+}
+
+void VideoJobRepository::SetJobError(const std::string& videoId)
+{
+    DP_INFO_LOG("entered, videoId: %{public}s", videoId.c_str());
+    std::lock_guard<std::recursive_mutex> lock(mutex_);
+    DeferredVideoJobPtr jobPtrFind = GetJobUnLocked(videoId);
+    DP_CHECK_RETURN_LOG(jobPtrFind == nullptr, "does not existed, videoId: %{public}s", videoId.c_str());
+
+    bool statusChanged = jobPtrFind->SetJobStatus(VideoJobStatus::ERROR);
+    UpdateRunningCountUnLocked(statusChanged, jobPtrFind);
+}
+
+DeferredVideoJobPtr VideoJobRepository::GetJob()
+{
+    DP_INFO_LOG("entered, video job size: %{public}d, running num: %{public}d",
+        jobQueue_->GetSize(), static_cast<int32_t>(runningSet_.size()));
+    std::lock_guard<std::recursive_mutex> lock(mutex_);
+    auto jobPtr = jobQueue_->Peek();
+    DP_CHECK_RETURN_RET(jobPtr == nullptr || jobPtr->GetCurStatus() == VideoJobStatus::COMPLETED ||
+        jobPtr->GetCurStatus() == VideoJobStatus::ERROR, nullptr);
+
+    if (jobPtr->GetCurStatus() == VideoJobStatus::FAILED) {
+        jobPtr->SetJobStatus(VideoJobStatus::PENDING);
+        jobQueue_->Update(jobPtr);
+    }
+    return jobPtr;
+}
+
+
+int32_t VideoJobRepository::GetRunningJobCounts()
+{
+    std::lock_guard<std::recursive_mutex> lock(mutex_);
+    DP_DEBUG_LOG("video running jobs num: %{public}d", static_cast<int32_t>(runningSet_.size()));
+    return static_cast<int32_t>(runningSet_.size());
+}
+
+void VideoJobRepository::GetRunningJobList(std::vector<std::string>& list)
+{
+    std::lock_guard<std::recursive_mutex> lock(mutex_);
+    DP_DEBUG_LOG("video running jobs num: %{public}d", static_cast<int32_t>(runningSet_.size()));
+    list.clear();
+    list.reserve(runningSet_.size());
+    for (auto& item : runningSet_) {
+        list.emplace_back(item);
+    }
+}
+
+void VideoJobRepository::RegisterJobListener(const std::weak_ptr<IVideoJobRepositoryListener>& listener)
+{
+    DP_INFO_LOG("entered");
+    jobListener_ = listener;
+}
+
+DeferredVideoJobPtr VideoJobRepository::GetJobUnLocked(const std::string& videoId)
+{
+    DeferredVideoJobPtr jobPtr = nullptr;
+    if (jobMap_.count(videoId) == 1) {
+        DP_DEBUG_LOG("video job, videoId: %{public}s", videoId.c_str());
+        jobPtr = jobMap_.find(videoId)->second;
+    }
+    return jobPtr;
+}
+
+void VideoJobRepository::NotifyJobChangedUnLocked(bool statusChanged, DeferredVideoJobPtr jobPtr)
+{
+    DP_DEBUG_LOG("entered, statusChanged: %{public}d, videoId: %{public}s",
+        statusChanged, jobPtr->GetVideoId().c_str());
+    if (auto listenerSptr = jobListener_.lock()) {
+        listenerSptr->OnVideoJobChanged(jobPtr);
+    }
+}
+
+void VideoJobRepository::UpdateRunningCountUnLocked(bool statusChanged, const DeferredVideoJobPtr& jobPtr)
+{
+    DP_CHECK_EXECUTE(statusChanged, jobQueue_->Update(jobPtr));
+
+    if (statusChanged && (jobPtr->GetPreStatus() == VideoJobStatus::RUNNING)) {
+        runningSet_.erase(jobPtr->GetVideoId());
+    }
+    if (statusChanged && (jobPtr->GetCurStatus() == VideoJobStatus::RUNNING)) {
+        runningSet_.emplace(jobPtr->GetVideoId());
+    }
+    DP_INFO_LOG("video running jobs num: %{public}d, videoId: %{public}s",
+        static_cast<int32_t>(runningSet_.size()), jobPtr->GetVideoId().c_str());
+}
+
+void VideoJobRepository::ClearCatch()
+{
+    jobQueue_->Clear();
+    jobMap_.clear();
+    runningSet_.clear();
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/session/command/session_command.cpp b/services/deferred_processing_service/src/session/command/session_command.cpp
new file mode 100644
index 000000000..3bfef9da1
--- /dev/null
+++ b/services/deferred_processing_service/src/session/command/session_command.cpp
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "session_command.h"
+
+#include "dps.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+
+SessionCommand::SessionCommand(const sptr<VideoSessionInfo>& sessionInfo) : sessionInfo_(sessionInfo)
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+SessionCommand::~SessionCommand()
+{
+    DP_DEBUG_LOG("entered.");
+    sessionManager_ = nullptr;
+    sessionInfo_ = nullptr;
+}
+
+int32_t SessionCommand::Initialize()
+{
+    DP_CHECK_RETURN_RET(initialized_.load(), DP_OK);
+
+    sessionManager_ = DPS_GetSessionManager();
+    DP_CHECK_ERROR_RETURN_RET_LOG(sessionManager_ == nullptr, DP_NULL_POINTER, "SessionManager is nullptr.");
+    initialized_.store(true);
+    return DP_OK;
+}
+
+int32_t AddVideoSessionCommand::Executing()
+{
+    if (int32_t ret = Initialize() != DP_OK) {
+        return ret;
+    }
+    
+    auto coordinator = sessionManager_->GetSessionCoordinator();
+    DP_CHECK_ERROR_RETURN_RET_LOG(coordinator == nullptr, DP_NULL_POINTER, "SessionCoordinator is nullptr.");
+    auto schedulerManager = DPS_GetSchedulerManager();
+    DP_CHECK_ERROR_RETURN_RET_LOG(schedulerManager == nullptr, DP_NULL_POINTER, "SchedulerManager is nullptr");
+    schedulerManager->CreateVideoProcessor(sessionInfo_->GetUserId(), coordinator->GetVideoProcCallbacks());
+    coordinator->AddSession(sessionInfo_);
+    return DP_OK;
+}
+
+int32_t DeleteVideoSessionCommand::Executing()
+{
+    if (int32_t ret = Initialize() != DP_OK) {
+        return ret;
+    }
+    
+    auto coordinator = sessionManager_->GetSessionCoordinator();
+    DP_CHECK_ERROR_RETURN_RET_LOG(coordinator == nullptr, DP_NULL_POINTER, "SessionCoordinator is nullptr.");
+    coordinator->DeleteSession(sessionInfo_->GetUserId());
+    return DP_OK;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/session/command/sync_command.cpp b/services/deferred_processing_service/src/session/command/sync_command.cpp
new file mode 100644
index 000000000..891babbd0
--- /dev/null
+++ b/services/deferred_processing_service/src/session/command/sync_command.cpp
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "sync_command.h"
+
+#include "dps.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+
+SyncCommand::SyncCommand(const int32_t userId) : userId_(userId)
+{
+    DP_DEBUG_LOG("entered. userId: %{public}d", userId_);
+}
+
+SyncCommand::~SyncCommand()
+{
+    DP_DEBUG_LOG("entered.");
+    schedulerManager_ = nullptr;
+    sessionManager_ = nullptr;
+    processor_ = nullptr;
+}
+
+int32_t SyncCommand::Initialize()
+{
+    DP_CHECK_RETURN_RET(initialized_.load(), DP_OK);
+
+    schedulerManager_ = DPS_GetSchedulerManager();
+    DP_CHECK_ERROR_RETURN_RET_LOG(schedulerManager_ == nullptr, DP_NULL_POINTER, "SchedulerManager is nullptr.");
+    sessionManager_ = DPS_GetSessionManager();
+    DP_CHECK_ERROR_RETURN_RET_LOG(sessionManager_ == nullptr, DP_NULL_POINTER, "SessionManager is nullptr.");
+    processor_ = schedulerManager_->GetVideoProcessor(userId_);
+    DP_CHECK_ERROR_RETURN_RET_LOG(processor_ == nullptr, DP_NULL_POINTER, "VideoProcessor is nullptr.");
+    initialized_.store(true);
+    return DP_OK;
+}
+
+VideoSyncCommand::VideoSyncCommand(const int32_t userId,
+    const std::unordered_map<std::string, std::shared_ptr<DeferredVideoProcessingSession::VideoInfo>>& videoIds)
+    : SyncCommand(userId), videoIds_(videoIds)
+{
+    DP_DEBUG_LOG("VideoSyncCommand, video job num: %{public}d", static_cast<int32_t>(videoIds_.size()));
+}
+
+int32_t VideoSyncCommand::Executing()
+{
+    if (int32_t ret = Initialize() != DP_OK) {
+        return ret;
+    }
+
+    std::vector<std::string> pendingVidoes;
+    bool isSuccess = processor_->GetPendingVideos(pendingVidoes);
+    if (!isSuccess) {
+        for (const auto& it : videoIds_) {
+            processor_->AddVideo(it.first, it.second->srcFd_, it.second->dstFd_);
+        }
+        return DP_OK;
+    }
+
+    std::set<std::string> hdiVideoIds(pendingVidoes.begin(), pendingVidoes.end());
+    for (auto& videoId : hdiVideoIds) {
+        if (videoIds_.count(videoId) != 0) {
+            processor_->AddVideo(videoId, videoIds_[videoId]->srcFd_, videoIds_[videoId]->dstFd_);
+            videoIds_.erase(videoId);
+        } else {
+            processor_->RemoveVideo(videoId, false);
+        }
+    }
+    auto info = sessionManager_->GetSessionInfo(userId_);
+    if (info != nullptr) {
+        auto callbacks =  info->GetRemoteCallback();
+        for (const auto& it : videoIds_) {
+            callbacks->OnError(it.first, ErrorCode::ERROR_VIDEO_PROC_INVALID_VIDEO_ID);
+        }
+    }
+    pendingVidoes.clear();
+    return DP_OK;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/session/command/video_command.cpp b/services/deferred_processing_service/src/session/command/video_command.cpp
new file mode 100644
index 000000000..b2738e69d
--- /dev/null
+++ b/services/deferred_processing_service/src/session/command/video_command.cpp
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "video_command.h"
+
+#include "dps.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+
+VideoCommand::VideoCommand(const int32_t userId, const std::string& videoId)
+    : userId_(userId), videoId_(videoId)
+{
+    DP_DEBUG_LOG("entered. userId: %{public}d, videoId: %{public}s", userId_, videoId_.c_str());
+}
+
+VideoCommand::~VideoCommand()
+{
+    DP_DEBUG_LOG("entered.");
+    schedulerManager_ = nullptr;
+    processor_ = nullptr;
+}
+
+int32_t VideoCommand::Initialize()
+{
+    DP_CHECK_RETURN_RET(initialized_.load(), DP_OK);
+
+    schedulerManager_ = DPS_GetSchedulerManager();
+    DP_CHECK_ERROR_RETURN_RET_LOG(schedulerManager_ == nullptr, DP_NULL_POINTER, "SchedulerManager is nullptr.");
+    processor_ = schedulerManager_->GetVideoProcessor(userId_);
+    DP_CHECK_ERROR_RETURN_RET_LOG(processor_ == nullptr, DP_NULL_POINTER, "VideoProcessor is nullptr.");
+    initialized_.store(true);
+    return DP_OK;
+}
+
+AddVideoCommand::AddVideoCommand(const int32_t userId, const std::string& videoId,
+    const sptr<IPCFileDescriptor>& srcFd, const sptr<IPCFileDescriptor>& dstFd)
+    : VideoCommand(userId, videoId), srcFd_(srcFd), dstFd_(dstFd)
+{
+    DP_DEBUG_LOG("AddVideoCommand, videoId: %{public}s, srcFd: %{public}d, dstFd: %{public}d",
+        videoId_.c_str(), srcFd_->GetFd(), dstFd_->GetFd());
+}
+
+int32_t AddVideoCommand::Executing()
+{
+    if (int32_t ret = Initialize() != DP_OK) {
+        return ret;
+    }
+
+    processor_->AddVideo(videoId_, srcFd_, dstFd_);
+    return DP_OK;
+}
+
+RemoveVideoCommand::RemoveVideoCommand(const int32_t userId, const std::string& videoId, const bool restorable)
+    : VideoCommand(userId, videoId), restorable_(restorable)
+{
+    DP_DEBUG_LOG("RemoveVideoCommand, videoId: %{public}s, restorable: %{public}d", videoId_.c_str(), restorable_);
+}
+
+int32_t RemoveVideoCommand::Executing()
+{
+    if (int32_t ret = Initialize() != DP_OK) {
+        return ret;
+    }
+    
+    processor_->RemoveVideo(videoId_, restorable_);
+    return DP_OK;
+}
+
+int32_t RestoreCommand::Executing()
+{
+    if (int32_t ret = Initialize() != DP_OK) {
+        return ret;
+    }
+
+    processor_->RestoreVideo(videoId_);
+    return DP_OK;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/session/photo_session/deferred_photo_processing_session.cpp b/services/deferred_processing_service/src/session/photo_session/deferred_photo_processing_session.cpp
index f34c0adf8..e10b905db 100644
--- a/services/deferred_processing_service/src/session/photo_session/deferred_photo_processing_session.cpp
+++ b/services/deferred_processing_service/src/session/photo_session/deferred_photo_processing_session.cpp
@@ -93,7 +93,7 @@ int32_t DeferredPhotoProcessingSession::EndSynchronize()
     return 0;
 }
 
-int32_t DeferredPhotoProcessingSession::AddImage(const std::string imageId, DpsMetadata& metadata, bool discardable)
+int32_t DeferredPhotoProcessingSession::AddImage(const std::string& imageId, DpsMetadata& metadata, bool discardable)
 {
     if (inSync_) {
         DP_INFO_LOG("AddImage error, inSync!");
@@ -109,7 +109,7 @@ int32_t DeferredPhotoProcessingSession::AddImage(const std::string imageId, DpsM
     return 0;
 }
 
-int32_t DeferredPhotoProcessingSession::RemoveImage(const std::string imageId, bool restorable)
+int32_t DeferredPhotoProcessingSession::RemoveImage(const std::string& imageId, bool restorable)
 {
     if (inSync_) {
         DP_INFO_LOG("RemoveImage error, inSync!");
@@ -124,7 +124,7 @@ int32_t DeferredPhotoProcessingSession::RemoveImage(const std::string imageId, b
     return 0;
 }
 
-int32_t DeferredPhotoProcessingSession::RestoreImage(const std::string imageId)
+int32_t DeferredPhotoProcessingSession::RestoreImage(const std::string& imageId)
 {
     if (inSync_) {
         DP_INFO_LOG("RestoreImage error, inSync!");
@@ -139,7 +139,7 @@ int32_t DeferredPhotoProcessingSession::RestoreImage(const std::string imageId)
     return 0;
 }
 
-int32_t DeferredPhotoProcessingSession::ProcessImage(const std::string appName, const std::string imageId)
+int32_t DeferredPhotoProcessingSession::ProcessImage(const std::string& appName, const std::string imageId)
 {
     if (inSync_) {
         DP_INFO_LOG("ProcessImage error, inSync!");
@@ -154,7 +154,7 @@ int32_t DeferredPhotoProcessingSession::ProcessImage(const std::string appName,
     return 0;
 }
 
-int32_t DeferredPhotoProcessingSession::CancelProcessImage(const std::string imageId)
+int32_t DeferredPhotoProcessingSession::CancelProcessImage(const std::string& imageId)
 {
     if (inSync_) {
         DP_INFO_LOG("CancelProcessImage error, inSync!");
diff --git a/services/deferred_processing_service/src/session/session_coordinator.cpp b/services/deferred_processing_service/src/session/session_coordinator.cpp
index 9d872fd07..219f25c38 100644
--- a/services/deferred_processing_service/src/session/session_coordinator.cpp
+++ b/services/deferred_processing_service/src/session/session_coordinator.cpp
@@ -20,6 +20,7 @@
 #include "dps_event_report.h"
 #include "steady_clock.h"
 #include "picture.h"
+#include "video_session_info.h"
 
 namespace OHOS {
 namespace CameraStandard {
@@ -49,6 +50,18 @@ ErrorCode MapDpsErrorCode(DpsError errorCode)
         case DpsError::DPS_ERROR_IMAGE_PROC_INTERRUPTED:
             code = ErrorCode::ERROR_IMAGE_PROC_INTERRUPTED;
             break;
+        case DpsError::DPS_ERROR_VIDEO_PROC_INVALID_VIDEO_ID:
+            code = ErrorCode::ERROR_VIDEO_PROC_INVALID_VIDEO_ID;
+            break;
+        case DpsError::DPS_ERROR_VIDEO_PROC_FAILED:
+            code = ErrorCode::ERROR_VIDEO_PROC_FAILED;
+            break;
+        case DpsError::DPS_ERROR_VIDEO_PROC_TIMEOUT:
+            code = ErrorCode::ERROR_VIDEO_PROC_TIMEOUT;
+            break;
+        case DpsError::DPS_ERROR_VIDEO_PROC_INTERRUPTED:
+            code = ErrorCode::ERROR_VIDEO_PROC_INTERRUPTED;
+            break;
         default:
             DP_WARNING_LOG("unexpected error code: %{public}d.", errorCode);
             break;
@@ -96,9 +109,8 @@ public:
         sptr<IPCFileDescriptor> ipcFd = bufferInfo->GetIPCFileDescriptor();
         int32_t dataSize = bufferInfo->GetDataSize();
         bool isCloudImageEnhanceSupported = bufferInfo->IsCloudImageEnhanceSupported();
-        if (coordinator_) {
-            coordinator_->OnProcessDone(userId, imageId, ipcFd, dataSize, isCloudImageEnhanceSupported);
-        }
+        DP_CHECK_EXECUTE(coordinator_ != nullptr,
+            coordinator_->OnProcessDone(userId, imageId, ipcFd, dataSize, isCloudImageEnhanceSupported));
     }
 
     void OnProcessDoneExt(int userId, const std::string& imageId,
@@ -112,26 +124,59 @@ public:
 
     void OnError(const int userId, const std::string& imageId, DpsError errorCode) override
     {
-        if (coordinator_) {
-            coordinator_->OnError(userId, imageId, errorCode);
-        }
+        DP_CHECK_EXECUTE(coordinator_ != nullptr, coordinator_->OnError(userId, imageId, errorCode));
     }
 
     void OnStateChanged(const int32_t userId, DpsStatus statusCode) override
     {
-        if (coordinator_) {
-            coordinator_->OnStateChanged(userId, statusCode);
-        }
+        DP_CHECK_EXECUTE(coordinator_ != nullptr, coordinator_->OnStateChanged(userId, statusCode));
     }
 
 private:
     SessionCoordinator* coordinator_;
 };
 
+class SessionCoordinator::VideoProcCallbacks : public IVideoProcessCallbacks {
+public:
+    explicit VideoProcCallbacks(const std::weak_ptr<SessionCoordinator>& coordinator) : coordinator_(coordinator)
+    {
+    }
+
+    ~VideoProcCallbacks() = default;
+
+    void OnProcessDone(const int32_t userId, const std::string& videoId,
+        const sptr<IPCFileDescriptor>& ipcFd) override
+    {
+        auto video = coordinator_.lock();
+        DP_CHECK_ERROR_RETURN_LOG(video == nullptr, "SessionCoordinator is nullptr.");
+        video->OnVideoProcessDone(userId, videoId, ipcFd);
+    }
+
+    void OnError(const int32_t userId, const std::string& videoId, DpsError errorCode) override
+    {
+        auto video = coordinator_.lock();
+        DP_CHECK_ERROR_RETURN_LOG(video == nullptr, "SessionCoordinator is nullptr.");
+        video->OnVideoError(userId, videoId, errorCode);
+    }
+
+    void OnStateChanged(const int32_t userId, DpsStatus statusCode) override
+    {
+        auto video = coordinator_.lock();
+        DP_CHECK_ERROR_RETURN_LOG(video == nullptr, "SessionCoordinator is nullptr.");
+        video->OnStateChanged(userId, statusCode);
+    }
+
+private:
+    std::weak_ptr<SessionCoordinator> coordinator_;
+};
+
 SessionCoordinator::SessionCoordinator()
     : imageProcCallbacks_(nullptr),
       remoteImageCallbacksMap_(),
-      pendingImageResults_()
+      pendingImageResults_(),
+      videoProcCallbacks_(nullptr),
+      remoteVideoCallbacksMap_(),
+      pendingRequestResults_()
 {
     DP_DEBUG_LOG("entered.");
 }
@@ -139,11 +184,18 @@ SessionCoordinator::SessionCoordinator()
 SessionCoordinator::~SessionCoordinator()
 {
     DP_DEBUG_LOG("entered.");
+    imageProcCallbacks_ = nullptr;
+    remoteImageCallbacksMap_.clear();
+    pendingImageResults_.clear();
+    videoProcCallbacks_ = nullptr;
+    remoteVideoCallbacksMap_.clear();
+    pendingRequestResults_.clear();
 }
 
 void SessionCoordinator::Initialize()
 {
     imageProcCallbacks_ = std::make_shared<ImageProcCallbacks>(this);
+    videoProcCallbacks_ = std::make_shared<VideoProcCallbacks>(weak_from_this());
 }
 
 void SessionCoordinator::Start()
@@ -161,6 +213,11 @@ std::shared_ptr<IImageProcessCallbacks> SessionCoordinator::GetImageProcCallback
     return imageProcCallbacks_;
 }
 
+std::shared_ptr<IVideoProcessCallbacks> SessionCoordinator::GetVideoProcCallbacks()
+{
+    return videoProcCallbacks_;
+}
+
 void SessionCoordinator::OnProcessDone(const int32_t userId, const std::string& imageId,
     const sptr<IPCFileDescriptor>& ipcFd, const int32_t dataSize, bool isCloudImageEnhanceSupported)
 {
@@ -265,6 +322,81 @@ void SessionCoordinator::NotifyCallbackDestroyed(const int32_t userId)
         remoteImageCallbacksMap_.erase(userId);
     }
 }
+
+void SessionCoordinator::AddSession(const sptr<VideoSessionInfo>& sessionInfo)
+{
+    int32_t userId = sessionInfo->GetUserId();
+    DP_INFO_LOG("add session userId: %{public}d", userId);
+    auto callback = sessionInfo->GetRemoteCallback();
+    if (callback != nullptr) {
+        remoteVideoCallbacksMap_[userId] = callback;
+        ProcessVideoResults(callback);
+    }
+}
+
+void SessionCoordinator::DeleteSession(const int32_t userId)
+{
+    if (remoteVideoCallbacksMap_.count(userId) != 0) {
+        DP_INFO_LOG("delete session userId: %{public}d", userId);
+        remoteVideoCallbacksMap_.erase(userId);
+    }
+}
+
+void SessionCoordinator::OnVideoProcessDone(const int32_t userId, const std::string& videoId,
+    const sptr<IPCFileDescriptor> &ipcFd)
+{
+    DP_INFO_LOG("userId: %{public}d, map size: %{public}d.",
+        userId, static_cast<int32_t>(remoteVideoCallbacksMap_.size()));
+    auto iter = remoteVideoCallbacksMap_.find(userId);
+    if (iter != remoteVideoCallbacksMap_.end()) {
+        auto wpCallback = iter->second;
+        sptr<IDeferredVideoProcessingSessionCallback> spCallback = wpCallback.promote();
+        DP_INFO_LOG("videoId: %{public}s", videoId.c_str());
+        spCallback->OnProcessVideoDone(videoId, ipcFd);
+    } else {
+        DP_INFO_LOG("callback is null, videoId: %{public}s.", videoId.c_str());
+    }
+}
+
+void SessionCoordinator::OnVideoError(const int32_t userId, const std::string& videoId, DpsError errorCode)
+{
+    DP_INFO_LOG("userId: %{public}d, map size: %{public}d.",
+        userId, static_cast<int32_t>(remoteVideoCallbacksMap_.size()));
+    auto iter = remoteVideoCallbacksMap_.find(userId);
+    if (iter != remoteVideoCallbacksMap_.end()) {
+        auto wpCallback = iter->second;
+        sptr<IDeferredVideoProcessingSessionCallback> spCallback = wpCallback.promote();
+        auto error = MapDpsErrorCode(errorCode);
+        DP_INFO_LOG("videoId: %{public}s, error: %{public}d", videoId.c_str(), error);
+        spCallback->OnError(videoId, error);
+    } else {
+        DP_INFO_LOG("callback is null, videoId: %{public}s, errorCode: %{public}d.",
+            videoId.c_str(), errorCode);
+    }
+}
+
+void SessionCoordinator::OnVideoStateChanged(const int32_t userId, DpsStatus statusCode)
+{
+    DP_DEBUG_LOG("entered.");
+}
+
+void SessionCoordinator::ProcessVideoResults(sptr<IDeferredVideoProcessingSessionCallback> callback)
+{
+    DP_DEBUG_LOG("entered.");
+    while (!pendingRequestResults_.empty()) {
+        auto result = pendingRequestResults_.front();
+        if (result.callbackType == CallbackType::ON_PROCESS_DONE) {
+            callback->OnProcessVideoDone(result.requestId, result.ipcFd);
+        }
+        if (result.callbackType == CallbackType::ON_ERROR) {
+            callback->OnError(result.requestId, MapDpsErrorCode(result.errorCode));
+        }
+        if (result.callbackType == CallbackType::ON_STATE_CHANGED) {
+            callback->OnStateChanged(MapDpsStatus(result.statusCode));
+        }
+        pendingRequestResults_.pop_back();
+    }
+}
 } // namespace DeferredProcessing
 } // namespace CameraStandard
 } // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/session/session_info.cpp b/services/deferred_processing_service/src/session/session_info.cpp
index 1ac0d33fd..85c0986e0 100644
--- a/services/deferred_processing_service/src/session/session_info.cpp
+++ b/services/deferred_processing_service/src/session/session_info.cpp
@@ -1,107 +1,107 @@
-/*
- * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "session_info.h"
-
-#include "system_ability_definition.h"
-#include "iservice_registry.h"
-#include "session_manager.h"
-#include "dp_log.h"
-
-namespace OHOS {
-namespace CameraStandard {
-namespace DeferredProcessing {
-class SessionInfo::CallbackDeathRecipient : public IRemoteObject::DeathRecipient {
-public:
-    explicit CallbackDeathRecipient(SessionInfo* sessionInfo)
-        : sessionInfo_(sessionInfo)
-    {
-    }
-    ~CallbackDeathRecipient()
-    {
-        sessionInfo_ = nullptr;
-    }
-    void OnRemoteDied(const wptr<IRemoteObject> &remote) override
-    {
-        DP_ERR_LOG("Remote died, do clean works.");
-        if (sessionInfo_ == nullptr) {
-            return;
-        }
-        sessionInfo_->OnCallbackDied();
-    }
-private:
-    SessionInfo* sessionInfo_;
-};
-
-SessionInfo::SessionInfo(const int32_t userId, const sptr<IDeferredPhotoProcessingSessionCallback>& callback,
-    SessionManager* sessionManager)
-    : userId_(userId),
-      callback_(callback),
-      sessionManager_(sessionManager)
-{
-    DP_DEBUG_LOG("userId: %{public}d.", userId_);
-    callbackDeathRecipient_ = sptr<CallbackDeathRecipient>::MakeSptr(this);
-    SetCallback(callback);
-}
-
-SessionInfo::~SessionInfo()
-{
-    DP_DEBUG_LOG("entered.");
-    callback_ = nullptr;
-    sessionManager_ = nullptr;
-}
-
-sptr<IDeferredPhotoProcessingSession> SessionInfo::CreateDeferredPhotoProcessingSession(const int32_t userId,
-    std::shared_ptr<DeferredPhotoProcessor> processor, TaskManager* taskManager,
-    sptr<IDeferredPhotoProcessingSessionCallback> callback)
-{
-    session_ = sptr<DeferredPhotoProcessingSession>::MakeSptr(userId, processor, taskManager, callback);
-    DP_INFO_LOG("CreateDeferredProcessingSession successful.");
-    return session_;
-}
-
-sptr<IDeferredPhotoProcessingSession> SessionInfo::GetDeferredPhotoProcessingSession()
-{
-    return session_;
-}
-
-sptr<IDeferredPhotoProcessingSessionCallback> SessionInfo::GetRemoteCallback()
-{
-    return callback_;
-}
-
-void SessionInfo::OnCallbackDied()
-{
-    if (sessionManager_ == nullptr) {
-        DP_ERR_LOG("SessionInfo::sessionManager_ is null.");
-        return;
-    }
-    sessionManager_->OnCallbackDied(userId_);
-}
-
-void SessionInfo::SetCallback(const sptr<IDeferredPhotoProcessingSessionCallback>& callback)
-{
-    DP_INFO_LOG("reset callback");
-    callback_ = callback;
-    sptr<IRemoteObject> object = callback_->AsObject();
-    auto result = object->AddDeathRecipient(callbackDeathRecipient_);
-    if (!result) {
-        DP_ERR_LOG("AddDeathRecipient for Callback failed.");
-    }
-    return;
-}
-} // namespace DeferredProcessing
-} // namespace CameraStandard
-} // namespace OHOS
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "session_info.h"
+
+#include "iservice_registry.h"
+#include "session_manager.h"
+#include "dp_log.h"
+#include "ideferred_photo_processing_session.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class SessionInfo::CallbackDeathRecipient : public IRemoteObject::DeathRecipient {
+public:
+    explicit CallbackDeathRecipient(SessionInfo* sessionInfo)
+        : sessionInfo_(sessionInfo)
+    {
+    }
+    ~CallbackDeathRecipient()
+    {
+        sessionInfo_ = nullptr;
+    }
+    void OnRemoteDied(const wptr<IRemoteObject> &remote) override
+    {
+        DP_ERR_LOG("Remote died, do clean works.");
+        if (sessionInfo_ == nullptr) {
+            return;
+        }
+        sessionInfo_->OnCallbackDied();
+    }
+private:
+    SessionInfo* sessionInfo_;
+};
+
+SessionInfo::SessionInfo(const int32_t userId, const sptr<IDeferredPhotoProcessingSessionCallback>& callback,
+    SessionManager* sessionManager)
+    : userId_(userId),
+      callback_(callback),
+      sessionManager_(sessionManager)
+{
+    DP_DEBUG_LOG("userId: %{public}d.", userId_);
+    callbackDeathRecipient_ = sptr<CallbackDeathRecipient>::MakeSptr(this);
+    SetCallback(callback);
+}
+
+SessionInfo::~SessionInfo()
+{
+    DP_DEBUG_LOG("entered.");
+    callback_ = nullptr;
+    sessionManager_ = nullptr;
+}
+
+sptr<IDeferredPhotoProcessingSession> SessionInfo::CreateDeferredPhotoProcessingSession(const int32_t userId,
+    std::shared_ptr<DeferredPhotoProcessor> processor, TaskManager* taskManager,
+    sptr<IDeferredPhotoProcessingSessionCallback> callback)
+{
+    session_ = sptr<DeferredPhotoProcessingSession>::MakeSptr(userId, processor, taskManager, callback);
+    DP_INFO_LOG("CreateDeferredProcessingSession successful.");
+    return session_;
+}
+
+sptr<IDeferredPhotoProcessingSession> SessionInfo::GetDeferredPhotoProcessingSession()
+{
+    return session_;
+}
+
+sptr<IDeferredPhotoProcessingSessionCallback> SessionInfo::GetRemoteCallback()
+{
+    return callback_;
+}
+
+void SessionInfo::OnCallbackDied()
+{
+    if (sessionManager_ == nullptr) {
+        DP_ERR_LOG("SessionInfo::sessionManager_ is null.");
+        return;
+    }
+    sessionManager_->OnCallbackDied(userId_);
+}
+
+void SessionInfo::SetCallback(const sptr<IDeferredPhotoProcessingSessionCallback>& callback)
+{
+    DP_INFO_LOG("reset callback");
+    callback_ = callback;
+    sptr<IRemoteObject> object = callback_->AsObject();
+    auto result = object->AddDeathRecipient(callbackDeathRecipient_);
+    if (!result) {
+        DP_ERR_LOG("AddDeathRecipient for Callback failed.");
+    }
+    return;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
diff --git a/services/deferred_processing_service/src/session/session_manager.cpp b/services/deferred_processing_service/src/session/session_manager.cpp
index 9af9cc72c..2f317e677 100644
--- a/services/deferred_processing_service/src/session/session_manager.cpp
+++ b/services/deferred_processing_service/src/session/session_manager.cpp
@@ -15,9 +15,10 @@
 
 #include "session_manager.h"
 
-#include "system_ability_definition.h"
 #include "dp_log.h"
-#include "dp_utils.h"
+#include "dps.h"
+#include "session_command.h"
+#include "session_coordinator.h"
 
 namespace OHOS {
 namespace CameraStandard {
@@ -36,7 +37,8 @@ std::shared_ptr<SessionManager> SessionManager::Create()
 SessionManager::SessionManager()
     : initialized_(false),
       photoSessionInfos_(),
-      coordinator_(std::make_unique<SessionCoordinator>())
+      videoSessionInfos_(),
+      coordinator_(std::make_shared<SessionCoordinator>())
 {
     DP_DEBUG_LOG("entered.");
 }
@@ -47,6 +49,7 @@ SessionManager::~SessionManager()
     initialized_ = false;
     coordinator_ = nullptr;
     photoSessionInfos_.clear();
+    videoSessionInfos_.Clear();
 }
 
 void SessionManager::Initialize()
@@ -72,11 +75,9 @@ sptr<IDeferredPhotoProcessingSession> SessionManager::CreateDeferredPhotoProcess
     const sptr<IDeferredPhotoProcessingSessionCallback> callback, std::shared_ptr<DeferredPhotoProcessor> processor,
     TaskManager* taskManager)
 {
+    DP_CHECK_ERROR_RETURN_RET_LOG(!initialized_.load(), nullptr, "failed due to uninitialized.");
+
     DP_INFO_LOG("SessionManager::CreateDeferredPhotoProcessingSession create session for userId: %{public}d", userId);
-    if (initialized_.load() == false) {
-        DP_ERR_LOG("failed due to uninitialized.");
-        return nullptr;
-    }
     for (auto it = photoSessionInfos_.begin(); it != photoSessionInfos_.end(); ++it) {
         DP_DEBUG_LOG("dump photoSessionInfos_ userId: %{public}d", it->first);
     }
@@ -113,7 +114,42 @@ sptr<IDeferredPhotoProcessingSessionCallback> SessionManager::GetCallback(const
     return nullptr;
 }
 
-void SessionManager::OnCallbackDied(const int userId)
+sptr<IDeferredVideoProcessingSession> SessionManager::CreateDeferredVideoProcessingSession(const int32_t userId,
+    const sptr<IDeferredVideoProcessingSessionCallback> callback)
+{
+    DP_CHECK_ERROR_RETURN_RET_LOG(!initialized_.load(), nullptr, "failed due to uninitialized.");
+
+    DP_INFO_LOG("create video session for userId: %{public}d", userId);
+    auto sessionInfo = GetSessionInfo(userId);
+    if (sessionInfo == nullptr) {
+        DP_INFO_LOG("video session creat susses");
+        sessionInfo = sptr<VideoSessionInfo>::MakeSptr(userId, callback);
+        videoSessionInfos_.Insert(userId, sessionInfo);
+    } else {
+        DP_DEBUG_LOG("video session already existed");
+        sessionInfo->SetCallback(callback);
+    }
+    auto ret = DPS_SendUrgentCommand<AddVideoSessionCommand>(sessionInfo);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != DP_OK, nullptr, "AddVideoSession failed, ret: %{public}d", ret);
+
+    return sessionInfo->GetDeferredVideoProcessingSession();
+}
+
+sptr<VideoSessionInfo> SessionManager::GetSessionInfo(const int32_t userId)
+{
+    sptr<VideoSessionInfo> info;
+    DP_CHECK_RETURN_RET(videoSessionInfos_.Find(userId, info), info);
+    
+    DP_ERR_LOG("not get SessionInfo, userId: %{public}d", userId);
+    return nullptr;
+}
+
+std::shared_ptr<SessionCoordinator> SessionManager::GetSessionCoordinator()
+{
+    return coordinator_;
+}
+
+void SessionManager::OnCallbackDied(const int32_t userId)
 {
     if (photoSessionInfos_.count(userId) != 0) {
         coordinator_->NotifyCallbackDestroyed(userId);
diff --git a/services/deferred_processing_service/src/session/video_session/deferred_video_processing_session.cpp b/services/deferred_processing_service/src/session/video_session/deferred_video_processing_session.cpp
new file mode 100644
index 000000000..46e3d7db9
--- /dev/null
+++ b/services/deferred_processing_service/src/session/video_session/deferred_video_processing_session.cpp
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "deferred_video_processing_session.h"
+
+#include "dps_video_report.h"
+#include "dps.h"
+#include "video_command.h"
+#include "sync_command.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+DeferredVideoProcessingSession::DeferredVideoProcessingSession(const int32_t userId)
+    : userId_(userId)
+{
+    DP_DEBUG_LOG("entered. userId: %{public}d", userId_);
+}
+
+DeferredVideoProcessingSession::~DeferredVideoProcessingSession()
+{
+    DP_DEBUG_LOG("entered.");
+    videoIds_.clear();
+}
+
+int32_t DeferredVideoProcessingSession::BeginSynchronize()
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    DP_INFO_LOG("entered.");
+    inSync_.store(true);
+    const std::string videoId = "default";
+    return DP_OK;
+}
+
+int32_t DeferredVideoProcessingSession::EndSynchronize()
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    if (inSync_.load()) {
+        DP_INFO_LOG("entered, video job num: %{public}d", static_cast<int32_t>(videoIds_.size()));
+        auto ret = DPS_SendCommand<VideoSyncCommand>(userId_, videoIds_);
+        inSync_.store(false);
+        DP_CHECK_ERROR_RETURN_RET_LOG(ret != DP_OK, ret, "video synchronize failed, ret: %{public}d", ret);
+        videoIds_.clear();
+        const std::string videoId = "default";
+    }
+    return DP_OK;
+}
+
+int32_t DeferredVideoProcessingSession::AddVideo(const std::string& videoId,
+    const sptr<IPCFileDescriptor>& srcFd, const sptr<IPCFileDescriptor>& dstFd)
+{
+    auto infd = sptr<IPCFileDescriptor>::MakeSptr(dup(srcFd->GetFd()));
+    auto outFd = sptr<IPCFileDescriptor>::MakeSptr(dup(dstFd->GetFd()));
+    if (inSync_.load()) {
+        std::lock_guard<std::mutex> lock(mutex_);
+        DP_INFO_LOG("AddVideo error, inSync!");
+        auto info = std::make_shared<VideoInfo>(infd, outFd);
+        videoIds_.emplace(videoId, info);
+        return DP_OK;
+    }
+
+    auto ret = DPS_SendCommand<AddVideoCommand>(userId_, videoId, infd, outFd);
+    DP_CHECK_ERROR_PRINT_LOG(ret != DP_OK, "add videoId: %{public}s failed. ret: %{public}d", videoId.c_str(), ret);
+    DfxVideoReport::GetInstance().ReportAddVideoEvent(videoId, GetDpsCallerInfo());
+    return ret;
+}
+
+int32_t DeferredVideoProcessingSession::RemoveVideo(const std::string& videoId, bool restorable)
+{
+    DP_CHECK_RETURN_RET_LOG(inSync_.load(), DP_OK, "RemoveVideo error, inSync!");
+
+    auto ret = DPS_SendCommand<RemoveVideoCommand>(userId_, videoId, restorable);
+    DP_CHECK_ERROR_PRINT_LOG(ret != DP_OK, "remove videoId: %{public}s failed. ret: %{public}d", videoId.c_str(), ret);
+    
+    DfxVideoReport::GetInstance().ReportRemoveVideoEvent(videoId, GetDpsCallerInfo());
+    return ret;
+}
+
+int32_t DeferredVideoProcessingSession::RestoreVideo(const std::string& videoId)
+{
+    DP_CHECK_RETURN_RET_LOG(inSync_.load(), DP_OK, "RestoreVideo error, inSync!");
+
+    auto ret = DPS_SendCommand<RestoreCommand>(userId_, videoId);
+    DP_CHECK_ERROR_PRINT_LOG(ret != DP_OK, "restore videoId: %{public}s failed. ret: %{public}u", videoId.c_str(), ret);
+    return ret;
+}
+
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/session/video_session/video_session_info.cpp b/services/deferred_processing_service/src/session/video_session/video_session_info.cpp
new file mode 100644
index 000000000..91365ade1
--- /dev/null
+++ b/services/deferred_processing_service/src/session/video_session/video_session_info.cpp
@@ -0,0 +1,128 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "video_session_info.h"
+
+#include "deferred_video_processing_session.h"
+#include "dp_catch.h"
+#include "dp_log.h"
+#include "dps.h"
+#include "session_command.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+class VideoSessionInfo::CallbackDeathRecipient : public IRemoteObject::DeathRecipient {
+public:
+    explicit CallbackDeathRecipient(wptr<VideoSessionInfo> sessionInfo)
+        : sessionInfo_(sessionInfo)
+    {
+    }
+
+    virtual ~CallbackDeathRecipient() = default;
+
+    int32_t Initialize(const sptr<CallbackDeathRecipient>& recipient,
+        const sptr<IDeferredVideoProcessingSessionCallback>& callback)
+    {
+        DP_DEBUG_LOG("entered.");
+        sptr<IRemoteObject> object = callback->AsObject();
+        auto result = object->AddDeathRecipient(recipient);
+        DP_CHECK_ERROR_RETURN_RET_LOG(!result, DP_INIT_FAIL, "add DeathRecipient for Callback failed.");
+        return DP_OK;
+    }
+
+    int32_t Destory(const sptr<CallbackDeathRecipient>& recipient,
+        const sptr<IDeferredVideoProcessingSessionCallback>& callback)
+    {
+        DP_DEBUG_LOG("entered.");
+        sptr<IRemoteObject> object = callback->AsObject();
+        auto result = object->RemoveDeathRecipient(recipient);
+        DP_CHECK_ERROR_RETURN_RET_LOG(!result, DP_INIT_FAIL, "remove DeathRecipient for Callback failed.");
+        return DP_OK;
+    }
+
+    void OnRemoteDied(const wptr<IRemoteObject> &remote) override
+    {
+        DP_ERR_LOG("Remote died, do clean works.");
+        auto info = sessionInfo_.promote();
+        DP_CHECK_RETURN_LOG(info == nullptr, "VideoSessionInfo is nullptr.");
+        info->OnCallbackDied();
+    }
+
+private:
+    wptr<VideoSessionInfo> sessionInfo_;
+};
+
+VideoSessionInfo::VideoSessionInfo(const int32_t userId, const sptr<IDeferredVideoProcessingSessionCallback>& callback)
+    : userId_(userId), callback_(callback), deathRecipient_(nullptr)
+{
+    DP_DEBUG_LOG("entered. userId: %{public}d.", userId_);
+    Initialize();
+}
+
+VideoSessionInfo::~VideoSessionInfo()
+{
+    DP_DEBUG_LOG("entered.");
+    DP_CHECK_EXECUTE(callback_ != nullptr && deathRecipient_ != nullptr,
+        deathRecipient_->Destory(deathRecipient_, callback_));
+    session_ = nullptr;
+    callback_ = nullptr;
+    deathRecipient_ =nullptr;
+}
+
+int32_t VideoSessionInfo::Initialize()
+{
+    DP_CHECK_ERROR_RETURN_RET_LOG(callback_ == nullptr, DP_NULL_POINTER,
+        "VideoSessionInfo init failed, callback is nullptr.");
+
+    session_ = sptr<DeferredVideoProcessingSession>::MakeSptr(userId_);
+    deathRecipient_ = sptr<CallbackDeathRecipient>::MakeSptr(this);
+
+    auto ret = deathRecipient_->Initialize(deathRecipient_, callback_);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret != DP_OK, ret, "set DeathRecipient failed.");
+    return DP_OK;
+}
+
+sptr<IDeferredVideoProcessingSession> VideoSessionInfo::GetDeferredVideoProcessingSession()
+{
+    return session_;
+}
+
+sptr<IDeferredVideoProcessingSessionCallback> VideoSessionInfo::GetRemoteCallback()
+{
+    return callback_;
+}
+
+int32_t VideoSessionInfo::GetUserId() const
+{
+    return userId_;
+}
+
+void VideoSessionInfo::OnCallbackDied()
+{
+    auto ret = DPS_SendUrgentCommand<DeleteVideoSessionCommand>(this);
+    DP_CHECK_ERROR_PRINT_LOG(ret != DP_OK, "DeleteVideoSession failed.");
+}
+
+void VideoSessionInfo::SetCallback(const sptr<IDeferredVideoProcessingSessionCallback>& callback)
+{
+    DP_INFO_LOG("reset callback");
+    callback_ = callback;
+    auto ret = deathRecipient_->Initialize(deathRecipient_, callback_);
+    DP_CHECK_ERROR_PRINT_LOG(ret != DP_OK, "set DeathRecipient failed.");
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
diff --git a/services/deferred_processing_service/src/utils/dp_power_manager.cpp b/services/deferred_processing_service/src/utils/dp_power_manager.cpp
new file mode 100644
index 000000000..1aaf6be33
--- /dev/null
+++ b/services/deferred_processing_service/src/utils/dp_power_manager.cpp
@@ -0,0 +1,95 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "dp_power_manager.h"
+
+#include "dp_log.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+namespace {
+    const std::string DEFERRED_LOCK_NAME = "DeferredProcessingWakeLock";
+}
+
+DPSProwerManager::DPSProwerManager()
+{
+    DP_DEBUG_LOG("entered.");
+    Initialize();
+}
+
+DPSProwerManager::~DPSProwerManager()
+{
+    DP_DEBUG_LOG("entered.");
+    wakeLock_ = nullptr;
+}
+
+void DPSProwerManager::Initialize()
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    DP_DEBUG_LOG("entered.");
+    if (initialized_.load()) {
+        return;
+    }
+
+#ifdef CAMERA_USE_POWER
+    auto& power = PowerMgr::PowerMgrClient::GetInstance();
+    wakeLock_ = power.CreateRunningLock(DEFERRED_LOCK_NAME, PowerMgr::RunningLockType::RUNNINGLOCK_BACKGROUND);
+    if (wakeLock_ == nullptr) {
+        DP_ERR_LOG("DPSProwerManager initialize failed.");
+        return;
+    }
+#endif
+    initialized_.store(true);
+}
+
+void DPSProwerManager::SetAutoSuspend(bool isAutoSuspend, uint32_t time)
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    DP_DEBUG_LOG("entered.");
+    if (wakeLock_ == nullptr) {
+        DP_ERR_LOG("WakeLock is null.");
+        return;
+    }
+
+    if (isAutoSuspend) {
+        if (isSuspend_) {
+            EnableAutoSuspend();
+            isSuspend_ = false;
+        } else {
+            DP_DEBUG_LOG("AutoSuspend already turn on.");
+        }
+    } else {
+        if (!isSuspend_) {
+            DisableAutoSuspend(time);
+            isSuspend_ = true;
+        } else {
+            DP_DEBUG_LOG("AutoSuspend already not turn on yet.");
+        }
+    }
+}
+
+void DPSProwerManager::EnableAutoSuspend()
+{
+    DP_CHECK_EXECUTE(wakeLock_ != nullptr, wakeLock_->UnLock());
+}
+
+void DPSProwerManager::DisableAutoSuspend(uint32_t time)
+{
+    DP_CHECK_EXECUTE(wakeLock_ != nullptr, wakeLock_->Lock(time));
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/utils/dp_timer.cpp b/services/deferred_processing_service/src/utils/dp_timer.cpp
new file mode 100644
index 000000000..f9707db60
--- /dev/null
+++ b/services/deferred_processing_service/src/utils/dp_timer.cpp
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "dp_timer.h"
+
+#include "common_timer_errors.h"
+#include "dp_log.h"
+
+namespace OHOS {
+namespace CameraStandard {
+namespace DeferredProcessing {
+DpsTimer::DpsTimer() : timer_(std::make_unique<Utils::Timer>("DpsManagerTimer"))
+{
+    timer_->Setup();
+}
+
+DpsTimer::~DpsTimer()
+{
+    if (timer_) {
+        timer_->Shutdown(true);
+        timer_ = nullptr;
+    }
+}
+
+uint32_t DpsTimer::StartTimer(const TimerCallback& callback, uint32_t interval)
+{
+    DP_CHECK_ERROR_RETURN_RET_LOG(timer_ == nullptr, INVALID_TIMEID, "DpsTimer is nullptr");
+
+    uint32_t ret = timer_->Register(callback, interval, true);
+    DP_CHECK_ERROR_RETURN_RET_LOG(ret == Utils::TIMER_ERR_DEAL_FAILED, INVALID_TIMEID, "Register timer failed");
+
+    DP_DEBUG_LOG("timerId is %{public}u, interval is %{public}u", ret, interval);
+    return ret;
+}
+
+void DpsTimer::StopTimer(uint32_t& timerId)
+{
+    DP_DEBUG_LOG("timer shutting down, timerId = %{public}u", timerId);
+    DP_CHECK_ERROR_RETURN_LOG(timerId == INVALID_TIMEID, "UnRegister timer failed, timerId is invalid");
+    DP_CHECK_ERROR_RETURN_LOG(timer_ == nullptr, "DpsTimer is nullptr");
+
+    timer_->Unregister(timerId);
+    timerId = INVALID_TIMEID;
+}
+} // namespace DeferredProcessing
+} // namespace CameraStandard
+} // namespace OHOS
\ No newline at end of file
diff --git a/services/deferred_processing_service/src/utils/dp_utils.cpp b/services/deferred_processing_service/src/utils/dp_utils.cpp
index ff6a9775d..764f91020 100644
--- a/services/deferred_processing_service/src/utils/dp_utils.cpp
+++ b/services/deferred_processing_service/src/utils/dp_utils.cpp
@@ -12,8 +12,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 #include "dp_utils.h"
+
+#include "bundle_mgr_interface.h"
 #include "dp_log.h"
+#include "ipc_skeleton.h"
+#include "iservice_registry.h"
+#include "system_ability_definition.h"
 
 namespace OHOS {
 namespace CameraStandard {
@@ -23,22 +29,74 @@ Watchdog& GetGlobalWatchdog()
     static Watchdog instance("DPSGlobalWatchdog");
     return instance;
 }
-std::unordered_map<std::string, float> exifOrientationDegree = {
-    {"Top-left", 0},
-    {"Top-right", 90},
-    {"Bottom-right", 180},
-    {"Right-top", 90},
-    {"Left-bottom", 270},
-};
-
-float TransExifOrientationToDegree(const std::string& orientation)
-{
-    float degree = .0;
-    if (exifOrientationDegree.count(orientation)) {
-        degree = exifOrientationDegree[orientation];
-    }
-    return degree;
-}
+std::unordered_map<std::string, float> exifOrientationDegree = {
+    {"Top-left", 0},
+    {"Top-right", 90},
+    {"Bottom-right", 180},
+    {"Right-top", 90},
+    {"Left-bottom", 270},
+};
+
+float TransExifOrientationToDegree(const std::string& orientation)
+{
+    float degree = .0;
+    if (exifOrientationDegree.count(orientation)) {
+        degree = exifOrientationDegree[orientation];
+    }
+    return degree;
+}
+
+std::string GetClientBundle(int uid)
+{
+    std::string bundleName = "";
+    auto samgr = SystemAbilityManagerClient::GetInstance().GetSystemAbilityManager();
+    if (samgr == nullptr) {
+        DP_ERR_LOG("Get ability manager failed");
+        return bundleName;
+    }
+
+    sptr<IRemoteObject> object = samgr->GetSystemAbility(BUNDLE_MGR_SERVICE_SYS_ABILITY_ID);
+    if (object == nullptr) {
+        DP_DEBUG_LOG("object is NULL.");
+        return bundleName;
+    }
+
+    sptr<OHOS::AppExecFwk::IBundleMgr> bms = iface_cast<OHOS::AppExecFwk::IBundleMgr>(object);
+    if (bms == nullptr) {
+        DP_DEBUG_LOG("bundle manager service is NULL.");
+        return bundleName;
+    }
+
+    auto result = bms->GetNameForUid(uid, bundleName);
+    if (result != ERR_OK || bundleName.empty()) {
+        DP_ERR_LOG("GetBundleNameForUid fail");
+        return "";
+    }
+    AppExecFwk::BundleInfo bundleInfo;
+    bms->GetBundleInfo(bundleName,
+        static_cast<int32_t>(AppExecFwk::GetBundleInfoFlag::GET_BUNDLE_INFO_WITH_APPLICATION),
+        bundleInfo, AppExecFwk::Constants::ALL_USERID);
+    std::string versionName = bundleInfo.versionName;
+    if (versionName.empty()) {
+        DP_ERR_LOG("get versionName form application failed.");
+        return "";
+    }
+    DP_INFO_LOG("bundle name is %{public}s versionName:%{public}s", bundleName.c_str(), versionName.c_str());
+
+    return bundleName;
+}
+
+DpsCallerInfo GetDpsCallerInfo()
+{
+    DpsCallerInfo dpsCallerInfo;
+    dpsCallerInfo.pid = IPCSkeleton::GetCallingPid();
+    dpsCallerInfo.uid = IPCSkeleton::GetCallingUid();
+    dpsCallerInfo.tokenID = IPCSkeleton::GetCallingTokenID();
+    dpsCallerInfo.bundleName = GetClientBundle(dpsCallerInfo.uid);
+    DP_DEBUG_LOG("GetDpsCallerInfo pid:%{public}d uid:%{public}d tokenID:%{public}d",
+        dpsCallerInfo.pid, dpsCallerInfo.uid, dpsCallerInfo.tokenID);
+    return dpsCallerInfo;
+}
 } // namespace DeferredProcessing
 } // namespace CameraStandard
 } // namespace OHOS
\ No newline at end of file
diff --git a/services/etc/camera_service.cfg b/services/etc/camera_service.cfg
index 090cae0a3..d47a1afce 100644
--- a/services/etc/camera_service.cfg
+++ b/services/etc/camera_service.cfg
@@ -1,4 +1,12 @@
 {
+    "jobs" : [{
+            "name" : "post-fs-data",
+            "cmds" : [
+                "mkdir /data/service/el1/public/camera_service 0760 cameraserver cameraserver",
+                "mkdir /data/service/el1/public/camera_service/cache 0760 cameraserver cameraserver"
+            ]
+        }
+    ],
     "services" : [{
             "name" : "camera_service",
             "path" : ["/system/bin/sa_main", "/system/profile/camera_service.json"],
-- 
2.45.2.huawei.5

