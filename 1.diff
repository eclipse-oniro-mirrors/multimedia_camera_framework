From 6d02cf4304bd1f393e2813ca7d254c492a00af89 Mon Sep 17 00:00:00 2001
From: x00680562 <x00680562@notesmail.huawei.com/>
Date: Sun, 11 Aug 2024 17:07:21 +0800
Subject: [PATCH] TicketNo: DTS2024082035960 Description: depth data stream
 Team:OTHERS Feature or Bugfix:Bugfix Binary Source: sync from gitee
 PrivateCode(Yes/No):No cherry picked from commit
 4b2d83e609c759972e07ee9a715b39f11fa2a9f3

Change-Id: I1c49232ee758f149860121e2159d91eb61114deb
---
 .../src/camera_napi_object_types.cpp          |  18 +
 .../src/input/camera_manager_napi.cpp         |  30 +
 .../src/native_module_ohos_camera.cpp         |   4 +
 .../src/output/depth_data_napi.cpp            | 293 ++++++++
 .../src/output/depth_data_output_napi.cpp     | 682 ++++++++++++++++++
 .../src/session/camera_session_napi.cpp       |   5 +
 frameworks/native/camera/BUILD.gn             |   4 +
 .../camera/src/input/camera_manager.cpp       | 130 +++-
 .../src/output/camera_output_capability.cpp   |  19 +
 .../camera/src/output/capture_output.cpp      |  12 +
 .../camera/src/output/depth_data_output.cpp   | 223 ++++++
 .../camera/src/session/capture_session.cpp    |   7 +
 .../camera/include/camera_stream_info_parse.h | 113 +++
 .../camera/include/input/camera_manager.h     |  36 +-
 .../include/output/camera_output_capability.h |  40 +-
 .../camera/include/output/capture_output.h    |   5 +
 .../camera/include/output/depth_data_output.h | 113 +++
 interfaces/kits/js/camera_napi/BUILD.gn       |   2 +
 .../camera_napi/include/camera_napi_const.h   |   2 +
 .../include/camera_napi_object_types.h        |   9 +
 .../include/input/camera_manager_napi.h       |   3 +
 .../include/output/depth_data_napi.h          |  68 ++
 .../include/output/depth_data_output_napi.h   | 173 +++++
 .../include/session/camera_session_napi.h     |   1 +
 services/camera_service/BUILD.gn              |   5 +
 .../camera_service_ipc_interface_code.h       |  25 +
 .../binder/base/include/icamera_service.h     |   4 +
 .../binder/base/include/istream_common.h      |   1 +
 .../binder/base/include/istream_depth_data.h  |  42 ++
 .../include/istream_depth_data_callback.h     |  33 +
 .../client/include/hcamera_service_proxy.h    |   3 +
 .../hstream_depth_data_callback_proxy.h       |  38 +
 .../client/include/hstream_depth_data_proxy.h |  44 ++
 .../client/src/hcamera_service_proxy.cpp      |  35 +
 .../src/hstream_depth_data_callback_proxy.cpp |  46 ++
 .../client/src/hstream_depth_data_proxy.cpp   | 118 +++
 .../server/include/hcamera_service_stub.h     |   1 +
 .../server/include/hcapture_session_stub.h    |   1 +
 .../hstream_depth_data_callback_stub.h        |  34 +
 .../server/include/hstream_depth_data_stub.h  |  37 +
 .../server/src/hcamera_service_stub.cpp       |  28 +
 .../server/src/hcapture_session_stub.cpp      |   6 +-
 .../src/hstream_depth_data_callback_stub.cpp  |  48 ++
 .../server/src/hstream_depth_data_stub.cpp    |  82 +++
 .../camera_service/include/hcamera_service.h  |   3 +
 .../include/hstream_depth_data.h              |  68 ++
 services/camera_service/src/camera_util.cpp   |   3 +-
 .../camera_service/src/hcamera_service.cpp    |  30 +-
 .../camera_service/src/hcapture_session.cpp   |   3 +
 .../camera_service/src/hstream_depth_data.cpp | 267 +++++++
 50 files changed, 2990 insertions(+), 7 deletions(-)
 create mode 100644 frameworks/js/camera_napi/src/output/depth_data_napi.cpp
 create mode 100644 frameworks/js/camera_napi/src/output/depth_data_output_napi.cpp
 create mode 100644 frameworks/native/camera/src/output/depth_data_output.cpp
 create mode 100644 interfaces/inner_api/native/camera/include/output/depth_data_output.h
 create mode 100644 interfaces/kits/js/camera_napi/include/output/depth_data_napi.h
 create mode 100644 interfaces/kits/js/camera_napi/include/output/depth_data_output_napi.h
 create mode 100644 services/camera_service/binder/base/include/istream_depth_data.h
 create mode 100644 services/camera_service/binder/base/include/istream_depth_data_callback.h
 create mode 100644 services/camera_service/binder/client/include/hstream_depth_data_callback_proxy.h
 create mode 100644 services/camera_service/binder/client/include/hstream_depth_data_proxy.h
 create mode 100644 services/camera_service/binder/client/src/hstream_depth_data_callback_proxy.cpp
 create mode 100644 services/camera_service/binder/client/src/hstream_depth_data_proxy.cpp
 create mode 100644 services/camera_service/binder/server/include/hstream_depth_data_callback_stub.h
 create mode 100644 services/camera_service/binder/server/include/hstream_depth_data_stub.h
 create mode 100644 services/camera_service/binder/server/src/hstream_depth_data_callback_stub.cpp
 create mode 100644 services/camera_service/binder/server/src/hstream_depth_data_stub.cpp
 create mode 100644 services/camera_service/include/hstream_depth_data.h
 create mode 100644 services/camera_service/src/hstream_depth_data.cpp

diff --git a/frameworks/js/camera_napi/src/camera_napi_object_types.cpp b/frameworks/js/camera_napi/src/camera_napi_object_types.cpp
index 96fad4619..cd9503879 100644
--- a/frameworks/js/camera_napi/src/camera_napi_object_types.cpp
+++ b/frameworks/js/camera_napi/src/camera_napi_object_types.cpp
@@ -67,6 +67,17 @@ CameraNapiObject& CameraNapiObjVideoProfile::GetCameraNapiObject()
         { "frameRateRange", &frameRateRange->GetCameraNapiObject() } });
 }
 
+CameraNapiObject& CameraNapiObjDepthProfile::GetCameraNapiObject()
+{
+    auto format = Hold<int32_t>(depthProfile_.format_);
+    auto sizeObj = Hold<CameraNapiObjSize>(depthProfile_.size_);
+    auto dataAccuracy = Hold<int32_t>(depthProfile_.dataAccuracy_);
+    return *Hold<CameraNapiObject>(CameraNapiObject::CameraNapiObjFieldMap {
+        { "format", format },
+        { "size", &sizeObj->GetCameraNapiObject() },
+        { "dataAccuracy", dataAccuracy } });
+}
+
 CameraNapiObject& CameraNapiObjCameraDevice::GetCameraNapiObject()
 {
     auto cameraId = Hold<std::string>(cameraDevice_.GetID());
@@ -126,6 +137,12 @@ CameraNapiObject& CameraNapiObjCameraOutputCapability::GetCameraNapiObject()
         videoProfiles->emplace_back(std::move(Hold<CameraNapiObjVideoProfile>(profile)->GetCameraNapiObject()));
     }
 
+    auto depthProfiles = Hold<std::list<CameraNapiObject>>();
+    auto nativeDepthProfiles = Hold<std::vector<DepthProfile>>(cameraOutputCapability_.GetDepthProfiles());
+    for (auto& profile : *nativeDepthProfiles) {
+        depthProfiles->emplace_back(std::move(Hold<CameraNapiObjDepthProfile>(profile)->GetCameraNapiObject()));
+    }
+
     auto supportedMetadataObjectTypes = Hold<std::vector<int32_t>>();
     auto nativeSupportedMetadataObjectTypes = cameraOutputCapability_.GetSupportedMetadataObjectType();
     for (auto& type : nativeSupportedMetadataObjectTypes) {
@@ -136,6 +153,7 @@ CameraNapiObject& CameraNapiObjCameraOutputCapability::GetCameraNapiObject()
         { "previewProfiles", previewProfiles },
         { "photoProfiles", photoProfiles },
         { "videoProfiles", videoProfiles },
+        { "depthProfiles", depthProfiles },
         { "supportedMetadataObjectTypes", supportedMetadataObjectTypes } });
 }
 } // namespace CameraStandard
diff --git a/frameworks/js/camera_napi/src/input/camera_manager_napi.cpp b/frameworks/js/camera_napi/src/input/camera_manager_napi.cpp
index 562d13dec..fb1020299 100644
--- a/frameworks/js/camera_napi/src/input/camera_manager_napi.cpp
+++ b/frameworks/js/camera_napi/src/input/camera_manager_napi.cpp
@@ -655,6 +655,7 @@ napi_value CameraManagerNapi::Init(napi_env env, napi_value exports)
         DECLARE_NAPI_FUNCTION("createPhotoOutput", CreatePhotoOutputInstance),
         DECLARE_NAPI_FUNCTION("createVideoOutput", CreateVideoOutputInstance),
         DECLARE_NAPI_FUNCTION("createMetadataOutput", CreateMetadataOutputInstance),
+        DECLARE_NAPI_FUNCTION("createDepthDataOutput", CreateDepthDataOutputInstance),
         DECLARE_NAPI_FUNCTION("isTorchSupported", IsTorchSupported),
         DECLARE_NAPI_FUNCTION("isTorchModeSupported", IsTorchModeSupported),
         DECLARE_NAPI_FUNCTION("getTorchMode", GetTorchMode),
@@ -1000,6 +1001,35 @@ napi_value CameraManagerNapi::CreateVideoOutputInstance(napi_env env, napi_callb
     return VideoOutputNapi::CreateVideoOutput(env, surfaceId);
 }
 
+napi_value CameraManagerNapi::CreateDepthDataOutputInstance(napi_env env, napi_callback_info info)
+{
+    MEDIA_INFO_LOG("CreateDepthDataOutputInstance is called");
+    CameraManagerNapi* cameraManagerNapi = nullptr;
+    size_t napiArgsSize = CameraNapiUtils::GetNapiArgs(env, info);
+    MEDIA_INFO_LOG("CameraManagerNapi::CreateDepthDataOutputInstance napi args size is %{public}zu", napiArgsSize);
+
+    DepthProfile depthProfile;
+    CameraNapiObject profileSizeObj {{
+        { "width", &depthProfile.size_.width },
+        { "height", &depthProfile.size_.height }
+    }};
+    CameraNapiObject profileNapiOjbect {{
+        { "size", &profileSizeObj },
+        { "dataAccuracy", reinterpret_cast<int32_t*>(&depthProfile.dataAccuracy_) },
+        { "format", reinterpret_cast<int32_t*>(&depthProfile.format_) }
+    }};
+
+    if (!CameraNapiParamParser(env, info, cameraManagerNapi, profileNapiOjbect)
+            .AssertStatus(INVALID_ARGUMENT, "CameraManagerNapi::CreateDepthDataOutputInstance 1 args parse error")) {
+        return nullptr;
+    }
+    MEDIA_INFO_LOG(
+        "CameraManagerNapi::CreateDepthDataOutputInstance ParseDepthProfile "
+        "size.width = %{public}d, size.height = %{public}d, format = %{public}d, dataAccuracy = %{public}d,",
+        depthProfile.size_.width, depthProfile.size_.height, depthProfile.format_, depthProfile.dataAccuracy_);
+    return DepthDataOutputNapi::CreateDepthDataOutput(env, depthProfile);
+}
+
 napi_value ParseMetadataObjectTypes(napi_env env, napi_value arrayParam,
                                     std::vector<MetadataObjectType> &metadataObjectTypes)
 {
diff --git a/frameworks/js/camera_napi/src/native_module_ohos_camera.cpp b/frameworks/js/camera_napi/src/native_module_ohos_camera.cpp
index bc78fcebe..d9798a01c 100644
--- a/frameworks/js/camera_napi/src/native_module_ohos_camera.cpp
+++ b/frameworks/js/camera_napi/src/native_module_ohos_camera.cpp
@@ -38,6 +38,8 @@
 #include "mode/video_session_for_sys_napi.h"
 #include "mode/video_session_napi.h"
 #include "output/deferred_photo_proxy_napi.h"
+#include "output/depth_data_napi.h"
+#include "output/depth_data_output_napi.h"
 #include "output/photo_napi.h"
 #include "output/photo_output_napi.h"
 #include "output/preview_output_napi.h"
@@ -57,6 +59,8 @@ static napi_value Export(napi_env env, napi_value exports)
     PreviewOutputNapi::Init(env, exports);
     PhotoOutputNapi::Init(env, exports);
     VideoOutputNapi::Init(env, exports);
+    DepthDataOutputNapi::Init(env, exports);
+    DepthDataNapi::Init(env, exports);
     CameraSessionNapi::Init(env, exports);
     CameraManagerNapi::Init(env, exports);
     CameraNapi::Init(env, exports);
diff --git a/frameworks/js/camera_napi/src/output/depth_data_napi.cpp b/frameworks/js/camera_napi/src/output/depth_data_napi.cpp
new file mode 100644
index 000000000..dfb258207
--- /dev/null
+++ b/frameworks/js/camera_napi/src/output/depth_data_napi.cpp
@@ -0,0 +1,293 @@
+/*
+ * Copyright (C) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "output/depth_data_napi.h"
+
+#include "camera_log.h"
+#include "camera_napi_utils.h"
+#include "camera_util.h"
+#include "napi/native_common.h"
+
+namespace OHOS {
+namespace CameraStandard {
+thread_local napi_ref DepthDataNapi::sConstructor_ = nullptr;
+thread_local napi_value DepthDataNapi::sFormat_ = nullptr;
+thread_local napi_value DepthDataNapi::sDepthMap_ = nullptr;
+thread_local napi_value DepthDataNapi::sQualityLevel_ = nullptr;
+thread_local napi_value DepthDataNapi::sAccuracy_ = nullptr;
+thread_local uint32_t DepthDataNapi::depthDataTaskId = DEPTH_DATA_TASKID;
+
+DepthDataNapi::DepthDataNapi() : env_(nullptr), format_(nullptr), depthMap_(nullptr),
+    qualityLevel_(nullptr), accuracy_(nullptr)
+{}
+
+DepthDataNapi::~DepthDataNapi()
+{
+    MEDIA_DEBUG_LOG("~PhotoNapi is called");
+}
+
+// Constructor callback
+napi_value DepthDataNapi::DepthDataNapiConstructor(napi_env env, napi_callback_info info)
+{
+    MEDIA_DEBUG_LOG("DepthDataNapiConstructor is called");
+    napi_status status;
+    napi_value result = nullptr;
+    napi_value thisVar = nullptr;
+
+    napi_get_undefined(env, &result);
+    CAMERA_NAPI_GET_JS_OBJ_WITH_ZERO_ARGS(env, info, status, thisVar);
+
+    if (status == napi_ok && thisVar != nullptr) {
+        std::unique_ptr<DepthDataNapi> obj = std::make_unique<DepthDataNapi>();
+        obj->env_ = env;
+        obj->format_ = sFormat_;
+        obj->depthMap_ = sDepthMap_;
+        obj->qualityLevel_ = sQualityLevel_;
+        obj->accuracy_ = sAccuracy_;
+        status = napi_wrap(env, thisVar, reinterpret_cast<void*>(obj.get()),
+                           DepthDataNapi::DepthDataNapiDestructor, nullptr, nullptr);
+        if (status == napi_ok) {
+            obj.release();
+            return thisVar;
+        } else {
+            MEDIA_ERR_LOG("Failure wrapping js to native napi");
+        }
+    }
+    MEDIA_ERR_LOG("DepthDataNapiConstructor call Failed!");
+    return result;
+}
+
+void DepthDataNapi::DepthDataNapiDestructor(napi_env env, void *nativeObject, void *finalize)
+{
+    MEDIA_DEBUG_LOG("DepthDataNapiDestructor is called");
+    DepthDataNapi* depthData = reinterpret_cast<DepthDataNapi*>(nativeObject);
+    if (depthData != nullptr) {
+        delete depthData;
+    }
+}
+
+napi_value DepthDataNapi::Init(napi_env env, napi_value exports)
+{
+    MEDIA_DEBUG_LOG("Init is called");
+    napi_status status;
+    napi_value ctorObj;
+    int32_t refCount = PARAM1;
+
+    napi_property_descriptor depth_data_properties[] = {
+        DECLARE_NAPI_GETTER("format", GetFormat),
+        DECLARE_NAPI_GETTER("depthMap", GetDepthMap),
+        DECLARE_NAPI_GETTER("qualityLevel", GetQualityLevel),
+        DECLARE_NAPI_GETTER("dataAccurary", GetAccuracy),
+        DECLARE_NAPI_FUNCTION("release", Release),
+    };
+
+    status = napi_define_class(env, DEPTH_DATA_NAPI_CLASS_NAME, NAPI_AUTO_LENGTH,
+                               DepthDataNapiConstructor, nullptr,
+                               sizeof(depth_data_properties) / sizeof(depth_data_properties[PARAM0]),
+                               depth_data_properties, &ctorObj);
+    if (status == napi_ok) {
+        if (napi_create_reference(env, ctorObj, refCount, &sConstructor_) == napi_ok) {
+            status = napi_set_named_property(env, exports, DEPTH_DATA_NAPI_CLASS_NAME, ctorObj);
+            if (status == napi_ok) {
+                return exports;
+            }
+        }
+    }
+    MEDIA_ERR_LOG("Init call failed!");
+    return nullptr;
+}
+
+napi_value DepthDataNapi::CreateDepthData(napi_env env, napi_value format, napi_value depthMap,
+    napi_value qualityLevel, napi_value accuracy)
+{
+    MEDIA_DEBUG_LOG("CreateDepthData is called");
+    CAMERA_SYNC_TRACE;
+    napi_status status;
+    napi_value result = nullptr;
+    napi_value constructor;
+    napi_get_undefined(env, &result);
+
+    status = napi_get_reference_value(env, sConstructor_, &constructor);
+    if (status == napi_ok) {
+        sFormat_ = format;
+        sDepthMap_ = depthMap;
+        sQualityLevel_ = qualityLevel;
+        sAccuracy_ = accuracy;
+        status = napi_new_instance(env, constructor, 0, nullptr, &result);
+        sFormat_ = nullptr;
+        sDepthMap_ = nullptr;
+        sQualityLevel_ = nullptr;
+        sAccuracy_ = nullptr;
+        if (status == napi_ok && result != nullptr) {
+            return result;
+        } else {
+            MEDIA_ERR_LOG("Failed to create depthData obj instance");
+        }
+    }
+    napi_get_undefined(env, &result);
+    MEDIA_ERR_LOG("CreateDepthData call Failed");
+    return result;
+}
+
+napi_value DepthDataNapi::GetFormat(napi_env env, napi_callback_info info)
+{
+    MEDIA_DEBUG_LOG("GetFormat is called");
+    napi_status status;
+    napi_value result = nullptr;
+    size_t argc = ARGS_ZERO;
+    napi_value argv[ARGS_ZERO];
+    napi_value thisVar = nullptr;
+
+    CAMERA_NAPI_GET_JS_ARGS(env, info, argc, argv, thisVar);
+
+    napi_get_undefined(env, &result);
+    DepthDataNapi* depthDataNapi = nullptr;
+    status = napi_unwrap(env, thisVar, reinterpret_cast<void**>(&depthDataNapi));
+    if (status == napi_ok && depthDataNapi != nullptr) {
+        result = depthDataNapi->format_;
+        return result;
+    }
+    napi_get_undefined(env, &result);
+    MEDIA_ERR_LOG("DepthDataNapi::GetFormat call Failed");
+    return result;
+}
+
+napi_value DepthDataNapi::GetDepthMap(napi_env env, napi_callback_info info)
+{
+    MEDIA_DEBUG_LOG("GetDepthMap is called");
+    napi_status status;
+    napi_value result = nullptr;
+    size_t argc = ARGS_ZERO;
+    napi_value argv[ARGS_ZERO];
+    napi_value thisVar = nullptr;
+
+    CAMERA_NAPI_GET_JS_ARGS(env, info, argc, argv, thisVar);
+
+    napi_get_undefined(env, &result);
+    DepthDataNapi* depthDataNapi = nullptr;
+    status = napi_unwrap(env, thisVar, reinterpret_cast<void**>(&depthDataNapi));
+    if (status == napi_ok && depthDataNapi != nullptr) {
+        result = depthDataNapi->depthMap_;
+        return result;
+    }
+    napi_get_undefined(env, &result);
+    MEDIA_ERR_LOG("DepthDataNapi::GetDepthMap call Failed");
+    return result;
+}
+
+napi_value DepthDataNapi::GetQualityLevel(napi_env env, napi_callback_info info)
+{
+    MEDIA_INFO_LOG("GetQualityLevel is called");
+    napi_status status;
+    napi_value result = nullptr;
+    size_t argc = ARGS_ZERO;
+    napi_value argv[ARGS_ZERO];
+    napi_value thisVar = nullptr;
+
+    CAMERA_NAPI_GET_JS_ARGS(env, info, argc, argv, thisVar);
+
+    napi_get_undefined(env, &result);
+    DepthDataNapi* depthDataNapi = nullptr;
+    status = napi_unwrap(env, thisVar, reinterpret_cast<void**>(&depthDataNapi));
+    if (status == napi_ok && depthDataNapi != nullptr) {
+        result = depthDataNapi->qualityLevel_;
+        return result;
+    }
+    napi_get_undefined(env, &result);
+    MEDIA_ERR_LOG("DepthDataNapi::GetQualityLevel call Failed");
+    return result;
+}
+
+napi_value DepthDataNapi::GetAccuracy(napi_env env, napi_callback_info info)
+{
+    MEDIA_INFO_LOG("GetAccuracy is called");
+    napi_status status;
+    napi_value result = nullptr;
+    size_t argc = ARGS_ZERO;
+    napi_value argv[ARGS_ZERO];
+    napi_value thisVar = nullptr;
+
+    CAMERA_NAPI_GET_JS_ARGS(env, info, argc, argv, thisVar);
+
+    napi_get_undefined(env, &result);
+    DepthDataNapi* depthDataNapi = nullptr;
+    status = napi_unwrap(env, thisVar, reinterpret_cast<void**>(&depthDataNapi));
+    if (status == napi_ok && depthDataNapi != nullptr) {
+        result = depthDataNapi->accuracy_;
+        return result;
+    }
+    napi_get_undefined(env, &result);
+    MEDIA_ERR_LOG("DepthDataNapi::GetAccuracy call Failed");
+    return result;
+}
+
+napi_value DepthDataNapi::Release(napi_env env, napi_callback_info info)
+{
+    MEDIA_INFO_LOG("Release is called");
+    napi_status status;
+    napi_value result = nullptr;
+    napi_value resource = nullptr;
+    size_t argc = ARGS_ZERO;
+    napi_value argv[ARGS_ZERO];
+    napi_value thisVar = nullptr;
+
+    CAMERA_NAPI_GET_JS_ARGS(env, info, argc, argv, thisVar);
+
+    napi_get_undefined(env, &result);
+    std::unique_ptr<DepthDataAsyncContext> asyncContext = std::make_unique<DepthDataAsyncContext>();
+    status = napi_unwrap(env, thisVar, reinterpret_cast<void**>(&asyncContext->objectInfo));
+    if (status == napi_ok && asyncContext->objectInfo != nullptr) {
+        CAMERA_NAPI_CREATE_PROMISE(env, asyncContext->callbackRef, asyncContext->deferred, result);
+        CAMERA_NAPI_CREATE_RESOURCE_NAME(env, resource, "Release");
+
+        status = napi_create_async_work(
+            env, nullptr, resource,
+            [](napi_env env, void* data) {
+                auto context = static_cast<DepthDataAsyncContext*>(data);
+                context->status = false;
+                // Start async trace
+                context->funcName = "DepthDataNapi::Release";
+                context->taskId = CameraNapiUtils::IncrementAndGet(depthDataTaskId);
+                CAMERA_START_ASYNC_TRACE(context->funcName, context->taskId);
+                if (context->objectInfo != nullptr) {
+                    context->status = true;
+                    context->objectInfo->format_ = nullptr;
+                    context->objectInfo->depthMap_ = nullptr;
+                    context->objectInfo->qualityLevel_ = nullptr;
+                    context->objectInfo->accuracy_ = nullptr;
+                }
+            },
+            [](napi_env env, napi_status status, void* data) {
+                auto context = static_cast<DepthDataAsyncContext*>(data);
+                napi_resolve_deferred(env, context->deferred, nullptr);
+                napi_delete_async_work(env, context->work);
+                delete context->objectInfo;
+                delete context;
+            }, static_cast<void*>(asyncContext.get()), &asyncContext->work);
+        if (status != napi_ok) {
+            MEDIA_ERR_LOG("Failed to create napi_create_async_work for DepthDataNapi::Release");
+            napi_get_undefined(env, &result);
+        } else {
+            napi_queue_async_work_with_qos(env, asyncContext->work, napi_qos_user_initiated);
+            asyncContext.release();
+        }
+    } else {
+        MEDIA_ERR_LOG("Release call Failed!");
+    }
+    return result;
+}
+
+}  // namespace CameraStandard
+}  // namespace OHOS
diff --git a/frameworks/js/camera_napi/src/output/depth_data_output_napi.cpp b/frameworks/js/camera_napi/src/output/depth_data_output_napi.cpp
new file mode 100644
index 000000000..565151a27
--- /dev/null
+++ b/frameworks/js/camera_napi/src/output/depth_data_output_napi.cpp
@@ -0,0 +1,682 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "output/depth_data_output_napi.h"
+
+#include <cstdint>
+#include <memory>
+#include <string>
+#include <unistd.h>
+#include <uv.h>
+
+#include "camera_error_code.h"
+#include "camera_napi_const.h"
+#include "camera_napi_object_types.h"
+#include "camera_napi_param_parser.h"
+#include "camera_napi_security_utils.h"
+#include "camera_napi_template_utils.h"
+#include "camera_napi_utils.h"
+#include "camera_output_capability.h"
+#include "depth_data_output.h"
+#include "js_native_api.h"
+#include "js_native_api_types.h"
+#include "listener_base.h"
+#include "napi/native_api.h"
+#include "napi/native_common.h"
+#include "native_image.h"
+#include "output/photo_napi.h"
+#include "pixel_map_napi.h"
+#include "refbase.h"
+#include "surface_utils.h"
+#include "video_key_info.h"
+
+namespace OHOS {
+namespace CameraStandard {
+using namespace std;
+thread_local napi_ref DepthDataOutputNapi::sConstructor_ = nullptr;
+thread_local sptr<DepthDataOutput> DepthDataOutputNapi::sDepthDataOutput_ = nullptr;
+thread_local sptr<Surface> DepthDataOutputNapi::sDepthDataSurface_ = nullptr;
+thread_local std::shared_ptr<DepthProfile> DepthDataOutputNapi::depthProfile_ = nullptr;
+thread_local uint32_t DepthDataOutputNapi::depthDataOutputTaskId = CAMERA_DEPTH_DATA_OUTPUT_TASKID;
+static std::mutex g_depthDataMutex;
+
+DepthDataListener::DepthDataListener(napi_env env, const sptr<Surface> depthDataSurface,
+                                     sptr<DepthDataOutput> depthDataOutput)
+    : ListenerBase(env), depthDataSurface_(depthDataSurface), depthDataOutput_(depthDataOutput)
+{
+    if (bufferProcessor_ == nullptr && depthDataSurface != nullptr) {
+        bufferProcessor_ = std::make_shared<DepthDataBufferProcessor>(depthDataSurface);
+    }
+}
+
+void DepthDataListener::OnBufferAvailable()
+{
+    std::lock_guard<std::mutex> lock(g_depthDataMutex);
+    CAMERA_SYNC_TRACE;
+    MEDIA_INFO_LOG("DepthDataListener::OnBufferAvailable is called");
+    if (!depthDataSurface_) {
+        MEDIA_ERR_LOG("DepthDataListener napi depthDataSurface_ is null");
+        return;
+    }
+    UpdateJSCallbackAsync(depthDataSurface_);
+}
+
+void DepthDataListener::ExecuteDepthData(sptr<SurfaceBuffer> surfaceBuffer) const
+{
+    MEDIA_INFO_LOG("ExecuteDepthData");
+    napi_value result[ARGS_TWO] = {nullptr, nullptr};
+    napi_value retVal;
+
+    // create pixelMap
+    int32_t depthDataWidth = depthProfile_->GetSize().width;
+    int32_t depthDataHeight = depthProfile_->GetSize().height;
+    Media::InitializationOptions opts;
+    opts.srcPixelFormat = Media::PixelFormat::RGBA_F16;
+    opts.pixelFormat = Media::PixelFormat::RGBA_F16;
+    opts.size = { .width = depthDataWidth, .height = depthDataHeight };
+    MEDIA_INFO_LOG("ExecuteDepthData depthDataWidth:%{public}d, depthDataHeight: %{public}d",
+        depthDataWidth, depthDataHeight);
+    const int32_t formatSize = 4;
+    auto pixelMap = Media::PixelMap::Create(static_cast<const uint32_t*>(surfaceBuffer->GetVirAddr()),
+        depthDataWidth * depthDataHeight * formatSize, 0, depthDataWidth, opts, true);
+    if (pixelMap == nullptr) {
+        MEDIA_ERR_LOG("create pixelMap failed, pixelMap is null");
+    }
+    napi_value depthMap;
+    napi_get_undefined(env_, &depthMap);
+    depthMap = Media::PixelMapNapi::CreatePixelMap(env_, std::move(pixelMap));
+
+    napi_value format;
+    napi_get_undefined(env_, &format);
+    int32_t nativeFormat = 0;
+    nativeFormat = static_cast<int32_t>(depthProfile_->GetCameraFormat());
+    napi_create_int32(env_, nativeFormat, &format);
+
+    napi_value qualityLevel;
+    napi_get_undefined(env_, &qualityLevel);
+    int32_t nativeQualityLevel = 0;
+    surfaceBuffer->GetExtraData()->ExtraGet(OHOS::Camera::depthDataQualityLevel, nativeQualityLevel);
+    napi_create_int32(env_, nativeQualityLevel, &qualityLevel);
+
+    napi_value accuracy;
+    napi_get_undefined(env_, &accuracy);
+    int32_t nativeAccuracy = 0;
+    nativeAccuracy = static_cast<int32_t>(depthProfile_->GetDataAccuracy());
+    napi_create_int32(env_, nativeAccuracy, &accuracy);
+
+    result[1] = DepthDataNapi::CreateDepthData(env_, format, depthMap, qualityLevel, accuracy);
+
+    ExecuteCallbackNapiPara callbackNapiPara { .recv = nullptr, .argc = ARGS_TWO, .argv = result, .result = &retVal };
+    ExecuteCallback(CONST_DEPTH_DATA_AVAILABLE, callbackNapiPara);
+    depthDataSurface_->ReleaseBuffer(surfaceBuffer, -1);
+}
+
+void DepthDataListener::UpdateJSCallback(sptr<Surface> depthSurface) const
+{
+    MEDIA_DEBUG_LOG("DepthDataListener UpdateJSCallback enter");
+    sptr<SurfaceBuffer> surfaceBuffer = nullptr;
+    int32_t fence = -1;
+    int64_t timestamp;
+    OHOS::Rect damage;
+
+    SurfaceError surfaceRet = depthSurface->AcquireBuffer(surfaceBuffer, fence, timestamp, damage);
+    if (surfaceRet != SURFACE_ERROR_OK) {
+        MEDIA_ERR_LOG("DepthDataListener Failed to acquire surface buffer");
+        return;
+    }
+
+    ExecuteDepthData(surfaceBuffer);
+}
+
+void DepthDataListener::UpdateJSCallbackAsync(sptr<Surface> depthSurface) const
+{
+    MEDIA_DEBUG_LOG("DepthDataListener UpdateJSCallbackAsync enter");
+    uv_loop_s* loop = nullptr;
+    napi_get_uv_event_loop(env_, &loop);
+    if (!loop) {
+        MEDIA_ERR_LOG("DepthDataListener:UpdateJSCallbackAsync() failed to get event loop");
+        return;
+    }
+    uv_work_t* work = new (std::nothrow) uv_work_t;
+    if (!work) {
+        MEDIA_ERR_LOG("DepthDataListener:UpdateJSCallbackAsync() failed to allocate work");
+        return;
+    }
+    std::unique_ptr<DepthDataListenerInfo> callbackInfo = std::make_unique<DepthDataListenerInfo>(depthSurface, this);
+    work->data = callbackInfo.get();
+    MEDIA_DEBUG_LOG("DepthDataListener UpdateJSCallbackAsync uv_queue_work_with_qos start");
+    int ret = uv_queue_work_with_qos(
+        loop, work, [](uv_work_t* work) {},
+        [](uv_work_t* work, int status) {
+            DepthDataListenerInfo* callbackInfo = reinterpret_cast<DepthDataListenerInfo*>(work->data);
+            if (callbackInfo) {
+                callbackInfo->listener_->UpdateJSCallback(callbackInfo->depthDataSurface_);
+                MEDIA_INFO_LOG("DepthDataListener:UpdateJSCallbackAsync() complete");
+                callbackInfo->depthDataSurface_ = nullptr;
+                callbackInfo->listener_ = nullptr;
+                delete callbackInfo;
+            }
+            delete work;
+        },
+        uv_qos_user_initiated);
+    if (ret) {
+        MEDIA_ERR_LOG("DepthDataListenerInfo:UpdateJSCallbackAsync() failed to execute work");
+        delete work;
+    } else {
+        callbackInfo.release();
+    }
+}
+
+void DepthDataListener::SaveCallback(const std::string eventName, napi_value callback)
+{
+    MEDIA_INFO_LOG("DepthDataListener::SaveCallback is called eventName:%{public}s", eventName.c_str());
+    SaveCallbackReference(eventName, callback, false);
+}
+
+void DepthDataListener::RemoveCallback(const std::string eventName, napi_value callback)
+{
+    MEDIA_INFO_LOG("DepthDataListener::RemoveCallback is called eventName:%{public}s", eventName.c_str());
+    RemoveCallbackRef(eventName, callback);
+}
+
+void DepthDataListener::SetDepthProfile(std::shared_ptr<DepthProfile> depthProfile)
+{
+    depthProfile_ = depthProfile;
+}
+
+DepthDataOutputCallback::DepthDataOutputCallback(napi_env env) : ListenerBase(env) {}
+
+void DepthDataOutputCallback::OnDepthDataError(const int32_t errorCode) const
+{
+    CAMERA_SYNC_TRACE;
+    MEDIA_DEBUG_LOG("OnDepthDataError is called, errorCode: %{public}d", errorCode);
+    UpdateJSCallbackAsync(DepthDataOutputEventType::DEPTH_DATA_ERROR, errorCode);
+}
+
+void DepthDataOutputCallback::UpdateJSCallbackAsync(DepthDataOutputEventType eventType, const int32_t value) const
+{
+    MEDIA_DEBUG_LOG("UpdateJSCallbackAsync is called");
+    uv_loop_s* loop = nullptr;
+    napi_get_uv_event_loop(env_, &loop);
+    if (!loop) {
+        MEDIA_ERR_LOG("failed to get event loop");
+        return;
+    }
+    uv_work_t* work = new(std::nothrow) uv_work_t;
+    if (!work) {
+        MEDIA_ERR_LOG("failed to allocate work");
+        return;
+    }
+    std::unique_ptr<DepthDataOutputCallbackInfo> callbackInfo =
+        std::make_unique<DepthDataOutputCallbackInfo>(eventType, value, shared_from_this());
+    work->data = callbackInfo.get();
+    int ret = uv_queue_work_with_qos(loop, work, [] (uv_work_t* work) {}, [] (uv_work_t* work, int status) {
+        DepthDataOutputCallbackInfo* callbackInfo = reinterpret_cast<DepthDataOutputCallbackInfo *>(work->data);
+        if (callbackInfo) {
+            auto listener = callbackInfo->listener_.lock();
+            if (listener) {
+                listener->UpdateJSCallback(callbackInfo->eventType_, callbackInfo->value_);
+            }
+            delete callbackInfo;
+        }
+        delete work;
+    }, uv_qos_user_initiated);
+    if (ret) {
+        MEDIA_ERR_LOG("failed to execute work");
+        delete work;
+    } else {
+        callbackInfo.release();
+    }
+}
+
+void DepthDataOutputCallback::UpdateJSCallback(DepthDataOutputEventType eventType, const int32_t value) const
+{
+    MEDIA_DEBUG_LOG("UpdateJSCallback is called");
+    napi_value result[ARGS_ONE];
+    napi_value retVal;
+    napi_value propValue;
+    napi_get_undefined(env_, &result[PARAM0]);
+    std::string eventName = DepthDataOutputEventTypeHelper.GetKeyString(eventType);
+    if (eventName.empty()) {
+        MEDIA_WARNING_LOG(
+            "DepthDataOutputCallback::UpdateJSCallback, event type is invalid %d", static_cast<int32_t>(eventType));
+        return;
+    }
+
+    if (eventType == DepthDataOutputEventType::DEPTH_DATA_ERROR) {
+        napi_create_object(env_, &result[PARAM0]);
+        napi_create_int32(env_, value, &propValue);
+        napi_set_named_property(env_, result[PARAM0], "code", propValue);
+    }
+    ExecuteCallbackNapiPara callbackNapiPara { .recv = nullptr, .argc = ARGS_ONE, .argv = result, .result = &retVal };
+    ExecuteCallback(eventName, callbackNapiPara);
+}
+
+DepthDataOutputNapi::DepthDataOutputNapi() {}
+
+DepthDataOutputNapi::~DepthDataOutputNapi()
+{
+    MEDIA_DEBUG_LOG("~DepthDataOutputNapi is called");
+}
+
+void DepthDataOutputNapi::DepthDataOutputNapiDestructor(napi_env env, void* nativeObject, void* finalize_hint)
+{
+    MEDIA_DEBUG_LOG("DepthDataOutputNapiDestructor is called");
+    DepthDataOutputNapi* cameraObj = reinterpret_cast<DepthDataOutputNapi*>(nativeObject);
+    if (cameraObj != nullptr) {
+        delete cameraObj;
+    }
+}
+
+napi_value DepthDataOutputNapi::Init(napi_env env, napi_value exports)
+{
+    MEDIA_DEBUG_LOG("Init is called");
+    napi_status status;
+    napi_value ctorObj;
+    int32_t refCount = 1;
+
+    napi_property_descriptor depth_data_output_props[] = {
+        DECLARE_NAPI_FUNCTION("start", Start),
+        DECLARE_NAPI_FUNCTION("stop", Stop),
+        DECLARE_NAPI_FUNCTION("release", Release),
+        DECLARE_NAPI_FUNCTION("on", On),
+        DECLARE_NAPI_FUNCTION("once", Once),
+        DECLARE_NAPI_FUNCTION("off", Off),
+    };
+
+    status = napi_define_class(env, CAMERA_DEPTH_DATA_OUTPUT_NAPI_CLASS_NAME, NAPI_AUTO_LENGTH,
+                               DepthDataOutputNapiConstructor, nullptr,
+                               sizeof(depth_data_output_props) / sizeof(depth_data_output_props[PARAM0]),
+                               depth_data_output_props, &ctorObj);
+    if (status == napi_ok) {
+        status = napi_create_reference(env, ctorObj, refCount, &sConstructor_);
+        if (status == napi_ok) {
+            status = napi_set_named_property(env, exports, CAMERA_DEPTH_DATA_OUTPUT_NAPI_CLASS_NAME, ctorObj);
+            if (status == napi_ok) {
+                return exports;
+            }
+        }
+    }
+    MEDIA_ERR_LOG("Init call Failed!");
+    return nullptr;
+}
+
+// Constructor callback
+napi_value DepthDataOutputNapi::DepthDataOutputNapiConstructor(napi_env env, napi_callback_info info)
+{
+    MEDIA_DEBUG_LOG("DepthDataOutputNapiConstructor is called");
+    napi_status status;
+    napi_value result = nullptr;
+    napi_value thisVar = nullptr;
+
+    napi_get_undefined(env, &result);
+    CAMERA_NAPI_GET_JS_OBJ_WITH_ZERO_ARGS(env, info, status, thisVar);
+
+    if (status == napi_ok && thisVar != nullptr) {
+        std::unique_ptr<DepthDataOutputNapi> obj = std::make_unique<DepthDataOutputNapi>();
+        if (obj != nullptr) {
+            obj->env_ = env;
+            obj->depthDataOutput_ = sDepthDataOutput_;
+
+            status = napi_wrap(env, thisVar, reinterpret_cast<void*>(obj.get()),
+                               DepthDataOutputNapi::DepthDataOutputNapiDestructor, nullptr, nullptr);
+            if (status == napi_ok) {
+                obj.release();
+                return thisVar;
+            } else {
+                MEDIA_ERR_LOG("Failure wrapping js to native napi");
+            }
+        }
+    }
+    MEDIA_ERR_LOG("DepthDataOutputNapiConstructor call Failed!");
+    return result;
+}
+
+static void CommonCompleteCallback(napi_env env, napi_status status, void* data)
+{
+    MEDIA_DEBUG_LOG("CommonCompleteCallback is called");
+    auto context = static_cast<DepthDataOutputAsyncContext*>(data);
+    if (context == nullptr) {
+        MEDIA_ERR_LOG("Async context is null");
+        return;
+    }
+    std::unique_ptr<JSAsyncContextOutput> jsContext = std::make_unique<JSAsyncContextOutput>();
+    if (!context->status) {
+        CameraNapiUtils::CreateNapiErrorObject(env, context->errorCode, context->errorMsg.c_str(), jsContext);
+    } else {
+        jsContext->status = true;
+        napi_get_undefined(env, &jsContext->error);
+        if (context->bRetBool) {
+            napi_get_boolean(env, context->status, &jsContext->data);
+        } else {
+            napi_get_undefined(env, &jsContext->data);
+        }
+    }
+    if (!context->funcName.empty() && context->taskId > 0) {
+        // Finish async trace
+        CAMERA_FINISH_ASYNC_TRACE(context->funcName, context->taskId);
+        jsContext->funcName = context->funcName;
+    }
+    if (context->work != nullptr) {
+        CameraNapiUtils::InvokeJSAsyncMethod(env, context->deferred, context->callbackRef, context->work, *jsContext);
+    }
+    delete context;
+}
+
+napi_value DepthDataOutputNapi::CreateDepthDataOutput(napi_env env, DepthProfile& depthProfile)
+{
+    MEDIA_DEBUG_LOG("CreateDepthDataOutput is called");
+    CAMERA_SYNC_TRACE;
+    napi_status status;
+    napi_value result = nullptr;
+    napi_value constructor;
+    napi_get_undefined(env, &result);
+    status = napi_get_reference_value(env, sConstructor_, &constructor);
+    if (status == napi_ok) {
+        sptr<Surface> depthDataSurface;
+        MEDIA_INFO_LOG("create surface as consumer");
+        depthDataSurface = Surface::CreateSurfaceAsConsumer("depthDataOutput");
+        sDepthDataSurface_ = depthDataSurface;
+        if (depthDataSurface == nullptr) {
+            MEDIA_ERR_LOG("failed to get surface");
+            return result;
+        }
+
+        sptr<IBufferProducer> surfaceProducer = depthDataSurface->GetProducer();
+        MEDIA_INFO_LOG("depthProfile width: %{public}d, height: %{public}d, format = %{public}d, "
+                       "surface width: %{public}d, height: %{public}d", depthProfile.GetSize().width,
+                       depthProfile.GetSize().height, static_cast<int32_t>(depthProfile.GetCameraFormat()),
+                       depthDataSurface->GetDefaultWidth(), depthDataSurface->GetDefaultHeight());
+        int retCode = CameraManager::GetInstance()->CreateDepthDataOutput(depthProfile, surfaceProducer,
+            &sDepthDataOutput_);
+        if (!CameraNapiUtils::CheckError(env, retCode) || sDepthDataOutput_ == nullptr) {
+            MEDIA_ERR_LOG("failed to create CreateDepthDataOutput");
+            return result;
+        }
+        status = napi_new_instance(env, constructor, 0, nullptr, &result);
+        sDepthDataOutput_ = nullptr;
+
+        if (status == napi_ok && result != nullptr) {
+            depthProfile_ = std::make_shared<DepthProfile>(depthProfile);
+            return result;
+        } else {
+            MEDIA_ERR_LOG("Failed to create depth data output instance");
+        }
+    }
+    MEDIA_ERR_LOG("CreateDepthDataOutput call Failed!");
+    return result;
+}
+
+sptr<DepthDataOutput> DepthDataOutputNapi::GetDepthDataOutput()
+{
+    return depthDataOutput_;
+}
+
+bool DepthDataOutputNapi::IsDepthDataOutput(napi_env env, napi_value obj)
+{
+    MEDIA_DEBUG_LOG("IsDepthDataOutput is called");
+    bool result = false;
+    napi_status status;
+    napi_value constructor = nullptr;
+
+    status = napi_get_reference_value(env, sConstructor_, &constructor);
+    if (status == napi_ok) {
+        status = napi_instanceof(env, obj, constructor, &result);
+        if (status != napi_ok) {
+            result = false;
+        }
+    }
+    return result;
+}
+
+napi_value DepthDataOutputNapi::Release(napi_env env, napi_callback_info info)
+{
+    MEDIA_DEBUG_LOG("Release is called");
+    napi_status status;
+    napi_value result = nullptr;
+    const int32_t refCount = 1;
+    napi_value resource = nullptr;
+    size_t argc = ARGS_ONE;
+    napi_value argv[ARGS_ONE] = {0};
+    napi_value thisVar = nullptr;
+
+    CAMERA_NAPI_GET_JS_ARGS(env, info, argc, argv, thisVar);
+    NAPI_ASSERT(env, argc <= ARGS_ONE, "requires 1 parameter maximum");
+
+    napi_get_undefined(env, &result);
+    std::unique_ptr<DepthDataOutputAsyncContext> asyncContext = std::make_unique<DepthDataOutputAsyncContext>();
+    status = napi_unwrap(env, thisVar, reinterpret_cast<void**>(&asyncContext->objectInfo));
+    if (status == napi_ok && asyncContext->objectInfo != nullptr) {
+        if (argc == ARGS_ONE) {
+            CAMERA_NAPI_GET_JS_ASYNC_CB_REF(env, argv[PARAM0], refCount, asyncContext->callbackRef);
+        }
+
+        CAMERA_NAPI_CREATE_PROMISE(env, asyncContext->callbackRef, asyncContext->deferred, result);
+        CAMERA_NAPI_CREATE_RESOURCE_NAME(env, resource, "Release");
+
+        status = napi_create_async_work(
+            env, nullptr, resource, [](napi_env env, void* data) {
+                auto context = static_cast<DepthDataOutputAsyncContext*>(data);
+                context->status = false;
+                // Start async trace
+                context->funcName = "DepthDataOutputNapi::Release";
+                context->taskId = CameraNapiUtils::IncrementAndGet(depthDataOutputTaskId);
+                CAMERA_START_ASYNC_TRACE(context->funcName, context->taskId);
+                if (context->objectInfo != nullptr) {
+                    context->bRetBool = false;
+                    context->status = true;
+                    ((sptr<DepthDataOutput>&)(context->objectInfo->depthDataOutput_))->Release();
+                }
+            },
+            CommonCompleteCallback, static_cast<void*>(asyncContext.get()), &asyncContext->work);
+        if (status != napi_ok) {
+            MEDIA_ERR_LOG("Failed to create napi_create_async_work for DepthDataOutputNapi::Release");
+            napi_get_undefined(env, &result);
+        } else {
+            napi_queue_async_work_with_qos(env, asyncContext->work, napi_qos_user_initiated);
+            asyncContext.release();
+        }
+    } else {
+        MEDIA_ERR_LOG("Release call Failed!");
+    }
+    return result;
+}
+
+napi_value DepthDataOutputNapi::Start(napi_env env, napi_callback_info info)
+{
+    MEDIA_INFO_LOG("Start is called");
+    napi_status status;
+    napi_value result = nullptr;
+    const int32_t refCount = 1;
+    napi_value resource = nullptr;
+    size_t argc = ARGS_ONE;
+    napi_value argv[ARGS_ONE] = {0};
+    napi_value thisVar = nullptr;
+
+    CAMERA_NAPI_GET_JS_ARGS(env, info, argc, argv, thisVar);
+    NAPI_ASSERT(env, argc <= ARGS_ONE, "requires 1 parameter maximum");
+
+    napi_get_undefined(env, &result);
+    std::unique_ptr<DepthDataOutputAsyncContext> asyncContext = std::make_unique<DepthDataOutputAsyncContext>();
+    status = napi_unwrap(env, thisVar, reinterpret_cast<void**>(&asyncContext->objectInfo));
+    if (status == napi_ok && asyncContext->objectInfo != nullptr) {
+        if (argc == ARGS_ONE) {
+            CAMERA_NAPI_GET_JS_ASYNC_CB_REF(env, argv[PARAM0], refCount, asyncContext->callbackRef);
+        }
+
+        CAMERA_NAPI_CREATE_PROMISE(env, asyncContext->callbackRef, asyncContext->deferred, result);
+        CAMERA_NAPI_CREATE_RESOURCE_NAME(env, resource, "Start");
+
+        status = napi_create_async_work(
+            env, nullptr, resource,
+            [](napi_env env, void* data) {
+                auto context = static_cast<DepthDataOutputAsyncContext*>(data);
+                context->status = false;
+                // Start async trace
+                context->funcName = "DepthDataOutputNapi::Start";
+                context->taskId = CameraNapiUtils::IncrementAndGet(depthDataOutputTaskId);
+                CAMERA_START_ASYNC_TRACE(context->funcName, context->taskId);
+                if (context->objectInfo != nullptr) {
+                    context->bRetBool = false;
+                    context->errorCode = context->objectInfo->depthDataOutput_->Start();
+                    context->status = context->errorCode == 0;
+                }
+            },
+            CommonCompleteCallback, static_cast<void*>(asyncContext.get()), &asyncContext->work);
+        if (status != napi_ok) {
+            MEDIA_ERR_LOG("Failed to create napi_create_async_work for DepthDataOutputNapi::Release");
+            napi_get_undefined(env, &result);
+        } else {
+            napi_queue_async_work_with_qos(env, asyncContext->work, napi_qos_user_initiated);
+            asyncContext.release();
+        }
+    } else {
+        MEDIA_ERR_LOG("Start call Failed!");
+    }
+    return result;
+}
+
+napi_value DepthDataOutputNapi::Stop(napi_env env, napi_callback_info info)
+{
+    MEDIA_INFO_LOG("Stop is called");
+    napi_status status;
+    napi_value result = nullptr;
+    const int32_t refCount = 1;
+    napi_value resource = nullptr;
+    size_t argc = ARGS_ONE;
+    napi_value argv[ARGS_ONE] = {0};
+    napi_value thisVar = nullptr;
+
+    CAMERA_NAPI_GET_JS_ARGS(env, info, argc, argv, thisVar);
+    NAPI_ASSERT(env, argc <= ARGS_ONE, "requires 1 parameter maximum");
+
+    napi_get_undefined(env, &result);
+    std::unique_ptr<DepthDataOutputAsyncContext> asyncContext = std::make_unique<DepthDataOutputAsyncContext>();
+    status = napi_unwrap(env, thisVar, reinterpret_cast<void**>(&asyncContext->objectInfo));
+    if (status == napi_ok && asyncContext->objectInfo != nullptr) {
+        if (argc == ARGS_ONE) {
+            CAMERA_NAPI_GET_JS_ASYNC_CB_REF(env, argv[PARAM0], refCount, asyncContext->callbackRef);
+        }
+
+        CAMERA_NAPI_CREATE_PROMISE(env, asyncContext->callbackRef, asyncContext->deferred, result);
+        CAMERA_NAPI_CREATE_RESOURCE_NAME(env, resource, "Stop");
+
+        status = napi_create_async_work(
+            env, nullptr, resource,
+            [](napi_env env, void* data) {
+                auto context = static_cast<DepthDataOutputAsyncContext*>(data);
+                context->status = false;
+                // Start async trace
+                context->funcName = "DepthDataOutputNapi::Stop";
+                context->taskId = CameraNapiUtils::IncrementAndGet(depthDataOutputTaskId);
+                CAMERA_START_ASYNC_TRACE(context->funcName, context->taskId);
+                if (context->objectInfo != nullptr) {
+                    context->bRetBool = false;
+                    context->errorCode = context->objectInfo->depthDataOutput_->Stop();
+                    context->status = context->errorCode == 0;
+                }
+            },
+            CommonCompleteCallback, static_cast<void*>(asyncContext.get()), &asyncContext->work);
+        if (status != napi_ok) {
+            MEDIA_ERR_LOG("Failed to create napi_create_async_work for DepthDataOutputNapi::Release");
+            napi_get_undefined(env, &result);
+        } else {
+            napi_queue_async_work_with_qos(env, asyncContext->work, napi_qos_user_initiated);
+            asyncContext.release();
+        }
+    } else {
+        MEDIA_ERR_LOG("Stop call Failed!");
+    }
+    return result;
+}
+
+void DepthDataOutputNapi::RegisterDepthDataAvailableCallbackListener(
+    const std::string& eventName, napi_env env, napi_value callback, const std::vector<napi_value>& args, bool isOnce)
+{
+    if (sDepthDataSurface_ == nullptr) {
+        MEDIA_ERR_LOG("sDepthDataSurface_ is null!");
+        return;
+    }
+    if (depthDataListener_ == nullptr) {
+        MEDIA_INFO_LOG("new depthDataListener_ and register surface consumer listener");
+        sptr<DepthDataListener> depthDataListener = new (std::nothrow) DepthDataListener(env, sDepthDataSurface_,
+            depthDataOutput_);
+        SurfaceError ret = sDepthDataSurface_->RegisterConsumerListener((
+            sptr<IBufferConsumerListener>&)depthDataListener);
+        if (ret != SURFACE_ERROR_OK) {
+            MEDIA_ERR_LOG("register surface consumer listener failed!");
+        }
+        depthDataListener_ = depthDataListener;
+    }
+    depthDataListener_->SetDepthProfile(depthProfile_);
+    depthDataListener_->SaveCallback(CONST_DEPTH_DATA_AVAILABLE, callback);
+}
+
+void DepthDataOutputNapi::UnregisterDepthDataAvailableCallbackListener(
+    const std::string& eventName, napi_env env, napi_value callback, const std::vector<napi_value>& args)
+{
+    if (depthDataListener_ != nullptr) {
+        depthDataListener_->RemoveCallback(CONST_DEPTH_DATA_AVAILABLE, callback);
+    }
+}
+
+void DepthDataOutputNapi::RegisterErrorCallbackListener(
+    const std::string& eventName, napi_env env, napi_value callback, const std::vector<napi_value>& args, bool isOnce)
+{
+    if (depthDataCallback_ == nullptr) {
+        depthDataCallback_ = std::make_shared<DepthDataOutputCallback>(env);
+        depthDataOutput_->SetCallback(depthDataCallback_);
+    }
+    depthDataCallback_->SaveCallbackReference(CONST_DEPTH_DATA_ERROR, callback, isOnce);
+}
+
+void DepthDataOutputNapi::UnregisterErrorCallbackListener(
+    const std::string& eventName, napi_env env, napi_value callback, const std::vector<napi_value>& args)
+{
+    if (depthDataCallback_ == nullptr) {
+        MEDIA_ERR_LOG("depthDataCallback is null");
+        return;
+    }
+    depthDataCallback_->RemoveCallbackRef(CONST_DEPTH_DATA_ERROR, callback);
+}
+
+const DepthDataOutputNapi::EmitterFunctions& DepthDataOutputNapi::GetEmitterFunctions()
+{
+    static const EmitterFunctions funMap = {
+        { CONST_DEPTH_DATA_AVAILABLE, {
+            &DepthDataOutputNapi::RegisterDepthDataAvailableCallbackListener,
+            &DepthDataOutputNapi::UnregisterDepthDataAvailableCallbackListener } },
+        { CONST_DEPTH_DATA_ERROR, {
+            &DepthDataOutputNapi::RegisterErrorCallbackListener,
+            &DepthDataOutputNapi::UnregisterErrorCallbackListener } } };
+    return funMap;
+}
+
+napi_value DepthDataOutputNapi::On(napi_env env, napi_callback_info info)
+{
+    return ListenerTemplate<DepthDataOutputNapi>::On(env, info);
+}
+
+napi_value DepthDataOutputNapi::Once(napi_env env, napi_callback_info info)
+{
+    return ListenerTemplate<DepthDataOutputNapi>::Once(env, info);
+}
+
+napi_value DepthDataOutputNapi::Off(napi_env env, napi_callback_info info)
+{
+    return ListenerTemplate<DepthDataOutputNapi>::Off(env, info);
+}
+} // namespace CameraStandard
+} // namespace OHOS
diff --git a/frameworks/js/camera_napi/src/session/camera_session_napi.cpp b/frameworks/js/camera_napi/src/session/camera_session_napi.cpp
index 0a2c9c397..b89822196 100644
--- a/frameworks/js/camera_napi/src/session/camera_session_napi.cpp
+++ b/frameworks/js/camera_napi/src/session/camera_session_napi.cpp
@@ -1110,6 +1110,7 @@ napi_value CameraSessionNapi::GetJSArgsForCameraOutput(napi_env env, size_t argc
     PhotoOutputNapi* photoOutputNapiObj = nullptr;
     VideoOutputNapi* videoOutputNapiObj = nullptr;
     MetadataOutputNapi* metadataOutputNapiObj = nullptr;
+    DepthDataOutputNapi* depthDataOutputNapiObj = nullptr;
 
     NAPI_ASSERT(env, argv != nullptr, "Argument list is empty");
 
@@ -1134,6 +1135,10 @@ napi_value CameraSessionNapi::GetJSArgsForCameraOutput(napi_env env, size_t argc
                 MEDIA_INFO_LOG("metadata output adding..");
                 napi_unwrap(env, argv[i], reinterpret_cast<void**>(&metadataOutputNapiObj));
                 cameraOutput = metadataOutputNapiObj->GetMetadataOutput();
+            } else if (DepthDataOutputNapi::IsDepthDataOutput(env, argv[i])) {
+                MEDIA_INFO_LOG("depth data output adding..");
+                napi_unwrap(env, argv[i], reinterpret_cast<void**>(&depthDataOutputNapiObj));
+                cameraOutput = depthDataOutputNapiObj->GetDepthDataOutput();
             } else {
                 MEDIA_INFO_LOG("invalid output ..");
                 NAPI_ASSERT(env, false, "type mismatch");
diff --git a/frameworks/native/camera/BUILD.gn b/frameworks/native/camera/BUILD.gn
index d4b3f453d..361627e7a 100644
--- a/frameworks/native/camera/BUILD.gn
+++ b/frameworks/native/camera/BUILD.gn
@@ -69,6 +69,7 @@ ohos_shared_library("camera_framework") {
     "//foundation/multimedia/camera_framework/services/camera_service/binder/client/src/hcamera_service_proxy.cpp",
     "//foundation/multimedia/camera_framework/services/camera_service/binder/client/src/hcapture_session_proxy.cpp",
     "//foundation/multimedia/camera_framework/services/camera_service/binder/client/src/hstream_capture_proxy.cpp",
+    "//foundation/multimedia/camera_framework/services/camera_service/binder/client/src/hstream_depth_data_proxy.cpp",
     "//foundation/multimedia/camera_framework/services/camera_service/binder/client/src/hstream_metadata_proxy.cpp",
     "//foundation/multimedia/camera_framework/services/camera_service/binder/client/src/hstream_repeat_proxy.cpp",
     "//foundation/multimedia/camera_framework/services/camera_service/binder/server/src/hcamera_device_callback_stub.cpp",
@@ -76,6 +77,7 @@ ohos_shared_library("camera_framework") {
     "//foundation/multimedia/camera_framework/services/camera_service/binder/server/src/hcamera_service_callback_stub.cpp",
     "//foundation/multimedia/camera_framework/services/camera_service/binder/server/src/hcapture_session_callback_stub.cpp",
     "//foundation/multimedia/camera_framework/services/camera_service/binder/server/src/hstream_capture_callback_stub.cpp",
+    "//foundation/multimedia/camera_framework/services/camera_service/binder/server/src/hstream_depth_data_callback_stub.cpp",
     "//foundation/multimedia/camera_framework/services/camera_service/binder/server/src/hstream_repeat_callback_stub.cpp",
     "src/ability/camera_ability.cpp",
     "src/ability/camera_ability_builder.cpp",
@@ -90,6 +92,7 @@ ohos_shared_library("camera_framework") {
     "src/output/camera_photo_proxy.cpp",
     "src/output/capture_output.cpp",
     "src/output/deferred_photo_proxy.cpp",
+    "src/output/depth_data_output.cpp",
     "src/output/metadata_output.cpp",
     "src/output/photo_output.cpp",
     "src/output/preview_output.cpp",
@@ -176,6 +179,7 @@ ohos_shared_library("camera_framework") {
     "ipc:ipc_core",
     "media_library:media_library",
     "media_library:media_library_manager",
+    "napi:ace_napi",
     "os_account:libaccountkits",
     "os_account:os_account_innerkits",
     "safwk:system_ability_fwk",
diff --git a/frameworks/native/camera/src/input/camera_manager.cpp b/frameworks/native/camera/src/input/camera_manager.cpp
index 542201703..5bb52d315 100644
--- a/frameworks/native/camera/src/input/camera_manager.cpp
+++ b/frameworks/native/camera/src/input/camera_manager.cpp
@@ -76,6 +76,13 @@ const std::unordered_map<camera_format_t, CameraFormat> CameraManager::metaToFwC
     {OHOS_CAMERA_FORMAT_YCBCR_420_SP, CAMERA_FORMAT_NV12},
     {OHOS_CAMERA_FORMAT_422_YUYV, CAMERA_FORMAT_YUV_422_YUYV},
     {OHOS_CAMERA_FORMAT_DNG, CAMERA_FORMAT_DNG},
+    {OHOS_CAMERA_FORMAT_DEPTH_16, CAMERA_FORMAT_DEPTH_16},
+    {OHOS_CAMERA_FORMAT_DEPTH_32, CAMERA_FORMAT_DEPTH_32}
+};
+
+const std::unordered_map<DepthDataAccuracyType, DepthDataAccuracy> CameraManager::metaToFwDepthDataAccuracy_ = {
+    {OHOS_DEPTH_DATA_ACCURACY_RELATIVE, DEPTH_DATA_ACCURACY_RELATIVE},
+    {OHOS_DEPTH_DATA_ACCURACY_ABSOLUTE, DEPTH_DATA_ACCURACY_ABSOLUTE},
 };
 
 const std::unordered_map<CameraFormat, camera_format_t> CameraManager::fwToMetaCameraFormat_ = {
@@ -87,7 +94,8 @@ const std::unordered_map<CameraFormat, camera_format_t> CameraManager::fwToMetaC
     {CAMERA_FORMAT_NV12, OHOS_CAMERA_FORMAT_YCBCR_420_SP},
     {CAMERA_FORMAT_YUV_422_YUYV, OHOS_CAMERA_FORMAT_422_YUYV},
     {CAMERA_FORMAT_DNG, OHOS_CAMERA_FORMAT_DNG},
-
+    {CAMERA_FORMAT_DEPTH_16, OHOS_CAMERA_FORMAT_DEPTH_16},
+    {CAMERA_FORMAT_DEPTH_32, OHOS_CAMERA_FORMAT_DEPTH_32}
 };
 
 const std::unordered_map<OperationMode, SceneMode> g_metaToFwSupportedMode_ = {
@@ -664,6 +672,58 @@ int CameraManager::CreateMetadataOutput(sptr<MetadataOutput>& pMetadataOutput)
     return CameraErrorCode::SUCCESS;
 }
 
+sptr<DepthDataOutput> CameraManager::CreateDepthDataOutput(DepthProfile& depthProfile, sptr<IBufferProducer> &surface)
+{
+    CAMERA_SYNC_TRACE;
+    sptr<DepthDataOutput> depthDataOutput = nullptr;
+    int ret = CreateDepthDataOutput(depthProfile, surface, &depthDataOutput);
+    if (ret != CameraErrorCode::SUCCESS) {
+        MEDIA_ERR_LOG("Failed to CreateDepthDataOutput with error code:%{public}d", ret);
+        return nullptr;
+    }
+    return depthDataOutput;
+}
+
+int CameraManager::CreateDepthDataOutput(DepthProfile& depthProfile, sptr<IBufferProducer> &surface,
+    sptr<DepthDataOutput>* pDepthDataOutput)
+{
+    CAMERA_SYNC_TRACE;
+    sptr<IStreamDepthData> streamDepthData = nullptr;
+    sptr<DepthDataOutput> depthDataOutput = nullptr;
+    int32_t retCode = CAMERA_OK;
+    camera_format_t metaFormat;
+
+    auto serviceProxy = GetServiceProxy();
+    if ((serviceProxy == nullptr) || (surface == nullptr)) {
+        MEDIA_ERR_LOG("serviceProxy is null or DepthDataOutputSurface/profile is null");
+        return CameraErrorCode::INVALID_ARGUMENT;
+    }
+
+    if ((depthProfile.GetCameraFormat() == CAMERA_FORMAT_INVALID) ||
+        (depthProfile.GetSize().width == 0) ||
+        (depthProfile.GetSize().height == 0)) {
+        MEDIA_ERR_LOG("invalid fomrat or width or height is zero");
+        return CameraErrorCode::INVALID_ARGUMENT;
+    }
+
+    metaFormat = GetCameraMetadataFormat(depthProfile.GetCameraFormat());
+    retCode = serviceProxy->CreateDepthDataOutput(
+        surface, metaFormat, depthProfile.GetSize().width, depthProfile.GetSize().height, streamDepthData);
+    if (retCode == CAMERA_OK) {
+        depthDataOutput = new(std::nothrow) DepthDataOutput(surface);
+        if (depthDataOutput == nullptr) {
+            return CameraErrorCode::SERVICE_FATL_ERROR;
+        }
+        depthDataOutput->SetStream(streamDepthData);
+    } else {
+        MEDIA_ERR_LOG("Failed to get stream depth data object from hcamera service!, %{public}d", retCode);
+        return ServiceToCameraError(retCode);
+    }
+    depthDataOutput->SetDepthProfile(depthProfile);
+    *pDepthDataOutput = depthDataOutput;
+    return CameraErrorCode::SUCCESS;
+}
+
 sptr<VideoOutput> CameraManager::CreateVideoOutput(sptr<Surface> &surface)
 {
     CAMERA_SYNC_TRACE;
@@ -1441,6 +1501,60 @@ void CameraManager::ParseExtendCapability(ProfilesWrapper& profilesWrapper, cons
     }
 }
 
+void CameraManager::ParseDepthCapability(const int32_t modeName, const camera_metadata_item_t& item)
+    __attribute__((no_sanitize("cfi")))
+{
+    ExtendInfo extendInfo = {};
+    std::shared_ptr<CameraDepthInfoParse> depthStreamParse = std::make_shared<CameraDepthInfoParse>();
+    depthStreamParse->getModeInfo(item.data.i32, item.count, extendInfo); // 解析tag中带的数据信息意义
+    for (uint32_t i = 0; i < extendInfo.modeCount; i++) {
+        if (modeName == extendInfo.modeInfo[i].modeName) {
+            for (uint32_t j = 0; j < extendInfo.modeInfo[i].streamTypeCount; j++) {
+                OutputCapStreamType streamType =
+                    static_cast<OutputCapStreamType>(extendInfo.modeInfo[i].streamInfo[j].streamType);
+                CreateDepthProfile4StreamType(streamType, i, j, extendInfo);
+            }
+            break;
+        }
+    }
+}
+
+void CameraManager::CreateDepthProfile4StreamType(OutputCapStreamType streamType, uint32_t modeIndex,
+    uint32_t streamIndex, ExtendInfo extendInfo) __attribute__((no_sanitize("cfi")))
+{
+    for (uint32_t k = 0; k < extendInfo.modeInfo[modeIndex].streamInfo[streamIndex].detailInfoCount; k++) {
+        const auto& detailInfo = extendInfo.modeInfo[modeIndex].streamInfo[streamIndex].detailInfo[k];
+        CameraFormat format = CAMERA_FORMAT_INVALID;
+        auto itr = metaToFwCameraFormat_.find(static_cast<camera_format_t>(detailInfo.format));
+        if (itr != metaToFwCameraFormat_.end()) {
+            format = itr->second;
+        } else {
+            MEDIA_ERR_LOG("CreateDepthProfile4StreamType failed format = %{public}d",
+                extendInfo.modeInfo[modeIndex].streamInfo[streamIndex].detailInfo[k].format);
+            format = CAMERA_FORMAT_INVALID;
+            continue;
+        }
+        Size size{static_cast<uint32_t>(detailInfo.width), static_cast<uint32_t>(detailInfo.height)};
+        DepthDataAccuracy dataAccuracy = DEPTH_DATA_ACCURACY_INVALID;
+        auto it = metaToFwDepthDataAccuracy_.find(static_cast<DepthDataAccuracyType>(detailInfo.dataAccuracy));
+        if (it != metaToFwDepthDataAccuracy_.end()) {
+            dataAccuracy = it->second;
+        } else {
+            MEDIA_ERR_LOG("CreateDepthProfile4StreamType failed dataAccuracy = %{public}d",
+                extendInfo.modeInfo[modeIndex].streamInfo[streamIndex].detailInfo[k].dataAccuracy);
+            dataAccuracy = DEPTH_DATA_ACCURACY_INVALID;
+            continue;
+        }
+        MEDIA_DEBUG_LOG("streamType: %{public}d, OutputCapStreamType::DEPTH: %{public}d", streamType,
+            OutputCapStreamType::DEPTH);
+        DepthProfile depthProfile = DepthProfile(format, dataAccuracy, size);
+        MEDIA_DEBUG_LOG("depthdata format : %{public}d, data accuracy: %{public}d, width: %{public}d,"
+            "height: %{public}d", depthProfile.GetCameraFormat(), depthProfile.GetDataAccuracy(),
+            depthProfile.GetSize().width, depthProfile.GetSize().height);
+        depthProfiles_.push_back(depthProfile);
+    }
+}
+
 void CameraManager::ParseProfileLevel(ProfilesWrapper& profilesWrapper, const int32_t modeName,
     const camera_metadata_item_t& item) __attribute__((no_sanitize("cfi")))
 {
@@ -1519,6 +1633,17 @@ void CameraManager::ParseCapability(ProfilesWrapper& profilesWrapper, sptr<Camer
     } else {
         MEDIA_ERR_LOG("Failed get stream info");
     }
+    // 解析深度流信息
+    if (g_isCapabilitySupported(metadata, item, OHOS_ABILITY_DEPTH_DATA_PROFILES)) {
+        std::vector<SceneMode> supportedModes = GetSupportedModes(camera);
+        int32_t mode = (supportedModes.empty() && isTemplateMode_.count(modeName)) ? SceneMode::NORMAL : modeName;
+        MEDIA_INFO_LOG("Depth g_isCapabilitySupported by device = %{public}s, mode = %{public}d, tag = %{public}d",
+            camera->GetID().c_str(), mode, OHOS_ABILITY_DEPTH_DATA_PROFILES);
+        ParseDepthCapability(mode, item);
+    } else {
+        MEDIA_INFO_LOG("Depth GetSupportedOutputCapability is not supported by device = %{public}s,"
+            "tag = %{public}d", camera->GetID().c_str(), OHOS_ABILITY_DEPTH_DATA_PROFILES);
+    }
 }
 
 sptr<CameraOutputCapability> CameraManager::GetSupportedOutputCapability(sptr<CameraDevice>& camera, int32_t modeName)
@@ -1532,6 +1657,7 @@ sptr<CameraOutputCapability> CameraManager::GetSupportedOutputCapability(sptr<Ca
     CHECK_ERROR_RETURN_RET(metadata == nullptr, nullptr);
     camera_metadata_item_t item;
     ProfilesWrapper profilesWrapper = {};
+    depthProfiles_.clear();
 
     ParseCapability(profilesWrapper, camera, modeName, item, metadata);
     SceneMode profileMode = static_cast<SceneMode>(modeName);
@@ -1547,6 +1673,8 @@ sptr<CameraOutputCapability> CameraManager::GetSupportedOutputCapability(sptr<Ca
         cameraOutputCapability->SetVideoProfiles(profilesWrapper.vidProfiles);
     }
     MEDIA_INFO_LOG("SetVideoProfiles size = %{public}zu", profilesWrapper.vidProfiles.size());
+    cameraOutputCapability->SetDepthProfiles(depthProfiles_);
+    MEDIA_INFO_LOG("SetDepthProfiles size = %{public}zu", depthProfiles_.size());
 
     std::vector<MetadataObjectType> objectTypes = {};
     GetSupportedMetadataObjectType(metadata->get(), objectTypes);
diff --git a/frameworks/native/camera/src/output/camera_output_capability.cpp b/frameworks/native/camera/src/output/camera_output_capability.cpp
index a87e1bfd4..f8d1b0b87 100644
--- a/frameworks/native/camera/src/output/camera_output_capability.cpp
+++ b/frameworks/native/camera/src/output/camera_output_capability.cpp
@@ -124,6 +124,15 @@ std::vector<int32_t> VideoProfile::GetFrameRates()
     return framerates_;
 }
 
+DepthProfile::DepthProfile(CameraFormat format, DepthDataAccuracy dataAccuracy, Size size) : Profile(format, size)
+{
+    dataAccuracy_ = dataAccuracy;
+}
+DepthDataAccuracy DepthProfile::GetDataAccuracy()
+{
+    return dataAccuracy_;
+}
+
 bool CameraOutputCapability::IsMatchPreviewProfiles(std::vector<Profile>& previewProfiles)
 {
     CHECK_ERROR_RETURN_RET(previewProfiles.empty(), true);
@@ -238,6 +247,16 @@ void CameraOutputCapability::SetVideoProfiles(std::vector<VideoProfile> videoPro
     videoProfiles_ = videoProfiles;
 }
 
+std::vector<DepthProfile> CameraOutputCapability::GetDepthProfiles()
+{
+    return depthProfiles_;
+}
+
+void CameraOutputCapability::SetDepthProfiles(std::vector<DepthProfile> depthProfiles)
+{
+    depthProfiles_ = depthProfiles;
+}
+
 std::vector<MetadataObjectType> CameraOutputCapability::GetSupportedMetadataObjectType()
 {
     return metadataObjTypes_;
diff --git a/frameworks/native/camera/src/output/capture_output.cpp b/frameworks/native/camera/src/output/capture_output.cpp
index 8cfdc53e4..38efb8e7b 100644
--- a/frameworks/native/camera/src/output/capture_output.cpp
+++ b/frameworks/native/camera/src/output/capture_output.cpp
@@ -176,6 +176,18 @@ std::shared_ptr<VideoProfile> CaptureOutput::GetVideoProfile()
     return videoProfile_;
 }
 
+void CaptureOutput::SetDepthProfile(DepthProfile& depthProfile)
+{
+    std::lock_guard<std::mutex> lock(depthProfileMutex_);
+    depthProfile_ = std::make_shared<DepthProfile>(depthProfile);
+}
+
+std::shared_ptr<DepthProfile> CaptureOutput::GetDepthProfile()
+{
+    std::lock_guard<std::mutex> lock(depthProfileMutex_);
+    return depthProfile_;
+}
+
 void CaptureOutput::ClearProfiles()
 {
     {
diff --git a/frameworks/native/camera/src/output/depth_data_output.cpp b/frameworks/native/camera/src/output/depth_data_output.cpp
new file mode 100644
index 000000000..962294580
--- /dev/null
+++ b/frameworks/native/camera/src/output/depth_data_output.cpp
@@ -0,0 +1,223 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "output/depth_data_output.h"
+
+#include <cstdint>
+#include <limits>
+#include <memory>
+#include <utility>
+#include <variant>
+
+#include "camera_device_ability_items.h"
+#include "camera_error_code.h"
+#include "camera_log.h"
+#include "camera_manager.h"
+#include "camera_metadata_operator.h"
+#include "camera_output_capability.h"
+#include "camera_util.h"
+#include "hstream_depth_data_callback_stub.h"
+#include "image_format.h"
+#include "metadata_common_utils.h"
+#include "pixel_map.h"
+#include "session/capture_session.h"
+
+namespace OHOS {
+namespace CameraStandard {
+
+int32_t DepthDataOutputCallbackImpl::OnDepthDataError(int32_t errorCode)
+{
+    auto item = depthDataOutput_.promote();
+    if (item != nullptr) {
+        auto callback = item->GetApplicationCallback();
+        if (callback != nullptr) {
+            callback->OnDepthDataError(errorCode);
+        } else {
+            MEDIA_INFO_LOG("Discarding DepthDataOutputCallbackImpl::OnDepthDataError callback in depthoutput");
+        }
+    } else {
+        MEDIA_INFO_LOG("DepthDataOutputCallbackImpl::OnDepthDataError DepthDataOutput is nullptr");
+    }
+    return CAMERA_OK;
+}
+
+DepthDataOutput::DepthDataOutput(sptr<IBufferProducer> bufferProducer)
+    : CaptureOutput(CAPTURE_OUTPUT_TYPE_DEPTH_DATA, StreamType::DEPTH, bufferProducer, nullptr)
+{
+    DepthDataFormat_ = 0;
+    DepthDataSize_.height = 0;
+    DepthDataSize_.width = 0;
+}
+
+DepthDataOutput::~DepthDataOutput()
+{
+    MEDIA_DEBUG_LOG("Enter Into DepthDataOutput::~DepthDataOutput()");
+}
+
+int32_t DepthDataOutput::Start()
+{
+    CAMERA_SYNC_TRACE;
+    SetDataAccuracy(GetDepthProfile()->GetDataAccuracy());
+    std::lock_guard<std::mutex> lock(asyncOpMutex_);
+    MEDIA_DEBUG_LOG("Enter Into DepthDataOutput::Start");
+    auto captureSession = GetSession();
+    if (captureSession == nullptr || !captureSession->IsSessionCommited()) {
+        MEDIA_ERR_LOG("DepthDataOutput Failed to Start!, session not config");
+        return CameraErrorCode::SESSION_NOT_CONFIG;
+    }
+    if (GetStream() == nullptr) {
+        MEDIA_ERR_LOG("DepthDataOutput Failed to Start!, GetStream is nullptr");
+        return CameraErrorCode::SERVICE_FATL_ERROR;
+    }
+    auto itemStream = static_cast<IStreamDepthData*>(GetStream().GetRefPtr());
+    int32_t errCode = CAMERA_UNKNOWN_ERROR;
+    if (itemStream) {
+        errCode = itemStream->Start();
+        if (errCode != CAMERA_OK) {
+            MEDIA_ERR_LOG("DepthDataOutput Failed to Start!, errCode: %{public}d", errCode);
+        }
+    } else {
+        MEDIA_ERR_LOG("DepthDataOutput::Start itemStream is nullptr");
+    }
+    return ServiceToCameraError(errCode);
+}
+
+int32_t DepthDataOutput::Stop()
+{
+    std::lock_guard<std::mutex> lock(asyncOpMutex_);
+    MEDIA_DEBUG_LOG("Enter Into DepthDataOutput::Stop");
+    if (GetStream() == nullptr) {
+        MEDIA_ERR_LOG("DepthDataOutput Failed to Stop!, GetStream is nullptr");
+        return CameraErrorCode::SERVICE_FATL_ERROR;
+    }
+    auto itemStream = static_cast<IStreamDepthData*>(GetStream().GetRefPtr());
+    int32_t errCode = CAMERA_UNKNOWN_ERROR;
+    if (itemStream) {
+        errCode = itemStream->Stop();
+        if (errCode != CAMERA_OK) {
+            MEDIA_ERR_LOG("DepthDataOutput Failed to Stop!, errCode: %{public}d", errCode);
+        }
+    } else {
+        MEDIA_ERR_LOG("DepthDataOutput::Stop itemStream is nullptr");
+    }
+    return ServiceToCameraError(errCode);
+}
+
+int32_t DepthDataOutput::SetDataAccuracy(int32_t dataAccuracy)
+{
+    CAMERA_SYNC_TRACE;
+    std::lock_guard<std::mutex> lock(asyncOpMutex_);
+    MEDIA_DEBUG_LOG("Enter Into DepthDataOutput::SetDataAccuracy");
+    if (GetStream() == nullptr) {
+        MEDIA_ERR_LOG("DepthDataOutput Failed to SetDataAccuracy!, GetStream is nullptr");
+        return CameraErrorCode::SERVICE_FATL_ERROR;
+    }
+    auto itemStream = static_cast<IStreamDepthData*>(GetStream().GetRefPtr());
+    int32_t errCode = CAMERA_UNKNOWN_ERROR;
+    if (itemStream) {
+        errCode = itemStream->SetDataAccuracy(dataAccuracy);
+        if (errCode != CAMERA_OK) {
+            MEDIA_ERR_LOG("DepthDataOutput Failed to SetDataAccuracy!, errCode: %{public}d", errCode);
+        }
+    } else {
+        MEDIA_ERR_LOG("DepthDataOutput::SetDataAccuracy itemStream is nullptr");
+    }
+    return ServiceToCameraError(errCode);
+}
+
+int32_t DepthDataOutput::CreateStream()
+{
+    MEDIA_INFO_LOG("DepthDataOutput::CreateStream enter");
+    return CameraErrorCode::SUCCESS;
+}
+
+int32_t DepthDataOutput::Release()
+{
+    {
+        std::lock_guard<std::mutex> lock(outputCallbackMutex_);
+        svcCallback_ = nullptr;
+        appCallback_ = nullptr;
+    }
+    std::lock_guard<std::mutex> lock(asyncOpMutex_);
+    MEDIA_DEBUG_LOG("Enter Into DepthDataOutput::Release");
+    if (GetStream() == nullptr) {
+        MEDIA_ERR_LOG("DepthDataOutput Failed to Release!, GetStream is nullptr");
+        return CameraErrorCode::SERVICE_FATL_ERROR;
+    }
+    auto itemStream = static_cast<IStreamDepthData*>(GetStream().GetRefPtr());
+    int32_t errCode = CAMERA_UNKNOWN_ERROR;
+    if (itemStream) {
+        errCode = itemStream->Release();
+        if (errCode != CAMERA_OK) {
+            MEDIA_ERR_LOG("Failed to release DepthDataOutput!, errCode: %{public}d", errCode);
+        }
+    } else {
+        MEDIA_ERR_LOG("DepthDataOutput::Release() itemStream is nullptr");
+    }
+    CaptureOutput::Release();
+    return ServiceToCameraError(errCode);
+}
+
+void DepthDataOutput::SetCallback(std::shared_ptr<DepthDataStateCallback> callback)
+{
+    std::lock_guard<std::mutex> lock(outputCallbackMutex_);
+    appCallback_ = callback;
+    if (appCallback_ != nullptr) {
+        if (svcCallback_ == nullptr) {
+            svcCallback_ = new (std::nothrow) DepthDataOutputCallbackImpl(this);
+            if (svcCallback_ == nullptr) {
+                MEDIA_ERR_LOG("new DepthDataOutputCallbackImpl Failed to register callback");
+                appCallback_ = nullptr;
+                return;
+            }
+        }
+        if (GetStream() == nullptr) {
+            MEDIA_ERR_LOG("DepthDataOutput Failed to SetCallback!, GetStream is nullptr");
+            return;
+        }
+        auto itemStream = static_cast<IStreamDepthData*>(GetStream().GetRefPtr());
+        int32_t errorCode = CAMERA_OK;
+        if (itemStream) {
+            errorCode = itemStream->SetCallback(svcCallback_);
+        } else {
+            MEDIA_ERR_LOG("DepthDataOutput::SetCallback itemStream is nullptr");
+        }
+        if (errorCode != CAMERA_OK) {
+            MEDIA_ERR_LOG("DepthDataOutput::SetCallback Failed to register callback, errorCode: %{public}d", errorCode);
+            svcCallback_ = nullptr;
+            appCallback_ = nullptr;
+        }
+    }
+    return;
+}
+
+std::shared_ptr<DepthDataStateCallback> DepthDataOutput::GetApplicationCallback()
+{
+    std::lock_guard<std::mutex> lock(outputCallbackMutex_);
+    return appCallback_;
+}
+
+void DepthDataOutput::CameraServerDied(pid_t pid)
+{
+    MEDIA_ERR_LOG("camera server has died, pid:%{public}d!", pid);
+    std::lock_guard<std::mutex> lock(outputCallbackMutex_);
+    if (appCallback_ != nullptr) {
+        MEDIA_DEBUG_LOG("appCallback not nullptr");
+        int32_t serviceErrorType = ServiceToCameraError(CAMERA_INVALID_STATE);
+        appCallback_->OnDepthDataError(serviceErrorType);
+    }
+}
+} // namespace CameraStandard
+} // namespace OHOS
diff --git a/frameworks/native/camera/src/session/capture_session.cpp b/frameworks/native/camera/src/session/capture_session.cpp
index e69ae1015..89fe651d8 100644
--- a/frameworks/native/camera/src/session/capture_session.cpp
+++ b/frameworks/native/camera/src/session/capture_session.cpp
@@ -897,6 +897,9 @@ bool CaptureSession::CanAddOutput(sptr<CaptureOutput>& output)
             profilePtr = output->IsTagSetted(CaptureOutput::DYNAMIC_PROFILE) ? GetPreconfigVideoProfile()
                                                                              : output->GetVideoProfile();
             break;
+        case CAPTURE_OUTPUT_TYPE_DEPTH_DATA:
+            profilePtr = output->GetDepthProfile();
+            break;
         default:
             MEDIA_ERR_LOG("CaptureSession::CanAddOutput CaptureOutputType unknown");
             return false;
@@ -4168,6 +4171,10 @@ bool CaptureSession::ValidateOutputProfile(Profile& outputProfile, CaptureOutput
         MEDIA_INFO_LOG("CaptureSession::ValidateOutputProfile MetadataOutput");
         return true;
     }
+    if (outputType == CAPTURE_OUTPUT_TYPE_DEPTH_DATA) {
+        MEDIA_INFO_LOG("CaptureSession::ValidateOutputProfile DepthDataOutput");
+        return true;
+    }
     auto modeName = GetMode();
     auto validateOutputProfileFunc = [modeName](auto validateProfile, auto& profiles) -> bool {
         MEDIA_INFO_LOG("CaptureSession::ValidateOutputProfile in mode(%{public}d): "
diff --git a/interfaces/inner_api/native/camera/include/camera_stream_info_parse.h b/interfaces/inner_api/native/camera/include/camera_stream_info_parse.h
index e4729e608..f58a9d10d 100644
--- a/interfaces/inner_api/native/camera/include/camera_stream_info_parse.h
+++ b/interfaces/inner_api/native/camera/include/camera_stream_info_parse.h
@@ -28,6 +28,7 @@ typedef struct DetailInfo {
     int32_t fixedFps;
     int32_t minFps;
     int32_t maxFps;
+    int32_t dataAccuracy;
     std::vector<uint32_t> abilityId;
 } DetailInfo;
 
@@ -183,6 +184,118 @@ private:
     std::queue<uint32_t> abilityEndIndex_;
     std::queue<uint32_t> abilityStartIndex_;
 };
+
+class CameraDepthInfoParse {
+public:
+    void getModeInfo(int32_t* originInfo, uint32_t count, ExtendInfo& transferedInfo)
+    {
+        modeStartIndex_.push_back(0);
+        for (uint32_t i = TWO_STEP; i < count; i++) {
+            if (originInfo[i] == MODE_FINISH) { // 判断mode的-1 结束符位置
+                    modeEndIndex_.push_back(i);
+                    if (i + ONE_STEP < count) {
+                        modeStartIndex_.push_back(i + ONE_STEP);
+                    }
+                transferedInfo.modeCount++;
+            }
+        }
+        modeCount_ = transferedInfo.modeCount;
+        transferedInfo.modeInfo.resize(transferedInfo.modeCount);
+        getStreamCount(originInfo, transferedInfo);
+        for (uint32_t i = 0; i < modeCount_; i++) {
+            transferedInfo.modeInfo[i].modeName = originInfo[modeStartIndex_[i]];
+            streamTypeCount_.push(transferedInfo.modeInfo[i].streamTypeCount);
+        }
+        for (uint32_t i = 0; i < transferedInfo.modeCount; i++) {
+            getStreamInfo(originInfo, transferedInfo.modeInfo[i]);
+        }
+        for (uint32_t i = 0; i < transferedInfo.modeCount; i++) {
+            getDetailStreamInfo(originInfo, transferedInfo.modeInfo[i]);
+        }
+    }
+private:
+    void getStreamCount(int32_t* originInfo, ExtendInfo& transferedInfo)
+    {
+        for (uint32_t i = 0; i < modeCount_; i++) {
+            for (uint32_t j = modeStartIndex_[i]; j < modeEndIndex_[i]; j++) {
+                if (j == modeStartIndex_[i]) {
+                    streamStartIndex_.push(modeStartIndex_[i]);
+                }
+                if (originInfo[j + ONE_STEP] == STREAM_FINISH) {
+                    streamEndIndex_.push(j + ONE_STEP);
+                    transferedInfo.modeInfo[i].streamTypeCount++;
+                }
+            }
+        }
+        
+        modeStartIndex_.clear();
+        modeEndIndex_.clear();
+        return;
+    }
+
+    void getStreamInfo(int32_t* originInfo, ModeInfo& modeInfo)
+    {
+        modeInfo.streamInfo.resize(modeInfo.streamTypeCount);
+        for (uint32_t j = 0; j < modeInfo.streamTypeCount; j++) {
+            modeInfo.streamInfo[j].streamType = originInfo[streamStartIndex_.front()];
+            for (uint32_t k = streamStartIndex_.front(); k < streamEndIndex_.front(); k++) {
+                if (k == streamStartIndex_.front()) {
+                    abilityStartIndex_.push(k);
+                }
+                if (originInfo[k + ONE_STEP] == ABILITY_FINISH) {
+                    abilityEndIndex_.push(k + ONE_STEP);
+                    modeInfo.streamInfo[j].detailInfoCount++;
+                }
+            }
+            deatiInfoCount_.push(modeInfo.streamInfo[j].detailInfoCount);
+            streamStartIndex_.pop();
+            streamEndIndex_.pop();
+        }
+        return;
+    }
+
+    void getDetailStreamInfo(int32_t* originInfo, ModeInfo& modeInfo)
+    {
+        for (uint32_t j = 0; j < streamTypeCount_.front(); j++) {
+            modeInfo.streamInfo[j].detailInfo.resize(deatiInfoCount_.front());
+            getDetailAbilityInfo(originInfo, modeInfo.streamInfo[j]);
+        }
+        streamTypeCount_.pop();
+    }
+
+    void getDetailAbilityInfo(int32_t* originInfo, StreamRelatedInfo& streamInfo)
+    {
+        uint32_t formatOffset = 1;
+        uint32_t dataAccuracyOffset = 2;
+        uint32_t widthOffset = 3;
+        uint32_t heightOffset = 4;
+        for (uint32_t k = 0; k < deatiInfoCount_.front(); k++) {
+            for (uint32_t m = abilityStartIndex_.front(); m < abilityEndIndex_.front(); m++) {
+                streamInfo.detailInfo[k].format =
+                    originInfo[m + formatOffset];
+                streamInfo.detailInfo[k].dataAccuracy =
+                    originInfo[m + dataAccuracyOffset];
+                streamInfo.detailInfo[k].width =
+                    originInfo[m + widthOffset];
+                streamInfo.detailInfo[k].height =
+                    originInfo[m + heightOffset];
+                m += abilityEndIndex_.front();
+            }
+            abilityStartIndex_.pop();
+            abilityEndIndex_.pop();
+        }
+        deatiInfoCount_.pop();
+    }
+    uint32_t modeCount_ = 0;
+    std::vector<uint32_t> modeStartIndex_ = {};
+    std::vector<uint32_t> modeEndIndex_ = {};
+    std::queue<uint32_t> streamStartIndex_;
+    std::queue<uint32_t> streamEndIndex_;
+    std::queue<uint32_t> streamTypeCount_;
+    std::queue<uint32_t> deatiInfoCount_;
+    std::queue<uint32_t> abilityEndIndex_;
+    std::queue<uint32_t> abilityStartIndex_;
+};
 } // namespace CameraStandard
 } // namespace OHOS
 #endif // CAMERA_ERROR_CODE_H
\ No newline at end of file
diff --git a/interfaces/inner_api/native/camera/include/input/camera_manager.h b/interfaces/inner_api/native/camera/include/input/camera_manager.h
index 1b2541b78..f31a80297 100644
--- a/interfaces/inner_api/native/camera/include/input/camera_manager.h
+++ b/interfaces/inner_api/native/camera/include/input/camera_manager.h
@@ -37,6 +37,7 @@
 #include "istream_common.h"
 #include "istream_repeat.h"
 #include "output/camera_output_capability.h"
+#include "output/depth_data_output.h"
 #include "output/metadata_output.h"
 #include "output/photo_output.h"
 #include "output/preview_output.h"
@@ -92,7 +93,8 @@ typedef enum OutputCapStreamType {
     STILL_CAPTURE = 2,
     POST_VIEW = 3,
     ANALYZE = 4,
-    CUSTOM = 5
+    CUSTOM = 5,
+    DEPTH = 6
 } OutputCapStreamType;
 
 class CameraManagerCallback {
@@ -438,6 +440,26 @@ public:
      */
     int CreateMetadataOutput(sptr<MetadataOutput>& pMetadataOutput);
 
+    /**
+     * @brief Create depth output instance.
+     *
+     * @param depthProfile depth profile.
+     * @param surface depth data buffer surface.
+     * @return pointer to depth data output instance.
+     */
+    sptr<DepthDataOutput> CreateDepthDataOutput(DepthProfile& depthProfile, sptr<IBufferProducer> &surface);
+
+    /**
+     * @brief Create depth output instance.
+     *
+     * @param depthProfile depth profile.
+     * @param surface depth data buffer surface.
+     * @param pDepthDataOutput pointer to depth data output instance.
+     * @return Returns error code.
+     */
+    int CreateDepthDataOutput(DepthProfile& depthProfile, sptr<IBufferProducer> &surface,
+                              sptr<DepthDataOutput>* pDepthDataOutput);
+
     /**
      * @brief Set camera manager callback.
      *
@@ -651,7 +673,7 @@ public:
         std::lock_guard<std::mutex> lock(cameraDeviceAbilitySupportMapMutex_);
         cameraDeviceAbilitySupportMap_.clear();
     }
-    
+
     void GetCameraOutputStatus(int32_t pid, int32_t &status);
 
 protected:
@@ -697,10 +719,19 @@ private:
         uint32_t streamIndex, ExtendInfo extendInfo);
     static const std::unordered_map<camera_format_t, CameraFormat> metaToFwCameraFormat_;
     static const std::unordered_map<CameraFormat, camera_format_t> fwToMetaCameraFormat_;
+    static const std::unordered_map<DepthDataAccuracyType, DepthDataAccuracy> metaToFwDepthDataAccuracy_;
     void ParseExtendCapability(
         ProfilesWrapper& profilesWrapper, const int32_t modeName, const camera_metadata_item_t& item);
     void ParseBasicCapability(ProfilesWrapper& profilesWrapper, std::shared_ptr<OHOS::Camera::CameraMetadata> metadata,
         const camera_metadata_item_t& item);
+    void CreateDepthProfile4StreamType(OutputCapStreamType streamType, uint32_t modeIndex,
+        uint32_t streamIndex, ExtendInfo extendInfo);
+    void CreateProfile4StreamType(OutputCapStreamType streamType, uint32_t modeIndex,
+        uint32_t streamIndex, ExtendInfo extendInfo);
+    void ParseExtendCapability(const int32_t modeName, const camera_metadata_item_t& item);
+    void ParseBasicCapability(
+        std::shared_ptr<OHOS::Camera::CameraMetadata> metadata, const camera_metadata_item_t& item);
+    void ParseDepthCapability(const int32_t modeName, const camera_metadata_item_t& item);
     void AlignVideoFpsProfile(std::vector<sptr<CameraDevice>>& cameraObjList);
     void SetProfile(std::vector<sptr<CameraDevice>>& cameraObjList);
     SceneMode GetFallbackConfigMode(SceneMode profileMode, ProfilesWrapper& profilesWrapper);
@@ -788,6 +819,7 @@ private:
 
     std::map<std::string, std::vector<Profile>> modePhotoProfiles_ = {};
     std::map<std::string, std::vector<Profile>> modePreviewProfiles_ = {};
+    std::vector<DepthProfile> depthProfiles_ = {};
 
     sptr<CameraInput> cameraInput_;
     TorchMode torchMode_ = TorchMode::TORCH_MODE_OFF;
diff --git a/interfaces/inner_api/native/camera/include/output/camera_output_capability.h b/interfaces/inner_api/native/camera/include/output/camera_output_capability.h
index ccf07c0d4..1ea742b17 100644
--- a/interfaces/inner_api/native/camera/include/output/camera_output_capability.h
+++ b/interfaces/inner_api/native/camera/include/output/camera_output_capability.h
@@ -50,7 +50,15 @@ enum CameraFormat {
     CAMERA_FORMAT_YUV_422_YUYV = 1005,
     CAMERA_FORMAT_JPEG = 2000,
     CAMERA_FORMAT_YCBCR_P010 = 2001,
-    CAMERA_FORMAT_YCRCB_P010 = 2002
+    CAMERA_FORMAT_YCRCB_P010 = 2002,
+    CAMERA_FORMAT_DEPTH_16 = 3000,
+    CAMERA_FORMAT_DEPTH_32 = 3001,
+};
+
+enum DepthDataAccuracy {
+    DEPTH_DATA_ACCURACY_INVALID = -1,
+    DEPTH_DATA_ACCURACY_RELATIVE = 0,
+    DEPTH_DATA_ACCURACY_ABSOLUTE = 1,
 };
 
 enum ProfileSizeRatio : int32_t {
@@ -149,6 +157,21 @@ public:
     void DumpVideoProfile(std::string name) const;
 };
 
+class DepthProfile : public Profile {
+public:
+    DepthProfile(CameraFormat format, DepthDataAccuracy dataAccuracy, Size size);
+    DepthProfile() = default;
+    virtual ~DepthProfile() = default;
+    DepthProfile& operator=(const DepthProfile& rhs)
+    {
+        Profile::operator=(rhs);
+        this->dataAccuracy_ = rhs.dataAccuracy_;
+        return *this;
+    }
+    DepthDataAccuracy GetDataAccuracy();
+    DepthDataAccuracy dataAccuracy_;
+};
+
 float GetTargetRatio(ProfileSizeRatio sizeRatio, float unspecifiedValue);
 bool IsProfileSameRatio(Profile& srcProfile, ProfileSizeRatio sizeRatio, float unspecifiedValue);
 
