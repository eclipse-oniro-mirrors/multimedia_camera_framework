diff --git a/services/camera_service/include/hcamera_device.h b/services/camera_service/include/hcamera_device.h
index 7be033af..4a68c74f 100644
--- a/services/camera_service/include/hcamera_device.h
+++ b/services/camera_service/include/hcamera_device.h
@@ -36,6 +36,7 @@
 
 namespace OHOS {
 namespace CameraStandard {
+constexpr int32_t HDI_STREAM_ID_INIT = 1;
 using OHOS::HDI::Camera::V1_0::CaptureEndedInfo;
 using OHOS::HDI::Camera::V1_0::CaptureErrorInfo;
 using OHOS::HDI::Camera::V1_0::ICameraDeviceCallback;
@@ -94,6 +95,16 @@ public:
         std::lock_guard<std::mutex> lock(proxyStreamOperatorCallbackMutex_);
         return proxyStreamOperatorCallback_.promote();
     }
+
+    inline int32_t GenerateHdiStreamId()
+    {
+        return hdiStreamIdGenerator_.fetch_add(1);
+    }
+
+    inline void ResetHdiStreamId()
+    {
+        hdiStreamIdGenerator_ = HDI_STREAM_ID_INIT;
+    }
     
     void NotifyCameraSessionStatus(bool running);
 
@@ -134,6 +145,7 @@ private:
     uint32_t zoomTimerId_;
     std::atomic<bool> inPrepareZoom_;
 
+    std::atomic<int32_t> hdiStreamIdGenerator_ = HDI_STREAM_ID_INIT;
     void UpdateDeviceOpenLifeCycleSettings(std::shared_ptr<OHOS::Camera::CameraMetadata> changedSettings);
     void ResetDeviceOpenLifeCycleSettings();
 
diff --git a/services/camera_service/include/hcapture_session.h b/services/camera_service/include/hcapture_session.h
index 853ee0af..179cf16e 100644
--- a/services/camera_service/include/hcapture_session.h
+++ b/services/camera_service/include/hcapture_session.h
@@ -92,6 +92,7 @@ public:
     bool AddStream(sptr<HStreamCommon> stream);
     bool RemoveStream(sptr<HStreamCommon> stream);
     sptr<HStreamCommon> GetStream(int32_t streamId);
+    sptr<HStreamCommon> GetHdiStream(int32_t streamId);
     void Clear();
     size_t Size();
 
@@ -119,6 +120,8 @@ public:
 
     virtual const sptr<HStreamCommon> GetStreamByStreamID(int32_t streamId) = 0;
 
+    virtual const sptr<HStreamCommon> GetHdiStreamByStreamID(int32_t streamId) = 0;
+
 private:
     std::mutex cbMutex_;
 };
@@ -163,6 +166,7 @@ public:
 
     int32_t OperatePermissionCheck(uint32_t interfaceCode) override;
     const sptr<HStreamCommon> GetStreamByStreamID(int32_t streamId) override;
+    const sptr<HStreamCommon> GetHdiStreamByStreamID(int32_t streamId) override;
     int32_t SetFeatureMode(int32_t featureMode) override;
 
 private:
diff --git a/services/camera_service/include/hstream_common.h b/services/camera_service/include/hstream_common.h
index cd01cc32..8688b657 100644
--- a/services/camera_service/include/hstream_common.h
+++ b/services/camera_service/include/hstream_common.h
@@ -39,7 +39,7 @@ constexpr int32_t STREAM_ID_UNSET = 0;
 
 class HStreamCommon : virtual public RefBase {
 public:
-    HStreamCommon(
+    explicit HStreamCommon(
         StreamType streamType, sptr<OHOS::IBufferProducer> producer, int32_t format, int32_t width, int32_t height);
     virtual ~HStreamCommon();
     virtual int32_t LinkInput(sptr<OHOS::HDI::Camera::V1_0::IStreamOperator> streamOperator,
@@ -54,9 +54,9 @@ public:
 
     virtual int32_t GetPreparedCaptureId() final;
 
-    inline int32_t GetStreamId()
+    inline int32_t GetFwkStreamId()
     {
-        return streamId_;
+        return fwkStreamId_;
     }
 
     inline StreamType GetStreamType()
@@ -64,13 +64,23 @@ public:
         return streamType_;
     }
 
+    inline void SetHdiStreamId(int32_t hdiStreamId)
+    {
+        hdiStreamId_ = hdiStreamId;
+    }
+
+    inline int32_t GetHdiStreamId()
+    {
+        return hdiStreamId_;
+    }
+
     int32_t format_;
     int32_t width_;
     int32_t height_;
-    int32_t dataSpace_;
+    int32_t dataSpace_ = 0;
     sptr<OHOS::IBufferProducer> producer_;
 
-    std::shared_ptr<OHOS::Camera::CameraMetadata> cameraAbility_;
+    std::shared_ptr<OHOS::Camera::CameraMetadata> cameraAbility_ = nullptr;
 
 protected:
     /*
@@ -96,12 +106,13 @@ protected:
     uint32_t callerToken_;
 
     std::mutex streamOperatorLock_;
-    sptr<OHOS::HDI::Camera::V1_0::IStreamOperator> streamOperator_;
+    sptr<OHOS::HDI::Camera::V1_0::IStreamOperator> streamOperator_ = nullptr;
 
 private:
     StreamType streamType_;
-    int32_t streamId_;
-    int32_t curCaptureID_;
+    int32_t fwkStreamId_ = STREAM_ID_UNSET;
+    int32_t hdiStreamId_ = STREAM_ID_UNSET;
+    int32_t curCaptureID_ = CAPTURE_ID_UNSET;
 };
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/services/camera_service/src/hcamera_device.cpp b/services/camera_service/src/hcamera_device.cpp
index 0efabed7..1b25dfca 100644
--- a/services/camera_service/src/hcamera_device.cpp
+++ b/services/camera_service/src/hcamera_device.cpp
@@ -252,6 +252,7 @@ int32_t HCameraDevice::OpenDevice()
     if (errorCode != CAMERA_OK) {
         MEDIA_ERR_LOG("HCameraDevice::OpenDevice Failed to open camera");
     } else {
+        ResetHdiStreamId();
         isOpenedCameraDevice_.store(true);
         HCameraDeviceManager::GetInstance()->AddDevice(IPCSkeleton::GetCallingPid(), this);
     }
@@ -822,6 +823,8 @@ int32_t HCameraDevice::ReleaseStreams(std::vector<int32_t>& releaseStreamIds)
     CAMERA_SYNC_TRACE;
     std::lock_guard<std::mutex> lock(opMutex_);
     if (streamOperator_ != nullptr && !releaseStreamIds.empty()) {
+        MEDIA_INFO_LOG("HCameraDevice::ReleaseStreams %{public}s",
+        Container2String(releaseStreamIds.begin(), releaseStreamIds.end()).c_str());
         int32_t rc = streamOperator_->ReleaseStreams(releaseStreamIds);
         if (rc != HDI::Camera::V1_0::NO_ERROR) {
             MEDIA_ERR_LOG("HCameraDevice::ClearStreamOperator ReleaseStreams fail, error Code:%{public}d", rc);
diff --git a/services/camera_service/src/hcamera_host_manager.cpp b/services/camera_service/src/hcamera_host_manager.cpp
index 2a58e0b5..3688c4f4 100644
--- a/services/camera_service/src/hcamera_host_manager.cpp
+++ b/services/camera_service/src/hcamera_host_manager.cpp
@@ -87,6 +87,8 @@ public:
     int32_t SetTorchLevel(float level);
     int32_t Prelaunch(sptr<HCameraRestoreParam> cameraRestoreParam);
     int32_t PreCameraSwitch(const std::string& cameraId);
+    bool IsNeedRestore(int32_t opMode,
+    std::shared_ptr<OHOS::Camera::CameraMetadata> cameraSettings, std::string& cameraId);
     void NotifyDeviceStateChangeInfo(int notifyType, int deviceState);
 
     // CameraHostCallbackStub
@@ -342,7 +344,7 @@ int32_t HCameraHostManager::CameraHostInfo::SetTorchLevel(float level)
 
 int32_t HCameraHostManager::CameraHostInfo::Prelaunch(sptr<HCameraRestoreParam> cameraRestoreParam)
 {
-    std::lock_guard<std::mutex> lock(mutex_);
+    //std::lock_guard<std::mutex> lock(mutex_);
     if (cameraHostProxy_ == nullptr) {
         MEDIA_ERR_LOG("CameraHostInfo::Prelaunch cameraHostProxy_ is null");
         return CAMERA_UNKNOWN_ERROR;
@@ -358,16 +360,21 @@ int32_t HCameraHostManager::CameraHostInfo::Prelaunch(sptr<HCameraRestoreParam>
     OHOS::HDI::Camera::V1_1::PrelaunchConfig prelaunchConfig;
     std::vector<uint8_t> settings;
     prelaunchConfig.cameraId = cameraRestoreParam->GetCameraId();
-    prelaunchConfig.setting = {};
     prelaunchConfig.streamInfos_V1_1 = cameraRestoreParam->GetStreamInfo();
     DumpMetadata(cameraRestoreParam->GetSetting());
     OHOS::Camera::MetadataUtils::ConvertMetadataToVec(cameraRestoreParam->GetSetting(), settings);
     prelaunchConfig.setting = settings;
     int32_t opMode = cameraRestoreParam->GetCameraOpMode();
+    bool isNeedRestore = IsNeedRestore(opMode, cameraRestoreParam->GetSetting(), prelaunchConfig.cameraId);
     CamRetCode rc;
     if (cameraHostProxyV1_2_ != nullptr && GetCameraHostVersion() > GetVersionId(1, 1)) {
-        MEDIA_DEBUG_LOG("CameraHostInfo::PrelaunchWithOpMode ICameraHost V1_2 %{public}d", opMode);
-        rc = (CamRetCode)(cameraHostProxyV1_2_->PrelaunchWithOpMode(prelaunchConfig, opMode));
+        if (isNeedRestore) {
+            MEDIA_INFO_LOG("CameraHostInfo::PrelaunchWithOpMode ICameraHost V1_2 %{public}d", opMode);
+            rc = (CamRetCode)(cameraHostProxyV1_2_->PrelaunchWithOpMode(prelaunchConfig, opMode));
+        } else {
+            MEDIA_INFO_LOG("CameraHostInfo::Prelaunch ICameraHost V1_2 %{public}d", opMode);
+            rc = (CamRetCode)(cameraHostProxyV1_2_->Prelaunch(prelaunchConfig));
+        }
     } else if (cameraHostProxyV1_1_ != nullptr && GetCameraHostVersion() == GetVersionId(1, 1)) {
         MEDIA_DEBUG_LOG("CameraHostInfo::Prelaunch ICameraHost V1_1");
         rc = (CamRetCode)(cameraHostProxyV1_1_->Prelaunch(prelaunchConfig));
@@ -381,6 +388,43 @@ int32_t HCameraHostManager::CameraHostInfo::Prelaunch(sptr<HCameraRestoreParam>
     return CAMERA_OK;
 }
 
+bool HCameraHostManager::CameraHostInfo::IsNeedRestore(int32_t opMode,
+    std::shared_ptr<OHOS::Camera::CameraMetadata> cameraSettings, std::string& cameraId) {
+    if (cameraSettings == nullptr) {
+        return false;
+    }
+    std::shared_ptr<OHOS::Camera::CameraMetadata> cameraAbility;
+    int32_t ret = GetCameraAbility(cameraId, cameraAbility);
+    if (ret != CAMERA_OK || cameraAbility == nullptr) {
+        MEDIA_ERR_LOG("CameraHostInfo::IsNeedRestore failed");
+        return false;
+    }
+    if (opMode == 0) { // 0 is normal mode
+        MEDIA_INFO_LOG("operationMode:%{public}d", opMode);
+        return true;
+    }
+    camera_metadata_item_t item;
+    ret = OHOS::Camera::FindCameraMetadataItem(cameraAbility->get(), OHOS_ABILITY_CAMERA_MODES, &item);
+    if (ret != CAM_META_SUCCESS || item.count == 0) {
+        MEDIA_ERR_LOG("Failed to find stream extend configuration in camera ability with return code %{public}d", ret);
+        ret = OHOS::Camera::FindCameraMetadataItem(cameraAbility->get(),
+            OHOS_ABILITY_STREAM_AVAILABLE_BASIC_CONFIGURATIONS, &item);
+        if (ret == CAM_META_SUCCESS && item.count != 0) {
+            MEDIA_INFO_LOG("basic config no need valid mode");
+            return true;
+        }
+        return false;
+    }
+
+    for (uint32_t i = 0; i < item.count; i++) {
+        if (opMode == item.data.u8[i]) {
+            MEDIA_DEBUG_LOG("operationMode:%{public}d found in supported streams", opMode);
+            return true;
+        }
+    }
+    MEDIA_ERR_LOG("operationMode:%{public}d not found in supported streams", opMode);
+    return false;
+}
 int32_t HCameraHostManager::CameraHostInfo::PreCameraSwitch(const std::string& cameraId)
 {
     std::lock_guard<std::mutex> lock(mutex_);
diff --git a/services/camera_service/src/hcapture_session.cpp b/services/camera_service/src/hcapture_session.cpp
index 6cb7a84c..3409ab41 100644
--- a/services/camera_service/src/hcapture_session.cpp
+++ b/services/camera_service/src/hcapture_session.cpp
@@ -246,9 +246,9 @@ int32_t HCaptureSession::AddOutputStream(sptr<HStreamCommon> stream)
         MEDIA_ERR_LOG("HCaptureSession::AddOutputStream stream is null");
         return CAMERA_INVALID_ARG;
     }
-    MEDIA_INFO_LOG("HCaptureSession::AddOutputStream streamId:%{public}d streamType:%{public}d", stream->GetStreamId(),
+    MEDIA_INFO_LOG("HCaptureSession::AddOutputStream streamId:%{public}d streamType:%{public}d", stream->GetFwkStreamId(),
         stream->GetStreamType());
-    if (stream->GetStreamId() == STREAM_ID_UNSET) {
+    if (stream->GetFwkStreamId() == STREAM_ID_UNSET) {
         MEDIA_ERR_LOG("HCaptureSession::AddOutputStream stream is released!");
         return CAMERA_INVALID_ARG;
     }
@@ -337,7 +337,7 @@ int32_t HCaptureSession::RemoveOutputStream(sptr<HStreamCommon> stream)
         return CAMERA_INVALID_ARG;
     }
     MEDIA_INFO_LOG("HCaptureSession::RemoveOutputStream,streamType:%{public}d, streamId:%{public}d",
-        stream->GetStreamType(), stream->GetStreamId());
+        stream->GetStreamType(), stream->GetFwkStreamId());
     bool isRemoveSuccess = streamContainer_.RemoveStream(stream);
     if (!isRemoveSuccess) {
         MEDIA_ERR_LOG("HCaptureSession::RemoveOutputStream Invalid output");
@@ -414,8 +414,12 @@ int32_t HCaptureSession::LinkInputAndOutputs()
     MEDIA_INFO_LOG("HCaptureSession::LinkInputAndOutputs allStream size:%{public}zu", allStream.size());
     for (auto& stream : allStream) {
         rc = stream->LinkInput(streamOperator, settings);
-        MEDIA_INFO_LOG("HCaptureSession::LinkInputAndOutputs streamType:%{public}d, streamId:%{public}d",
-            stream->GetStreamType(), stream->GetStreamId());
+        if(rc == CAMERA_OK){
+            stream->SetHdiStreamId(device->GenerateHdiStreamId());
+        }
+        MEDIA_INFO_LOG(
+            "HCaptureSession::LinkInputAndOutputs streamType:%{public}d, streamId:%{public}d ,hdiStreamId:%{public}d",
+            stream->GetStreamType(), stream->GetFwkStreamId(), stream->GetHdiStreamId());
         if (rc != CAMERA_OK) {
             MEDIA_ERR_LOG("HCaptureSession::LinkInputAndOutputs() Failed to link Output, %{public}d", rc);
             return rc;
@@ -434,21 +438,26 @@ int32_t HCaptureSession::UnlinkInputAndOutputs()
 {
     CAMERA_SYNC_TRACE;
     int32_t rc = CAMERA_UNKNOWN_ERROR;
-    std::vector<int32_t> streamIds;
+    std::vector<int32_t> fwkStreamIds;
+    std::vector<int32_t> hdiStreamIds;
     auto allStream = streamContainer_.GetAllStreams();
     for (auto& stream : allStream) {
-        streamIds.emplace_back(stream->GetStreamId());
+        fwkStreamIds.emplace_back(stream->GetFwkStreamId());
+        hdiStreamIds.emplace_back(stream->GetHdiStreamId());
         stream->UnlinkInput();
     }
-    MEDIA_INFO_LOG("HCaptureSession::UnlinkInputAndOutputs() streamIds size() = %{public}zu, streamIds:%{public}s",
-        streamIds.size(), Container2String(streamIds.begin(), streamIds.end()).c_str());
+    MEDIA_INFO_LOG("HCaptureSession::UnlinkInputAndOutputs() streamIds size() = %{public}zu, streamIds:%{public}s, "
+                   "hdiStreamIds:%{public}s",
+        fwkStreamIds.size(), Container2String(fwkStreamIds.begin(), fwkStreamIds.end()).c_str(),
+        Container2String(hdiStreamIds.begin(), hdiStreamIds.end()).c_str());
 
     // HDI release streams, do not clear streamContainer_
     auto cameraDevice = GetCameraDevice();
     if ((cameraDevice != nullptr)) {
-        cameraDevice->ReleaseStreams(streamIds);
+        cameraDevice->ReleaseStreams(hdiStreamIds);
         std::vector<StreamInfo_V1_1> emptyStreams;
         cameraDevice->UpdateStreams(emptyStreams);
+        cameraDevice->ResetHdiStreamId();
     }
     return rc;
 }
@@ -488,6 +497,15 @@ const sptr<HStreamCommon> HCaptureSession::GetStreamByStreamID(int32_t streamId)
     return stream;
 }
 
+const sptr<HStreamCommon> HCaptureSession::GetHdiStreamByStreamID(int32_t streamId)
+{
+    auto stream = streamContainer_.GetHdiStream(streamId);
+    if (stream == nullptr) {
+        MEDIA_ERR_LOG("HCaptureSession::GetHdiStreamByStreamID get stream fail, streamId is:%{public}d", streamId);
+    }
+    return stream;
+}
+
 void HCaptureSession::ClearSketchRepeatStream()
 {
     MEDIA_DEBUG_LOG("Enter HCaptureSession::ClearSketchRepeatStream()");
@@ -503,7 +521,7 @@ void HCaptureSession::ClearSketchRepeatStream()
             continue;
         }
         MEDIA_DEBUG_LOG(
-            "HCaptureSession::ClearSketchRepeatStream() stream id is:%{public}d", sketchStream->GetStreamId());
+            "HCaptureSession::ClearSketchRepeatStream() stream id is:%{public}d", sketchStream->GetFwkStreamId());
         RemoveOutputStream(repeatStream);
     }
     MEDIA_DEBUG_LOG("Exit HCaptureSession::ClearSketchRepeatStream()");
@@ -918,11 +936,11 @@ int32_t HCaptureSession::Stop()
                 CastStream<HStreamCapture>(item)->CancelCapture();
             } else {
                 MEDIA_ERR_LOG("HCaptureSession::Stop(), get unknow stream, streamType: %{public}d, streamId:%{public}d",
-                    item->GetStreamType(), item->GetStreamId());
+                    item->GetStreamType(), item->GetFwkStreamId());
             }
             if (errorCode != CAMERA_OK) {
                 MEDIA_ERR_LOG("HCaptureSession::Stop(), Failed to stop stream, rc: %{public}d, streamId:%{public}d",
-                    errorCode, item->GetStreamId());
+                    errorCode, item->GetFwkStreamId());
             }
         }
         if (errorCode == CAMERA_OK) {
@@ -936,18 +954,28 @@ int32_t HCaptureSession::Stop()
 void HCaptureSession::ReleaseStreams()
 {
     CAMERA_SYNC_TRACE;
-    std::vector<int32_t> streamIds;
+    std::vector<int32_t> fwkStreamIds;
+    std::vector<int32_t> hdiStreamIds;
     auto allStream = streamContainer_.GetAllStreams();
     for (auto& stream : allStream) {
-        streamIds.emplace_back(stream->GetStreamId());
+        auto fwkStreamId = stream->GetFwkStreamId();
+        if (fwkStreamId != STREAM_ID_UNSET) {
+            fwkStreamIds.emplace_back(fwkStreamId);
+        }
+        auto hdiStreamId = stream->GetHdiStreamId();
+        if (hdiStreamId != STREAM_ID_UNSET) {
+            hdiStreamIds.emplace_back(hdiStreamId);
+        }
         stream->ReleaseStream(true);
     }
     streamContainer_.Clear();
-    MEDIA_INFO_LOG("HCaptureSession::ReleaseStreams() streamIds size() = %{public}zu, values:%{public}s",
-        streamIds.size(), Container2String(streamIds.begin(), streamIds.end()).c_str());
+    MEDIA_INFO_LOG("HCaptureSession::ReleaseStreams() streamIds size() = %{public}zu, fwkStreamIds:%{public}s, "
+                   "hdiStreamIds:%{public}s,",
+        fwkStreamIds.size(), Container2String(fwkStreamIds.begin(), fwkStreamIds.end()).c_str(),
+        Container2String(hdiStreamIds.begin(), hdiStreamIds.end()).c_str());
     auto cameraDevice = GetCameraDevice();
-    if ((cameraDevice != nullptr) && !streamIds.empty()) {
-        cameraDevice->ReleaseStreams(streamIds);
+    if ((cameraDevice != nullptr) && !hdiStreamIds.empty()) {
+        cameraDevice->ReleaseStreams(hdiStreamIds);
     }
 }
 
@@ -1164,7 +1192,7 @@ int32_t StreamOperatorCallback::OnCaptureStarted(int32_t captureId, const std::v
         Container2String(streamIds.begin(), streamIds.end()).c_str());
     std::lock_guard<std::mutex> lock(cbMutex_);
     for (auto& streamId : streamIds) {
-        sptr<HStreamCommon> curStream = GetStreamByStreamID(streamId);
+        sptr<HStreamCommon> curStream = GetHdiStreamByStreamID(streamId);
         if (curStream == nullptr) {
             MEDIA_ERR_LOG("StreamOperatorCallback::OnCaptureStarted StreamId: %{public}d not found", streamId);
             return CAMERA_INVALID_ARG;
@@ -1186,7 +1214,7 @@ int32_t StreamOperatorCallback::OnCaptureStarted_V1_2(
     MEDIA_INFO_LOG("StreamOperatorCallback::OnCaptureStarted_V1_2 captureId:%{public}d", captureId);
     std::lock_guard<std::mutex> lock(cbMutex_);
     for (auto& captureInfo : infos) {
-        sptr<HStreamCommon> curStream = GetStreamByStreamID(captureInfo.streamId_);
+        sptr<HStreamCommon> curStream = GetHdiStreamByStreamID(captureInfo.streamId_);
         if (curStream == nullptr) {
             MEDIA_ERR_LOG("StreamOperatorCallback::OnCaptureStarted_V1_2 StreamId: %{public}d not found."
                           " exposureTime: %{public}u",
@@ -1207,7 +1235,7 @@ int32_t StreamOperatorCallback::OnCaptureEnded(int32_t captureId, const std::vec
     MEDIA_INFO_LOG("StreamOperatorCallback::OnCaptureEnded");
     std::lock_guard<std::mutex> lock(cbMutex_);
     for (auto& captureInfo : infos) {
-        sptr<HStreamCommon> curStream = GetStreamByStreamID(captureInfo.streamId_);
+        sptr<HStreamCommon> curStream = GetHdiStreamByStreamID(captureInfo.streamId_);
         if (curStream == nullptr) {
             MEDIA_ERR_LOG("StreamOperatorCallback::OnCaptureEnded StreamId: %{public}d not found."
                           " Framecount: %{public}d",
@@ -1227,7 +1255,7 @@ int32_t StreamOperatorCallback::OnCaptureError(int32_t captureId, const std::vec
     MEDIA_INFO_LOG("StreamOperatorCallback::OnCaptureError");
     std::lock_guard<std::mutex> lock(cbMutex_);
     for (auto& errInfo : infos) {
-        sptr<HStreamCommon> curStream = GetStreamByStreamID(errInfo.streamId_);
+        sptr<HStreamCommon> curStream = GetHdiStreamByStreamID(errInfo.streamId_);
         if (curStream == nullptr) {
             MEDIA_ERR_LOG("StreamOperatorCallback::OnCaptureError StreamId: %{public}d not found."
                           " Error: %{public}d",
@@ -1248,7 +1276,7 @@ int32_t StreamOperatorCallback::OnFrameShutter(
     MEDIA_INFO_LOG("StreamOperatorCallback::OnFrameShutter");
     std::lock_guard<std::mutex> lock(cbMutex_);
     for (auto& streamId : streamIds) {
-        sptr<HStreamCommon> curStream = GetStreamByStreamID(streamId);
+        sptr<HStreamCommon> curStream = GetHdiStreamByStreamID(streamId);
         if ((curStream != nullptr) && (curStream->GetStreamType() == StreamType::CAPTURE)) {
             CastStream<HStreamCapture>(curStream)->OnFrameShutter(captureId, timestamp);
         } else {
@@ -1265,7 +1293,7 @@ int32_t StreamOperatorCallback::OnFrameShutterEnd(
     MEDIA_DEBUG_LOG("StreamOperatorCallback::OnFrameShutterEnd");
     std::lock_guard<std::mutex> lock(cbMutex_);
     for (auto& streamId : streamIds) {
-        sptr<HStreamCommon> curStream = GetStreamByStreamID(streamId);
+        sptr<HStreamCommon> curStream = GetHdiStreamByStreamID(streamId);
         if ((curStream != nullptr) && (curStream->GetStreamType() == StreamType::CAPTURE)) {
             CastStream<HStreamCapture>(curStream)->OnFrameShutterEnd(captureId, timestamp);
         } else {
@@ -1282,7 +1310,7 @@ int32_t StreamOperatorCallback::OnCaptureReady(
     MEDIA_DEBUG_LOG("StreamOperatorCallback::OnCaptureReady");
     std::lock_guard<std::mutex> lock(cbMutex_);
     for (auto& streamId : streamIds) {
-        sptr<HStreamCommon> curStream = GetStreamByStreamID(streamId);
+        sptr<HStreamCommon> curStream = GetHdiStreamByStreamID(streamId);
         if ((curStream != nullptr) && (curStream->GetStreamType() == StreamType::CAPTURE)) {
             CastStream<HStreamCapture>(curStream)->OnCaptureReady(captureId, timestamp);
         } else {
@@ -1357,7 +1385,20 @@ sptr<HStreamCommon> StreamContainer::GetStream(int32_t streamId)
     std::lock_guard<std::mutex> lock(streamsLock_);
     for (auto& pair : streams_) {
         for (auto& stream : pair.second) {
-            if (stream->GetStreamId() == streamId) {
+            if (stream->GetFwkStreamId() == streamId) {
+                return stream;
+            }
+        }
+    }
+    return nullptr;
+}
+
+sptr<HStreamCommon> StreamContainer::GetHdiStream(int32_t streamId)
+{
+    std::lock_guard<std::mutex> lock(streamsLock_);
+    for (auto& pair : streams_) {
+        for (auto& stream : pair.second) {
+            if (stream->GetHdiStreamId() == streamId) {
                 return stream;
             }
         }
@@ -1387,7 +1428,7 @@ std::list<sptr<HStreamCommon>> StreamContainer::GetStreams(const StreamType stre
     std::list<sptr<HStreamCommon>> totalOrderedStreams;
     for (auto& stream : streams_[streamType]) {
         auto insertPos = std::find_if(totalOrderedStreams.begin(), totalOrderedStreams.end(),
-            [&stream](auto& it) { return stream->GetStreamId() <= it->GetStreamId(); });
+            [&stream](auto& it) { return stream->GetFwkStreamId() <= it->GetFwkStreamId(); });
         totalOrderedStreams.emplace(insertPos, stream);
     }
     return totalOrderedStreams;
@@ -1400,7 +1441,7 @@ std::list<sptr<HStreamCommon>> StreamContainer::GetAllStreams()
     for (auto& pair : streams_) {
         for (auto& stream : pair.second) {
             auto insertPos = std::find_if(totalOrderedStreams.begin(), totalOrderedStreams.end(),
-                [&stream](auto& it) { return stream->GetStreamId() <= it->GetStreamId(); });
+                [&stream](auto& it) { return stream->GetFwkStreamId() <= it->GetFwkStreamId(); });
             totalOrderedStreams.emplace(insertPos, stream);
         }
     }
diff --git a/services/camera_service/src/hstream_capture.cpp b/services/camera_service/src/hstream_capture.cpp
index 4961d6ef..3214793f 100644
--- a/services/camera_service/src/hstream_capture.cpp
+++ b/services/camera_service/src/hstream_capture.cpp
@@ -33,7 +33,7 @@ HStreamCapture::HStreamCapture(sptr<OHOS::IBufferProducer> producer, int32_t for
 {
     MEDIA_INFO_LOG(
         "HStreamCapture::HStreamCapture construct, format:%{public}d size:%{public}dx%{public}d streamId:%{public}d",
-        format, width, height, GetStreamId());
+        format, width, height, GetFwkStreamId());
     thumbnailSwitch_ = 0;
     modeName_ = 0;
     deferredPhotoSwitch_ = 0;
@@ -44,13 +44,13 @@ HStreamCapture::~HStreamCapture()
 {
     MEDIA_INFO_LOG(
         "HStreamCapture::~HStreamCapture deconstruct, format:%{public}d size:%{public}dx%{public}d streamId:%{public}d",
-        format_, width_, height_, GetStreamId());
+        format_, width_, height_, GetFwkStreamId());
 }
 
 int32_t HStreamCapture::LinkInput(sptr<OHOS::HDI::Camera::V1_0::IStreamOperator> streamOperator,
     std::shared_ptr<OHOS::Camera::CameraMetadata> cameraAbility)
 {
-    MEDIA_INFO_LOG("HStreamCapture::LinkInput streamId:%{public}d", GetStreamId());
+    MEDIA_INFO_LOG("HStreamCapture::LinkInput streamId:%{public}d", GetFwkStreamId());
     return HStreamCommon::LinkInput(streamOperator, cameraAbility);
 }
 
@@ -103,7 +103,7 @@ int32_t HStreamCapture::DeferImageDeliveryFor(int32_t type)
 int32_t HStreamCapture::Capture(const std::shared_ptr<OHOS::Camera::CameraMetadata>& captureSettings)
 {
     CAMERA_SYNC_TRACE;
-    MEDIA_INFO_LOG("HStreamCapture::Capture Entry, streamId:%{public}d", GetStreamId());
+    MEDIA_INFO_LOG("HStreamCapture::Capture Entry, streamId:%{public}d", GetFwkStreamId());
     auto streamOperator = GetStreamOperator();
     if (streamOperator == nullptr) {
         return CAMERA_INVALID_STATE;
@@ -127,7 +127,7 @@ int32_t HStreamCapture::Capture(const std::shared_ptr<OHOS::Camera::CameraMetada
         return ret;
     }
     CaptureInfo captureInfoPhoto;
-    captureInfoPhoto.streamIds_ = { GetStreamId() };
+    captureInfoPhoto.streamIds_ = { GetHdiStreamId() };
     if (!OHOS::Camera::GetCameraMetadataItemCount(captureSettings->get())) {
         std::lock_guard<std::mutex> lock(cameraAbilityLock_);
         OHOS::Camera::MetadataUtils::ConvertMetadataToVec(cameraAbility_, captureInfoPhoto.captureSetting_);
diff --git a/services/camera_service/src/hstream_common.cpp b/services/camera_service/src/hstream_common.cpp
index cfa9410a..2ecb5fd5 100644
--- a/services/camera_service/src/hstream_common.cpp
+++ b/services/camera_service/src/hstream_common.cpp
@@ -52,37 +52,18 @@ namespace {
 static const int32_t STREAMID_BEGIN = 1;
 static const int32_t CAPTUREID_BEGIN = 1;
 static int32_t g_currentStreamId = STREAMID_BEGIN;
-static std::set<int32_t> g_freeStreamIdQueue;
-static std::mutex g_freeStreamQueueMutex;
 
 static std::atomic_int32_t g_currentCaptureId = CAPTUREID_BEGIN;
 
 static int32_t GenerateStreamId()
 {
-    std::lock_guard<std::mutex> lock(g_freeStreamQueueMutex);
-    int newId;
-    if (g_freeStreamIdQueue.empty()) {
-        newId = g_currentStreamId++;
-        if (newId == INT32_MAX) {
-            g_currentStreamId = STREAMID_BEGIN;
-        }
-        return newId;
+    int newId = g_currentStreamId++;
+    if (newId == INT32_MAX) {
+        g_currentStreamId = STREAMID_BEGIN;
     }
-    auto firstIt = g_freeStreamIdQueue.begin();
-    newId = *firstIt;
-    g_freeStreamIdQueue.erase(firstIt);
     return newId;
 }
 
-static void FreeStreamId(int32_t streamId)
-{
-    if (streamId == STREAM_ID_UNSET) {
-        return;
-    }
-    std::lock_guard<std::mutex> lock(g_freeStreamQueueMutex);
-    g_freeStreamIdQueue.emplace(streamId);
-}
-
 static int32_t GenerateCaptureId()
 {
     int32_t newId = g_currentCaptureId++;
@@ -95,28 +76,19 @@ static int32_t GenerateCaptureId()
 
 HStreamCommon::HStreamCommon(
     StreamType streamType, sptr<OHOS::IBufferProducer> producer, int32_t format, int32_t width, int32_t height)
+    : format_(format), width_(width), height_(height), producer_(producer), streamType_(streamType)
 {
     MEDIA_DEBUG_LOG("Enter Into HStreamCommon::HStreamCommon");
     callerToken_ = IPCSkeleton::GetCallingTokenID();
-    streamId_ = streamType == StreamType::METADATA ? STREAM_ID_UNSET : GenerateStreamId();
-    curCaptureID_ = CAPTURE_ID_UNSET;
-    streamOperator_ = nullptr;
-    cameraAbility_ = nullptr;
-    producer_ = producer;
-    width_ = width;
-    height_ = height;
-    dataSpace_ = 0;
-    format_ = format;
-    streamType_ = streamType;
-    MEDIA_DEBUG_LOG("HStreamCommon Create streamId_ is %{public}d, streamType is:%{public}d", streamId_, streamType_);
+    fwkStreamId_ = streamType == StreamType::METADATA ? STREAM_ID_UNSET : GenerateStreamId();
+    MEDIA_DEBUG_LOG(
+        "HStreamCommon Create streamId_ is %{public}d, streamType is:%{public}d", fwkStreamId_, streamType_);
 }
 
 HStreamCommon::~HStreamCommon()
 {
     MEDIA_DEBUG_LOG("Enter Into HStreamCommon::~HStreamCommon streamId is:%{public}d, streamType is:%{public}d",
-        streamId_, streamType_);
-    FreeStreamId(streamId_);
-    streamId_ = STREAM_ID_UNSET;
+        fwkStreamId_, streamType_);
 }
 
 void HStreamCommon::SetColorSpace(ColorSpace colorSpace)
@@ -150,17 +122,20 @@ int32_t HStreamCommon::LinkInput(sptr<OHOS::HDI::Camera::V1_0::IStreamOperator>
 
 int32_t HStreamCommon::UnlinkInput()
 {
-    MEDIA_INFO_LOG("HStreamCommon::UnlinkInput streamType:%{public}d, streamId:%{public}d", streamType_, streamId_);
+    MEDIA_INFO_LOG("HStreamCommon::UnlinkInput streamType:%{public}d, streamId:%{public}d, hidStreamId:%{public}d",
+        streamType_, fwkStreamId_, hdiStreamId_);
     StopStream();
     SetStreamOperator(nullptr);
+    hdiStreamId_ = STREAM_ID_UNSET;
     return CAMERA_OK;
 }
 
 int32_t HStreamCommon::StopStream()
 {
     CAMERA_SYNC_TRACE;
-    MEDIA_INFO_LOG("HStreamCommon::StopStream streamType:%{public}d, streamId:%{public}d, captureId:%{public}d",
-        streamType_, streamId_, curCaptureID_);
+    MEDIA_INFO_LOG("HStreamCommon::StopStream streamType:%{public}d, streamId:%{public}d, hdiStreamId:%{public}d, "
+                   "captureId:%{public}d",
+        streamType_, fwkStreamId_, hdiStreamId_, curCaptureID_);
     auto streamOperator = GetStreamOperator();
     if (streamOperator == nullptr) {
         MEDIA_DEBUG_LOG("HStreamCommon::StopStream streamOperator is nullptr");
@@ -204,7 +179,7 @@ void HStreamCommon::SetStreamInfo(StreamInfo_V1_1 &streamInfo)
         MEDIA_ERR_LOG("HStreamCommon::SetStreamInfo find format error, pixelFormat use default format");
     }
     MEDIA_INFO_LOG("HStreamCommon::SetStreamInfo pixelFormat is %{public}d", pixelFormat);
-    streamInfo.v1_0.streamId_ = streamId_;
+    streamInfo.v1_0.streamId_ = hdiStreamId_;
     streamInfo.v1_0.width_ = width_;
     streamInfo.v1_0.height_ = height_;
     streamInfo.v1_0.format_ = pixelFormat;
@@ -226,18 +201,18 @@ void HStreamCommon::SetStreamInfo(StreamInfo_V1_1 &streamInfo)
 
 int32_t HStreamCommon::ReleaseStream(bool isDelay)
 {
-    MEDIA_INFO_LOG(
-        "Enter Into HStreamCommon::Release streamId is:%{public}d, streamType is:%{public}d, isDelay:%{public}d",
-        streamId_, streamType_, isDelay);
-    StopStream();
-    if (!isDelay && streamId_ != STREAM_ID_UNSET) {
-        auto streamOperator = GetStreamOperator();
-        if (streamOperator != nullptr) {
-            streamOperator->ReleaseStreams({ streamId_ });
-        }
-    }
-    FreeStreamId(streamId_);
-    streamId_ = STREAM_ID_UNSET;
+    MEDIA_INFO_LOG("Enter Into HStreamCommon::Release streamId is:%{public}d, hdiStreamId is:%{public}d, streamType "
+                   "is:%{public}d, isDelay:%{public}d",
+        fwkStreamId_, hdiStreamId_, streamType_, isDelay);
+     StopStream();
+    if (!isDelay && hdiStreamId_ != STREAM_ID_UNSET) {
+         auto streamOperator = GetStreamOperator();
+         if (streamOperator != nullptr) {
+            streamOperator->ReleaseStreams({ hdiStreamId_ });
+         }
+     }
+    fwkStreamId_ = STREAM_ID_UNSET;
+    hdiStreamId_ = STREAM_ID_UNSET;
     SetStreamOperator(nullptr);
     {
         std::lock_guard<std::mutex> lock(cameraAbilityLock_);
diff --git a/services/camera_service/src/hstream_metadata.cpp b/services/camera_service/src/hstream_metadata.cpp
index e5ce7126..085d7f4b 100644
--- a/services/camera_service/src/hstream_metadata.cpp
+++ b/services/camera_service/src/hstream_metadata.cpp
@@ -75,7 +75,7 @@ int32_t HStreamMetadata::Start()
         OHOS::Camera::MetadataUtils::ConvertMetadataToVec(cameraAbility_, ability);
     }
     CaptureInfo captureInfo;
-    captureInfo.streamIds_ = { GetStreamId() };
+    captureInfo.streamIds_ = { GetHdiStreamId() };
     captureInfo.captureSetting_ = ability;
     captureInfo.enableShutterCallback_ = false;
     MEDIA_INFO_LOG("HStreamMetadata::Start Starting with capture ID: %{public}d", preparedCaptureId);
diff --git a/services/camera_service/src/hstream_repeat.cpp b/services/camera_service/src/hstream_repeat.cpp
index 7251d53c..13f44190 100644
--- a/services/camera_service/src/hstream_repeat.cpp
+++ b/services/camera_service/src/hstream_repeat.cpp
@@ -42,24 +42,24 @@ HStreamRepeat::HStreamRepeat(
 {
     MEDIA_INFO_LOG("HStreamRepeat::HStreamRepeat construct, format:%{public}d size:%{public}dx%{public}d "
                    "repeatType:%{public}d, streamId:%{public}d",
-        format, width, height, type, GetStreamId());
+        format, width, height, type, GetFwkStreamId());
 }
 
 HStreamRepeat::~HStreamRepeat()
 {
-    MEDIA_INFO_LOG("HStreamRepeat::~HStreamRepeat deconstruct, format:%{public}d size:%{public}dx%{public}d "
-                   "repeatType:%{public}d, streamId:%{public}d",
-        format_, width_, height_, repeatStreamType_, GetStreamId());
+     MEDIA_INFO_LOG("HStreamRepeat::~HStreamRepeat deconstruct, format:%{public}d size:%{public}dx%{public}d "
+                   "repeatType:%{public}d, streamId:%{public}d, hdiStreamId:%{public}d",
+        format_, width_, height_, repeatStreamType_, GetFwkStreamId(), GetHdiStreamId());
 }
 
 int32_t HStreamRepeat::LinkInput(sptr<OHOS::HDI::Camera::V1_0::IStreamOperator> streamOperator,
     std::shared_ptr<OHOS::Camera::CameraMetadata> cameraAbility)
 {
     MEDIA_INFO_LOG(
-        "HStreamRepeat::LinkInput streamId:%{public}d ,repeatStreamType:%{public}d", GetStreamId(), repeatStreamType_);
+        "HStreamRepeat::LinkInput streamId:%{public}d ,repeatStreamType:%{public}d", GetFwkStreamId(), repeatStreamType_);
     int32_t ret = HStreamCommon::LinkInput(streamOperator, cameraAbility);
     if (ret != CAMERA_OK) {
-        MEDIA_ERR_LOG("HStreamRepeat::LinkInput err, streamId:%{public}d ,err:%{public}d", GetStreamId(), ret);
+        MEDIA_ERR_LOG("HStreamRepeat::LinkInput err, streamId:%{public}d ,err:%{public}d", GetFwkStreamId(), ret);
         return ret;
     }
     if (repeatStreamType_ != RepeatStreamType::VIDEO) {
@@ -187,11 +187,12 @@ int32_t HStreamRepeat::Start(std::shared_ptr<OHOS::Camera::CameraMetadata> setti
     OHOS::Camera::MetadataUtils::ConvertMetadataToVec(dynamicSetting, captureSetting);
 
     CaptureInfo captureInfo;
-    captureInfo.streamIds_ = { GetStreamId() };
+    captureInfo.streamIds_ = { GetHdiStreamId() };
     captureInfo.captureSetting_ = captureSetting;
     captureInfo.enableShutterCallback_ = false;
-    MEDIA_INFO_LOG("HStreamRepeat::Start stream:%{public}d With capture ID: %{public}d, repeatStreamType:%{public}d",
-        GetStreamId(), preparedCaptureId, repeatStreamType_);
+    MEDIA_INFO_LOG("HStreamRepeat::Start streamId:%{public}d hdiStreamId:%{public}d With capture ID: %{public}d, "
+        "repeatStreamType:%{public}d",
+        GetFwkStreamId(), GetHdiStreamId(), preparedCaptureId, repeatStreamType_);
     if (repeatStreamType_ == RepeatStreamType::VIDEO) {
         auto callingTokenId = IPCSkeleton::GetCallingTokenID();
         const std::string permissionName = "ohos.permission.CAMERA";
@@ -224,8 +225,9 @@ int32_t HStreamRepeat::Stop()
         return CAMERA_INVALID_STATE;
     }
     auto preparedCaptureId = GetPreparedCaptureId();
-    MEDIA_INFO_LOG("HStreamRepeat::Stop stream:%{public}d With capture ID: %{public}d, repeatStreamType:%{public}d",
-        GetStreamId(), preparedCaptureId, repeatStreamType_);
+    MEDIA_INFO_LOG("HStreamRepeat::Start streamId:%{public}d hdiStreamId:%{public}d With capture ID: %{public}d, "
+                   "repeatStreamType:%{public}d",
+        GetFwkStreamId(), GetHdiStreamId(), preparedCaptureId, repeatStreamType_);
     if (preparedCaptureId == CAPTURE_ID_UNSET) {
         MEDIA_ERR_LOG("HStreamRepeat::Stop, Stream not started yet");
         return CAMERA_INVALID_STATE;
@@ -346,14 +348,15 @@ int32_t HStreamRepeat::AddDeferredSurface(const sptr<OHOS::IBufferProducer>& pro
         MEDIA_ERR_LOG("HStreamRepeat::CreateAndHandleDeferredStreams(), streamOperator_ == null");
         return CAMERA_INVALID_STATE;
     }
-    MEDIA_INFO_LOG("HStreamRepeat::AttachBufferQueue start");
+    MEDIA_INFO_LOG("HStreamRepeat::AttachBufferQueue start streamId:%{public}d, hdiStreamId:%{public}d",
+        GetFwkStreamId(), GetHdiStreamId());
     sptr<BufferProducerSequenceable> bufferProducerSequenceable;
     CamRetCode rc;
     {
         std::lock_guard<std::mutex> lock(producerLock_);
         bufferProducerSequenceable = new BufferProducerSequenceable(producer_);
     }
-    rc = (CamRetCode)(streamOperator->AttachBufferQueue(GetStreamId(), bufferProducerSequenceable));
+    rc = (CamRetCode)(streamOperator->AttachBufferQueue(GetHdiStreamId(), bufferProducerSequenceable));
     if (rc != HDI::Camera::V1_0::NO_ERROR) {
         MEDIA_ERR_LOG("HStreamRepeat::AttachBufferQueue(), Failed to AttachBufferQueue %{public}d", rc);
     }
