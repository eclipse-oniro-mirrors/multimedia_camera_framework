From 28afec31932a8c21e340c19d95e329a724799ac8 Mon Sep 17 00:00:00 2001
From: h00897201 <h00897201@notesmail.huawei.com/>
Date: Thu, 28 Nov 2024 21:50:50 +0800
Subject: [PATCH] TicketNo:AR20241031409972 Description:Add Livephoto offline
 processing audio effect in camera_framework Team:OTHERS Feature or
 Bugfix:Feature Binary Source:No PrivateCode(Yes/No):No

Change-Id: If967158af78d730f134eca911222d3b74ac50260
---
 services/camera_service/BUILD.gn              |   2 +
 .../include/avcodec/audio_capturer_session.h  |   4 +
 .../include/avcodec/audio_deferred_process.h  |  63 +++++++
 .../include/avcodec/common/sample_info.h      |   3 +
 .../src/avcodec/audio_capturer_session.cpp    |  48 ++++-
 .../src/avcodec/audio_deferred_process.cpp    | 175 ++++++++++++++++++
 .../src/avcodec/audio_encoder.cpp             |   8 +-
 .../src/avcodec/avcodec_task_manager.cpp      |  10 +-
 8 files changed, 302 insertions(+), 11 deletions(-)
 create mode 100644 services/camera_service/include/avcodec/audio_deferred_process.h
 create mode 100644 services/camera_service/src/avcodec/audio_deferred_process.cpp

diff --git a/services/camera_service/BUILD.gn b/services/camera_service/BUILD.gn
index 60120fe1d..db687a5ba 100644
--- a/services/camera_service/BUILD.gn
+++ b/services/camera_service/BUILD.gn
@@ -46,6 +46,7 @@ ohos_shared_library("camera_service") {
     "src/app_manager_utils/camera_app_manager_client.cpp",
     "src/avcodec/audio_capturer_session.cpp",
     "src/avcodec/audio_encoder.cpp",
+    "src/avcodec/audio_deferred_process.cpp",
     "src/avcodec/audio_video_muxer.cpp",
     "src/avcodec/avcodec_task_manager.cpp",
     "src/avcodec/camera_server_photo_proxy.cpp",
@@ -209,6 +210,7 @@ ohos_shared_library("camera_service") {
     "drivers_interface_camera:libmap_data_sequenceable_1.0",
     "drivers_interface_camera:metadata",
     "e2fsprogs:libext2_uuid",
+    "audio_framework:offline_audio_effect",
   ]
 
   defines = []
diff --git a/services/camera_service/include/avcodec/audio_capturer_session.h b/services/camera_service/include/avcodec/audio_capturer_session.h
index cbdd30b3b..16438be23 100644
--- a/services/camera_service/include/avcodec/audio_capturer_session.h
+++ b/services/camera_service/include/avcodec/audio_capturer_session.h
@@ -20,6 +20,7 @@
 #include "blocking_queue.h"
 #include "refbase.h"
 #include "audio_record.h"
+#include "audio_deferred_process.h"
 #include <atomic>
 #include <cstdint>
 
@@ -38,6 +39,8 @@ public:
     void Stop();
     void Release();
     void GetAudioRecords(int64_t startTime, int64_t endTime, vector<sptr<AudioRecord>> &audioRecords);
+    sptr<AudioDeferredProcess> GetAudioDeferredProcess();
+    AudioChannel getMicNum();
 
 private:
     bool CreateAudioCapturer();
@@ -46,6 +49,7 @@ private:
     BlockingQueue<sptr<AudioRecord>> audioBufferQueue_;
     std::atomic<bool> startAudioCapture_ { false };
     std::unique_ptr<std::thread> audioThread_ = nullptr;
+    sptr<AudioDeferredProcess> audioDeferredProcess_ = nullptr;
 };
 } // CameraStandard
 } // OHOS
diff --git a/services/camera_service/include/avcodec/audio_deferred_process.h b/services/camera_service/include/avcodec/audio_deferred_process.h
new file mode 100644
index 000000000..087d0b8aa
--- /dev/null
+++ b/services/camera_service/include/avcodec/audio_deferred_process.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+ #ifndef AVCODEC_AUDIO_DEFERRED_PROCESS_H
+ #define AVCODEC_AUDIO_DEFERRED_PROCESS_H
+
+#include "refbase.h"
+#include "audio_capturer.h"
+#include "audio_record.h"
+#include "audio_session_manager.h"
+#include "offline_audio_effect_manager.h"
+#include <cstdint>
+#include <map>
+
+namespace OHOS {
+namespace CameraStandard {
+using namespace AudioStandard;
+class AudioDeferredProcess : public RefBase {
+public:
+    explicit AudioDeferredProcess();
+    ~AudioDeferredProcess();
+
+    int32_t ConfigOfflineAudioEffectChain(const AudioStreamInfo& inputOptions, const AudioStreamInfo& outputOptions);
+    int32_t PrepareOfflineAudioEffectChain();
+    int32_t GetMaxBufferSize(const AudioStreamInfo& inputOption, const AudioStreamInfo& outputOption);
+    int32_t GetOfflineEffectChain();
+    int32_t GetOutputSampleRate();
+    int32_t GetOutputChannelCount();
+    int32_t GetOneUnprocessedSize();
+    int32_t Process(vector<sptr<AudioRecord>>& audioRecords);
+    void Release();
+    
+    static constexpr int32_t ONE_THOUSAND = 1000;
+    static constexpr int32_t DURATION_EACH_AUDIO_FRAME = 20;
+    static constexpr int32_t PROCESS_BATCH_SIZE = 8;
+
+private:
+    std::string chainName_ = "offline_record_algo";
+    std::unique_ptr<OfflineAudioEffectManager> offlineAudioEffectManager_ = nullptr;
+    std::unique_ptr<OfflineAudioEffectChain> offlineEffectChain_ = nullptr;
+    map<sptr<AudioRecord>, bool> computedMap_;
+    uint32_t maxUnprocessedBufferSize_ = 0;
+    uint32_t maxProcessedBufferSize_ = 0;
+    AudioStreamInfo inputOptions_;
+    AudioStreamInfo outputOptions_;
+    uint32_t oneUnprocessedSize_ = 0;
+    uint32_t oneProcessedSize_ = 0;
+};
+} // CameraStandard
+} // OHOS
+#endif // AVCODEC_AUDIO_PRE_PROCESS_H
\ No newline at end of file
diff --git a/services/camera_service/include/avcodec/common/sample_info.h b/services/camera_service/include/avcodec/common/sample_info.h
index cacd59721..9a4c0362b 100644
--- a/services/camera_service/include/avcodec/common/sample_info.h
+++ b/services/camera_service/include/avcodec/common/sample_info.h
@@ -36,6 +36,7 @@ constexpr int32_t BITRATE_20M = 20 * 1000 * 1000; // 20Mbps
 constexpr int32_t BITRATE_22M = 22 * 1000 * 1000; // 22Mbps
 constexpr int32_t BITRATE_30M = 30 * 1000 * 1000; // 30Mbps
 constexpr uint32_t DEFAULT_SAMPLERATE = 48000;
+constexpr uint32_t SAMPLERATE_32000 = 32000;
 constexpr uint64_t DEFAULT_BITRATE = 48000;
 constexpr uint32_t DEFAULT_CHANNEL_COUNT = 1;
 constexpr int32_t AUDIO_ENCODE_EXPIREATION_TIME = 2;
@@ -44,6 +45,8 @@ constexpr OH_BitsPerSample SAMPLE_FORMAT = OH_BitsPerSample::SAMPLE_S16LE;
 constexpr int32_t COMPLIANCE_LEVEL = 0;
 constexpr OH_BitsPerSample BITS_PER_CODED_SAMPLE = OH_BitsPerSample::SAMPLE_S16LE;
 constexpr uint32_t DEFAULT_MAX_INPUT_SIZE = 1024 * DEFAULT_CHANNEL_COUNT * sizeof(short);
+constexpr uint32_t INPUT_SIZE_7680 = 48000 / 1000 * 4 * 20 * 2;
+constexpr uint32_t INPUT_SIZE_1280 = 32000 / 1000 * 1 * 20 * 2;
 constexpr int32_t VIDEO_FRAME_INTERVAL = 33333;
 constexpr float VIDEO_FRAME_INTERVAL_MS = 33.33333;
 constexpr int32_t AUDIO_FRAME_INTERVAL = 21333;
diff --git a/services/camera_service/src/avcodec/audio_capturer_session.cpp b/services/camera_service/src/avcodec/audio_capturer_session.cpp
index f237f49e2..9be91a0ac 100644
--- a/services/camera_service/src/avcodec/audio_capturer_session.cpp
+++ b/services/camera_service/src/avcodec/audio_capturer_session.cpp
@@ -20,6 +20,7 @@
 #include <thread>
 #include "audio_record.h"
 #include "audio_session_manager.h"
+#include "audio_deferred_process.h"
 #include "camera_log.h"
 #include "datetime_ex.h"
 #include "ipc_skeleton.h"
@@ -34,6 +35,24 @@ AudioCapturerSession::AudioCapturerSession()
 {
 }
 
+AudioChannel AudioCapturerSession::getMicNum()
+{
+    MEDIA_INFO_LOG("AudioCapturerSession::getMicNum");
+    std::string mainKey = "device_status";
+    std::vector<std::string> subKeys = {"hardware_info#mic_num"};
+    std::vector<std::pair<std::string, std::string>> result = {};
+    AudioSystemManager* audioSystemMgr = AudioSystemManager::GetInstance();
+    int32_t ret = audioSystemMgr->GetExtraParameters(mainKey, subKeys, result);
+    if (ret != 0) {
+        MEDIA_WARNING_LOG("AudioCapturerSession::getMicNum err");
+        return AudioChannel::STEREO;
+    }
+    int32_t micNum = std::stoi(result[0].second);
+    MEDIA_INFO_LOG("AudioCapturerSession::getMicNum %{public}d + %{public}d", micNum, micNum % 2);
+    // odd channel should + 1
+    return static_cast<AudioChannel>(micNum + (micNum % 2));
+}
+
 bool AudioCapturerSession::CreateAudioCapturer()
 {
     auto callingTokenID = IPCSkeleton::GetCallingTokenID();
@@ -42,8 +61,8 @@ bool AudioCapturerSession::CreateAudioCapturer()
     capturerOptions.streamInfo.samplingRate = static_cast<AudioSamplingRate>(AudioSamplingRate::SAMPLE_RATE_48000);
     capturerOptions.streamInfo.encoding = AudioEncodingType::ENCODING_PCM;
     capturerOptions.streamInfo.format = AudioSampleFormat::SAMPLE_S16LE;
-    capturerOptions.streamInfo.channels = AudioChannel::MONO;
-    capturerOptions.capturerInfo.sourceType = SourceType::SOURCE_TYPE_MIC;
+    capturerOptions.streamInfo.channels = getMicNum();
+    capturerOptions.capturerInfo.sourceType = SourceType::SOURCE_TYPE_UNPROCESSED;
     capturerOptions.capturerInfo.capturerFlags = 0;
     audioCapturer_ = AudioCapturer::Create(capturerOptions);
     if (audioCapturer_ == nullptr) {
@@ -53,6 +72,24 @@ bool AudioCapturerSession::CreateAudioCapturer()
     AudioSessionStrategy sessionStrategy;
     sessionStrategy.concurrencyMode = AudioConcurrencyMode::MIX_WITH_OTHERS;
     AudioSessionManager::GetInstance()->ActivateAudioSession(sessionStrategy);
+    audioDeferredProcess_ = new AudioDeferredProcess();
+    if (!audioDeferredProcess_ || audioDeferredProcess_->GetOfflineEffectChain() != 0) {
+        return false;
+    }
+    AudioStreamInfo outputOptions;
+    outputOptions.samplingRate = static_cast<AudioSamplingRate>(AudioSamplingRate::SAMPLE_RATE_32000);
+    outputOptions.encoding = AudioEncodingType::ENCODING_PCM;
+    outputOptions.format = AudioSampleFormat::SAMPLE_S16LE;
+    outputOptions.channels = AudioChannel::MONO;
+    if (audioDeferredProcess_->ConfigOfflineAudioEffectChain(capturerOptions.streamInfo, outputOptions) != 0) {
+        return false;
+    }
+    if (audioDeferredProcess_->PrepareOfflineAudioEffectChain() != 0) {
+        return false;
+    }
+    if (audioDeferredProcess_->GetMaxBufferSize(capturerOptions.streamInfo, outputOptions) != 0) {
+        return false;
+    }
     return true;
 }
 
@@ -104,7 +141,7 @@ void AudioCapturerSession::GetAudioRecords(int64_t startTime, int64_t endTime, v
 void AudioCapturerSession::ProcessAudioBuffer()
 {
     CHECK_ERROR_RETURN_LOG(audioCapturer_ == nullptr, "AudioCapturer_ is not init");
-    size_t bufferLen = DEFAULT_MAX_INPUT_SIZE;
+    size_t bufferLen = audioDeferredProcess_->GetOneUnprocessedSize();
     while (true) {
         CHECK_AND_BREAK_LOG(startAudioCapture_, "Audio capture work done, thread out");
         auto buffer = std::make_unique<uint8_t[]>(bufferLen);
@@ -165,5 +202,10 @@ void AudioCapturerSession::Release()
     audioCapturer_ = nullptr;
     MEDIA_INFO_LOG("Audio capture released");
 }
+
+sptr<AudioDeferredProcess> AudioCapturerSession::GetAudioDeferredProcess()
+{
+    return audioDeferredProcess_;
+}
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/services/camera_service/src/avcodec/audio_deferred_process.cpp b/services/camera_service/src/avcodec/audio_deferred_process.cpp
new file mode 100644
index 000000000..8c63ac707
--- /dev/null
+++ b/services/camera_service/src/avcodec/audio_deferred_process.cpp
@@ -0,0 +1,175 @@
+/*
+ * Copyright (c) 2024-2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "audio_deferred_process.h"
+
+#include "camera_log.h"
+#include "camera_util.h"
+#include "sample_info.h"
+#include <cstring>
+
+namespace OHOS {
+namespace CameraStandard {
+
+AudioDeferredProcess::AudioDeferredProcess()
+{
+    MEDIA_INFO_LOG("AudioDeferredProcess() Enter");
+    if (!offlineAudioEffectManager_) {
+        offlineAudioEffectManager_ = std::make_unique<OfflineAudioEffectManager>();
+    }
+}
+
+AudioDeferredProcess::~AudioDeferredProcess()
+{
+    MEDIA_INFO_LOG("~AudioDeferredProcess Enter");
+    Release();
+}
+
+int32_t AudioDeferredProcess::GetOfflineEffectChain()
+{
+    MEDIA_INFO_LOG("AudioDeferredProcess::GetOfflineEffectChain Enter");
+    if (!offlineAudioEffectManager_) {
+        MEDIA_ERR_LOG("AudioDeferredProcess::GetOfflineEffectChain offlineAudioEffectManager_ is nullptr");
+        return -1;
+    }
+    vector<std::string> effectChains = offlineAudioEffectManager_->GetOfflineAudioEffectChains();
+    if (std::find(effectChains.begin(), effectChains.end(), chainName_) == effectChains.end()) {
+        MEDIA_ERR_LOG("AudioDeferredProcess::GetOfflineEffectChain no effectChain moving photo need");
+        return -1;
+    }
+    offlineEffectChain_ = offlineAudioEffectManager_->CreateOfflineAudioEffectChain(chainName_);
+    if (!offlineEffectChain_) {
+        MEDIA_ERR_LOG("AudioDeferredProcess::GetOfflineEffectChain ERR");
+        return -1;
+    }
+    return CAMERA_OK;
+}
+
+int32_t AudioDeferredProcess::ConfigOfflineAudioEffectChain(const AudioStreamInfo& inputOptions,
+    const AudioStreamInfo& outputOptions)
+{
+    MEDIA_INFO_LOG("AudioDeferredProcess::ConfigOfflineAudioEffectChain Enter");
+    if (offlineEffectChain_->Configure(inputOptions, outputOptions) != 0) {
+        MEDIA_ERR_LOG("AudioDeferredProcess::ConfigOfflineAudioEffectChain Err");
+        return -1;
+    }
+    inputOptions_ = inputOptions;
+    outputOptions_ = outputOptions;
+    return CAMERA_OK;
+}
+
+int32_t AudioDeferredProcess::PrepareOfflineAudioEffectChain()
+{
+    MEDIA_INFO_LOG("AudioDeferredProcess::PrepareOfflineAudioEffectChain Enter");
+    if (offlineEffectChain_->Prepare() != 0) {
+        MEDIA_ERR_LOG("AudioDeferredProcess::PrepareOfflineAudioEffectChain Err");
+        return -1;
+    }
+    return CAMERA_OK;
+}
+
+int32_t AudioDeferredProcess::GetMaxBufferSize(const AudioStreamInfo& inputOptions,
+    const AudioStreamInfo& outputOptions)
+{
+    MEDIA_INFO_LOG("AudioDeferredProcess::GetMaxBufferSize Enter");
+    if (offlineEffectChain_->GetEffectBufferSize(maxUnprocessedBufferSize_, maxProcessedBufferSize_) != 0) {
+        MEDIA_ERR_LOG("AudioDeferredProcess::GetMaxBufferSize Err");
+        return -1;
+    }
+    oneUnprocessedSize_ = inputOptions.samplingRate / ONE_THOUSAND *
+        inputOptions.channels * DURATION_EACH_AUDIO_FRAME * sizeof(short);
+    oneProcessedSize_ = outputOptions.samplingRate / ONE_THOUSAND *
+        outputOptions.channels * DURATION_EACH_AUDIO_FRAME * sizeof(short);
+    MEDIA_INFO_LOG("AudioDeferredProcess::GetMaxBufferSize %{public}d", oneProcessedSize_);
+    if (oneUnprocessedSize_ * PROCESS_BATCH_SIZE > maxUnprocessedBufferSize_ ||
+        oneProcessedSize_ * PROCESS_BATCH_SIZE > maxProcessedBufferSize_) {
+        MEDIA_ERR_LOG("AudioDeferredProcess::GetMaxBufferSize MaxBufferSize Not Enough");
+        return -1;
+    }
+    return CAMERA_OK;
+}
+
+int32_t AudioDeferredProcess::GetOneUnprocessedSize()
+{
+    return oneUnprocessedSize_;
+}
+
+int32_t AudioDeferredProcess::GetOutputSampleRate()
+{
+    return outputOptions_.samplingRate;
+}
+
+int32_t AudioDeferredProcess::GetOutputChannelCount()
+{
+    return outputOptions_.channels;
+}
+
+int32_t AudioDeferredProcess::Process(vector<sptr<AudioRecord>>& audioRecords)
+{
+    if (offlineEffectChain_ == nullptr) {
+        MEDIA_WARNING_LOG("AudioDeferredProcess::Process offlineEffectChain_ is nullptr.");
+        return -1;
+    }
+    MEDIA_INFO_LOG("AudioDeferredProcess::Process Enter");
+    uint32_t audioRecordsLen = audioRecords.size();
+    uint8_t* rawArr = new uint8_t[oneUnprocessedSize_ * PROCESS_BATCH_SIZE];
+    uint8_t* processedArr = new uint8_t[oneProcessedSize_ * PROCESS_BATCH_SIZE];
+    uint32_t count = 0;
+
+    auto returnToRecords = [this, &audioRecords, rawArr, processedArr](uint32_t i, uint32_t batchSize)->void {
+        int32_t ret = offlineEffectChain_->Process(rawArr, oneUnprocessedSize_ * batchSize,
+            processedArr, oneProcessedSize_ * batchSize);
+        for (uint32_t j = 0; j < batchSize; ++ j) {
+            if (ret == 0) {
+                computedMap_.emplace(audioRecords[i - batchSize + 1 + j], true);
+            }
+            audioRecords[i - batchSize + 1 + j]->ReleaseAudioBuffer();
+            uint8_t* temp = new uint8_t[oneProcessedSize_];
+            memcpy_s(temp, oneProcessedSize_, processedArr + j * oneProcessedSize_, oneProcessedSize_);
+            audioRecords[i - batchSize + 1 + j]->SetAudioBuffer(temp);
+        }
+    };
+
+    for (uint32_t i = 0; i < audioRecordsLen; i ++) {
+        if (computedMap_[audioRecords[i]]) {
+            continue;
+        }
+        memcpy_s(rawArr + count * oneUnprocessedSize_, oneUnprocessedSize_,
+            audioRecords[i]->GetAudioBuffer(), oneUnprocessedSize_);
+        if (count == PROCESS_BATCH_SIZE - 1) {
+            returnToRecords(i, PROCESS_BATCH_SIZE);
+        } else if (i == audioRecordsLen - 1) { // last
+            returnToRecords(i, count + 1);
+        }
+        count = (count + 1) % PROCESS_BATCH_SIZE;
+    }
+
+    delete[] rawArr;
+    delete[] processedArr;
+    return CAMERA_OK;
+}
+
+void AudioDeferredProcess::Release()
+{
+    MEDIA_INFO_LOG("AudioDeferredProcess::Release Enter");
+    if (offlineEffectChain_) {
+        offlineEffectChain_->Release();
+    }
+    offlineEffectChain_ = nullptr;
+    offlineAudioEffectManager_ = nullptr;
+}
+
+} // CameraStandard
+} // OHOS
diff --git a/services/camera_service/src/avcodec/audio_encoder.cpp b/services/camera_service/src/avcodec/audio_encoder.cpp
index 773e59990..1805f4b17 100644
--- a/services/camera_service/src/avcodec/audio_encoder.cpp
+++ b/services/camera_service/src/avcodec/audio_encoder.cpp
@@ -142,11 +142,11 @@ bool AudioEncoder::EnqueueBuffer(sptr<AudioRecord> audioRecord)
         context_->inputBufferInfoQueue_.pop();
         context_->inputFrameCount_++;
         bufferInfo->attr.pts = audioRecord->GetTimeStamp();
-        bufferInfo->attr.size = DEFAULT_MAX_INPUT_SIZE;
+        bufferInfo->attr.size = INPUT_SIZE_1280;
         bufferInfo->attr.flags = AVCODEC_BUFFER_FLAGS_NONE;
         auto bufferAddr = OH_AVBuffer_GetAddr(bufferInfo->buffer);
         int32_t bufferCap = OH_AVBuffer_GetCapacity(bufferInfo->buffer);
-        errno_t cpyRet = memcpy_s(bufferAddr, bufferCap, buffer, DEFAULT_MAX_INPUT_SIZE);
+        errno_t cpyRet = memcpy_s(bufferAddr, bufferCap, buffer, INPUT_SIZE_1280);
         CHECK_AND_RETURN_RET_LOG(cpyRet == 0, false, "encoder memcpy_s failed. %{public}d", cpyRet);
         lock.unlock();
         contextLock.unlock();
@@ -236,11 +236,11 @@ int32_t AudioEncoder::Configure()
     CHECK_AND_RETURN_RET_LOG(format != nullptr, 1, "AVFormat create failed");
 
     OH_AVFormat_SetIntValue(format, OH_MD_KEY_AUD_CHANNEL_COUNT, DEFAULT_CHANNEL_COUNT);
-    OH_AVFormat_SetIntValue(format, OH_MD_KEY_AUD_SAMPLE_RATE, DEFAULT_SAMPLERATE);
+    OH_AVFormat_SetIntValue(format, OH_MD_KEY_AUD_SAMPLE_RATE, SAMPLERATE_32000);
     OH_AVFormat_SetLongValue(format, OH_MD_KEY_BITRATE, DEFAULT_BITRATE);
     OH_AVFormat_SetIntValue(format, OH_MD_KEY_AUDIO_SAMPLE_FORMAT, SAMPLE_FORMAT);
     OH_AVFormat_SetLongValue(format, OH_MD_KEY_CHANNEL_LAYOUT, CHANNEL_LAYOUT);
-    OH_AVFormat_SetIntValue(format, OH_MD_KEY_MAX_INPUT_SIZE, DEFAULT_MAX_INPUT_SIZE);
+    OH_AVFormat_SetIntValue(format, OH_MD_KEY_MAX_INPUT_SIZE, INPUT_SIZE_1280);
     int ret = OH_AudioCodec_Configure(encoder_, format);
     OH_AVFormat_Destroy(format);
     format = nullptr;
diff --git a/services/camera_service/src/avcodec/avcodec_task_manager.cpp b/services/camera_service/src/avcodec/avcodec_task_manager.cpp
index 2fa00303f..d8167e98b 100644
--- a/services/camera_service/src/avcodec/avcodec_task_manager.cpp
+++ b/services/camera_service/src/avcodec/avcodec_task_manager.cpp
@@ -133,9 +133,9 @@ sptr<AudioVideoMuxer> AvcodecTaskManager::CreateAVMuxer(vector<sptr<FrameRecord>
 {
     CAMERA_SYNC_TRACE;
     unique_lock<mutex> lock(videoFdMutex_);
+    auto thisPtr = sptr<AvcodecTaskManager>(this);
     if (videoFdQueue_.empty()) {
         bool waitResult = false;
-        auto thisPtr = sptr<AvcodecTaskManager>(this);
         waitResult = cvEmpty_.wait_for(lock, std::chrono::milliseconds(GET_FD_EXPIREATION_TIME),
             [thisPtr] { return !thisPtr->videoFdQueue_.empty(); });
         CHECK_ERROR_RETURN_RET(!waitResult || videoFdQueue_.empty(), nullptr);
@@ -164,8 +164,10 @@ sptr<AudioVideoMuxer> AvcodecTaskManager::CreateAVMuxer(vector<sptr<FrameRecord>
     #ifdef MOVING_PHOTO_ADD_AUDIO
     auto formatAudio = make_shared<Format>();
     formatAudio->PutStringValue(MediaDescriptionKey::MD_KEY_CODEC_MIME, OH_AVCODEC_MIMETYPE_AUDIO_AAC);
-    formatAudio->PutIntValue(MediaDescriptionKey::MD_KEY_SAMPLE_RATE, DEFAULT_SAMPLERATE);
-    formatAudio->PutIntValue(MediaDescriptionKey::MD_KEY_CHANNEL_COUNT, DEFAULT_CHANNEL_COUNT);
+    formatAudio->PutIntValue(MediaDescriptionKey::MD_KEY_SAMPLE_RATE, thisPtr->audioCapturerSession_ ?
+        thisPtr->audioCapturerSession_->GetAudioDeferredProcess()->GetOutputSampleRate() : DEFAULT_SAMPLERATE);
+    formatAudio->PutIntValue(MediaDescriptionKey::MD_KEY_CHANNEL_COUNT, thisPtr->audioCapturerSession_ ?
+        thisPtr->audioCapturerSession_->GetAudioDeferredProcess()->GetOutputChannelCount() : DEFAULT_CHANNEL_COUNT);
     muxer->AddTrack(audioTrackId, formatAudio, AUDIO_TRACK);
     #endif
     int metaTrackId = -1;
@@ -174,7 +176,6 @@ sptr<AudioVideoMuxer> AvcodecTaskManager::CreateAVMuxer(vector<sptr<FrameRecord>
     formatMeta->PutStringValue(MediaDescriptionKey::MD_KEY_TIMED_METADATA_KEY, TIMED_METADATA_KEY);
     formatMeta->PutIntValue(MediaDescriptionKey::MD_KEY_TIMED_METADATA_SRC_TRACK_ID, videoTrackId);
     muxer->AddTrack(metaTrackId, formatMeta, META_TRACK);
-
     MEDIA_INFO_LOG("CreateMuxer vId:%{public}d,aid:%{public}d,mid:%{public}d", videoTrackId, audioTrackId, metaTrackId);
     muxer->SetTimedMetadata();
     muxer->Start();
@@ -242,6 +243,7 @@ void AvcodecTaskManager::DoMuxerVideo(vector<sptr<FrameRecord>> frameRecords, ui
             int64_t startTime = NanosecToMillisec(videoStartTime);
             int64_t endTime = NanosecToMillisec(choosedBuffer.back()->GetTimeStamp());
             thisPtr->audioCapturerSession_->GetAudioRecords(startTime, endTime, audioRecords);
+            thisPtr->audioCapturerSession_->GetAudioDeferredProcess()->Process(audioRecords);
         }
         thisPtr->CollectAudioBuffer(audioRecords, muxer);
         #endif
-- 

