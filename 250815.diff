diff --git a/services/camera_service/include/camera_buffer_manager/camera_surface_buffer_util.h b/common/utils/camera_surface_buffer_util.h
similarity index 99%
rename from services/camera_service/include/camera_buffer_manager/camera_surface_buffer_util.h
rename to common/utils/camera_surface_buffer_util.h
index c1fb51bb8..3013e0360 100644
--- a/services/camera_service/include/camera_buffer_manager/camera_surface_buffer_util.h
+++ b/common/utils/camera_surface_buffer_util.h
@@ -315,4 +315,4 @@ private:
 };
 }  // namespace CameraStandard
 }  // namespace OHOS
-#endif
+#endif
\ No newline at end of file
diff --git a/frameworks/js/camera_napi/src/output/photo_output_napi.cpp b/frameworks/js/camera_napi/src/output/photo_output_napi.cpp
index 497e32eab..63172e5a6 100644
--- a/frameworks/js/camera_napi/src/output/photo_output_napi.cpp
+++ b/frameworks/js/camera_napi/src/output/photo_output_napi.cpp
@@ -780,7 +780,7 @@ napi_value PhotoOutputNapi::CreatePhotoOutput(napi_env env, Profile& profile, st
         MEDIA_INFO_LOG("CreatePhotoOutput surfaceId: %{public}s", surfaceId.c_str());
         int retCode = SUCCESS;
         if (surfaceId == "") {
-            MEDIA_INFO_LOG("create surface as consumer");
+            MEDIA_INFO_LOG("create surface on camera service");
             retCode = CameraManager::GetInstance()->CreatePhotoOutput(profile, &sPhotoOutput_);
         } else {
             MEDIA_INFO_LOG("get surface by surfaceId");
@@ -827,8 +827,8 @@ napi_value PhotoOutputNapi::CreatePhotoOutput(napi_env env, std::string surfaceI
         MEDIA_INFO_LOG("CreatePhotoOutput surfaceId: %{public}s", surfaceId.c_str());
         int retCode = SUCCESS;
         if (surfaceId == "") {
-            MEDIA_INFO_LOG("create surface as consumer");
-            retCode = CameraManager::GetInstance()->CreatePhotoOutputWithoutProfile(surfaceId, &sPhotoOutput_);
+            MEDIA_INFO_LOG("create surface on camera service");
+            retCode = CameraManager::GetInstance()->CreatePhotoOutputWithoutProfile(&sPhotoOutput_);
         } else {
             MEDIA_INFO_LOG("get surface by surfaceId");
             sptr<Surface> photoSurface = Media::ImageReceiver::getSurfaceById(surfaceId);
diff --git a/frameworks/native/camera/base/src/input/camera_manager.cpp b/frameworks/native/camera/base/src/input/camera_manager.cpp
index b3baba640..ef14842eb 100644
--- a/frameworks/native/camera/base/src/input/camera_manager.cpp
+++ b/frameworks/native/camera/base/src/input/camera_manager.cpp
@@ -505,24 +505,25 @@ sptr<PhotoOutput> CameraManager::CreatePhotoOutput(sptr<IBufferProducer> &surfac
     return result;
 }
 
-sptr<PhotoOutput> CameraManager::CreatePhotoOutput(Profile &profile, sptr<IBufferProducer> &surface)
+sptr<PhotoOutput> CameraManager::CreatePhotoOutput(Profile &profile, sptr<IBufferProducer> &surfaceProducer)
 {
     CAMERA_SYNC_TRACE;
     sptr<PhotoOutput> photoOutput = nullptr;
-    int32_t retCode = CreatePhotoOutput(profile, surface, &photoOutput);
+    int32_t retCode = CreatePhotoOutput(profile, surfaceProducer, &photoOutput);
     CHECK_RETURN_RET_ELOG(retCode != CameraErrorCode::SUCCESS, nullptr,
         "Failed to CreatePhotoOutput with error code:%{public}d", retCode);
     return photoOutput;
 }
 
-int CameraManager::CreatePhotoOutputWithoutProfile(sptr<IBufferProducer> surface, sptr<PhotoOutput>* pPhotoOutput)
+int CameraManager::CreatePhotoOutputWithoutProfile(sptr<IBufferProducer> surfaceProducer,
+                                                   sptr<PhotoOutput>* pPhotoOutput)
 {
     CAMERA_SYNC_TRACE;
     auto serviceProxy = GetServiceProxy();
     // LCOV_EXCL_START
-    CHECK_RETURN_RET_ELOG((serviceProxy == nullptr) || (surface == nullptr), CameraErrorCode::INVALID_ARGUMENT,
+    CHECK_RETURN_RET_ELOG((serviceProxy == nullptr) || (surfaceProducer == nullptr), CameraErrorCode::INVALID_ARGUMENT,
         "CreatePhotoOutputWithoutProfile serviceProxy is null or PhotoOutputSurface is null");
-    sptr<PhotoOutput> photoOutput = new (std::nothrow) PhotoOutput(surface);
+    sptr<PhotoOutput> photoOutput = new (std::nothrow) PhotoOutput(surfaceProducer);
     CHECK_RETURN_RET(photoOutput == nullptr, CameraErrorCode::SERVICE_FATL_ERROR);
     photoOutput->AddTag(CaptureOutput::DYNAMIC_PROFILE);
     *pPhotoOutput = photoOutput;
@@ -530,15 +531,15 @@ int CameraManager::CreatePhotoOutputWithoutProfile(sptr<IBufferProducer> surface
     // LCOV_EXCL_STOP
 }
 
-int CameraManager::CreatePhotoOutputWithoutProfile(sptr<IBufferProducer> surface,
-    sptr<PhotoOutput>* pPhotoOutput, sptr<Surface> photoSurface)
+int CameraManager::CreatePhotoOutputWithoutProfile(sptr<IBufferProducer> surfaceProducer,
+                                                   sptr<PhotoOutput>* pPhotoOutput, sptr<Surface> photoSurface)
 {
     // LCOV_EXCL_START
     CAMERA_SYNC_TRACE;
     auto serviceProxy = GetServiceProxy();
-    CHECK_RETURN_RET_ELOG((serviceProxy == nullptr) || (surface == nullptr), CameraErrorCode::INVALID_ARGUMENT,
+    CHECK_RETURN_RET_ELOG((serviceProxy == nullptr) || (surfaceProducer == nullptr), CameraErrorCode::INVALID_ARGUMENT,
         "CreatePhotoOutputWithoutProfile serviceProxy is null or PhotoOutputSurface is null");
-    sptr<PhotoOutput> photoOutput = new (std::nothrow) PhotoOutput(surface, photoSurface);
+    sptr<PhotoOutput> photoOutput = new (std::nothrow) PhotoOutput(surfaceProducer, photoSurface);
     CHECK_RETURN_RET(photoOutput == nullptr, CameraErrorCode::SERVICE_FATL_ERROR);
     photoOutput->AddTag(CaptureOutput::DYNAMIC_PROFILE);
     *pPhotoOutput = photoOutput;
@@ -546,7 +547,7 @@ int CameraManager::CreatePhotoOutputWithoutProfile(sptr<IBufferProducer> surface
     // LCOV_EXCL_STOP
 }
 
-int CameraManager::CreatePhotoOutputWithoutProfile(std::string surfaceId, sptr<PhotoOutput>* pPhotoOutput)
+int CameraManager::CreatePhotoOutputWithoutProfile(sptr<PhotoOutput>* pPhotoOutput)
 {
     // LCOV_EXCL_START
     CAMERA_SYNC_TRACE;
@@ -561,12 +562,12 @@ int CameraManager::CreatePhotoOutputWithoutProfile(std::string surfaceId, sptr<P
     // LCOV_EXCL_STOP
 }
 
-int CameraManager::CreatePhotoOutput(Profile &profile, sptr<IBufferProducer> &surface, sptr<PhotoOutput> *pPhotoOutput)
-    __attribute__((no_sanitize("cfi")))
+int CameraManager::CreatePhotoOutput(Profile &profile, sptr<IBufferProducer> &surfaceProducer,
+                                     sptr<PhotoOutput> *pPhotoOutput) __attribute__((no_sanitize("cfi")))
 {
     CAMERA_SYNC_TRACE;
     auto serviceProxy = GetServiceProxy();
-    CHECK_RETURN_RET_ELOG((serviceProxy == nullptr) || (surface == nullptr), CameraErrorCode::INVALID_ARGUMENT,
+    CHECK_RETURN_RET_ELOG((serviceProxy == nullptr) || (surfaceProducer == nullptr), CameraErrorCode::INVALID_ARGUMENT,
         "CreatePhotoOutput serviceProxy is null or PhotoOutputSurface/profile is null");
     CHECK_RETURN_RET_ELOG((profile.GetCameraFormat() == CAMERA_FORMAT_INVALID) || (profile.GetSize().width == 0)
         || (profile.GetSize().height == 0), CameraErrorCode::INVALID_ARGUMENT,
@@ -576,10 +577,10 @@ int CameraManager::CreatePhotoOutput(Profile &profile, sptr<IBufferProducer> &su
     camera_format_t metaFormat = GetCameraMetadataFormat(yuvFormat);
     sptr<IStreamCapture> streamCapture = nullptr;
     int32_t retCode = serviceProxy->CreatePhotoOutput(
-        surface, metaFormat, profile.GetSize().width, profile.GetSize().height, streamCapture);
+        surfaceProducer, metaFormat, profile.GetSize().width, profile.GetSize().height, streamCapture);
     CHECK_RETURN_RET_ELOG(retCode != CAMERA_OK, ServiceToCameraError(retCode),
         "Failed to get stream capture object from hcamera service!, %{public}d", retCode);
-    sptr<PhotoOutput> photoOutput = new(std::nothrow) PhotoOutput(surface);
+    sptr<PhotoOutput> photoOutput = new(std::nothrow) PhotoOutput(surfaceProducer);
     CHECK_RETURN_RET(photoOutput == nullptr, CameraErrorCode::SERVICE_FATL_ERROR);
     photoOutput->SetStream(streamCapture);
     photoOutput->SetPhotoProfile(profile);
@@ -588,7 +589,7 @@ int CameraManager::CreatePhotoOutput(Profile &profile, sptr<IBufferProducer> &su
 }
 
 int CameraManager::CreatePhotoOutput(Profile &profile, sptr<IBufferProducer> &surfaceProducer,
-    sptr<PhotoOutput> *pPhotoOutput, sptr<Surface> photoSurface)
+                                     sptr<PhotoOutput> *pPhotoOutput, sptr<Surface> photoSurface)
 {
     // LCOV_EXCL_START
     CAMERA_SYNC_TRACE;
@@ -742,7 +743,7 @@ int32_t CameraManager::CreatePhotoOutputStream(
 }
 
 int32_t CameraManager::CreatePhotoOutputStream(
-    sptr<IStreamCapture>& streamPtr, Profile& profile, std::string surfaceId)
+    sptr<IStreamCapture>& streamPtr, Profile& profile)
 {
     // LCOV_EXCL_START
     auto serviceProxy = GetServiceProxy();
diff --git a/frameworks/native/camera/base/src/output/photo_output.cpp b/frameworks/native/camera/base/src/output/photo_output.cpp
index 43a27411e..244a5abd9 100644
--- a/frameworks/native/camera/base/src/output/photo_output.cpp
+++ b/frameworks/native/camera/base/src/output/photo_output.cpp
@@ -350,6 +350,7 @@ PhotoOutput::PhotoOutput()
     : CaptureOutput(CAPTURE_OUTPUT_TYPE_PHOTO, StreamType::CAPTURE, nullptr)
 {
     MEDIA_INFO_LOG("new PhotoOutput");
+    isSurfaceOnService_ = true;
 }
 
 PhotoOutput::~PhotoOutput()
@@ -505,15 +506,35 @@ void PhotoOutput::SetCallback(std::shared_ptr<PhotoStateCallback> callback)
     }
 }
 
+void PhotoOutput::SetPhotoNativeConsumer()
+{
+    MEDIA_DEBUG_LOG("SetPhotoNativeConsumer E");
+    CHECK_RETURN_ELOG(photoSurface_ == nullptr, "SetPhotoNativeConsumer err, surface is null");
+    CHECK_RETURN(photoNativeConsumer_ != nullptr);
+    photoSurface_->UnregisterConsumerListener();
+    photoNativeConsumer_ = new (std::nothrow) PhotoNativeConsumer(wptr<PhotoOutput>(this));
+    SurfaceError ret = photoSurface_->RegisterConsumerListener((sptr<IBufferConsumerListener> &)photoNativeConsumer_);
+    CHECK_PRINT_ELOG(ret != SURFACE_ERROR_OK, "SetPhotoNativeConsumer failed:%{public}d", ret);
+}
+
 void PhotoOutput::SetPhotoAvailableCallback(std::shared_ptr<PhotoAvailableCallback> callback)
 {
-    // LCOV_EXCL_START
     MEDIA_DEBUG_LOG("SetPhotoAvailableCallback E");
     CHECK_RETURN_ELOG(callback == nullptr, "photo callback nullptr");
     std::lock_guard<std::mutex> lock(outputCallbackMutex_);
     appPhotoCallback_ = nullptr;
     svcPhotoCallback_ = nullptr;
     appPhotoCallback_ = callback;
+    if (isSurfaceOnService_) {
+        SetPhotoAvailableInSvc();
+    } else {
+        SetPhotoNativeConsumer();
+    }
+}
+
+void PhotoOutput::SetPhotoAvailableInSvc()
+{
+    MEDIA_DEBUG_LOG("SetPhotoAvailableInSvc E");
     svcPhotoCallback_ = new (std::nothrow) HStreamCapturePhotoCallbackImpl(this);
     CHECK_RETURN_ELOG(svcPhotoCallback_ == nullptr, "new photo svc callback err");
     auto itemStream = CastStream<IStreamCapture>(GetStream());
@@ -521,6 +542,7 @@ void PhotoOutput::SetPhotoAvailableCallback(std::shared_ptr<PhotoAvailableCallba
     if (itemStream) {
         errorCode = itemStream->SetPhotoAvailableCallback(svcPhotoCallback_);
     } else {
+        reSetFlag_ = RESET_PHOTO;
         MEDIA_ERR_LOG("SetPhotoAvailableCallback itemStream is nullptr");
     }
     if (errorCode != CAMERA_OK) {
@@ -529,7 +551,6 @@ void PhotoOutput::SetPhotoAvailableCallback(std::shared_ptr<PhotoAvailableCallba
         appPhotoCallback_ = nullptr;
     }
     MEDIA_DEBUG_LOG("SetPhotoAvailableCallback X");
-    // LCOV_EXCL_STOP
 }
 
 void PhotoOutput::UnSetPhotoAvailableCallback()
@@ -555,6 +576,17 @@ void PhotoOutput::SetPhotoAssetAvailableCallback(std::shared_ptr<PhotoAssetAvail
     appPhotoAssetCallback_ = nullptr;
     svcPhotoAssetCallback_ = nullptr;
     appPhotoAssetCallback_ = callback;
+    if (isSurfaceOnService_) {
+        SetPhotoAssetAvailableInSvc();
+    } else {
+        SetPhotoNativeConsumer();
+    }
+    // LCOV_EXCL_STOP
+}
+
+void PhotoOutput::SetPhotoAssetAvailableInSvc()
+{
+    MEDIA_DEBUG_LOG("SetPhotoAssetAvailableInSvc E");
     svcPhotoAssetCallback_ = new (std::nothrow) HStreamCapturePhotoAssetCallbackImpl(this);
     CHECK_RETURN_ELOG(svcPhotoAssetCallback_ == nullptr, "new photoAsset svc callback err");
     auto itemStream = CastStream<IStreamCapture>(GetStream());
@@ -562,6 +594,7 @@ void PhotoOutput::SetPhotoAssetAvailableCallback(std::shared_ptr<PhotoAssetAvail
     if (itemStream) {
         errorCode = itemStream->SetPhotoAssetAvailableCallback(svcPhotoAssetCallback_);
     } else {
+        reSetFlag_ = RESET_PHOTO_ASSET;
         MEDIA_ERR_LOG("SetPhotoAssetAvailableCallback itemStream is nullptr");
     }
     if (errorCode != CAMERA_OK) {
@@ -570,7 +603,6 @@ void PhotoOutput::SetPhotoAssetAvailableCallback(std::shared_ptr<PhotoAssetAvail
         appPhotoAssetCallback_ = nullptr;
     }
     MEDIA_DEBUG_LOG("SetPhotoAssetAvailableCallback X");
-    // LCOV_EXCL_STOP
 }
 
 void PhotoOutput::UnSetPhotoAssetAvailableCallback()
@@ -587,6 +619,24 @@ void PhotoOutput::UnSetPhotoAssetAvailableCallback()
     // LCOV_EXCL_STOP
 }
 
+void PhotoOutput::ReSetSavedCallback()
+{
+    MEDIA_DEBUG_LOG("ReSetSavedCallback E");
+    CHECK_RETURN_ELOG(!isSurfaceOnService_, "ReSetSavedCallback no need");
+    auto itemStream = CastStream<IStreamCapture>(GetStream());
+    CHECK_RETURN_ELOG(itemStream == nullptr, "ReSetSavedCallback faild");
+    int32_t errorCode = CAMERA_OK;
+    if (reSetFlag_ == RESET_PHOTO && appPhotoCallback_ && svcPhotoCallback_) {
+        errorCode = itemStream->SetPhotoAvailableCallback(svcPhotoCallback_);
+    } else if (reSetFlag_ == RESET_PHOTO_ASSET && appPhotoAssetCallback_ && svcPhotoAssetCallback_) {
+        errorCode = itemStream->SetPhotoAssetAvailableCallback(svcPhotoAssetCallback_);
+    }
+    reSetFlag_ = NO_NEED_RESET;
+    if (errorCode != CAMERA_OK) {
+        MEDIA_ERR_LOG("ReSetSavedCallback failed, errorCode: %{public}d", errorCode);
+    }
+}
+
 void PhotoOutput::SetThumbnailCallback(std::shared_ptr<ThumbnailCallback> callback)
 {
     // LCOV_EXCL_START
@@ -817,18 +867,23 @@ int32_t PhotoOutput::CreateStream()
     CHECK_RETURN_RET_ELOG(stream != nullptr, CameraErrorCode::OPERATION_NOT_ALLOWED,
         "PhotoOutput::CreateStream stream is not null");
     // LCOV_EXCL_START
-    auto producer = GetBufferProducer();
-    CHECK_RETURN_RET_ELOG(producer == nullptr, CameraErrorCode::OPERATION_NOT_ALLOWED,
-        "PhotoOutput::CreateStream producer is null");
     sptr<IStreamCapture> streamPtr = nullptr;
     auto photoProfile = GetPhotoProfile();
     CHECK_RETURN_RET_ELOG(photoProfile == nullptr, CameraErrorCode::SERVICE_FATL_ERROR,
         "PhotoOutput::CreateStream photoProfile is null");
-
-    int32_t res = CameraManager::GetInstance()->CreatePhotoOutputStream(streamPtr, *photoProfile, producer);
+    int32_t res = CameraErrorCode::SUCCESS;
+    if (isSurfaceOnService_) {
+        res = CameraManager::GetInstance()->CreatePhotoOutputStream(streamPtr, *photoProfile);
+    } else {
+        auto producer = GetBufferProducer();
+        CHECK_RETURN_RET_ELOG(
+            !producer, CameraErrorCode::OPERATION_NOT_ALLOWED, "PhotoOutput::CreateStream producer is null");
+        res = CameraManager::GetInstance()->CreatePhotoOutputStream(streamPtr, *photoProfile, producer);
+    }
     CHECK_PRINT_ELOG(res != CameraErrorCode::SUCCESS,
         "PhotoOutput::CreateStream fail! error code :%{public}d", res);
     SetStream(streamPtr);
+    CHECK_EXECUTE(isSurfaceOnService_, ReSetSavedCallback());
     return res;
     // LCOV_EXCL_STOP
 }
@@ -1423,5 +1478,21 @@ void PhotoOutput::NotifyOfflinePhotoOutput(int32_t captureId)
     }
     // LCOV_EXCL_STOP
 }
+
+void PhotoOutput::CreateMediaLibrary(sptr<CameraPhotoProxy> photoProxy, std::string &uri, int32_t &cameraShotType,
+    std::string &burstKey, int64_t timestamp)
+{
+    MEDIA_INFO_LOG("PhotoOutput::CreateMediaLibrary E");
+    CAMERA_SYNC_TRACE;
+    int32_t errorCode = CAMERA_OK;
+    auto itemStream = CastStream<IStreamCapture>(GetStream());
+    if (itemStream) {
+        errorCode = itemStream->CreateMediaLibrary(photoProxy, uri, cameraShotType, burstKey, timestamp);
+        CHECK_RETURN_ELOG(errorCode != CAMERA_OK, "Failed to createMediaLibrary, errorCode: %{public}d", errorCode);
+    } else {
+        MEDIA_ERR_LOG("PhotoOutput::CreateMediaLibrary itemStream is nullptr");
+    }
+    MEDIA_INFO_LOG("PhotoOutput::CreateMediaLibrary X");
+}
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/frameworks/native/camera/base/src/output/photo_output_callback.cpp b/frameworks/native/camera/base/src/output/photo_output_callback.cpp
index 98b65f44f..e304d1f34 100644
--- a/frameworks/native/camera/base/src/output/photo_output_callback.cpp
+++ b/frameworks/native/camera/base/src/output/photo_output_callback.cpp
@@ -28,6 +28,8 @@
 #include "metadata_helper.h"
 #include <pixel_map.h>
 #include "hdr_type.h"
+#include "camera_surface_buffer_util.h"
+#include "task_manager.h"
 using namespace std;
 
 namespace OHOS {
@@ -248,5 +250,130 @@ std::unique_ptr<Media::PixelMap> HStreamCaptureThumbnailCallbackImpl::SetPixelMa
     MEDIA_INFO_LOG("CamThumbnail::SetPixelMapYuvInf end");
     return pixelMap;
 }
+
+PhotoNativeConsumer::PhotoNativeConsumer(wptr<PhotoOutput> photoOutput) : innerPhotoOutput_(photoOutput)
+{
+    MEDIA_INFO_LOG("PhotoNativeConsumer new E");
+}
+
+PhotoNativeConsumer::~PhotoNativeConsumer()
+{
+    MEDIA_INFO_LOG("PhotoNativeConsumer ~ E");
+    ClearTaskManager();
+}
+
+void PhotoNativeConsumer::OnBufferAvailable()
+{
+    MEDIA_INFO_LOG("PhotoNativeConsumer OnBufferAvailable E");
+    auto photoOutput = innerPhotoOutput_.promote();
+    CHECK_RETURN_ELOG(!photoOutput, "OnBufferAvailable photoOutput is null");
+    CHECK_RETURN_ELOG(!photoOutput->photoSurface_, "OnBufferAvailable photoNative surface is null");
+    auto taskManager = GetDefaultTaskManager();
+    CHECK_RETURN_ELOG(!taskManager, "PhotoNativeConsumer OnBufferAvailable task is null");
+    wptr<PhotoNativeConsumer> thisPtr(this);
+    taskManager->SubmitTask([thisPtr]() {
+        auto listener = thisPtr.promote();
+        CHECK_EXECUTE(listener, listener->ExecuteOnBufferAvailable());
+    });
+    MEDIA_INFO_LOG("PhotoNativeConsumer OnBufferAvailable X");
+}
+
+void PhotoNativeConsumer::ExecuteOnBufferAvailable()
+{
+    MEDIA_INFO_LOG("PN_ExecuteOnBufferAvailable E");
+    CAMERA_SYNC_TRACE;
+    auto photoOutput = innerPhotoOutput_.promote();
+    CHECK_RETURN_ELOG(!photoOutput, "ExecuteOnBufferAvailable photoOutput is null");
+    CHECK_RETURN_ELOG(!photoOutput->photoSurface_, "ExecuteOnBufferAvailable photoNative surface is null");
+    sptr<SurfaceBuffer> surfaceBuffer = nullptr;
+    int32_t fence = -1;
+    int64_t timestamp;
+    OHOS::Rect damage;
+    SurfaceError surfaceRet = photoOutput->photoSurface_->AcquireBuffer(surfaceBuffer, fence, timestamp, damage);
+    CHECK_RETURN_ELOG(surfaceRet != SURFACE_ERROR_OK, "PhotoNativeConsumer Failed to acquire surface buffer");
+    int32_t isDegradedImage = CameraSurfaceBufferUtil::GetIsDegradedImage(surfaceBuffer);
+    MEDIA_INFO_LOG("PhotoNativeConsumer ts isDegradedImage:%{public}d", isDegradedImage);
+    MEDIA_INFO_LOG("PhotoNativeConsumer ts is:%{public}" PRId64, timestamp);
+    // deep copy surfaceBuffer
+    sptr<SurfaceBuffer> newSurfaceBuffer = CameraSurfaceBufferUtil::DeepCopyBuffer(surfaceBuffer);
+    // release surfaceBuffer to bufferQueue
+    photoOutput->photoSurface_->ReleaseBuffer(surfaceBuffer, -1);
+    CHECK_RETURN_ELOG(newSurfaceBuffer == nullptr, "newSurfaceBuffer is null");
+    if ((photoOutput->callbackFlag_ & CAPTURE_PHOTO_ASSET) != 0) {
+        ExecutePhotoAssetAvailable(newSurfaceBuffer, timestamp);
+    } else if (isDegradedImage == 0 && (photoOutput->callbackFlag_ & CAPTURE_PHOTO) != 0) {
+        ExecutePhotoAvailable(newSurfaceBuffer, timestamp);
+    } else if (isDegradedImage != 0 && (photoOutput->callbackFlag_ & CAPTURE_DEFERRED_PHOTO) != 0) {
+        MEDIA_INFO_LOG("PN_ExecuteOnBufferAvailable on abandon callback");
+    } else {
+        MEDIA_INFO_LOG("PN_ExecuteOnBufferAvailable on error callback");
+    }
+    MEDIA_INFO_LOG("PN_ExecuteOnBufferAvailable X");
+}
+
+void PhotoNativeConsumer::ExecutePhotoAvailable(sptr<SurfaceBuffer> surfaceBuffer, int64_t timestamp)
+{
+    MEDIA_INFO_LOG("PN_ExecutePhotoAvailable E");
+    CAMERA_SYNC_TRACE;
+    CHECK_RETURN_ELOG(surfaceBuffer == nullptr, "ExecutePhotoAvailable surfaceBuffer is null");
+    auto photoOutput = innerPhotoOutput_.promote();
+    CHECK_RETURN_ELOG(!photoOutput, "ExecutePhotoAvailable photoOutput is null");
+    auto callback = photoOutput->GetAppPhotoCallback();
+    CHECK_RETURN_ELOG(callback == nullptr, "ExecutePhotoAvailable callback is nullptr");
+    std::shared_ptr<CameraBufferProcessor> bufferProcessor;
+    std::shared_ptr<Media::NativeImage> image =
+        std::make_shared<Media::NativeImage>(surfaceBuffer, bufferProcessor, timestamp);
+    callback->OnPhotoAvailable(image, false);
+    MEDIA_INFO_LOG("PN_ExecutePhotoAvailable X");
+}
+
+void PhotoNativeConsumer::ExecutePhotoAssetAvailable(sptr<SurfaceBuffer> newSurfaceBuffer, int64_t timestamp)
+{
+    MEDIA_INFO_LOG("PN_ExecutePhotoAssetAvailable E");
+    CAMERA_SYNC_TRACE;
+    CHECK_RETURN_ELOG(newSurfaceBuffer == nullptr, "ExecutePhotoAssetAvailable surfaceBuffer is null");
+    auto photoOutput = innerPhotoOutput_.promote();
+    CHECK_RETURN_ELOG(!photoOutput, "ExecutePhotoAssetAvailable photoOutput is null");
+    auto callback = photoOutput->GetAppPhotoAssetCallback();
+    CHECK_RETURN_ELOG(callback == nullptr, "ExecutePhotoAssetAvailable callback is nullptr");
+    // prepare CameraPhotoProxy
+    BufferHandle* bufferHandle = newSurfaceBuffer->GetBufferHandle();
+    newSurfaceBuffer->Map();
+    int32_t format = bufferHandle->format;
+    int32_t photoWidth = CameraSurfaceBufferUtil::GetDataWidth(newSurfaceBuffer);
+    int32_t photoHeight = CameraSurfaceBufferUtil::GetDataWidth(newSurfaceBuffer);
+    bool isHighQuality = (CameraSurfaceBufferUtil::GetIsDegradedImage(newSurfaceBuffer) == 0);
+    int32_t captureId = CameraSurfaceBufferUtil::GetCaptureId(newSurfaceBuffer);
+    int32_t burstSeqId = -1;
+    sptr<CameraPhotoProxy> photoProxy = new (std::nothrow)
+        CameraPhotoProxy(bufferHandle, format, photoWidth, photoHeight, isHighQuality, captureId, burstSeqId);
+    // ipc CreateMediaLibrary
+    string uri = "";
+    int32_t cameraShotType = 0;
+    std::string burstKey = "";
+    photoOutput->CreateMediaLibrary(photoProxy, uri, cameraShotType, burstKey, timestamp);
+    MEDIA_INFO_LOG("PN_ExecutePhotoAssetAvailable CreateMediaLibrary get uri:%{public}s", uri.c_str());
+    callback->OnPhotoAssetAvailable(captureId, uri, cameraShotType, burstKey);
+    MEDIA_INFO_LOG("PN_ExecutePhotoAssetAvailable X");
+}
+
+void PhotoNativeConsumer::ClearTaskManager()
+{
+    std::lock_guard<std::mutex> lock(taskManagerMutex_);
+    if (taskManager_ != nullptr) {
+        taskManager_->CancelAllTasks();
+        taskManager_ = nullptr;
+    }
+}
+ 
+std::shared_ptr<DeferredProcessing::TaskManager> PhotoNativeConsumer::GetDefaultTaskManager()
+{
+    constexpr int32_t numThreads = 1;
+    std::lock_guard<std::mutex> lock(taskManagerMutex_);
+    if (taskManager_ == nullptr) {
+        taskManager_ = std::make_shared<DeferredProcessing::TaskManager>("PhotoListener", numThreads, false);
+    }
+    return taskManager_;
+}
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/frameworks/native/ndk/impl/camera_manager_impl.cpp b/frameworks/native/ndk/impl/camera_manager_impl.cpp
index d0411c0b2..83ec75cac 100644
--- a/frameworks/native/ndk/impl/camera_manager_impl.cpp
+++ b/frameworks/native/ndk/impl/camera_manager_impl.cpp
@@ -632,7 +632,7 @@ Camera_ErrorCode Camera_Manager::CreatePhotoOutputUsedInPreconfig(const char* su
         retCode =
             CameraManager::GetInstance()->CreatePhotoOutputWithoutProfile(surfaceProducer, &innerPhotoOutput);
     } else {
-        retCode = CameraManager::GetInstance()->CreatePhotoOutputWithoutProfile(surfaceId, &innerPhotoOutput);
+        retCode = CameraManager::GetInstance()->CreatePhotoOutputWithoutProfile(&innerPhotoOutput);
     }
     CHECK_RETURN_RET_ELOG(retCode != CameraErrorCode::SUCCESS, CAMERA_SERVICE_FATAL_ERROR,
         "Camera_Manager::CreatePhotoOutputUsedInPreconfig create innerPhotoOutput fail!");
diff --git a/interfaces/inner_api/native/camera/include/input/camera_manager.h b/interfaces/inner_api/native/camera/include/input/camera_manager.h
index 59dc53543..ba2fc0b62 100644
--- a/interfaces/inner_api/native/camera/include/input/camera_manager.h
+++ b/interfaces/inner_api/native/camera/include/input/camera_manager.h
@@ -265,12 +265,12 @@ public:
     int32_t CreateCaptureSession(sptr<CaptureSession>* pCaptureSession);
 
     /**
-     * @brief Create photo output instance using surface.
+     * @brief Create photo output instance using surfaceProducer.
      *
-     * @param The surface to be used for photo output.
+     * @param The surfaceProducer to be used for photo output.
      * @return Returns pointer to photo output instance.
      */
-    sptr<PhotoOutput> CreatePhotoOutput(Profile& profile, sptr<IBufferProducer>& surface);
+    sptr<PhotoOutput> CreatePhotoOutput(Profile& profile, sptr<IBufferProducer>& surfaceProducer);
 
     /**
     * @brief Create deferred photo processing session.
@@ -334,18 +334,19 @@ public:
      * @brief Create photo output instance.
      *
      * @param profile photo profile.
-     * @param surface photo buffer surface.
+     * @param surfaceProducer photo buffer surfaceProducer.
      * @param pPhotoOutput pointer to photo output instance.
      * @return Returns error code.
      */
-    int CreatePhotoOutput(Profile& profile, sptr<IBufferProducer>& surface, sptr<PhotoOutput>* pPhotoOutput);
+    int CreatePhotoOutput(Profile& profile, sptr<IBufferProducer>& surfaceProducer, sptr<PhotoOutput>* pPhotoOutput);
 
     /**
      * @brief Create photo output instance.
      *
      * @param profile photo profile.
-     * @param surface photo buffer surface.
+     * @param surfaceProducer photo buffer surfaceProducer.
      * @param pPhotoOutput pointer to photo output instance.
+     * @param photoSurface photo buffer surface.
      * @return Returns error code.
      */
     int CreatePhotoOutput(Profile &profile, sptr<IBufferProducer> &surfaceProducer, sptr<PhotoOutput> *pPhotoOutput,
@@ -363,38 +364,38 @@ public:
     /**
      * @brief Create photo output instance without profile.
      *
-     * @param surface photo buffer surface.
+     * @param surfaceProducer photo buffer surfaceProducer.
      * @param pPhotoOutput pointer to photo output instance.
      * @return Returns error code.
      */
-    int CreatePhotoOutputWithoutProfile(sptr<IBufferProducer> surface, sptr<PhotoOutput>* pPhotoOutput);
+    int CreatePhotoOutputWithoutProfile(sptr<IBufferProducer> surfaceProducer, sptr<PhotoOutput>* pPhotoOutput);
 
     /**
      * @brief Create photo output instance without profile.
      *
-     * @param surface photo buffer surface.
+     * @param surfaceProducer photo buffer surfaceProducer.
      * @param pPhotoOutput pointer to photo output instance.
+     * @param photoSurface photo buffer surface.
      * @return Returns error code.
      */
-    int CreatePhotoOutputWithoutProfile(sptr<IBufferProducer> surface,
-        sptr<PhotoOutput>* pPhotoOutput, sptr<Surface> photoSurface);
+    int CreatePhotoOutputWithoutProfile(sptr<IBufferProducer> surfaceProducer, sptr<PhotoOutput>* pPhotoOutput,
+                                        sptr<Surface> photoSurface);
 
     /**
      * @brief Create photo output instance without profile.
      *
-     * @param surfaceId photo buffer surface id.
      * @param pPhotoOutput pointer to photo output instance.
      * @return Returns error code.
      */
-    int CreatePhotoOutputWithoutProfile(std::string surfaceId, sptr<PhotoOutput>* pPhotoOutput);
+    int CreatePhotoOutputWithoutProfile(sptr<PhotoOutput>* pPhotoOutput);
 
     /**
-     * @brief Create photo output instance using surface.
+     * @brief Create photo output instance using surfaceProducer.
      *
-     * @param The surface to be used for photo output.
+     * @param The surfaceProducer to be used for photo output.
      * @return Returns pointer to photo output instance.
      */
-    [[deprecated]] sptr<PhotoOutput> CreatePhotoOutput(sptr<IBufferProducer>& surface);
+    [[deprecated]] sptr<PhotoOutput> CreatePhotoOutput(sptr<IBufferProducer>& surfaceProducer);
 
     /**
      * @brief Create photo output instance using IBufferProducer.
@@ -403,7 +404,8 @@ public:
      * @param The format to be used for photo capture.
      * @return Returns pointer to photo output instance.
      */
-    [[deprecated]] sptr<PhotoOutput> CreatePhotoOutput(const sptr<OHOS::IBufferProducer>& producer, int32_t format);
+    [[deprecated]] sptr<PhotoOutput> CreatePhotoOutput(
+        const sptr<OHOS::IBufferProducer> &surfaceProducer, int32_t format);
 
     /**
      * @brief Create video output instance using surface.
@@ -552,11 +554,11 @@ public:
      * @brief Get stream depth data from service.
      *
      * @param depthProfile depth profile.
-     * @param surface depth data buffer surface.
+     * @param surfaceProducer depth data buffer surfaceProducer.
      * @param streamDepthData pointer to depth data stream.
      * @return Returns error code.
      */
-    int GetStreamDepthDataFromService(DepthProfile& depthProfile, sptr<IBufferProducer> &surface,
+    int GetStreamDepthDataFromService(DepthProfile& depthProfile, sptr<IBufferProducer> &surfaceProducer,
         sptr<IStreamDepthData>& streamDepthData);
 
     /**
@@ -895,8 +897,7 @@ public:
     int32_t CreatePhotoOutputStream(
         sptr<IStreamCapture>& streamPtr, Profile& profile, const sptr<OHOS::IBufferProducer>& producer);
 
-    int32_t CreatePhotoOutputStream(
-        sptr<IStreamCapture>& streamPtr, Profile& profile, std::string surfaceId);
+    int32_t CreatePhotoOutputStream(sptr<IStreamCapture>& streamPtr, Profile& profile);
     /**
     * @brief clear remote stub obj.
     *
diff --git a/interfaces/inner_api/native/camera/include/output/photo_output.h b/interfaces/inner_api/native/camera/include/output/photo_output.h
index 359dc0260..a0a5896e0 100644
--- a/interfaces/inner_api/native/camera/include/output/photo_output.h
+++ b/interfaces/inner_api/native/camera/include/output/photo_output.h
@@ -36,6 +36,7 @@ class PictureIntf;
 class PhotoAvailableCallback;
 class PhotoAssetAvailableCallback;
 class ThumbnailCallback;
+class PhotoNativeConsumer;
 class PhotoStateCallback {
 public:
     PhotoStateCallback() = default;
@@ -555,11 +556,12 @@ public:
     std::atomic<bool> isRawImageDelivery_ = false;
     std::map<int32_t, captureMonitorInfo> captureIdToCaptureInfoMap_;
 
+    uint8_t callbackFlag_ = CAPTURE_DEFERRED_PHOTO;
 private:
     std::mutex callbackMutex_;
     std::mutex offlineStatusMutex_;
-    uint8_t callbackFlag_ = CAPTURE_DEFERRED_PHOTO;
     bool isNativeSurface_ = false;
+    bool isSurfaceOnService_ = false;
     DeferredDeliveryImageType deferredType_ = DeferredDeliveryImageType::DELIVERY_NONE;
     std::shared_ptr<PhotoStateCallback> appCallback_;
     std::shared_ptr<PhotoAvailableCallback> appPhotoCallback_;
@@ -570,10 +572,17 @@ private:
     sptr<IStreamCapturePhotoAssetCallback> svcPhotoAssetCallback_;
     sptr<IStreamCaptureThumbnailCallback> svcThumbnailCallback_;
     std::shared_ptr<PhotoCaptureSetting> defaultCaptureSetting_;
+    sptr<PhotoNativeConsumer> photoNativeConsumer_;
     void CameraServerDied(pid_t pid) override;
     bool mIsHasEnableOfflinePhoto_ = false;
     bool isHasSwitched_ = false;
     bool isDepthBufferSupported_ = false;
+    enum ReSetFlag { NO_NEED_RESET = 0, RESET_PHOTO, RESET_PHOTO_ASSET };
+    ReSetFlag reSetFlag_ = NO_NEED_RESET;
+    void ReSetSavedCallback();
+    void SetPhotoNativeConsumer();
+    void SetPhotoAvailableInSvc();
+    void SetPhotoAssetAvailableInSvc();
 };
 
 class HStreamCaptureCallbackImpl : public StreamCaptureCallbackStub {
diff --git a/interfaces/inner_api/native/camera/include/output/photo_output_callback.h b/interfaces/inner_api/native/camera/include/output/photo_output_callback.h
index 1d9617c0b..8ba715676 100644
--- a/interfaces/inner_api/native/camera/include/output/photo_output_callback.h
+++ b/interfaces/inner_api/native/camera/include/output/photo_output_callback.h
@@ -26,6 +26,9 @@
 namespace OHOS {
 namespace CameraStandard {
 class PhotoOutput;
+namespace DeferredProcessing {
+class TaskManager;
+}
 class PhotoAvailableCallback {
 public:
     PhotoAvailableCallback() = default;
@@ -136,6 +139,25 @@ private:
 
     wptr<PhotoOutput> innerPhotoOutput_ = nullptr;
 };
+
+class PhotoNativeConsumer : public IBufferConsumerListener {
+public:
+    explicit PhotoNativeConsumer(wptr<PhotoOutput> photoOutput);
+    ~PhotoNativeConsumer() override;
+    void OnBufferAvailable() override;
+    void ClearTaskManager();
+    std::shared_ptr<DeferredProcessing::TaskManager> GetDefaultTaskManager();
+
+private:
+    void ExecuteOnBufferAvailable();
+    void ExecutePhotoAvailable(sptr<SurfaceBuffer> surfaceBuffer, int64_t timestamp);
+    void ExecutePhotoAssetAvailable(sptr<SurfaceBuffer> surfaceBuffer, int64_t timestamp);
+
+    std::mutex taskManagerMutex_;
+    std::shared_ptr<DeferredProcessing::TaskManager> taskManager_ = nullptr;
+
+    wptr<PhotoOutput> innerPhotoOutput_ = nullptr;
+};
 } // namespace CameraStandard
 } // namespace OHOS
 #endif // OHOS_CAMERA_PHOTO_OUTPUT_CALLBACK_H
diff --git a/services/camera_service/idls/IStreamCapture.idl b/services/camera_service/idls/IStreamCapture.idl
index 9a04b698f..4f1ba1641 100644
--- a/services/camera_service/idls/IStreamCapture.idl
+++ b/services/camera_service/idls/IStreamCapture.idl
@@ -51,4 +51,5 @@ interface IStreamCapture extends IStreamCommon {
   [ipccode 21] void UnSetPhotoAvailableCallback();
   [ipccode 22] void UnSetPhotoAssetAvailableCallback();
   [ipccode 23] void UnSetThumbnailCallback();
+  [ipccode 24] void CreateMediaLibrary([in] sptr<CameraPhotoProxy> photoProxy, [out] String uri, [out] int cameraShotType, [out] String burstKey, [in] long timestamp);
 }
\ No newline at end of file
diff --git a/services/camera_service/include/hstream_capture.h b/services/camera_service/include/hstream_capture.h
index db5d5ed6f..154288823 100644
--- a/services/camera_service/include/hstream_capture.h
+++ b/services/camera_service/include/hstream_capture.h
@@ -129,6 +129,8 @@ public:
     void SwitchToOffline();
     bool IsHasSwitchToOffline();
     void SetStreamOperator(wptr<HStreamOperator> hStreamOperator);
+    int32_t CreateMediaLibrary(const sptr<CameraPhotoProxy>& photoProxy, std::string& uri, int32_t& cameraShotType,
+        std::string& burstKey, int64_t timestamp) override;
     int32_t CreateMediaLibrary(sptr<CameraServerPhotoProxy>& photoProxy, std::string& uri, int32_t& cameraShotType,
         std::string& burstKey, int64_t timestamp);
     int32_t CreateMediaLibrary(std::shared_ptr<PictureIntf> picture, sptr<CameraServerPhotoProxy> &photoProxy,
diff --git a/services/camera_service/src/hstream_capture.cpp b/services/camera_service/src/hstream_capture.cpp
index 2e5ec3499..a48b25df8 100644
--- a/services/camera_service/src/hstream_capture.cpp
+++ b/services/camera_service/src/hstream_capture.cpp
@@ -1516,6 +1516,23 @@ int32_t HStreamCapture::CreateMediaLibrary(sptr<CameraServerPhotoProxy> &cameraP
     }
     return CAMERA_OK;
 }
+
+int32_t HStreamCapture::CreateMediaLibrary(const sptr<CameraPhotoProxy> &photoProxy, std::string &uri,
+    int32_t &cameraShotType, std::string &burstKey, int64_t timestamp)
+{
+    MessageParcel data;
+    photoProxy->WriteToParcel(data);
+    photoProxy->CameraFreeBufferHandle();
+    sptr<CameraServerPhotoProxy> cameraPhotoProxy = new CameraServerPhotoProxy();
+    cameraPhotoProxy->ReadFromParcel(data);
+    auto hStreamOperatorSptr_ = hStreamOperator_.promote();
+    CHECK_RETURN_RET_ELOG(!hStreamOperatorSptr_, CAMERA_UNKNOWN_ERROR, "CreateMediaLibrary with null operator");
+    CHECK_RETURN_RET_ELOG(!cameraPhotoProxy, CAMERA_UNKNOWN_ERROR, "CreateMediaLibrary with null photoProxy");
+    cameraPhotoProxy->SetLatitude(latitude_);
+    cameraPhotoProxy->SetLongitude(longitude_);
+    hStreamOperatorSptr_->CreateMediaLibrary(cameraPhotoProxy, uri, cameraShotType, burstKey, timestamp);
+    return CAMERA_OK;
+}
 // LCOV_EXCL_STOP
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/test/fuzztest/hstreamcapturestub_fuzzer/hstream_capture_stub_fuzzer.h b/test/fuzztest/hstreamcapturestub_fuzzer/hstream_capture_stub_fuzzer.h
index fc1369aa7..cbc8bc629 100644
--- a/test/fuzztest/hstreamcapturestub_fuzzer/hstream_capture_stub_fuzzer.h
+++ b/test/fuzztest/hstreamcapturestub_fuzzer/hstream_capture_stub_fuzzer.h
@@ -119,6 +119,11 @@ public:
     {
         return 0;
     }
+    ErrCode CreateMediaLibrary(const sptr<CameraPhotoProxy>& photoProxy, std::string& uri, int32_t& cameraShotType,
+        std::string& burstKey, int64_t timestamp) override
+    {
+        return 0;
+    }
 };
 class HStreamCaptureStubFuzzer {
 public:
