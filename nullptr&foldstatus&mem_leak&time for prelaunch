From e7a4ade850c138b0f1c06f87bc99a655d0473e01 Mon Sep 17 00:00:00 2001
From: f00880772 <f00880772@notesmail.huawei.com/>
Date: Sat, 12 Apr 2025 10:28:45 +0800
Subject: [PATCH] TicketNo: DTS2025041121827 Description:modify session
 abnormal release befor close camera Team:EMUI Feature or Bugfix:Bugfix Binary
 Source: sync from gitee PrivateCode(Yes/No):No ------ DO NOT MODIFY,
 AUTO-GENERATED! ------ Gitee-Issue: #IBZ6P3 Time:
 "2025-04-07T14:16:40.370171Z" PR-Num: 3097 Gitee-PR:
 https://openharmony.gitee.com/openharmony/multimedia_camera_framework/pulls/3097

Change-Id: Ife70f44be70b349ff94201e630c6dea9a2a770bf
---
 .../camera_service/include/hcapture_session.h | 13 +++-
 .../camera_service/include/hstream_operator.h |  2 +-
 .../camera_service/src/hcamera_device.cpp     |  9 ++-
 .../src/hcamera_host_manager.cpp              | 11 ++-
 .../camera_service/src/hcamera_service.cpp    |  4 --
 .../camera_service/src/hcapture_session.cpp   | 71 +++++++++++--------
 .../camera_service/src/hstream_operator.cpp   | 11 +--
 7 files changed, 76 insertions(+), 45 deletions(-)

diff --git a/services/camera_service/include/hcapture_session.h b/services/camera_service/include/hcapture_session.h
index 999845bb9..164126958 100644
--- a/services/camera_service/include/hcapture_session.h
+++ b/services/camera_service/include/hcapture_session.h
@@ -162,6 +162,16 @@ public:
             hStreamOperatorSptr->SetCameraDevice(cameraDevice_);
         }
     }
+
+    inline sptr<HStreamOperator> GetStreamOperator()
+    {
+        std::lock_guard<std::mutex> lock(streamOperatorLock_);
+        if (hStreamOperator_ == nullptr) {
+            return nullptr;
+        }
+        return hStreamOperator_.promote();
+    }
+
     void SetCameraRotateStrategyInfos(std::vector<CameraRotateStrategyInfo> infos);
     std::vector<CameraRotateStrategyInfo> GetCameraRotateStrategyInfos();
     void UpdateCameraRotateAngleAndZoom(std::vector<CameraRotateStrategyInfo> &infos,
@@ -206,6 +216,7 @@ private:
     bool IsNeedDynamicConfig();
     void ClearMovingPhotoRepeatStream();
     int32_t SetHasFitedRotation(bool isHasFitedRotation) override;
+    void InitialHStreamOperator();
     StateMachine stateMachine_;
 
 #ifdef CAMERA_USE_SENSOR
@@ -235,7 +246,7 @@ private:
     bool isSessionStarted_ = false;
     bool isDynamicConfiged_ = false;
     std::string deviceClass_ = "phone";
-    wptr<HStreamOperator> hStreamOperator_;
+    wptr<HStreamOperator> hStreamOperator_ = nullptr;
     std::mutex cameraRotateStrategyInfosLock_;
     std::vector<CameraRotateStrategyInfo> cameraRotateStrategyInfos_;
     bool isHasFitedRotation_ = false;
diff --git a/services/camera_service/include/hstream_operator.h b/services/camera_service/include/hstream_operator.h
index 3b296250d..da429b973 100644
--- a/services/camera_service/include/hstream_operator.h
+++ b/services/camera_service/include/hstream_operator.h
@@ -342,7 +342,7 @@ private:
     sptr<MovingPhotoVideoCache> videoCache_;
     std::mutex displayListenerLock_;
     sptr<DisplayRotationListener> displayListener_;
-    sptr<OHOS::HDI::Camera::V1_0::IStreamOperator> streamOperator_;
+    sptr<OHOS::HDI::Camera::V1_0::IStreamOperator> streamOperator_ = nullptr;
     bool isOfflineStreamOperator_ =  false;
     int32_t mlastCaptureId = 0;
     int32_t sensorRotation_ = 0;
diff --git a/services/camera_service/src/hcamera_device.cpp b/services/camera_service/src/hcamera_device.cpp
index ddb30539e..8700233a4 100644
--- a/services/camera_service/src/hcamera_device.cpp
+++ b/services/camera_service/src/hcamera_device.cpp
@@ -126,8 +126,8 @@ public:
     virtual ~FoldScreenListener() = default;
     void OnFoldStatusChanged(OHOS::Rosen::FoldStatus foldStatus) override
     {
-        FoldStatus currentFoldStatus = FoldStatus::UNKNOWN_FOLD;
-        if (foldStatus == OHOS::Rosen::FoldStatus::HALF_FOLD) {
+        FoldStatus currentFoldStatus = static_cast<FoldStatus>(foldStatus);
+        if (currentFoldStatus == FoldStatus::HALF_FOLD) {
             currentFoldStatus = FoldStatus::EXPAND;
         }
         if (cameraHostManager_ == nullptr || mLastFoldStatus == currentFoldStatus) {
@@ -1078,7 +1078,10 @@ void HCameraDevice::RegisterFoldStatusListener()
 {
     listener = new FoldScreenListener(cameraHostManager_, cameraID_);
     if (cameraHostManager_) {
-        int foldStatus = (int)OHOS::Rosen::DisplayManagerLite::GetInstance().GetFoldStatus();
+        int foldStatus = static_cast<int>(OHOS::Rosen::DisplayManagerLite::GetInstance().GetFoldStatus());
+        if (foldStatus == FoldStatus::HALF_FOLD) {
+            foldStatus = FoldStatus::EXPAND;
+        }
         cameraHostManager_->NotifyDeviceStateChangeInfo(DeviceType::FOLD_TYPE, foldStatus);
     }
     auto ret = OHOS::Rosen::DisplayManagerLite::GetInstance().RegisterFoldStatusListener(listener);
diff --git a/services/camera_service/src/hcamera_host_manager.cpp b/services/camera_service/src/hcamera_host_manager.cpp
index 3bd80144d..599daf934 100644
--- a/services/camera_service/src/hcamera_host_manager.cpp
+++ b/services/camera_service/src/hcamera_host_manager.cpp
@@ -1070,9 +1070,14 @@ void HCameraHostManager::UpdateRestoreParam(sptr<HCameraRestoreParam> &cameraRes
         if (closeTime.tv_sec != 0 && CheckCameraId(restoreParam, cameraId)) {
             timeval openTime;
             gettimeofday(&openTime, nullptr);
-            long timeInterval = (openTime.tv_sec - closeTime.tv_sec) * MILLISEC_TIME +
-                (openTime.tv_usec - closeTime.tv_usec) / MILLISEC_TIME;
-            if ((long)(restoreParam->GetStartActiveTime() * 60 * MILLISEC_TIME) < timeInterval) { // 60 is 60 Seconds
+            int64_t sec_diff = openTime.tv_sec - closeTime.tv_sec;
+            int64_t usec_diff = openTime.tv_usec - closeTime.tv_usec;
+            if (usec_diff < 0) {
+                sec_diff -= 1;
+                usec_diff += MILLISEC_TIME * MILLISEC_TIME;
+            }
+            int64_t timeInterval = sec_diff * MILLISEC_TIME + usec_diff / MILLISEC_TIME;
+            if ((restoreParam->GetStartActiveTime() * 60 * MILLISEC_TIME) < timeInterval) { // 60 is 60 Seconds
                 MEDIA_DEBUG_LOG("HCameraHostManager::UpdateRestoreParam get persistent");
                 cameraRestoreParam = restoreParam;
             } else {
diff --git a/services/camera_service/src/hcamera_service.cpp b/services/camera_service/src/hcamera_service.cpp
index 918a137f6..828fab35a 100644
--- a/services/camera_service/src/hcamera_service.cpp
+++ b/services/camera_service/src/hcamera_service.cpp
@@ -545,10 +545,6 @@ int32_t HCameraService::CreateCaptureSession(sptr<ICaptureSession>& session, int
     session = captureSession;
     pid_t pid = IPCSkeleton::GetCallingPid();
     captureSessionsManager_.EnsureInsert(pid, captureSession);
-
-    sptr<HStreamOperator> hStreamOperator = HStreamOperator::NewInstance(callerToken, opMode);
-    captureSession->SetStreamOperator(hStreamOperator);
-    HStreamOperatorManager::GetInstance()->AddStreamOperator(hStreamOperator); // 鍗曚緥绠＄悊streamoperator 寰呮壘鍞竴key
     return rc;
 }
 
diff --git a/services/camera_service/src/hcapture_session.cpp b/services/camera_service/src/hcapture_session.cpp
index 79eb28cc3..4aa11a67d 100644
--- a/services/camera_service/src/hcapture_session.cpp
+++ b/services/camera_service/src/hcapture_session.cpp
@@ -78,6 +78,7 @@
 #include "surface_buffer.h"
 #include "system_ability_definition.h"
 #include "v1_0/types.h"
+#include "hstream_operator_manager.h"
 
 using namespace OHOS::AAFwk;
 namespace OHOS {
@@ -163,6 +164,7 @@ HCaptureSession::HCaptureSession(const uint32_t callingTokenId, int32_t opMode)
     sessionId_ = GenerateSessionId();
     callerToken_ = callingTokenId;
     opMode_ = opMode;
+    InitialHStreamOperator();
 }
 
 HCaptureSession::~HCaptureSession()
@@ -189,7 +191,7 @@ int32_t HCaptureSession::GetopMode()
 
 int32_t HCaptureSession::GetCurrentStreamInfos(std::vector<StreamInfo_V1_1>& streamInfos)
 {
-    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    auto hStreamOperatorSptr = GetStreamOperator();
     CHECK_ERROR_RETURN_RET_LOG(hStreamOperatorSptr == nullptr, CAMERA_INVALID_ARG,
         "hStreamOperator_ is null");
     return hStreamOperatorSptr->GetCurrentStreamInfos(streamInfos);
@@ -228,6 +230,7 @@ int32_t HCaptureSession::BeginConfig()
     CAMERA_SYNC_TRACE;
     int32_t errCode;
     MEDIA_INFO_LOG("HCaptureSession::BeginConfig prepare execute, sessionID: %{public}d", GetSessionId());
+    InitialHStreamOperator();
     stateMachine_.StateGuard([&errCode, this](const CaptureSessionState state) {
         DynamicConfigStream();
         bool isStateValid = stateMachine_.Transfer(CaptureSessionState::SESSION_CONFIG_INPROGRESS);
@@ -240,7 +243,7 @@ int32_t HCaptureSession::BeginConfig()
             isDynamicConfiged_ = false;
             return;
         }
-        auto hStreamOperatorSptr = hStreamOperator_.promote();
+        auto hStreamOperatorSptr = GetStreamOperator();
         CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr, "hStreamOperator_ is null");
         if (!IsNeedDynamicConfig() && (hStreamOperatorSptr->GetOfflineOutptSize() == 0)) {
             UnlinkInputAndOutputs();
@@ -322,9 +325,6 @@ int32_t HCaptureSession::AddInput(sptr<ICameraDeviceService> cameraDevice)
         sptr<HCameraDevice> hCameraDevice = static_cast<HCameraDevice*>(cameraDevice.GetRefPtr());
         MEDIA_INFO_LOG("HCaptureSession::AddInput device:%{public}s", hCameraDevice->GetCameraId().c_str());
         SetCameraDevice(hCameraDevice);
-        auto hStreamOperatorSptr = hStreamOperator_.promote();
-        CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr, "hStreamOperator_ is null");
-        hStreamOperatorSptr->ResetHdiStreamId();
         hCameraDevice->DispatchDefaultSettingToHdi();
     });
     if (errorCode == CAMERA_OK) {
@@ -341,7 +341,7 @@ void HCaptureSession::BeforeDeviceClose()
 {
     MEDIA_INFO_LOG("HCaptureSession::BeforeDeviceClose UnlinkInputAndOutputs");
     UnlinkInputAndOutputs();
-    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    auto hStreamOperatorSptr = GetStreamOperator();
     CHECK_ERROR_RETURN_LOG(
         hStreamOperatorSptr == nullptr, "HCaptureSession::BeforeDeviceClose hStreamOperatorSptr is null");
     if (!hStreamOperatorSptr->IsOfflineCapture()) {
@@ -398,13 +398,23 @@ public:
 
 int32_t HCaptureSession::SetPreviewRotation(std::string &deviceClass)
 {
-    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    auto hStreamOperatorSptr = GetStreamOperator();
     CHECK_ERROR_RETURN_RET_LOG(hStreamOperatorSptr == nullptr, CAMERA_INVALID_ARG,
         "hStreamOperator_ is null");
     hStreamOperatorSptr->SetPreviewRotation(deviceClass);
     return CAMERA_OK;
 }
 
+void HCaptureSession::InitialHStreamOperator()
+{
+    auto hStreamOperatorTemp = GetStreamOperator();
+    if (hStreamOperatorTemp == nullptr) {
+        sptr<HStreamOperator> hStreamOperator = HStreamOperator::NewInstance(callerToken_, opMode_);
+        SetStreamOperator(hStreamOperator);
+        HStreamOperatorManager::GetInstance()->AddStreamOperator(hStreamOperator); // 鍗曚緥绠＄悊streamoperator 寰呮壘鍞竴key
+    }
+}
+
 int32_t HCaptureSession::AddOutput(StreamType streamType, sptr<IStreamCommon> stream)
 {
     int32_t errorCode = CAMERA_INVALID_ARG;
@@ -415,7 +425,8 @@ int32_t HCaptureSession::AddOutput(StreamType streamType, sptr<IStreamCommon> st
         return errorCode;
     }
     stateMachine_.StateGuard([this, &errorCode, streamType, &stream](const CaptureSessionState currentState) {
-        auto hStreamOperatorSptr = hStreamOperator_.promote();
+        InitialHStreamOperator();
+        auto hStreamOperatorSptr = GetStreamOperator();
         CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr, "hStreamOperator_ is null");
         if (currentState != CaptureSessionState::SESSION_CONFIG_INPROGRESS) {
             MEDIA_ERR_LOG("HCaptureSession::AddOutput Need to call BeginConfig "
@@ -499,7 +510,7 @@ int32_t HCaptureSession::RemoveOutputStream(sptr<HStreamCommon> stream)
         stream == nullptr, CAMERA_INVALID_ARG, "HCaptureSession::RemoveOutputStream stream is null");
     MEDIA_INFO_LOG("HCaptureSession::RemoveOutputStream,streamType:%{public}d, streamId:%{public}d",
         stream->GetStreamType(), stream->GetFwkStreamId());
-    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    auto hStreamOperatorSptr = GetStreamOperator();
     CHECK_ERROR_RETURN_RET_LOG(hStreamOperatorSptr == nullptr, CAMERA_INVALID_ARG,
         "hStreamOperatorSptr is null");
     int32_t errorCode = hStreamOperatorSptr->RemoveOutputStream(stream);
@@ -526,7 +537,7 @@ int32_t HCaptureSession::RemoveOutput(StreamType streamType, sptr<IStreamCommon>
             errorCode = CAMERA_INVALID_STATE;
             return;
         }
-        auto hStreamOperatorSptr = hStreamOperator_.promote();
+        auto hStreamOperatorSptr = GetStreamOperator();
         CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr, "hStreamOperatorSptr is null");
         errorCode = hStreamOperatorSptr->RemoveOutput(streamType, stream);
     });
@@ -553,7 +564,7 @@ int32_t HCaptureSession::ValidateSessionInputs()
 
 int32_t HCaptureSession::ValidateSessionOutputs()
 {
-    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    auto hStreamOperatorSptr = GetStreamOperator();
     CHECK_ERROR_RETURN_RET_LOG((hStreamOperatorSptr == nullptr || hStreamOperatorSptr->GetStreamsSize() == 0),
         CAMERA_INVALID_SESSION_CFG, "HCaptureSession::ValidateSessionOutputs No outputs present");
     return CAMERA_OK;
@@ -562,7 +573,7 @@ int32_t HCaptureSession::ValidateSessionOutputs()
 int32_t HCaptureSession::LinkInputAndOutputs()
 {
     int32_t rc;
-    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    auto hStreamOperatorSptr = GetStreamOperator();
     CHECK_ERROR_RETURN_RET_LOG(hStreamOperatorSptr == nullptr, CAMERA_INVALID_SESSION_CFG,
         "HCaptureSession::ValidateSessionOutputs No outputs present");
     auto device = GetCameraDevice();
@@ -582,7 +593,7 @@ int32_t HCaptureSession::UnlinkInputAndOutputs()
 {
     CAMERA_SYNC_TRACE;
     int32_t rc = CAMERA_UNKNOWN_ERROR;
-    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    auto hStreamOperatorSptr = GetStreamOperator();
     CHECK_ERROR_RETURN_RET_LOG(hStreamOperatorSptr == nullptr,  rc,
         "HCaptureSession::ValidateSessionOutputs No outputs present");
     rc = hStreamOperatorSptr->UnlinkInputAndOutputs();
@@ -593,7 +604,7 @@ int32_t HCaptureSession::UnlinkInputAndOutputs()
 void HCaptureSession::ExpandSketchRepeatStream()
 {
     MEDIA_DEBUG_LOG("Enter HCaptureSession::ExpandSketchRepeatStream()");
-    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    auto hStreamOperatorSptr = GetStreamOperator();
     CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr,
         "HCaptureSession::ValidateSessionOutputs No outputs present");
     hStreamOperatorSptr->ExpandSketchRepeatStream();
@@ -609,7 +620,7 @@ void HCaptureSession::ExpandMovingPhotoRepeatStream()
         MEDIA_DEBUG_LOG("movingPhoto is not supported");
         return;
     }
-    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    auto hStreamOperatorSptr = GetStreamOperator();
     CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr,
         "HCaptureSession::ValidateSessionOutputs No outputs present");
     hStreamOperatorSptr->ExpandMovingPhotoRepeatStream();
@@ -620,7 +631,7 @@ void HCaptureSession::ClearSketchRepeatStream()
 {
     MEDIA_DEBUG_LOG("Enter HCaptureSession::ClearSketchRepeatStream(), sessionID: %{public}d", GetSessionId());
 
-    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    auto hStreamOperatorSptr = GetStreamOperator();
     CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr, "hStreamOperator is nullptr");
     return hStreamOperatorSptr->ClearSketchRepeatStream();
 }
@@ -629,7 +640,7 @@ void HCaptureSession::ClearMovingPhotoRepeatStream()
 {
     CAMERA_SYNC_TRACE;
     MEDIA_DEBUG_LOG("Enter HCaptureSession::ClearMovingPhotoRepeatStream()");
-    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    auto hStreamOperatorSptr = GetStreamOperator();
     CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr, "hStreamOperator is nullptr");
     return hStreamOperatorSptr->ClearMovingPhotoRepeatStream();
 }
@@ -667,7 +678,7 @@ int32_t HCaptureSession::CommitConfig()
             stateMachine_.Transfer(CaptureSessionState::SESSION_CONFIG_COMMITTED);
             return;
         }
-        auto hStreamOperatorSptr = hStreamOperator_.promote();
+        auto hStreamOperatorSptr = GetStreamOperator();
         CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr, "hStreamOperator is nullptr");
         hStreamOperatorSptr->GetStreamOperator();
         errorCode = ValidateSession();
@@ -713,7 +724,7 @@ int32_t HCaptureSession::CommitConfig()
 
 int32_t HCaptureSession::GetActiveColorSpace(ColorSpace& colorSpace)
 {
-    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    auto hStreamOperatorSptr = GetStreamOperator();
     CHECK_ERROR_RETURN_RET_LOG(hStreamOperatorSptr == nullptr, CAMERA_OK, "hStreamOperator is nullptr");
     hStreamOperatorSptr->GetActiveColorSpace(colorSpace);
     return CAMERA_OK;
@@ -735,7 +746,7 @@ int32_t HCaptureSession::SetColorSpace(ColorSpace colorSpace, bool isNeedUpdate)
                 return;
             }
 
-            auto hStreamOperatorSptr = hStreamOperator_.promote();
+            auto hStreamOperatorSptr = GetStreamOperator();
             CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr, "hStreamOperator is nullptr");
             result = hStreamOperatorSptr->SetColorSpace(colorSpace, isNeedUpdate);
             if (result != CAMERA_OK && isNeedUpdate) {
@@ -1059,7 +1070,7 @@ void HCaptureSession::ProcessMetaZoomArray(std::vector<uint32_t>& zoomAndTimeArr
 
 int32_t HCaptureSession::EnableMovingPhoto(bool isEnable)
 {
-    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    auto hStreamOperatorSptr = GetStreamOperator();
     CHECK_ERROR_RETURN_RET_LOG(hStreamOperatorSptr == nullptr, CAMERA_OK, "hStreamOperatorSptr is null");
     std::shared_ptr<OHOS::Camera::CameraMetadata> settings = nullptr;
     auto cameraDevice = GetCameraDevice();
@@ -1100,7 +1111,7 @@ int32_t HCaptureSession::Start()
             UpdateMuteSetting(cameraDevice->GetDeviceMuteMode(), settings);
         }
         camera_position_enum_t cameraPosition = static_cast<camera_position_enum_t>(usedAsPositionU8);
-        auto hStreamOperatorSptr = hStreamOperator_.promote();
+        auto hStreamOperatorSptr = GetStreamOperator();
         CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr, "hStreamOperatorSptr is null");
         if (OHOS::Rosen::DisplayManagerLite::GetInstance().GetFoldStatus() == OHOS::Rosen::FoldStatus::FOLDED &&
             !isHasFitedRotation_) {
@@ -1147,7 +1158,7 @@ int32_t HCaptureSession::Stop()
             errorCode = CAMERA_INVALID_STATE;
             return;
         }
-        auto hStreamOperatorSptr = hStreamOperator_.promote();
+        auto hStreamOperatorSptr = GetStreamOperator();
         if (hStreamOperatorSptr == nullptr) {
             MEDIA_ERR_LOG("hStreamOperatorSptr is null");
             errorCode = CAMERA_INVALID_STATE;
@@ -1188,7 +1199,7 @@ int32_t HCaptureSession::Release(CaptureSessionReleaseType type)
             MEDIA_DEBUG_LOG("HCaptureSession::Release clear pid left sessions(%{public}zu).",
                 HCameraSessionManager::GetInstance().GetTotalSessionSize());
         }
-        auto hStreamOperatorSptr = hStreamOperator_.promote();
+        auto hStreamOperatorSptr = GetStreamOperator();
         CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr, "hStreamOperatorSptr is null");
         // stop movingPhoto
         hStreamOperatorSptr->StopMovingPhoto();
@@ -1202,6 +1213,10 @@ int32_t HCaptureSession::Release(CaptureSessionReleaseType type)
             cameraDevice->Release();
             SetCameraDevice(nullptr);
         }
+
+        if ((hStreamOperatorSptr->GetAllOutptSize()) == 0) {
+            hStreamOperatorSptr->Release();
+        }
         sptr<ICaptureSessionCallback> emptyCallback = nullptr;
         SetCallback(emptyCallback);
         stateMachine_.Transfer(CaptureSessionState::SESSION_RELEASED);
@@ -1297,7 +1312,7 @@ void HCaptureSession::DumpSessionInfo(CameraInfoDumper& infoDumper)
 {
     infoDumper.Msg("Client pid:[" + std::to_string(pid_) + "]    Client uid:[" + std::to_string(uid_) + "]");
     infoDumper.Msg("session state:[" + GetSessionState() + "]");
-    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    auto hStreamOperatorSptr = GetStreamOperator();
     CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr, "hStreamOperatorSptr is null");
     for (auto& stream : hStreamOperatorSptr->GetAllStreams()) {
         infoDumper.Push();
@@ -1308,7 +1323,7 @@ void HCaptureSession::DumpSessionInfo(CameraInfoDumper& infoDumper)
 
 int32_t HCaptureSession::EnableMovingPhotoMirror(bool isMirror, bool isConfig)
 {
-    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    auto hStreamOperatorSptr = GetStreamOperator();
     CHECK_ERROR_RETURN_RET_LOG(hStreamOperatorSptr == nullptr, CAMERA_OK, "hStreamOperatorSptr is null");
     hStreamOperatorSptr->EnableMovingPhotoMirror(isMirror, isConfig);
     return CAMERA_OK;
@@ -1316,7 +1331,7 @@ int32_t HCaptureSession::EnableMovingPhotoMirror(bool isMirror, bool isConfig)
 
 void HCaptureSession::GetOutputStatus(int32_t& status)
 {
-    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    auto hStreamOperatorSptr = GetStreamOperator();
     CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr, "hStreamOperatorSptr is null");
     hStreamOperatorSptr->GetOutputStatus(status);
 }
@@ -1332,7 +1347,7 @@ void HCaptureSession::SetCameraDevice(sptr<HCameraDevice> device)
     }
     cameraDevice_ = device;
 
-    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    auto hStreamOperatorSptr = GetStreamOperator();
     if (hStreamOperatorSptr != nullptr) {
         hStreamOperatorSptr->SetCameraDevice(device);
     }
diff --git a/services/camera_service/src/hstream_operator.cpp b/services/camera_service/src/hstream_operator.cpp
index 5298f5177..8e09e91bf 100644
--- a/services/camera_service/src/hstream_operator.cpp
+++ b/services/camera_service/src/hstream_operator.cpp
@@ -156,6 +156,7 @@ HStreamOperator::HStreamOperator()
 HStreamOperator::HStreamOperator(const uint32_t callingTokenId, int32_t opMode)
 {
     Initialize(callingTokenId, opMode);
+    ResetHdiStreamId();
 }
 
 HStreamOperator::~HStreamOperator()
@@ -415,7 +416,9 @@ void  HStreamOperator::GetStreamOperator()
         return;
     }
     std::lock_guard<std::mutex> lock(streamOperatorLock_);
-    cameraDevice_->GetStreamOperator(this, streamOperator_);
+    if (streamOperator_ == nullptr) {
+        cameraDevice_->GetStreamOperator(this, streamOperator_);
+    }
 }
 
 bool HStreamOperator::IsOfflineCapture()
@@ -981,9 +984,6 @@ void HStreamOperator::ReleaseStreams()
     if (!hdiStreamIds.empty()) {
         ReleaseStreams(hdiStreamIds);
     }
-    if (GetAllOutptSize() == 0) {
-        Release();
-    }
 }
 
 int32_t HStreamOperator::GetOfflineOutptSize()
@@ -1005,7 +1005,7 @@ int32_t HStreamOperator::GetOfflineOutptSize()
 
 int32_t HStreamOperator::GetAllOutptSize()
 {
-    int32_t outputCount = streamContainerOffline_.Size() + streamContainer_.Size();
+    int32_t outputCount = streamContainer_.Size();
     return outputCount;
 }
 
@@ -1129,6 +1129,7 @@ int32_t HStreamOperator::EnableMovingPhotoMirror(bool isMirror, bool isConfig)
                 isMovingPhotoMirror_ = isMirror;
                 // set clear cache flag
                 std::lock_guard<std::mutex> lock(movingPhotoStatusLock_);
+                CHECK_ERROR_RETURN_RET_LOG(livephotoListener_ == nullptr, CAMERA_OK, "livephotoListener_ is null");
                 livephotoListener_->SetClearFlag();
             }
             break;
-- 
2.45.2.huawei.8
