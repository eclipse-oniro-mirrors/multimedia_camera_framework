From 22f7001a2123c852f3c5a86ceda0810519d55f2a Mon Sep 17 00:00:00 2001
From: n00564676 <nimaosen1@huawei.com>
Date: Mon, 26 Aug 2024 14:26:49 +0800
Subject: [PATCH] TicketNo:DTS2024071522780 Description:modify movingphoto
 mirror Team:EMUI Feature or Bugfix:Bugfix Binary Source:No
 PrivateCode(Yes/No):No ------ DO NOT MODIFY, AUTO-GENERATED! ------
 Gitee-Issue: #IAL202 Time: 2024-08-19T13:08:45.183Z PR-Num: 1826 Gitee-PR:
 https://openharmony.gitee.com/openharmony/multimedia_camera_framework/pulls/1826
 cherry picked from commit 05a7f2f7acb04e98391e7ebb71531fbb0fca4494

Change-Id: Ib599ce99f27488dd149fe3477276a997fa10703d
Reviewed-by: n00564676,w00640748
Approved-by: l00512942
Merged-on: https://open.codehub.huawei.com/OpenSourceCenter_CR/openharmony/multimedia_camera_framework/-/change_requests/2496
Merged-by: public hisicitools
---
 .../camera_service/include/hcapture_session.h |  18 ++-
 .../camera_service/include/hstream_repeat.h   |   2 +-
 .../camera_service/src/hcapture_session.cpp   | 137 ++++++++++++++++--
 .../camera_service/src/hstream_repeat.cpp     |   7 +-
 4 files changed, 142 insertions(+), 22 deletions(-)

diff --git a/services/camera_service/include/hcapture_session.h b/services/camera_service/include/hcapture_session.h
index 1f14f22c8..afe120e35 100644
--- a/services/camera_service/include/hcapture_session.h
+++ b/services/camera_service/include/hcapture_session.h
@@ -52,6 +52,10 @@
 #include "drain_manager.h"
 #include "audio_capturer_session.h"
 #include "safe_map.h"
+#ifdef CAMERA_USE_SENSOR
+#include "sensor_agent.h"
+#include "sensor_agent_type.h"
+#endif
 
 namespace OHOS {
 namespace CameraStandard {
@@ -300,12 +304,22 @@ private:
     void UnRegisterDisplayListener(sptr<HStreamRepeat> repeat);
     StateMachine stateMachine_;
 
+    #ifdef CAMERA_USE_SENSOR
+        std::mutex sensorLock_;
+        bool isRegisterSensorSuccess_ = false;
+        void RegisterSensorCallback();
+        void UnRegisterSensorCallback();
+        static void GravityDataCallbackImpl(SensorEvent *event);
+        static int32_t CalcSensorRotation(int32_t sensorDegree);
+        static int32_t CalcRotationDegree(GravityData data);
+    #endif
     // Make sure device thread safe,set device by {SetCameraDevice}, get device by {GetCameraDevice}
     std::mutex cameraDeviceLock_;
     sptr<HCameraDevice> cameraDevice_;
-
     StreamContainer streamContainer_;
-
+    #ifdef CAMERA_USE_SENSOR
+        SensorUser user;
+    #endif
     pid_t pid_;
     uid_t uid_;
     uint32_t callerToken_;
diff --git a/services/camera_service/include/hstream_repeat.h b/services/camera_service/include/hstream_repeat.h
index 5f26e3ad8..3876a9914 100644
--- a/services/camera_service/include/hstream_repeat.h
+++ b/services/camera_service/include/hstream_repeat.h
@@ -78,7 +78,7 @@ public:
     int32_t SetFrameRate(int32_t minFrameRate, int32_t maxFrameRate) override;
     int32_t SetMirror(bool isEnable) override;
     int32_t SetPreviewRotation(std::string &deviceClass);
-    void SetMirrorForLivePhoto(bool isEnable, int32_t mode);
+    bool SetMirrorForLivePhoto(bool isEnable, int32_t mode);
     void SetStreamTransform(int disPlayRotation = -1);
     int32_t AttachMetaSurface(const sptr<OHOS::IBufferProducer>& producer, int32_t videoMetaType) override;
     int32_t SetCameraRotation(bool isEnable, int32_t rotation) override;
diff --git a/services/camera_service/src/hcapture_session.cpp b/services/camera_service/src/hcapture_session.cpp
index ee415424c..4014098a8 100644
--- a/services/camera_service/src/hcapture_session.cpp
+++ b/services/camera_service/src/hcapture_session.cpp
@@ -75,6 +75,12 @@ using namespace OHOS::HDI::Display::Composer::V1_1;
 namespace {
 static std::map<pid_t, sptr<HCaptureSession>> g_totalSessions;
 static std::mutex g_totalSessionLock;
+#ifdef CAMERA_USE_SENSOR
+constexpr int32_t POSTURE_INTERVAL = 100000000; //100ms
+constexpr int VALID_INCLINATION_ANGLE_THRESHOLD_COEFFICIENT = 3;
+#endif
+static GravityData gravityData = {0.0, 0.0, 0.0};
+static int32_t sensorRotation = 0;
 static size_t TotalSessionSize()
 {
     std::lock_guard<std::mutex> lock(g_totalSessionLock);
@@ -1226,6 +1232,13 @@ int32_t HCaptureSession::EnableMovingPhoto(bool isEnable)
 {
     isSetMotionPhoto_ = isEnable;
     StartMovingPhotoStream();
+    #ifdef CAMERA_USE_SENSOR
+    if (isSetMotionPhoto_) {
+        RegisterSensorCallback();
+    } else {
+        UnRegisterSensorCallback();
+    }
+    #endif
     return CAMERA_OK;
 }
 
@@ -1424,6 +1437,11 @@ int32_t HCaptureSession::Release(CaptureSessionReleaseType type)
 
         sptr<ICaptureSessionCallback> emptyCallback = nullptr;
         SetCallback(emptyCallback);
+        #ifdef CAMERA_USE_SENSOR
+        if (isSetMotionPhoto_) {
+            UnRegisterSensorCallback();
+        }
+        #endif
         stateMachine_.Transfer(CaptureSessionState::SESSION_RELEASED);
         isSessionStarted_ = false;
         std::lock_guard<std::mutex> lock(movingPhotoStatusLock_);
@@ -1530,26 +1548,25 @@ void HCaptureSession::DumpSessionInfo(CameraInfoDumper& infoDumper)
 
 int32_t HCaptureSession::StartMovingPhotoCapture(bool isMirror, int32_t rotation)
 {
-    if (!isSetMotionPhoto_) {
+    if (!isSetMotionPhoto_ || isMirror == isMovingPhotoMirror_) {
         return CAMERA_OK;
     }
-    if (isMirror != isMovingPhotoMirror_) {
-        auto repeatStreams = streamContainer_.GetStreams(StreamType::REPEAT);
-        for (auto& stream : repeatStreams) {
-            if (stream == nullptr) {
-                continue;
-            }
-            auto streamRepeat = CastStream<HStreamRepeat>(stream);
-            if (streamRepeat->GetRepeatStreamType() == RepeatStreamType::LIVEPHOTO) {
-                MEDIA_INFO_LOG("restart movingphoto stream.");
-                std::lock_guard<std::mutex> lock(movingPhotoStatusLock_);
-                streamRepeat->SetMirrorForLivePhoto(isMirror, opMode_);
+    auto repeatStreams = streamContainer_.GetStreams(StreamType::REPEAT);
+    for (auto& stream : repeatStreams) {
+        if (stream == nullptr) {
+            continue;
+        }
+        auto streamRepeat = CastStream<HStreamRepeat>(stream);
+        if (streamRepeat->GetRepeatStreamType() == RepeatStreamType::LIVEPHOTO) {
+            MEDIA_INFO_LOG("restart movingphoto stream.");
+            std::lock_guard<std::mutex> lock(movingPhotoStatusLock_);
+            if (streamRepeat->SetMirrorForLivePhoto(isMirror, opMode_)) {
+                isMovingPhotoMirror_ = isMirror;
                 // set clear cache flag
                 livephotoListener_->SetClearFlag();
-                break;
             }
+            break;
         }
-        isMovingPhotoMirror_ = isMirror;
     }
     return CAMERA_OK;
 }
@@ -1571,13 +1588,101 @@ void HCaptureSession::GetOutputStatus(int32_t &status)
     }
 }
 
+#ifdef CAMERA_USE_SENSOR
+void HCaptureSession::RegisterSensorCallback()
+{
+    std::lock_guard<std::mutex> lock(sensorLock_);
+    if (isRegisterSensorSuccess_) {
+        MEDIA_INFO_LOG("HCaptureSession::RegisterSensorCallback isRegisterSensorSuccess return");
+        return;
+    }
+    MEDIA_INFO_LOG("HCaptureSession::RegisterSensorCallback start");
+    user.callback = GravityDataCallbackImpl;
+    int32_t subscribeRet = SubscribeSensor(SENSOR_TYPE_ID_GRAVITY, &user);
+    MEDIA_INFO_LOG("RegisterSensorCallback, subscribeRet: %{public}d", subscribeRet);
+    int32_t setBatchRet = SetBatch(SENSOR_TYPE_ID_GRAVITY, &user, POSTURE_INTERVAL, 0);
+    MEDIA_INFO_LOG("RegisterSensorCallback, setBatchRet: %{public}d", setBatchRet);
+    int32_t activateRet = ActivateSensor(SENSOR_TYPE_ID_GRAVITY, &user);
+    MEDIA_INFO_LOG("RegisterSensorCallback, activateRet: %{public}d", activateRet);
+    if (subscribeRet != CAMERA_OK || setBatchRet != CAMERA_OK || activateRet != CAMERA_OK) {
+        isRegisterSensorSuccess_ = false;
+        MEDIA_INFO_LOG("RegisterSensorCallback failed.");
+    } else {
+        isRegisterSensorSuccess_ = true;
+    }
+}
+
+void HCaptureSession::UnRegisterSensorCallback()
+{
+    std::lock_guard<std::mutex> lock(sensorLock_);
+    int32_t deactivateRet = DeactivateSensor(SENSOR_TYPE_ID_GRAVITY, &user);
+    int32_t unsubscribeRet = UnsubscribeSensor(SENSOR_TYPE_ID_GRAVITY, &user);
+    if (deactivateRet == CAMERA_OK && unsubscribeRet == CAMERA_OK) {
+        MEDIA_INFO_LOG("HCameraService.UnRegisterSensorCallback success.");
+        isRegisterSensorSuccess_ = false;
+    } else {
+        MEDIA_INFO_LOG("HCameraService.UnRegisterSensorCallback failed.");
+    }
+}
+
+void HCaptureSession::GravityDataCallbackImpl(SensorEvent* event)
+{
+    MEDIA_INFO_LOG("GravityDataCallbackImpl prepare execute");
+    CHECK_ERROR_RETURN_LOG(event == nullptr, "SensorEvent is nullptr.");
+    CHECK_ERROR_RETURN_LOG(event[0].data == nullptr, "SensorEvent[0].data is nullptr.");
+    CHECK_ERROR_RETURN_LOG(event->sensorTypeId != SENSOR_TYPE_ID_GRAVITY, "SensorCallback error type.");
+    // this data will be delete when callback execute finish
+    GravityData* nowGravityData = reinterpret_cast<GravityData*>(event->data);
+    gravityData = { nowGravityData->x, nowGravityData->y, nowGravityData->z };
+}
+
+int32_t HCaptureSession::CalcSensorRotation(int32_t sensorDegree)
+{
+    // Use ROTATION_0 when degree range is [0, 30]âˆª[330, 359]
+    if (sensorDegree >= 0 && (sensorDegree <= 30 || sensorDegree >= 330)) {
+        return STREAM_ROTATE_0;
+    } else if (sensorDegree >= 60 && sensorDegree <= 120) { // Use ROTATION_90 when degree range is [60, 120]
+        return STREAM_ROTATE_90;
+    } else if (sensorDegree >= 150 && sensorDegree <= 210) { // Use ROTATION_180 when degree range is [150, 210]
+        return STREAM_ROTATE_180;
+    } else if (sensorDegree >= 240 && sensorDegree <= 300) { // Use ROTATION_270 when degree range is [240, 300]
+        return STREAM_ROTATE_270;
+    } else {
+        return 0;
+    }
+}
+
+int32_t HCaptureSession::CalcRotationDegree(GravityData data)
+{
+    float x = data.x;
+    float y = data.y;
+    float z = data.z;
+    int degree = -1;
+    if ((x * x + y * y) * VALID_INCLINATION_ANGLE_THRESHOLD_COEFFICIENT < z * z) {
+        return degree;
+    }
+    // arccotx = pi / 2 - arctanx, 90 is used to calculate acot(in degree); degree = rad / pi * 180
+    degree = 90 - static_cast<int>(round(atan2(y, -x) / M_PI * 180));
+    // Normalize the degree to the range of 0~360
+    return degree >= 0 ? degree % 360 : degree % 360 + 360;
+}
+#endif
+
 void HCaptureSession::StartMovingPhotoEncode(int32_t rotation, uint64_t timestamp)
 {
     if (!isSetMotionPhoto_) {
         return;
     }
-    int32_t realRotation = GetSensorOritation() + rotation;
-    realRotation = realRotation > ROTATION_360 ? realRotation - ROTATION_360 : realRotation;
+    int32_t addMirrorRotation = 0;
+    #ifdef CAMERA_USE_SENSOR
+    sensorRotation = CalcSensorRotation(CalcRotationDegree(gravityData));
+    #endif
+    MEDIA_INFO_LOG("sensorRotation is %{public}d", sensorRotation);
+    if ((sensorRotation == STREAM_ROTATE_0 || sensorRotation == STREAM_ROTATE_180) && isMovingPhotoMirror_) {
+        addMirrorRotation = STREAM_ROTATE_180;
+    }
+    int32_t realRotation = GetSensorOritation() + rotation + addMirrorRotation;
+    realRotation = realRotation % ROTATION_360;
     StartRecord(timestamp, realRotation);
 }
 
diff --git a/services/camera_service/src/hstream_repeat.cpp b/services/camera_service/src/hstream_repeat.cpp
index 3207a3870..2514e81ec 100644
--- a/services/camera_service/src/hstream_repeat.cpp
+++ b/services/camera_service/src/hstream_repeat.cpp
@@ -531,14 +531,14 @@ int32_t HStreamRepeat::SetCameraRotation(bool isEnable, int32_t rotation)
     return CAMERA_OK;
 }
 
-void HStreamRepeat::SetMirrorForLivePhoto(bool isEnable, int32_t mode)
+bool HStreamRepeat::SetMirrorForLivePhoto(bool isEnable, int32_t mode)
 {
     camera_metadata_item_t item;
     const int32_t canMirrorVideoAndPhoto = 2;
     int32_t res;
     {
         std::lock_guard<std::mutex> lock(cameraAbilityLock_);
-        CHECK_ERROR_RETURN(cameraAbility_ == nullptr);
+        CHECK_ERROR_RETURN_RET(cameraAbility_ == nullptr, false);
         res = OHOS::Camera::FindCameraMetadataItem(cameraAbility_->get(),
             OHOS_CONTROL_CAPTURE_MIRROR_SUPPORTED, &item);
     }
@@ -556,10 +556,11 @@ void HStreamRepeat::SetMirrorForLivePhoto(bool isEnable, int32_t mode)
     }
     if (isMirrorSupported) {
         enableMirror_ = isEnable;
+        Start(nullptr, true);
     } else {
         MEDIA_ERR_LOG("HStreamRepeat::SetMirrorForLivePhoto not supported mirror with mode:%{public}d", mode);
     }
-    Start(nullptr, true);
+    return isMirrorSupported;
 }
 
 int32_t HStreamRepeat::UpdateSketchRatio(float sketchRatio)
-- 
2.45.2.huawei.6

