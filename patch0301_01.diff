+++ b/services/camera_service/include/hcapture_session.h
@@ -27,24 +27,13 @@
 #include <refbase.h>
 #include <unordered_map>
 #include <unordered_set>
-#include "camera_util.h"
-#include "fixed_size_list.h"
-#include "camera_dynamic_loader.h"
 #include "hcamera_device.h"
 #include "hcapture_session_stub.h"
-#include "hstream_capture.h"
-#include "hstream_metadata.h"
 #include "hstream_repeat.h"
+#include "hstream_operator.h"
 #include "icapture_session.h"
 #include "istream_common.h"
 #include "camera_photo_proxy.h"
-#include "moving_photo/moving_photo_surface_wrapper.h"
-#include "surface.h"
-#include "v1_0/istream_operator.h"
-#include "v1_1/istream_operator.h"
-#include "v1_2/istream_operator.h"
-#include "v1_3/istream_operator_callback.h"
-#include "hcamera_restore_param.h"
 #include "iconsumer_surface.h"
 #include "blocking_queue.h"
 #include "audio_capturer.h"
@@ -64,18 +53,7 @@ namespace OHOS::Media {
 }
 namespace OHOS {
 namespace CameraStandard {
-using OHOS::HDI::Camera::V1_0::CaptureEndedInfo;
-using OHOS::HDI::Camera::V1_0::CaptureErrorInfo;
-using namespace AudioStandard;
-using namespace std::chrono;
-using namespace DeferredProcessing;
-using namespace Media;
-class PermissionStatusChangeCb;
-class CameraUseStateChangeCb;
-class DisplayRotationListener;
-class CameraServerPhotoProxy;
 
-static const int32_t STREAM_NOT_FOUNT = -1;
 
 enum class CaptureSessionReleaseType : int32_t {
     RELEASE_TYPE_CLIENT = 0,
@@ -113,89 +91,11 @@ private:
     std::recursive_mutex sessionStateLock_;
     CaptureSessionState currentState_ = CaptureSessionState::SESSION_INIT;
 };
-
-class StreamContainer {
-public:
-    StreamContainer() {};
-    virtual ~StreamContainer() = default;
-
-    bool AddStream(sptr<HStreamCommon> stream);
-    bool RemoveStream(sptr<HStreamCommon> stream);
-    sptr<HStreamCommon> GetStream(int32_t streamId);
-    sptr<HStreamCommon> GetHdiStream(int32_t streamId);
-    void Clear();
-    size_t Size();
-
-    std::list<sptr<HStreamCommon>> GetStreams(const StreamType streamType);
-    std::list<sptr<HStreamCommon>> GetAllStreams();
-
-private:
-    std::mutex streamsLock_;
-    std::map<const StreamType, std::list<sptr<HStreamCommon>>> streams_;
-};
-
-class SessionDrainImageCallback;
 using MetaElementType = std::pair<int64_t, sptr<SurfaceBuffer>>;
-class MovingPhotoListener : public MovingPhotoSurfaceWrapper::SurfaceBufferListener {
-public:
-    explicit MovingPhotoListener(sptr<MovingPhotoSurfaceWrapper> surfaceWrapper, sptr<Surface> metaSurface,
-        shared_ptr<FixedSizeList<MetaElementType>> metaCache, uint32_t preCacheFrameCount,
-        uint32_t postCacheFrameCount);
-    ~MovingPhotoListener() override;
-    void OnBufferArrival(sptr<SurfaceBuffer> buffer, int64_t timestamp, GraphicTransformType transform) override;
-    void DrainOutImage(sptr<SessionDrainImageCallback> drainImageCallback);
-    void RemoveDrainImageManager(sptr<SessionDrainImageCallback> drainImageCallback);
-    void StopDrainOut();
-    void ClearCache(uint64_t timestamp);
-    void SetClearFlag();
-
-private:
-    sptr<MovingPhotoSurfaceWrapper> movingPhotoSurfaceWrapper_;
-    sptr<Surface> metaSurface_;
-    shared_ptr<FixedSizeList<MetaElementType>> metaCache_;
-    BlockingQueue<sptr<FrameRecord>> recorderBufferQueue_;
-    SafeMap<sptr<SessionDrainImageCallback>, sptr<DrainImageManager>> callbackMap_;
-    std::atomic<bool> isNeededClear_ { false };
-    std::atomic<bool> isNeededPop_ { false };
-    int64_t shutterTime_;
-    uint64_t postCacheFrameCount_;
-};
-
-class MovingPhotoMetaListener : public IBufferConsumerListener {
-public:
-    explicit MovingPhotoMetaListener(sptr<Surface> surface, shared_ptr<FixedSizeList<MetaElementType>> metaCache);
-    ~MovingPhotoMetaListener();
-    void OnBufferAvailable() override;
-private:
-    sptr<Surface> surface_;
-    shared_ptr<FixedSizeList<MetaElementType>> metaCache_;
-};
-
-class SessionDrainImageCallback : public DrainImageCallback {
-public:
-    explicit SessionDrainImageCallback(std::vector<sptr<FrameRecord>>& frameCacheList,
-                                       wptr<MovingPhotoListener> listener,
-                                       wptr<MovingPhotoVideoCache> cache,
-                                       uint64_t timestamp,
-                                       int32_t rotation,
-                                       int32_t captureId);
-    ~SessionDrainImageCallback();
-    void OnDrainImage(sptr<FrameRecord> frame) override;
-    void OnDrainImageFinish(bool isFinished) override;
-
-private:
-    std::mutex mutex_;
-    std::vector<sptr<FrameRecord>> frameCacheList_;
-    wptr<MovingPhotoListener> listener_;
-    wptr<MovingPhotoVideoCache> videoCache_;
-    uint64_t timestamp_;
-    int32_t rotation_;
-    int32_t captureId_;
-};
 
 class CameraInfoDumper;
 
-class EXPORT_API HCaptureSession : public HCaptureSessionStub, public OHOS::HDI::Camera::V1_3::IStreamOperatorCallback {
+class EXPORT_API HCaptureSession : public HCaptureSessionStub {
 public:
     static CamServiceError NewInstance(const uint32_t callerToken, int32_t opMode, sptr<HCaptureSession>& outSession);
     virtual ~HCaptureSession();
@@ -241,60 +141,49 @@ public:
     std::shared_ptr<PhotoAssetIntf> ProcessPhotoProxy(int32_t captureId,
         std::shared_ptr<Media::Picture> picturePtr, bool isBursting,
         sptr<CameraServerPhotoProxy> cameraPhotoProxy, std::string &uri);
-    int32_t CreateMediaLibrary(sptr<CameraPhotoProxy>& photoProxy, std::string& uri, int32_t& cameraShotType,
-        std::string& burstKey, int64_t timestamp) override;
-    int32_t CreateMediaLibrary(std::unique_ptr<Media::Picture> picture, sptr<CameraPhotoProxy>& photoProxy,
-        std::string &uri, int32_t &cameraShotType, std::string& burstKey, int64_t timestamp) override;
-    void SetCameraPhotoProxyInfo(sptr<CameraServerPhotoProxy> cameraPhotoProxy, int32_t &cameraShotType,
-        bool &isBursting, std::string &burstKey);
-    const sptr<HStreamCommon> GetStreamByStreamID(int32_t streamId);
-    const sptr<HStreamCommon> GetHdiStreamByStreamID(int32_t streamId);
     int32_t SetFeatureMode(int32_t featureMode) override;
-    void StartMovingPhotoEncode(int32_t rotation, uint64_t timestamp, int32_t format, int32_t captureId);
-    void StartRecord(uint64_t timestamp, int32_t rotation, int32_t captureId);
     void GetOutputStatus(int32_t &status);
     int32_t SetPreviewRotation(std::string &deviceClass) override;
+    int32_t SetCommitConfigFlag(bool isNeedCommitting) override;
 
     void DumpSessionInfo(CameraInfoDumper& infoDumper);
     static void DumpSessions(CameraInfoDumper& infoDumper);
     static void DumpCameraSessionSummary(CameraInfoDumper& infoDumper);
     void ReleaseStreams();
-    void StopMovingPhoto();
     bool isEqual(float zoomPointA, float zoomPointB);
+    inline void SetStreamOperator(wptr<HStreamOperator> hStreamOperator)
+    {
+        std::lock_guard<std::mutex> lock(streamOperatorLock_);
+        if (hStreamOperator == nullptr) {
+            return;
+        }
+        hStreamOperator_ = hStreamOperator;
+        auto hStreamOperatorSptr = hStreamOperator_.promote();
+        if (hStreamOperatorSptr != nullptr) {
+            hStreamOperatorSptr->SetCameraDevice(cameraDevice_);
+        }
+    }
 
-    uint32_t preCacheFrameCount_ = CACHE_FRAME_COUNT;
-    uint32_t postCacheFrameCount_ = CACHE_FRAME_COUNT;
+    // uint32_t preCacheFrameCount_ = CACHE_FRAME_COUNT;
+    // uint32_t postCacheFrameCount_ = CACHE_FRAME_COUNT;
     void ConfigPayload(uint32_t pid, uint32_t tid, const char *bundleName, int32_t qosLevel,
         std::unordered_map<std::string, std::string> &mapPayload);
 
-    // IStreamOperatorCallback interfaces.
-    int32_t OnCaptureStarted(int32_t captureId, const std::vector<int32_t>& streamIds) override;
-    int32_t OnCaptureStarted_V1_2(
-        int32_t captureId, const std::vector<OHOS::HDI::Camera::V1_2::CaptureStartedInfo>& infos) override;
-    int32_t OnCaptureEnded(int32_t captureId, const std::vector<CaptureEndedInfo>& infos) override;
-    int32_t OnCaptureEndedExt(
-        int32_t captureId, const std::vector<OHOS::HDI::Camera::V1_3::CaptureEndedInfoExt>& infos) override;
-    int32_t OnCaptureError(int32_t captureId, const std::vector<CaptureErrorInfo>& infos) override;
-    int32_t OnFrameShutter(int32_t captureId, const std::vector<int32_t>& streamIds, uint64_t timestamp) override;
-    int32_t OnFrameShutterEnd(int32_t captureId, const std::vector<int32_t>& streamIds, uint64_t timestamp) override;
-    int32_t OnCaptureReady(int32_t captureId, const std::vector<int32_t>& streamIds, uint64_t timestamp) override;
-    int32_t OnResult(int32_t streamId, const std::vector<uint8_t>& result) override;
-
 private:
     explicit HCaptureSession(const uint32_t callingTokenId, int32_t opMode);
     string lastDisplayName_ = "";
     string lastBurstPrefix_ = "";
     int32_t saveIndex = 0;
-    volatile bool isMovingPhotoMirror_ = false;
-    volatile bool isSetMotionPhoto_ = false;
-    std::mutex livePhotoStreamLock_; // Guard livePhotoStreamRepeat_
-    sptr<HStreamRepeat> livePhotoStreamRepeat_;
+    bool isNeedCommitting_ = false;
     inline void SetCameraDevice(sptr<HCameraDevice> device)
     {
         std::lock_guard<std::mutex> lock(cameraDeviceLock_);
         cameraDevice_ = device;
+        auto hStreamOperatorSptr = hStreamOperator_.promote();
+        if (hStreamOperatorSptr != nullptr) {
+            hStreamOperatorSptr->SetCameraDevice(device);
+        }
     }
-
     inline const sptr<HCameraDevice> GetCameraDevice()
     {
         std::lock_guard<std::mutex> lock(cameraDeviceLock_);
@@ -305,7 +194,6 @@ private:
     int32_t ValidateSessionInputs();
     int32_t ValidateSessionOutputs();
     int32_t ValidateSession();
-    int32_t AddOutputStream(sptr<HStreamCommon> stream);
     int32_t RemoveOutputStream(sptr<HStreamCommon> stream);
     int32_t LinkInputAndOutputs();
     int32_t UnlinkInputAndOutputs();
@@ -313,34 +201,19 @@ private:
     void ClearSketchRepeatStream();
     void ExpandSketchRepeatStream();
     void ExpandMovingPhotoRepeatStream();
-    void ClearMovingPhotoRepeatStream();
-    int32_t CreateMovingPhotoStreamRepeat(int32_t format, int32_t width, int32_t height,
-        sptr<OHOS::IBufferProducer> producer);
-    int32_t CheckIfColorSpaceMatchesFormat(ColorSpace colorSpace);
-    void CancelStreamsAndGetStreamInfos(std::vector<StreamInfo_V1_1>& streamInfos);
-    void RestartStreams();
-    int32_t UpdateStreamInfos();
-    void SetColorSpaceForStreams();
 
     void ProcessMetaZoomArray(std::vector<uint32_t>& zoomAndTimeArray, sptr<HCameraDevice>& cameraDevice);
-    void StartMovingPhotoStream();
-    bool InitAudioCapture();
-    bool StartAudioCapture();
-    void ProcessAudioBuffer();
-    void StartOnceRecord(uint64_t timestamp, int32_t rotation, int32_t captureId);
-    int32_t StartPreviewStream(const std::shared_ptr<OHOS::Camera::CameraMetadata>& settings,
-        camera_position_enum_t cameraPosition);
     void UpdateMuteSetting(bool muteMode, std::shared_ptr<OHOS::Camera::CameraMetadata> &settings);
     void StartMovingPhoto(sptr<HStreamRepeat>& curStreamRepeat);
     int32_t GetSensorOritation();
-    int32_t GetMovingPhotoBufferDuration();
-    void GetMovingPhotoStartAndEndTime();
+
+    // int32_t GetMovingPhotoBufferDuration();
+    // void GetMovingPhotoStartAndEndTime();
     std::string GetSessionState();
 
     void DynamicConfigStream();
     bool IsNeedDynamicConfig();
-    void RegisterDisplayListener(sptr<HStreamRepeat> repeat);
-    void UnregisterDisplayListener(sptr<HStreamRepeat> repeat);
+    void ClearMovingPhotoRepeatStream();
     StateMachine stateMachine_;
 
     #ifdef CAMERA_USE_SENSOR
@@ -357,6 +230,7 @@ private:
 
     // Make sure device thread safe,set device by {SetCameraDevice}, get device by {GetCameraDevice}
     std::mutex cameraDeviceLock_;
+    std::mutex streamOperatorLock_;
     sptr<HCameraDevice> cameraDevice_;
 
     StreamContainer streamContainer_;
@@ -368,21 +242,10 @@ private:
     uint32_t callerToken_ = 0;
     int32_t opMode_ = 0;
     int32_t featureMode_ = 0;
-    ColorSpace currColorSpace_ = ColorSpace::COLOR_SPACE_UNKNOWN;
-    ColorSpace currCaptureColorSpace_ = ColorSpace::COLOR_SPACE_UNKNOWN;
     bool isSessionStarted_ = false;
-    bool enableStreamRotate_ = false;
     bool isDynamicConfiged_ = false;
     std::string deviceClass_ = "phone";
-    std::mutex movingPhotoStatusLock_; // Guard movingPhotoStatus
-    sptr<MovingPhotoListener> livephotoListener_;
-    sptr<MovingPhotoMetaListener> livephotoMetaListener_;
-    sptr<AudioCapturerSession> audioCapturerSession_;
-    sptr<Surface> metaSurface_ = nullptr;
-    sptr<MovingPhotoVideoCache> videoCache_;
-    sptr<AvcodecTaskManager> taskManager_;
-    std::mutex displayListenerLock_;
-    sptr<DisplayRotationListener> displayListener_;
+    wptr<HStreamOperator> hStreamOperator_;
 };
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/services/camera_service/include/hstream_capture.h b/services/camera_service/include/hstream_capture.h
index a69760f0..a6bd5d7f 100644
--- a/services/camera_service/include/hstream_capture.h
+++ b/services/camera_service/include/hstream_capture.h
@@ -29,12 +29,16 @@
 #include "v1_2/istream_operator.h"
 #include "safe_map.h"
 
+namespace OHOS::Media {
+    class Picture;
+}
 namespace OHOS {
 namespace CameraStandard {
 using OHOS::HDI::Camera::V1_0::BufferProducerSequenceable;
 using namespace OHOS::HDI::Camera::V1_0;
 class PhotoAssetIntf;
 class CameraServerPhotoProxy;
+class HStreamOperator;
 constexpr const char* BURST_UUID_UNSET = "";
 class EXPORT_API HStreamCapture : public HStreamCaptureStub, public HStreamCommon {
 public:
@@ -63,6 +67,7 @@ public:
     int32_t OnFrameShutter(int32_t captureId, uint64_t timestamp);
     int32_t OnFrameShutterEnd(int32_t captureId, uint64_t timestamp);
     int32_t OnCaptureReady(int32_t captureId, uint64_t timestamp);
+    int32_t OnOfflineDeliveryFinished(int32_t captureId);
     void DumpStreamInfo(CameraInfoDumper& infoDumper) override;
     void SetRotation(const std::shared_ptr<OHOS::Camera::CameraMetadata> &captureMetadataSetting_, int32_t captureId);
     void SetMode(int32_t modeName);
@@ -86,6 +91,15 @@ public:
     std::shared_ptr<PhotoAssetIntf> GetPhotoAssetInstance(int32_t captureId);
     bool GetAddPhotoProxyEnabled();
     int32_t AcquireBufferToPrepareProxy(int32_t captureId) override;
+    int32_t EnableOfflinePhoto(bool isEnable) override;
+    bool IsHasEnableOfflinePhoto();
+    void SwitchToOffline();
+    bool IsHasSwitchToOffline();
+    void SetStreamOperator(wptr<HStreamOperator> hStreamOperator);
+    int32_t CreateMediaLibrary(sptr<CameraPhotoProxy>& photoProxy, std::string& uri, int32_t& cameraShotType,
+        std::string& burstKey, int64_t timestamp) override;
+    int32_t CreateMediaLibrary(std::unique_ptr<Media::Picture> picture, sptr<CameraPhotoProxy> &photoProxy,
+        std::string &uri, int32_t &cameraShotType, std::string& burstKey, int64_t timestamp) override;
 
 private:
     int32_t CheckBurstCapture(const std::shared_ptr<OHOS::Camera::CameraMetadata>& captureSettings,
@@ -102,6 +116,8 @@ private:
     int32_t thumbnailSwitch_;
     int32_t rawDeliverySwitch_;
     int32_t movingPhotoSwitch_;
+    std::condition_variable testDelay_;
+    std::mutex testDelayMutex_;
     sptr<BufferProducerSequenceable> thumbnailBufferQueue_;
     sptr<BufferProducerSequenceable> rawBufferQueue_;
     sptr<BufferProducerSequenceable> gainmapBufferQueue_;
@@ -123,6 +139,10 @@ private:
     int32_t videoCodecType_ = 0;
     std::mutex photoAssetLock_;
     std::map<int32_t, std::shared_ptr<PhotoAssetIntf>> photoAssetProxy_;
+    bool mEnableOfflinePhoto_ = false;
+    bool mSwitchToOfflinePhoto_ = false;
+    int32_t mlastCaptureId = 0;
+    wptr<HStreamOperator> hStreamOperator_;
 };
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/services/camera_service/include/hstream_operator.h b/services/camera_service/include/hstream_operator.h
new file mode 100755
index 00000000..55cce13e
--- /dev/null
+++ b/services/camera_service/include/hstream_operator.h
@@ -0,0 +1,328 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_H_STREAM_OPERATOR_H
+#define OHOS_CAMERA_H_STREAM_OPERATOR_H
+#define EXPORT_API __attribute__((visibility("default")))
+
+#include <atomic>
+#include <cstdint>
+#include <functional>
+#include <iostream>
+#include <list>
+#include <memory>
+#include <mutex>
+#include <refbase.h>
+#include <unordered_map>
+#include <unordered_set>
+#include "camera_util.h"
+#include "fixed_size_list.h"
+#include "hcamera_device.h"
+#include "hcapture_session_stub.h"
+#include "hstream_metadata.h"
+#include "hstream_repeat.h"
+#include "icapture_session.h"
+#include "istream_common.h"
+#include "camera_photo_proxy.h"
+#include "moving_photo/moving_photo_surface_wrapper.h"
+#include "surface.h"
+#include "v1_0/istream_operator.h"
+#include "v1_1/istream_operator.h"
+#include "v1_2/istream_operator.h"
+#include "v1_3/istream_operator_callback.h"
+#include "hcamera_restore_param.h"
+#include "iconsumer_surface.h"
+#include "blocking_queue.h"
+#include "audio_capturer.h"
+#include "audio_info.h"
+#include "avcodec_task_manager.h"
+#include "moving_photo_video_cache.h"
+#include "drain_manager.h"
+#include "audio_capturer_session.h"
+#include "safe_map.h"
+#ifdef CAMERA_USE_SENSOR
+#include "sensor_agent.h"
+#include "sensor_agent_type.h"
+#endif
+namespace OHOS::Media {
+    class Picture;
+}
+namespace OHOS {
+namespace CameraStandard {
+using OHOS::HDI::Camera::V1_0::CaptureEndedInfo;
+using OHOS::HDI::Camera::V1_0::CaptureErrorInfo;
+using namespace AudioStandard;
+using namespace std::chrono;
+using namespace DeferredProcessing;
+using namespace Media;
+class PermissionStatusChangeCb;
+class CameraUseStateChangeCb;
+class DisplayRotationListener;
+class CameraServerPhotoProxy;
+
+class StreamContainer {
+public:
+    StreamContainer() {};
+    virtual ~StreamContainer() = default;
+
+    bool AddStream(sptr<HStreamCommon> stream);
+    bool RemoveStream(sptr<HStreamCommon> stream);
+    sptr<HStreamCommon> GetStream(int32_t streamId);
+    sptr<HStreamCommon> GetHdiStream(int32_t streamId);
+    void Clear();
+    size_t Size();
+
+    std::list<sptr<HStreamCommon>> GetStreams(const StreamType streamType);
+    std::list<sptr<HStreamCommon>> GetAllStreams();
+
+private:
+    std::mutex streamsLock_;
+    std::map<const StreamType, std::list<sptr<HStreamCommon>>> streams_;
+};
+
+class SessionDrainImageCallback;
+using MetaElementType = std::pair<int64_t, sptr<SurfaceBuffer>>;
+class MovingPhotoListener : public MovingPhotoSurfaceWrapper::SurfaceBufferListener {
+public:
+    explicit MovingPhotoListener(sptr<MovingPhotoSurfaceWrapper> surfaceWrapper, sptr<Surface> metaSurface,
+        shared_ptr<FixedSizeList<MetaElementType>> metaCache, uint32_t preCacheFrameCount,
+        uint32_t postCacheFrameCount);
+    ~MovingPhotoListener() override;
+    void OnBufferArrival(sptr<SurfaceBuffer> buffer, int64_t timestamp, GraphicTransformType transform) override;
+    void DrainOutImage(sptr<SessionDrainImageCallback> drainImageCallback);
+    void RemoveDrainImageManager(sptr<SessionDrainImageCallback> drainImageCallback);
+    void StopDrainOut();
+    void ClearCache(uint64_t timestamp);
+    void SetClearFlag();
+
+private:
+    sptr<MovingPhotoSurfaceWrapper> movingPhotoSurfaceWrapper_;
+    sptr<Surface> metaSurface_;
+    shared_ptr<FixedSizeList<MetaElementType>> metaCache_;
+    BlockingQueue<sptr<FrameRecord>> recorderBufferQueue_;
+    SafeMap<sptr<SessionDrainImageCallback>, sptr<DrainImageManager>> callbackMap_;
+    std::atomic<bool> isNeededClear_ { false };
+    std::atomic<bool> isNeededPop_ { false };
+    int64_t shutterTime_;
+    uint64_t postCacheFrameCount_;
+};
+
+class MovingPhotoMetaListener : public IBufferConsumerListener {
+public:
+    explicit MovingPhotoMetaListener(sptr<Surface> surface, shared_ptr<FixedSizeList<MetaElementType>> metaCache);
+    ~MovingPhotoMetaListener();
+    void OnBufferAvailable() override;
+private:
+    sptr<Surface> surface_;
+    shared_ptr<FixedSizeList<MetaElementType>> metaCache_;
+};
+
+class SessionDrainImageCallback : public DrainImageCallback {
+public:
+    explicit SessionDrainImageCallback(std::vector<sptr<FrameRecord>>& frameCacheList,
+                                       wptr<MovingPhotoListener> listener,
+                                       wptr<MovingPhotoVideoCache> cache,
+                                       uint64_t timestamp,
+                                       int32_t rotation,
+                                       int32_t captureId);
+    ~SessionDrainImageCallback();
+    void OnDrainImage(sptr<FrameRecord> frame) override;
+    void OnDrainImageFinish(bool isFinished) override;
+
+private:
+    std::mutex mutex_;
+    std::vector<sptr<FrameRecord>> frameCacheList_;
+    wptr<MovingPhotoListener> listener_;
+    wptr<MovingPhotoVideoCache> videoCache_;
+    uint64_t timestamp_;
+    int32_t rotation_;
+    int32_t captureId_;
+};
+
+class CameraInfoDumper;
+
+class EXPORT_API HStreamOperator : public OHOS::HDI::Camera::V1_3::IStreamOperatorCallback {
+public:
+    static sptr<HStreamOperator> NewInstance(const uint32_t callerToken, int32_t opMode);
+    HStreamOperator();
+    explicit HStreamOperator(const uint32_t callingTokenId, int32_t opMode);
+    virtual ~HStreamOperator();
+    int32_t AddOutput(StreamType streamType, sptr<IStreamCommon> stream);
+    int32_t Stop();
+    int32_t Release();
+    int32_t EnableMovingPhoto(const std::shared_ptr<OHOS::Camera::CameraMetadata>& settings,
+        bool isEnable, int32_t sensorOritation);
+    int32_t GetCurrentStreamInfos(std::vector<StreamInfo_V1_1>& streamInfos);
+    std::list<sptr<HStreamCommon>> GetAllStreams();
+    int32_t EnableMovingPhotoMirror(bool isMirror, bool isConfig);
+    int32_t CreateMediaLibrary(sptr<CameraPhotoProxy>& photoProxy, std::string& uri, int32_t& cameraShotType,
+        std::string& burstKey, int64_t timestamp);
+    int32_t CreateMediaLibrary(std::unique_ptr<Media::Picture> picture, sptr<CameraPhotoProxy> &photoProxy,
+        std::string &uri, int32_t &cameraShotType, std::string& burstKey, int64_t timestamp);
+    void SetCameraPhotoProxyInfo(sptr<CameraServerPhotoProxy> cameraPhotoProxy, int32_t &cameraShotType,
+        bool &isBursting, std::string &burstKey);
+    int32_t LinkInputAndOutputs(const std::shared_ptr<OHOS::Camera::CameraMetadata>& settings, int32_t opMode);
+    const sptr<HStreamCommon> GetStreamByStreamID(int32_t streamId);
+    const sptr<HStreamCommon> GetHdiStreamByStreamID(int32_t streamId);
+    void StartMovingPhotoEncode(int32_t rotation, uint64_t timestamp, int32_t format, int32_t captureId);
+    void StartRecord(uint64_t timestamp, int32_t rotation, int32_t captureId);
+    void GetOutputStatus(int32_t &status);
+    int32_t SetPreviewRotation(std::string &deviceClass);
+    void ReleaseStreams();
+    void StopMovingPhoto();
+    int32_t GetActiveColorSpace(ColorSpace& colorSpace);
+    int32_t SetColorSpace(ColorSpace colorSpace, ColorSpace captureColorSpace, bool isNeedUpdate);
+    void SetColorSpaceForStreams();
+    int32_t CheckIfColorSpaceMatchesFormat(ColorSpace colorSpace);
+    int32_t StartPreviewStream(const std::shared_ptr<OHOS::Camera::CameraMetadata>& settings,
+        camera_position_enum_t cameraPosition);
+
+    int32_t CreateStreams(std::vector<HDI::Camera::V1_1::StreamInfo_V1_1>& streamInfos);
+    int32_t CommitStreams(const std::shared_ptr<OHOS::Camera::CameraMetadata>& deviceSettings, int32_t operationMode);
+    int32_t ReleaseStreams(std::vector<int32_t>& releaseStreamIds);
+    int32_t GetStreamsSize();
+    int32_t CreateAndCommitStreams(std::vector<HDI::Camera::V1_1::StreamInfo_V1_1>& streamInfos,
+        const std::shared_ptr<OHOS::Camera::CameraMetadata>& deviceSettings, int32_t operationMode);
+    int32_t UpdateStreams(std::vector<StreamInfo_V1_1>& streamInfos);
+    int32_t UpdateStreamInfos(const std::shared_ptr<OHOS::Camera::CameraMetadata>& settings);
+    int32_t RemoveOutput(StreamType streamType, sptr<IStreamCommon> stream);
+    int32_t RemoveOutputStream(sptr<HStreamCommon> stream);
+
+    int32_t OnCaptureStarted(int32_t captureId, const std::vector<int32_t>& streamIds) override;
+    int32_t OnCaptureStarted_V1_2(
+        int32_t captureId, const std::vector<OHOS::HDI::Camera::V1_2::CaptureStartedInfo>& infos) override;
+    int32_t OnCaptureEnded(int32_t captureId, const std::vector<CaptureEndedInfo>& infos) override;
+    int32_t OnCaptureEndedExt(
+        int32_t captureId, const std::vector<OHOS::HDI::Camera::V1_3::CaptureEndedInfoExt>& infos) override;
+    int32_t OnCaptureError(int32_t captureId, const std::vector<CaptureErrorInfo>& infos) override;
+    int32_t OnFrameShutter(int32_t captureId, const std::vector<int32_t>& streamIds, uint64_t timestamp) override;
+    int32_t OnFrameShutterEnd(int32_t captureId, const std::vector<int32_t>& streamIds, uint64_t timestamp) override;
+    int32_t OnCaptureReady(int32_t captureId, const std::vector<int32_t>& streamIds, uint64_t timestamp) override;
+    int32_t OnResult(int32_t streamId, const std::vector<uint8_t>& result) override;
+    int32_t UnlinkInputAndOutputs();
+    void RegisterDisplayListener(sptr<HStreamRepeat> repeat);
+    void UnRegisterDisplayListener(sptr<HStreamRepeat> repeat);
+    void ClearSketchRepeatStream();
+    void ExpandSketchRepeatStream();
+    void ExpandMovingPhotoRepeatStream();
+    void ClearMovingPhotoRepeatStream();
+    void GetStreamOperator();
+    inline void ResetHdiStreamId()
+    {
+        hdiStreamIdGenerator_ = HDI_STREAM_ID_INIT;
+    }
+    inline void SetCameraDevice(sptr<HCameraDevice> device)
+    {
+        std::lock_guard<std::mutex> lock(cameraDeviceLock_);
+        cameraDevice_ = device;
+    }
+
+    inline void SetStreamOperatorId(int32_t& streamOperatorId)
+    {
+        streamOperatorId_ = streamOperatorId;
+    }
+    void StartMovingPhotoStream(const std::shared_ptr<OHOS::Camera::CameraMetadata>& settings);
+    int32_t GetOfflineOutptSize();
+    int32_t GetAllOutptSize();
+
+    uint32_t preCacheFrameCount_ = CACHE_FRAME_COUNT;
+    uint32_t postCacheFrameCount_ = CACHE_FRAME_COUNT;
+    sptr<AvcodecTaskManager> taskManager_;
+
+private:
+    int32_t Initialize(const uint32_t callerToken, int32_t opMode);
+    string lastDisplayName_ = "";
+    string lastBurstPrefix_ = "";
+    int32_t saveIndex = 0;
+    int32_t streamOperatorId_ = -1;
+    volatile bool isMovingPhotoMirror_ = false;
+    volatile bool isSetMotionPhoto_ = false;
+    std::mutex livePhotoStreamLock_; // Guard livePhotoStreamRepeat_
+    std::mutex opMutex_; // Lock the operations updateSettings_, streamOperator_, and hdiCameraDevice
+    sptr<HStreamRepeat> livePhotoStreamRepeat_;
+    std::atomic<int32_t> hdiStreamIdGenerator_ = HDI_STREAM_ID_INIT;
+    int32_t deviceSensorOritation_ = 0;
+
+    inline int32_t GenerateHdiStreamId()
+    {
+        return hdiStreamIdGenerator_.fetch_add(1);
+    }
+
+    string CreateDisplayName();
+    string CreateBurstDisplayName(int32_t imageSeqId, int32_t seqId);
+    int32_t AddOutputStream(sptr<HStreamCommon> stream);
+    
+    int32_t CreateMovingPhotoStreamRepeat(int32_t format, int32_t width, int32_t height,
+        sptr<OHOS::IBufferProducer> producer);
+    void CancelStreamsAndGetStreamInfos(std::vector<StreamInfo_V1_1>& streamInfos);
+    void RestartStreams(const std::shared_ptr<OHOS::Camera::CameraMetadata>& settings);
+    void StartMovingPhoto(const std::shared_ptr<OHOS::Camera::CameraMetadata>& settings,
+        sptr<HStreamRepeat>& curStreamRepeat);
+    void ProcessMetaZoomArray(std::vector<uint32_t>& zoomAndTimeArray, sptr<HCameraDevice>& cameraDevice);
+    bool InitAudioCapture();
+    bool StartAudioCapture();
+    void ProcessAudioBuffer();
+    void StartOnceRecord(uint64_t timestamp, int32_t rotation, int32_t captureId);
+    void UpdateMuteSetting(bool muteMode, std::shared_ptr<OHOS::Camera::CameraMetadata> &settings);
+    int32_t GetMovingPhotoBufferDuration();
+    void GetMovingPhotoStartAndEndTime();
+    void ConfigPayload(uint32_t pid, uint32_t tid, const char *bundleName, int32_t qosLevel,
+        std::unordered_map<std::string, std::string> &mapPayload);
+    std::shared_ptr<PhotoAssetIntf> ProcessPhotoProxy(int32_t captureId, std::shared_ptr<Media::Picture> picturePtr,
+        bool isBursting, sptr<CameraServerPhotoProxy> cameraPhotoProxy, std::string& uri);
+
+#ifdef CAMERA_USE_SENSOR
+    std::mutex sensorLock_;
+    bool isRegisterSensorSuccess_ = false;
+    void RegisterSensorCallback();
+    void UnRegisterSensorCallback();
+    static void GravityDataCallbackImpl(SensorEvent* event);
+    static int32_t CalcSensorRotation(int32_t sensorDegree);
+    static int32_t CalcRotationDegree(GravityData data);
+#endif
+    // Make sure device thread safe,set device by {SetCameraDevice}, get device by {GetCameraDevice}
+    std::mutex cameraDeviceLock_;
+    std::mutex cbMutex_;
+    sptr<HCameraDevice> cameraDevice_;
+    StreamContainer streamContainer_;
+    StreamContainer streamContainerOffline_;
+#ifdef CAMERA_USE_SENSOR
+    SensorUser user = { "", nullptr, nullptr };
+#endif
+    pid_t pid_;
+    uid_t uid_;
+    uint32_t callerToken_;
+    int32_t opMode_;
+    ColorSpace currColorSpace_ = ColorSpace::COLOR_SPACE_UNKNOWN;
+    ColorSpace currCaptureColorSpace_ = ColorSpace::COLOR_SPACE_UNKNOWN;
+    bool isSessionStarted_ = false;
+    bool enableStreamRotate_ = false;
+    bool isDynamicConfiged_ = false;
+    std::string deviceClass_ = "phone";
+    std::mutex movingPhotoStatusLock_; // Guard movingPhotoStatus
+    sptr<MovingPhotoListener> livephotoListener_;
+    sptr<MovingPhotoMetaListener> livephotoMetaListener_;
+    sptr<AudioCapturerSession> audioCapturerSession_;
+    sptr<Surface> metaSurface_ = nullptr;
+    sptr<MovingPhotoVideoCache> videoCache_;
+    std::mutex displayListenerLock_;
+    sptr<DisplayRotationListener> displayListener_;
+    sptr<OHOS::HDI::Camera::V1_0::IStreamOperator> streamOperator_;
+    bool isOfflineStreamOperator_ =  false;
+    int32_t mlastCaptureId = 0;
+};
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_H_STREAM_OPERATOR_H
diff --git a/services/camera_service/include/hstream_operator_manager.h b/services/camera_service/include/hstream_operator_manager.h
new file mode 100755
index 00000000..6e11cd02
--- /dev/null
+++ b/services/camera_service/include/hstream_operator_manager.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2023-2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_CAMERA_H_STREAM_OPERATOR_MANAGER_H
+#define OHOS_CAMERA_H_STREAM_OPERATOR_MANAGER_H
+
+#include <refbase.h>
+#include <set>
+#include <mutex>
+#include "safe_map.h"
+namespace OHOS {
+namespace CameraStandard {
+class HStreamOperator;
+class HStreamOperatorManager : public RefBase {
+public:
+
+    ~HStreamOperatorManager();
+
+    static sptr<HStreamOperatorManager> &GetInstance();
+
+    void AddStreamOperator(sptr<HStreamOperator> hStreamOperator);
+
+    void RemoveStreamOperator(int32_t& hStreamOperatorId);
+
+    void UpdateStreamOperator(int32_t& hStreamOperatorId);
+
+    int32_t GetOfflineOutputSize();
+
+private:
+    HStreamOperatorManager();
+    std::mutex mapMutex_;
+    static sptr<HStreamOperatorManager> streamOperatorManager_;
+    std::map<int32_t, sptr<HStreamOperator>> streamOperatorManagerMap_;
+    static std::mutex instanceMutex_;
+    std::atomic<int32_t> streamOperatorIdGenerator_ = -1;
+
+    inline int32_t GenerateStreamOperatorId()
+    {
+        streamOperatorIdGenerator_.fetch_add(1);
+        if (streamOperatorIdGenerator_ == INT32_MAX) {
+            streamOperatorIdGenerator_ = 0;
+        }
+        return streamOperatorIdGenerator_;
+    }
+};
+} // namespace CameraStandard
+} // namespace OHOS
+#endif // OHOS_CAMERA_H_STREAM_OPERATOR_MANAGER_H
diff --git a/services/camera_service/src/camera_privacy.cpp b/services/camera_service/src/camera_privacy.cpp
index a6e7a4a4..4b665010 100644
--- a/services/camera_service/src/camera_privacy.cpp
+++ b/services/camera_service/src/camera_privacy.cpp
@@ -22,16 +22,20 @@
 #include "hcamera_device.h"
 #include "hcamera_device_manager.h"
 #include "hcapture_session.h"
+#include "hstream_operator.h"
 
 namespace OHOS {
 namespace CameraStandard {
 using OHOS::Security::AccessToken::PrivacyKit;
 using OHOS::Security::AccessToken::AccessTokenKit;
 
-sptr<HCaptureSession> CastToSession(sptr<IStreamOperatorCallback> streamOpCb)
+sptr<HStreamOperator> CastToSession(wptr<IStreamOperatorCallback> streamOpCb)
 {
-    CHECK_ERROR_RETURN_RET(streamOpCb == nullptr, nullptr);
-    return static_cast<HCaptureSession*>(streamOpCb.GetRefPtr());
+    CHECK_ERROR_RETURN_RET_LOG(streamOpCb == nullptr, nullptr, "streamOpCb is nullptr");
+    auto streamOpCbSptr = streamOpCb.promote();
+    CHECK_ERROR_RETURN_RET_LOG(streamOpCbSptr == nullptr, nullptr, "streamOpCbWptr is nullptr");
+
+    return static_cast<HStreamOperator*>(streamOpCbSptr.GetRefPtr());
 }
 
 void PermissionStatusChangeCb::PermStateChangeCallback(Security::AccessToken::PermStateChangeInfo& result)
diff --git a/services/camera_service/src/dfx/camera_report_uitls.cpp b/services/camera_service/src/dfx/camera_report_uitls.cpp
index 4ebb4165..bfc40a10 100644
--- a/services/camera_service/src/dfx/camera_report_uitls.cpp
+++ b/services/camera_service/src/dfx/camera_report_uitls.cpp
@@ -207,7 +207,7 @@ void CameraReportUtils::SetCapturePerfStartInfo(DfxCaptureInfo captureInfo)
     captureList_.insert(pair<int32_t, DfxCaptureInfo>(captureInfo.captureId, captureInfo));
 }
 
-void CameraReportUtils::SetCapturePerfEndInfo(int32_t captureId)
+void CameraReportUtils::SetCapturePerfEndInfo(int32_t captureId, bool isOfflinCapture, int32_t offlineOutputCnt)
 {
     MEDIA_DEBUG_LOG("SetCapturePerfEndInfo start");
     unique_lock<mutex> lock(mutex_);
@@ -217,6 +217,8 @@ void CameraReportUtils::SetCapturePerfEndInfo(int32_t captureId)
             MEDIA_DEBUG_LOG("SetCapturePerfEndInfo");
             auto dfxCaptureInfo = iter->second;
             dfxCaptureInfo.captureEndTime = DeferredProcessing::SteadyClock::GetTimestampMilli();
+            dfxCaptureInfo.isOfflinCapture = isOfflinCapture;
+            dfxCaptureInfo.offlineOutputCnt = offlineOutputCnt;
             ReportCapturePerf(dfxCaptureInfo);
             ReportImagingInfo(dfxCaptureInfo);
             captureList_.erase(captureId);
@@ -238,7 +240,9 @@ void CameraReportUtils::ReportCapturePerf(DfxCaptureInfo captureInfo)
         "COST_TIME", captureInfo.captureEndTime - captureInfo.captureStartTime,
         "CAPTURE_ID", captureInfo.captureId,
         "CUR_MODE", curMode_,
-        "CUR_CAMERA_ID", cameraId_);
+        "CUR_CAMERA_ID", cameraId_,
+        "IS_OFFLINE_CAPTURE", captureInfo.isOfflinCapture,
+        "CUR_OFFLINE_COUNT", captureInfo.offlineOutputCnt);
 }
 
 void CameraReportUtils::SetSwitchCamPerfStartInfo(CallerInfo caller)
diff --git a/services/camera_service/src/hcamera_device.cpp b/services/camera_service/src/hcamera_device.cpp
index ed52aacf..fcd0cd67 100644
--- a/services/camera_service/src/hcamera_device.cpp
+++ b/services/camera_service/src/hcamera_device.cpp
@@ -87,6 +87,7 @@ const std::vector<std::tuple<uint32_t, std::string, DFX_UB_NAME>> HCameraDevice:
     {OHOS_CONTROL_LIGHT_PAINTING_FLASH, "OHOS_CONTROL_LIGHT_PAINTING_FLASH", DFX_UB_NOT_REPORT},
     {OHOS_CONTROL_MANUAL_EXPOSURE_TIME, "OHOS_CONTROL_MANUAL_EXPOSURE_TIME", DFX_UB_NOT_REPORT},
     {OHOS_CONTROL_CAMERA_USED_AS_POSITION, "OHOS_CONTROL_CAMERA_USED_AS_POSITION", DFX_UB_NOT_REPORT},
+    {OHOS_CONTROL_CHANGETO_OFFLINE_STREAM_OPEATOR, "OHOS_CONTROL_CHANGETO_OFFLINE_STREAM_OPEATOR", DFX_UB_NOT_REPORT},
 };
 
 const std::unordered_map<DeviceProtectionStatus, CamServiceError> g_deviceProtectionToServiceError_ = {
@@ -328,7 +329,7 @@ int32_t HCameraDevice::OpenSecureCamera(uint64_t* secureSeqId)
     }  else {
         MEDIA_INFO_LOG("V1_3::ICameraDevice::CastFrom failed");
     }
-    MEDIA_INFO_LOG("CaptureSession::OpenSecureCamera secureSeqId = %{public}" PRIu64, *secureSeqId);
+    MEDIA_INFO_LOG("HCameraDevice::OpenSecureCamera secureSeqId = %{public}" PRIu64, *secureSeqId);
     return errCode;
 }
 
@@ -411,14 +412,12 @@ int32_t HCameraDevice::OpenDevice(bool isEnableSecCam)
         return CAMERA_UNKNOWN_ERROR;
     } else {
         g_openingCameraDevice = this;
-        ResetHdiStreamId();
         isOpenedCameraDevice_.store(true);
         HCameraDeviceManager::GetInstance()->AddDevice(IPCSkeleton::GetCallingPid(), this);
 #ifdef CAMERA_USE_SENSOR
         RegisterDropDetectionListener();
 #endif
     }
-    errorCode = InitStreamOperator();
     CHECK_ERROR_RETURN_RET_LOG(errorCode != CAMERA_OK, errorCode,
         "HCameraDevice::OpenDevice InitStreamOperator fail err code is:%{public}d", errorCode);
     std::lock_guard<std::mutex> lockSetting(opMutex_);
@@ -558,9 +557,6 @@ int32_t HCameraDevice::CloseDevice()
         } else {
             MEDIA_INFO_LOG("hdiCameraDevice is null");
         }
-        if (streamOperator_) {
-            streamOperator_ = nullptr;
-        }
         SetStreamOperatorCallback(nullptr);
     }
     if (cameraHostManager_) {
@@ -709,6 +705,7 @@ int32_t HCameraDevice::UpdateSetting(const std::shared_ptr<OHOS::Camera::CameraM
         std::vector<uint8_t> hdiSettings;
         OHOS::Camera::MetadataUtils::ConvertMetadataToVec(updateSettings_, hdiSettings);
         ReportMetadataDebugLog(updateSettings_);
+        DumpMetadata(updateSettings_);
         CamRetCode rc = (CamRetCode)(hdiCameraDevice_->UpdateSettings(hdiSettings));
         CHECK_ERROR_RETURN_RET_LOG(rc != HDI::Camera::V1_0::NO_ERROR, HdiToServiceError(rc),
             "HCameraDevice::UpdateSetting Failed with error Code: %{public}d", rc);
@@ -992,82 +989,60 @@ void HCameraDevice::ResetDeviceOpenLifeCycleSettings()
         std::make_shared<OHOS::Camera::CameraMetadata>(DEVICE_OPEN_LIFECYCLE_TAGS.size(), DEFAULT_SETTING_ITEM_LENGTH);
 }
 
-int32_t HCameraDevice::InitStreamOperator()
+int32_t HCameraDevice::GetStreamOperator(const sptr<IStreamOperatorCallback> &callbackObj,
+    sptr<OHOS::HDI::Camera::V1_0::IStreamOperator> &streamOperator)
 {
     std::lock_guard<std::mutex> lock(opMutex_);
+    proxyStreamOperatorCallback_ = callbackObj;
     CHECK_ERROR_RETURN_RET_LOG(hdiCameraDevice_ == nullptr, CAMERA_UNKNOWN_ERROR,
-        "HCameraDevice::InitStreamOperator hdiCameraDevice_ is null");
+        "HCameraDevice::GetStreamOperator hdiCameraDevice_ is null");
     CamRetCode rc;
     sptr<OHOS::HDI::Camera::V1_1::ICameraDevice> hdiCameraDeviceV1_1;
     sptr<OHOS::HDI::Camera::V1_2::ICameraDevice> hdiCameraDeviceV1_2;
     sptr<OHOS::HDI::Camera::V1_3::ICameraDevice> hdiCameraDeviceV1_3;
     int32_t versionRes = cameraHostManager_->GetVersionByCamera(cameraID_);
     if (versionRes >= GetVersionId(HDI_VERSION_1, HDI_VERSION_3)) {
-        MEDIA_DEBUG_LOG("HCameraDevice::InitStreamOperator ICameraDevice cast to V1_3");
+        MEDIA_DEBUG_LOG("HCameraDevice::GetStreamOperator ICameraDevice cast to V1_3");
         hdiCameraDeviceV1_3 = OHOS::HDI::Camera::V1_3::ICameraDevice::CastFrom(hdiCameraDevice_);
     } else if (versionRes >= GetVersionId(HDI_VERSION_1, HDI_VERSION_2)) {
-        MEDIA_DEBUG_LOG("HCameraDevice::InitStreamOperator ICameraDevice cast to V1_2");
+        MEDIA_DEBUG_LOG("HCameraDevice::GetStreamOperator ICameraDevice cast to V1_2");
         hdiCameraDeviceV1_2 = OHOS::HDI::Camera::V1_2::ICameraDevice::CastFrom(hdiCameraDevice_);
     } else if (versionRes == GetVersionId(HDI_VERSION_1, HDI_VERSION_1)) {
-        MEDIA_DEBUG_LOG("HCameraDevice::InitStreamOperator ICameraDevice cast to V1_1");
+        MEDIA_DEBUG_LOG("HCameraDevice::GetStreamOperator ICameraDevice cast to V1_1");
         hdiCameraDeviceV1_1 = OHOS::HDI::Camera::V1_1::ICameraDevice::CastFrom(hdiCameraDevice_);
         if (hdiCameraDeviceV1_1 == nullptr) {
-            MEDIA_ERR_LOG("HCameraDevice::InitStreamOperator ICameraDevice cast to V1_1 error");
+            MEDIA_ERR_LOG("HCameraDevice::GetStreamOperator ICameraDevice cast to V1_1 error");
             hdiCameraDeviceV1_1 = static_cast<OHOS::HDI::Camera::V1_1::ICameraDevice*>(hdiCameraDevice_.GetRefPtr());
         }
     }
 
     if (hdiCameraDeviceV1_3 != nullptr && versionRes >= GetVersionId(HDI_VERSION_1, HDI_VERSION_3)) {
         sptr<OHOS::HDI::Camera::V1_3::IStreamOperator> streamOperator_v1_3;
-        rc = (CamRetCode)(hdiCameraDeviceV1_3->GetStreamOperator_V1_3(this, streamOperator_v1_3));
-        streamOperator_ = streamOperator_v1_3;
+        rc = (CamRetCode)(hdiCameraDeviceV1_3->GetStreamOperator_V1_3(callbackObj, streamOperator_v1_3));
+        streamOperator = streamOperator_v1_3;
     } else if (hdiCameraDeviceV1_2 != nullptr && versionRes >= GetVersionId(HDI_VERSION_1, HDI_VERSION_2)) {
-        MEDIA_DEBUG_LOG("HCameraDevice::InitStreamOperator ICameraDevice V1_2");
+        MEDIA_DEBUG_LOG("HCameraDevice::GetStreamOperator ICameraDevice V1_2");
         sptr<OHOS::HDI::Camera::V1_2::IStreamOperator> streamOperator_v1_2;
-        rc = (CamRetCode)(hdiCameraDeviceV1_2->GetStreamOperator_V1_2(this, streamOperator_v1_2));
-        streamOperator_ = streamOperator_v1_2;
+        rc = (CamRetCode)(hdiCameraDeviceV1_2->GetStreamOperator_V1_2(callbackObj, streamOperator_v1_2));
+        streamOperator = streamOperator_v1_2;
     } else if (hdiCameraDeviceV1_1 != nullptr && versionRes == GetVersionId(HDI_VERSION_1, HDI_VERSION_1)) {
-        MEDIA_DEBUG_LOG("HCameraDevice::InitStreamOperator ICameraDevice V1_1");
+        MEDIA_DEBUG_LOG("HCameraDevice::GetStreamOperator ICameraDevice V1_1");
         sptr<OHOS::HDI::Camera::V1_1::IStreamOperator> streamOperator_v1_1;
-        rc = (CamRetCode)(hdiCameraDeviceV1_1->GetStreamOperator_V1_1(this, streamOperator_v1_1));
-        streamOperator_ = streamOperator_v1_1;
+        rc = (CamRetCode)(hdiCameraDeviceV1_1->GetStreamOperator_V1_1(callbackObj, streamOperator_v1_1));
+        streamOperator = streamOperator_v1_1;
     } else {
-        MEDIA_DEBUG_LOG("HCameraDevice::InitStreamOperator ICameraDevice V1_0");
-        rc = (CamRetCode)(hdiCameraDevice_->GetStreamOperator(this, streamOperator_));
+        MEDIA_DEBUG_LOG("HCameraDevice::GetStreamOperator ICameraDevice V1_0");
+        rc = (CamRetCode)(hdiCameraDevice_->GetStreamOperator(callbackObj, streamOperator));
     }
     if (rc != HDI::Camera::V1_0::NO_ERROR) {
-        MEDIA_ERR_LOG("HCameraDevice::InitStreamOperator failed with error Code:%{public}d", rc);
+        MEDIA_ERR_LOG("HCameraDevice::GetStreamOperator failed with error Code:%{public}d", rc);
         CameraReportUtils::ReportCameraError(
-            "HCameraDevice::InitStreamOperator", rc, true, CameraReportUtils::GetCallerInfo());
-        streamOperator_ = nullptr;
+            "HCameraDevice::GetStreamOperator", rc, true, CameraReportUtils::GetCallerInfo());
         return HdiToServiceError(rc);
     }
     return CAMERA_OK;
 }
 
-int32_t HCameraDevice::ReleaseStreams(std::vector<int32_t>& releaseStreamIds)
-{
-    CAMERA_SYNC_TRACE;
-    std::lock_guard<std::mutex> lock(opMutex_);
-    if (streamOperator_ != nullptr && !releaseStreamIds.empty()) {
-        MEDIA_INFO_LOG("HCameraDevice::ReleaseStreams %{public}s",
-            Container2String(releaseStreamIds.begin(), releaseStreamIds.end()).c_str());
-        int32_t rc = streamOperator_->ReleaseStreams(releaseStreamIds);
-        if (rc != HDI::Camera::V1_0::NO_ERROR) {
-            MEDIA_ERR_LOG("HCameraDevice::ClearStreamOperator ReleaseStreams fail, error Code:%{public}d", rc);
-            CameraReportUtils::ReportCameraError(
-                "HCameraDevice::ReleaseStreams", rc, true, CameraReportUtils::GetCallerInfo());
-        }
-    }
-    return CAMERA_OK;
-}
-
-sptr<OHOS::HDI::Camera::V1_0::IStreamOperator> HCameraDevice::GetStreamOperator()
-{
-    std::lock_guard<std::mutex> lock(opMutex_);
-    return streamOperator_;
-}
-
 int32_t HCameraDevice::OnError(const OHOS::HDI::Camera::V1_0::ErrorType type, const int32_t errorMsg)
 {
     auto errType = static_cast<OHOS::HDI::Camera::V1_3::ErrorType>(type);
@@ -1161,20 +1136,6 @@ int32_t HCameraDevice::OnResult(const uint64_t timestamp, const std::vector<uint
     return CAMERA_OK;
 }
 
-int32_t HCameraDevice::OnResult(int32_t streamId, const std::vector<uint8_t>& result)
-{
-    CHECK_ERROR_RETURN_RET_LOG(result.size() == 0, CAMERA_INVALID_ARG, "onResult get null meta from HAL");
-    std::shared_ptr<OHOS::Camera::CameraMetadata> cameraResult = nullptr;
-    OHOS::Camera::MetadataUtils::ConvertVecToMetadata(result, cameraResult);
-    if (cameraResult == nullptr) {
-        cameraResult = std::make_shared<OHOS::Camera::CameraMetadata>(0, 0);
-    }
-    auto streamOperatorCallback = GetStreamOperatorCallback();
-    CHECK_EXECUTE(streamOperatorCallback != nullptr, streamOperatorCallback->OnResult(streamId, result));
-    CHECK_EXECUTE(IsCameraDebugOn(), CheckOnResultData(cameraResult));
-    return CAMERA_OK;
-}
-
 void HCameraDevice::GetMovingPhotoStartAndEndTime(std::shared_ptr<OHOS::Camera::CameraMetadata> cameraResult)
 {
     MEDIA_DEBUG_LOG("HCameraDevice::GetMovingPhotoStartAndEndTime enter.");
@@ -1219,116 +1180,6 @@ int32_t HCameraDevice::GetCallerToken()
     return callerToken_;
 }
 
-int32_t HCameraDevice::CreateStreams(std::vector<HDI::Camera::V1_1::StreamInfo_V1_1>& streamInfos)
-{
-    CamRetCode hdiRc = HDI::Camera::V1_0::NO_ERROR;
-    uint32_t major;
-    uint32_t minor;
-    CHECK_ERROR_RETURN_RET_LOG(streamInfos.empty(), CAMERA_OK, "HCameraDevice::CreateStreams streamInfos is empty!");
-    std::lock_guard<std::mutex> lock(opMutex_);
-    sptr<OHOS::HDI::Camera::V1_1::IStreamOperator> streamOperatorV1_1;
-    sptr<OHOS::HDI::Camera::V1_0::IStreamOperator> streamOperator = streamOperator_;
-    CHECK_ERROR_RETURN_RET_LOG(streamOperator == nullptr, CAMERA_UNKNOWN_ERROR,
-        "HCameraDevice::CreateStreams GetStreamOperator is null!");
-    // get higher streamOperator version
-    streamOperator->GetVersion(major, minor);
-    MEDIA_INFO_LOG("streamOperator GetVersion major:%{public}d, minor:%{public}d", major, minor);
-    if (major >= HDI_VERSION_1 && minor >= HDI_VERSION_1) {
-        streamOperatorV1_1 = OHOS::HDI::Camera::V1_1::IStreamOperator::CastFrom(streamOperator);
-        if (streamOperatorV1_1 == nullptr) {
-            MEDIA_ERR_LOG("HCameraDevice::CreateStreams IStreamOperator cast to V1_1 error");
-            streamOperatorV1_1 = static_cast<OHOS::HDI::Camera::V1_1::IStreamOperator*>(streamOperator.GetRefPtr());
-        }
-    }
-    if (streamOperatorV1_1 != nullptr) {
-        MEDIA_INFO_LOG("HCameraDevice::CreateStreams streamOperator V1_1");
-        for (auto streamInfo : streamInfos) {
-            if (streamInfo.extendedStreamInfos.size() > 0) {
-                MEDIA_INFO_LOG("HCameraDevice::CreateStreams streamOperator V1_1 type %{public}d",
-                    streamInfo.extendedStreamInfos[0].type);
-            }
-        }
-        hdiRc = (CamRetCode)(streamOperatorV1_1->CreateStreams_V1_1(streamInfos));
-    } else {
-        MEDIA_INFO_LOG("HCameraDevice::CreateStreams streamOperator V1_0");
-        std::vector<StreamInfo> streamInfos_V1_0;
-        for (auto streamInfo : streamInfos) {
-            streamInfos_V1_0.emplace_back(streamInfo.v1_0);
-        }
-        hdiRc = (CamRetCode)(streamOperator->CreateStreams(streamInfos_V1_0));
-    }
-    if (hdiRc != HDI::Camera::V1_0::NO_ERROR) {
-        MEDIA_ERR_LOG("HCameraDevice::CreateStreams(), Failed to commit %{public}d", hdiRc);
-        CameraReportUtils::ReportCameraError(
-            "HCameraDevice::CreateStreams", hdiRc, true, CameraReportUtils::GetCallerInfo());
-        std::vector<int32_t> streamIds;
-        for (auto& streamInfo : streamInfos) {
-            streamIds.emplace_back(streamInfo.v1_0.streamId_);
-        }
-        CHECK_ERROR_PRINT_LOG(!streamIds.empty() &&
-            streamOperator->ReleaseStreams(streamIds) != HDI::Camera::V1_0::NO_ERROR,
-            "HCameraDevice::CreateStreams(), Failed to release streams");
-    }
-    for (auto& info : streamInfos) {
-        MEDIA_INFO_LOG("HCameraDevice::CreateStreams stream id is:%{public}d", info.v1_0.streamId_);
-    }
-    return HdiToServiceError(hdiRc);
-}
-
-int32_t HCameraDevice::CommitStreams(
-    std::shared_ptr<OHOS::Camera::CameraMetadata>& deviceSettings, int32_t operationMode)
-{
-    CamRetCode hdiRc = HDI::Camera::V1_0::NO_ERROR;
-    uint32_t major;
-    uint32_t minor;
-    sptr<OHOS::HDI::Camera::V1_0::IStreamOperator> streamOperator;
-    sptr<OHOS::HDI::Camera::V1_1::IStreamOperator> streamOperatorV1_1;
-    std::lock_guard<std::mutex> lock(opMutex_);
-    streamOperator = streamOperator_;
-    CHECK_ERROR_RETURN_RET_LOG(streamOperator == nullptr, CAMERA_UNKNOWN_ERROR,
-        "HCameraDevice::CommitStreams GetStreamOperator is null!");
-    // get higher streamOperator version
-    streamOperator->GetVersion(major, minor);
-    MEDIA_INFO_LOG(
-        "HCameraDevice::CommitStreams streamOperator GetVersion major:%{public}d, minor:%{public}d", major, minor);
-    if (major >= HDI_VERSION_1 && minor >= HDI_VERSION_1) {
-        MEDIA_DEBUG_LOG("HCameraDevice::CommitStreams IStreamOperator cast to V1_1");
-        streamOperatorV1_1 = OHOS::HDI::Camera::V1_1::IStreamOperator::CastFrom(streamOperator);
-        if (streamOperatorV1_1 == nullptr) {
-            MEDIA_ERR_LOG("HCameraDevice::CommitStreams IStreamOperator cast to V1_1 error");
-            streamOperatorV1_1 = static_cast<OHOS::HDI::Camera::V1_1::IStreamOperator*>(streamOperator.GetRefPtr());
-        }
-    }
-
-    std::vector<uint8_t> setting;
-    OHOS::Camera::MetadataUtils::ConvertMetadataToVec(deviceSettings, setting);
-    MEDIA_INFO_LOG("HCameraDevice::CommitStreams, commit mode %{public}d", operationMode);
-    if (streamOperatorV1_1 != nullptr) {
-        MEDIA_DEBUG_LOG("HCameraDevice::CommitStreams IStreamOperator V1_1");
-        hdiRc = (CamRetCode)(streamOperatorV1_1->CommitStreams_V1_1(
-            static_cast<OHOS::HDI::Camera::V1_1::OperationMode_V1_1>(operationMode), setting));
-    } else {
-        MEDIA_DEBUG_LOG("HCameraDevice::CommitStreams IStreamOperator V1_0");
-        OperationMode opMode = OperationMode::NORMAL;
-        hdiRc = (CamRetCode)(streamOperator->CommitStreams(opMode, setting));
-    }
-    if (hdiRc != HDI::Camera::V1_0::NO_ERROR) {
-        MEDIA_ERR_LOG("HCameraDevice::CommitStreams failed with error Code:%d", hdiRc);
-        CameraReportUtils::ReportCameraError(
-            "HCameraDevice::CommitStreams", hdiRc, true, CameraReportUtils::GetCallerInfo());
-    }
-    MEDIA_DEBUG_LOG("HCameraDevice::CommitStreams end");
-    return HdiToServiceError(hdiRc);
-}
-
-int32_t HCameraDevice::CreateAndCommitStreams(std::vector<HDI::Camera::V1_1::StreamInfo_V1_1>& streamInfos,
-    std::shared_ptr<OHOS::Camera::CameraMetadata>& deviceSettings, int32_t operationMode)
-{
-    int retCode = CreateStreams(streamInfos);
-    CHECK_ERROR_RETURN_RET(retCode != CAMERA_OK, retCode);
-    return CommitStreams(deviceSettings, operationMode);
-}
-
 bool HCameraDevice::CanOpenCamera()
 {
     int32_t cost;
@@ -1375,35 +1226,6 @@ bool HCameraDevice::GetCameraResourceCost(int32_t &cost, std::set<std::string> &
     return true;
 }
 
-int32_t HCameraDevice::UpdateStreams(std::vector<StreamInfo_V1_1>& streamInfos)
-{
-    sptr<OHOS::HDI::Camera::V1_0::IStreamOperator> streamOperator;
-    sptr<OHOS::HDI::Camera::V1_2::IStreamOperator> streamOperatorV1_2;
-    streamOperator = GetStreamOperator();
-    CHECK_ERROR_RETURN_RET_LOG(streamOperator == nullptr, CAMERA_UNKNOWN_ERROR,
-        "HCameraDevice::UpdateStreamInfos GetStreamOperator is null!");
-    uint32_t major;
-    uint32_t minor;
-    streamOperator->GetVersion(major, minor);
-    MEDIA_INFO_LOG("UpdateStreamInfos: streamOperator GetVersion major:%{public}d, minor:%{public}d", major, minor);
-    if (major >= HDI_VERSION_1 && minor >= HDI_VERSION_2) {
-        streamOperatorV1_2 = OHOS::HDI::Camera::V1_2::IStreamOperator::CastFrom(streamOperator);
-        if (streamOperatorV1_2 == nullptr) {
-            MEDIA_ERR_LOG("HCaptureSession::UpdateStreamInfos IStreamOperator cast to V1_2 error");
-            streamOperatorV1_2 = static_cast<OHOS::HDI::Camera::V1_2::IStreamOperator*>(streamOperator.GetRefPtr());
-        }
-    }
-    CamRetCode hdiRc = HDI::Camera::V1_0::CamRetCode::NO_ERROR;
-    if (streamOperatorV1_2 != nullptr) {
-        MEDIA_DEBUG_LOG("HCaptureSession::UpdateStreamInfos streamOperator V1_2");
-        hdiRc = (CamRetCode)(streamOperatorV1_2->UpdateStreams(streamInfos));
-    } else {
-        MEDIA_DEBUG_LOG("HCaptureSession::UpdateStreamInfos failed, streamOperator V1_2 is null.");
-        return CAMERA_UNKNOWN_ERROR;
-    }
-    return HdiToServiceError(hdiRc);
-}
-
 #ifdef CAMERA_USE_SENSOR
 void HCameraDevice::RegisterDropDetectionListener()
 {
@@ -1595,64 +1417,6 @@ int32_t HCameraDevice::OperatePermissionCheck(uint32_t interfaceCode)
     return CAMERA_OK;
 }
 
-int32_t HCameraDevice::OnCaptureStarted(int32_t captureId, const std::vector<int32_t>& streamIds)
-{
-    auto streamOperatorCallback = GetStreamOperatorCallback();
-    CHECK_ERROR_RETURN_RET(streamOperatorCallback == nullptr, CAMERA_INVALID_STATE);
-    return streamOperatorCallback->OnCaptureStarted(captureId, streamIds);
-}
-
-int32_t HCameraDevice::OnCaptureStarted_V1_2(
-    int32_t captureId, const std::vector<OHOS::HDI::Camera::V1_2::CaptureStartedInfo>& infos)
-{
-    auto streamOperatorCallback = GetStreamOperatorCallback();
-    CHECK_ERROR_RETURN_RET(streamOperatorCallback == nullptr, CAMERA_INVALID_STATE);
-    return streamOperatorCallback->OnCaptureStarted_V1_2(captureId, infos);
-}
-
-int32_t HCameraDevice::OnCaptureEnded(int32_t captureId, const std::vector<CaptureEndedInfo>& infos)
-{
-    auto streamOperatorCallback = GetStreamOperatorCallback();
-    CHECK_ERROR_RETURN_RET(streamOperatorCallback == nullptr, CAMERA_INVALID_STATE);
-    return streamOperatorCallback->OnCaptureEnded(captureId, infos);
-}
-
-int32_t HCameraDevice::OnCaptureEndedExt(int32_t captureId,
-    const std::vector<OHOS::HDI::Camera::V1_3::CaptureEndedInfoExt>& infos)
-{
-    auto streamOperatorCallback = GetStreamOperatorCallback();
-    CHECK_ERROR_RETURN_RET(streamOperatorCallback == nullptr, CAMERA_INVALID_STATE);
-    return streamOperatorCallback->OnCaptureEndedExt(captureId, infos);
-}
-
-int32_t HCameraDevice::OnCaptureError(int32_t captureId, const std::vector<CaptureErrorInfo>& infos)
-{
-    auto streamOperatorCallback = GetStreamOperatorCallback();
-    CHECK_ERROR_RETURN_RET(streamOperatorCallback == nullptr, CAMERA_INVALID_STATE);
-    return streamOperatorCallback->OnCaptureError(captureId, infos);
-}
-
-int32_t HCameraDevice::OnFrameShutter(int32_t captureId, const std::vector<int32_t>& streamIds, uint64_t timestamp)
-{
-    auto streamOperatorCallback = GetStreamOperatorCallback();
-    CHECK_ERROR_RETURN_RET(streamOperatorCallback == nullptr, CAMERA_INVALID_STATE);
-    return streamOperatorCallback->OnFrameShutter(captureId, streamIds, timestamp);
-}
-
-int32_t HCameraDevice::OnFrameShutterEnd(int32_t captureId, const std::vector<int32_t>& streamIds, uint64_t timestamp)
-{
-    auto streamOperatorCallback = GetStreamOperatorCallback();
-    CHECK_ERROR_RETURN_RET(streamOperatorCallback == nullptr, CAMERA_INVALID_STATE);
-    return streamOperatorCallback->OnFrameShutterEnd(captureId, streamIds, timestamp);
-}
-
-int32_t HCameraDevice::OnCaptureReady(int32_t captureId, const std::vector<int32_t>& streamIds, uint64_t timestamp)
-{
-    auto streamOperatorCallback = GetStreamOperatorCallback();
-    CHECK_ERROR_RETURN_RET(streamOperatorCallback == nullptr, CAMERA_INVALID_STATE);
-    return streamOperatorCallback->OnCaptureReady(captureId, streamIds, timestamp);
-}
-
 void HCameraDevice::NotifyCameraSessionStatus(bool running)
 {
     bool isSystemCamera = (clientName_ == SYSTEM_CAMERA);
diff --git a/services/camera_service/src/hcamera_service.cpp b/services/camera_service/src/hcamera_service.cpp
index 3b40ea06..08bcb923 100644
--- a/services/camera_service/src/hcamera_service.cpp
+++ b/services/camera_service/src/hcamera_service.cpp
@@ -43,6 +43,7 @@
 #include "device_manager.h"
 #endif
 #include "hcamera_device_manager.h"
+#include "hstream_operator_manager.h"
 #include "ipc_skeleton.h"
 #include "iservice_registry.h"
 #include "os_account_manager.h"
@@ -532,6 +533,10 @@ int32_t HCameraService::CreateCaptureSession(sptr<ICaptureSession>& session, int
     session = captureSession;
     pid_t pid = IPCSkeleton::GetCallingPid();
     captureSessionsManager_.EnsureInsert(pid, captureSession);
+
+    sptr<HStreamOperator> hStreamOperator = HStreamOperator::NewInstance(callerToken, opMode);
+    captureSession->SetStreamOperator(hStreamOperator);
+    HStreamOperatorManager::GetInstance()->AddStreamOperator(hStreamOperator); // streamoperator key
     return rc;
 }
 
@@ -1838,7 +1843,7 @@ int32_t HCameraService::SaveCurrentParamForRestore(std::string cameraId, Restore
     int count = 0;
     for (auto& info : allStreamInfos) {
         MEDIA_INFO_LOG("HCameraService::SaveCurrentParamForRestore: streamId is:%{public}d", info.v1_0.streamId_);
-        count = (info.v1_0.streamId_ == 0) ? count++ : 0;
+        count += (info.v1_0.streamId_ == 0) ? 1: 0;
     }
     CaptureSessionState currentState;
     captureSession->GetSessionState(currentState);
diff --git a/services/camera_service/src/hcamera_session_manager.cpp b/services/camera_service/src/hcamera_session_manager.cpp
index ac52f4b6..0be014a9 100644
--- a/services/camera_service/src/hcamera_session_manager.cpp
+++ b/services/camera_service/src/hcamera_session_manager.cpp
@@ -22,6 +22,7 @@
 
 #include "camera_util.h"
 #include "hcapture_session.h"
+#include "camera_dynamic_loader.h"
 #include "parameters.h"
 
 namespace OHOS {
@@ -143,9 +144,6 @@ void HCameraSessionManager::RemoveGroup(pid_t pid)
 void HCameraSessionManager::RemoveGroupNoLock(std::unordered_map<pid_t, SessionGroup>::iterator mapIt)
 {
     totalSessionMap_.erase(mapIt);
-    if (totalSessionMap_.empty()) {
-        CameraDynamicLoader::FreeDynamiclib(MEDIA_LIB_SO);
-    }
 }
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/services/camera_service/src/hcapture_session.cpp b/services/camera_service/src/hcapture_session.cpp
index 76587b90..4b56a3c5 100644
--- a/services/camera_service/src/hcapture_session.cpp
+++ b/services/camera_service/src/hcapture_session.cpp
@@ -65,7 +65,6 @@
 #include "moving_photo/moving_photo_surface_wrapper.h"
 #include "moving_photo_video_cache.h"
 #include "parameters.h"
-#include "picture.h"
 #include "refbase.h"
 #include "smooth_zoom.h"
 #include "surface.h"
@@ -80,12 +79,6 @@ namespace CameraStandard {
 using namespace OHOS::HDI::Display::Composer::V1_1;
 
 namespace {
-#ifdef CAMERA_USE_SENSOR
-constexpr int32_t POSTURE_INTERVAL = 100000000; // 100ms;
-constexpr int VALID_INCLINATION_ANGLE_THRESHOLD_COEFFICIENT = 3;
-#endif
-static GravityData gravityData = { 0.0, 0.0, 0.0 };
-static int32_t sensorRotation = 0;
 constexpr int32_t WIDE_CAMERA_ZOOM_RANGE = 0;
 constexpr int32_t MAIN_CAMERA_ZOOM_RANGE = 1;
 constexpr int32_t TWO_X_EXIT_TELE_ZOOM_RANGE = 2;
@@ -149,10 +142,6 @@ HCaptureSession::~HCaptureSession()
 {
     CAMERA_SYNC_TRACE;
     Release(CaptureSessionReleaseType::RELEASE_TYPE_OBJ_DIED);
-    if (displayListener_) {
-        OHOS::Rosen::DisplayManager::GetInstance().UnregisterDisplayListener(displayListener_);
-        displayListener_ = nullptr;
-    }
 }
 
 pid_t HCaptureSession::GetPid()
@@ -168,17 +157,13 @@ int32_t HCaptureSession::GetopMode()
 
 int32_t HCaptureSession::GetCurrentStreamInfos(std::vector<StreamInfo_V1_1>& streamInfos)
 {
-    auto streams = streamContainer_.GetAllStreams();
-    for (auto& stream : streams) {
-        if (stream) {
-            StreamInfo_V1_1 curStreamInfo;
-            stream->SetStreamInfo(curStreamInfo);
-            CHECK_EXECUTE(stream->GetStreamType() != StreamType::METADATA, streamInfos.push_back(curStreamInfo));
-        }
-    }
-    return CAMERA_OK;
+    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    CHECK_ERROR_RETURN_RET_LOG(hStreamOperatorSptr == nullptr, CAMERA_INVALID_ARG,
+        "hStreamOperator_ is null");
+    return hStreamOperatorSptr->GetCurrentStreamInfos(streamInfos);
 }
 
+
 void HCaptureSession::DynamicConfigStream()
 {
     isDynamicConfiged_ = false;
@@ -209,7 +194,9 @@ int32_t HCaptureSession::BeginConfig()
             isDynamicConfiged_ = false;
             return;
         }
-        if (!IsNeedDynamicConfig()) {
+        auto hStreamOperatorSptr = hStreamOperator_.promote();
+        CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr, "hStreamOperator_ is null");
+        if (!IsNeedDynamicConfig() && (hStreamOperatorSptr->GetOfflineOutptSize() == 0)) {
             UnlinkInputAndOutputs();
             ClearSketchRepeatStream();
             ClearMovingPhotoRepeatStream();
@@ -279,13 +266,10 @@ int32_t HCaptureSession::AddInput(sptr<ICameraDeviceService> cameraDevice)
         }
         sptr<HCameraDevice> hCameraDevice = static_cast<HCameraDevice*>(cameraDevice.GetRefPtr());
         MEDIA_INFO_LOG("HCaptureSession::AddInput device:%{public}s", hCameraDevice->GetCameraId().c_str());
-        auto deviceSession = hCameraDevice->GetStreamOperatorCallback();
-        if (deviceSession != nullptr) {
-            errorCode = CAMERA_OPERATION_NOT_ALLOWED;
-            return;
-        }
-        hCameraDevice->SetStreamOperatorCallback(this);
         SetCameraDevice(hCameraDevice);
+        auto hStreamOperatorSptr = hStreamOperator_.promote();
+        CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr, "hStreamOperator_ is null");
+        hStreamOperatorSptr->ResetHdiStreamId();
         hCameraDevice->DispatchDefaultSettingToHdi();
     });
     if (errorCode == CAMERA_OK) {
@@ -298,81 +282,6 @@ int32_t HCaptureSession::AddInput(sptr<ICameraDeviceService> cameraDevice)
     return errorCode;
 }
 
-int32_t HCaptureSession::AddOutputStream(sptr<HStreamCommon> stream)
-{
-    CAMERA_SYNC_TRACE;
-    CHECK_ERROR_RETURN_RET_LOG(
-        stream == nullptr, CAMERA_INVALID_ARG, "HCaptureSession::AddOutputStream stream is null");
-    MEDIA_INFO_LOG("HCaptureSession::AddOutputStream streamId:%{public}d streamType:%{public}d",
-        stream->GetFwkStreamId(), stream->GetStreamType());
-    CHECK_ERROR_RETURN_RET_LOG(
-        stream->GetFwkStreamId() == STREAM_ID_UNSET && stream->GetStreamType() != StreamType::METADATA,
-        CAMERA_INVALID_ARG, "HCaptureSession::AddOutputStream stream is released!");
-    bool isAddSuccess = streamContainer_.AddStream(stream);
-    CHECK_ERROR_RETURN_RET_LOG(
-        !isAddSuccess, CAMERA_INVALID_SESSION_CFG, "HCaptureSession::AddOutputStream add stream fail");
-    if (stream->GetStreamType() == StreamType::CAPTURE) {
-        auto captureStream = CastStream<HStreamCapture>(stream);
-        captureStream->SetMode(opMode_);
-        captureStream->SetColorSpace(currCaptureColorSpace_);
-        CameraDynamicLoader::LoadDynamiclibAsync(MEDIA_LIB_SO);
-    } else {
-        stream->SetColorSpace(currColorSpace_);
-    }
-    return CAMERA_OK;
-}
-
-void HCaptureSession::StartMovingPhotoStream()
-{
-    int32_t errorCode = 0;
-    stateMachine_.StateGuard([&errorCode, this](CaptureSessionState currentState) {
-        if (currentState != CaptureSessionState::SESSION_CONFIG_COMMITTED) {
-            MEDIA_ERR_LOG("EnableMovingPhoto, invalid session state: %{public}d, start after preview", currentState);
-            errorCode = CAMERA_INVALID_STATE;
-            return;
-        }
-        auto repeatStreams = streamContainer_.GetStreams(StreamType::REPEAT);
-        bool isPreviewStarted = false;
-        for (auto& item : repeatStreams) {
-            auto curStreamRepeat = CastStream<HStreamRepeat>(item);
-            auto repeatType = curStreamRepeat->GetRepeatStreamType();
-            if (repeatType != RepeatStreamType::PREVIEW) {
-                continue;
-            }
-            if (curStreamRepeat->GetPreparedCaptureId() != CAPTURE_ID_UNSET && curStreamRepeat->producer_ != nullptr) {
-                isPreviewStarted = true;
-                break;
-            }
-        }
-        CHECK_ERROR_RETURN_LOG(!isPreviewStarted, "EnableMovingPhoto, preview is not streaming");
-        std::shared_ptr<OHOS::Camera::CameraMetadata> settings = nullptr;
-        auto cameraDevice = GetCameraDevice();
-        if (cameraDevice != nullptr) {
-            settings = cameraDevice->CloneCachedSettings();
-            DumpMetadata(settings);
-        }
-        for (auto& item : repeatStreams) {
-            auto curStreamRepeat = CastStream<HStreamRepeat>(item);
-            auto repeatType = curStreamRepeat->GetRepeatStreamType();
-            if (repeatType != RepeatStreamType::LIVEPHOTO) {
-                continue;
-            }
-            if (isSetMotionPhoto_) {
-                errorCode = curStreamRepeat->Start(settings);
-#ifdef MOVING_PHOTO_ADD_AUDIO
-                std::lock_guard<std::mutex> lock(movingPhotoStatusLock_);
-                audioCapturerSession_ != nullptr && audioCapturerSession_->StartAudioCapture();
-#endif
-            } else {
-                errorCode = curStreamRepeat->Stop();
-                StopMovingPhoto();
-            }
-            break;
-        }
-    });
-    MEDIA_INFO_LOG("HCaptureSession::StartMovingPhotoStream result:%{public}d", errorCode);
-}
-
 class DisplayRotationListener : public OHOS::Rosen::DisplayManager::IDisplayListener {
 public:
     explicit DisplayRotationListener() {};
@@ -416,24 +325,12 @@ public:
     std::mutex mStreamManagerLock_;
 };
 
-void HCaptureSession::RegisterDisplayListener(sptr<HStreamRepeat> repeat)
+int32_t HCaptureSession::SetPreviewRotation(std::string &deviceClass)
 {
-    if (displayListener_ == nullptr) {
-        displayListener_ = new DisplayRotationListener();
-        OHOS::Rosen::DisplayManager::GetInstance().RegisterDisplayListener(displayListener_);
-    }
-    displayListener_->AddHstreamRepeatForListener(repeat);
-}
-
-void HCaptureSession::UnregisterDisplayListener(sptr<HStreamRepeat> repeatStream)
-{
-    CHECK_EXECUTE(displayListener_, displayListener_->RemoveHstreamRepeatForListener(repeatStream));
-}
-
-int32_t HCaptureSession::SetPreviewRotation(std::string& deviceClass)
-{
-    enableStreamRotate_ = true;
-    deviceClass_ = deviceClass;
+    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    CHECK_ERROR_RETURN_RET_LOG(hStreamOperatorSptr == nullptr, CAMERA_INVALID_ARG,
+        "hStreamOperator_ is null");
+    hStreamOperatorSptr->SetPreviewRotation(deviceClass);
     return CAMERA_OK;
 }
 
@@ -447,28 +344,14 @@ int32_t HCaptureSession::AddOutput(StreamType streamType, sptr<IStreamCommon> st
         return errorCode;
     }
     stateMachine_.StateGuard([this, &errorCode, streamType, &stream](const CaptureSessionState currentState) {
+        auto hStreamOperatorSptr = hStreamOperator_.promote();
+        CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr, "hStreamOperator_ is null");
         if (currentState != CaptureSessionState::SESSION_CONFIG_INPROGRESS) {
             MEDIA_ERR_LOG("HCaptureSession::AddOutput Need to call BeginConfig before adding output");
             errorCode = CAMERA_INVALID_STATE;
             return;
         }
-        // Temp hack to fix the library linking issue
-        sptr<IConsumerSurface> captureSurface = IConsumerSurface::Create();
-        if (streamType == StreamType::CAPTURE) {
-            errorCode = AddOutputStream(static_cast<HStreamCapture*>(stream.GetRefPtr()));
-        } else if (streamType == StreamType::REPEAT) {
-            HStreamRepeat* repeatSteam = static_cast<HStreamRepeat*>(stream.GetRefPtr());
-            if (enableStreamRotate_ && repeatSteam != nullptr &&
-                repeatSteam->GetRepeatStreamType() == RepeatStreamType::PREVIEW) {
-                RegisterDisplayListener(repeatSteam);
-                repeatSteam->SetPreviewRotation(deviceClass_);
-            }
-            errorCode = AddOutputStream(repeatSteam);
-        } else if (streamType == StreamType::METADATA) {
-            errorCode = AddOutputStream(static_cast<HStreamMetadata*>(stream.GetRefPtr()));
-        } else if (streamType == StreamType::DEPTH) {
-            errorCode = AddOutputStream(static_cast<HStreamDepthData*>(stream.GetRefPtr()));
-        }
+        errorCode = hStreamOperatorSptr->AddOutput(streamType, stream);