diff --git a/frameworks/native/camera/src/output/photo_output.cpp b/frameworks/native/camera/src/output/photo_output.cpp
index 281ad121..1baa4fda 100644
--- a/frameworks/native/camera/src/output/photo_output.cpp
+++ b/frameworks/native/camera/src/output/photo_output.cpp
@@ -282,10 +282,13 @@ int32_t HStreamCaptureCallbackImpl::OnCaptureEnded(const int32_t captureId, cons
         DeferredProcessing::GetGlobalWatchdog().StopMonitor((timeStartIter->second).CaptureHandle);
         (photoOutput->captureIdToCaptureInfoMap_).erase(captureId);
         if (photoOutput->IsHasSwitchOfflinePhoto() && (photoOutput->captureIdToCaptureInfoMap_).size() == 0) {
-            MEDIA_INFO_LOG("OnCaptureReady notify offline delivery finished with capture ID: %{public}d", captureId);
+            MEDIA_INFO_LOG("OnCaptureEnded notify offline delivery finished with capture ID: %{public}d", captureId);
             auto callback = photoOutput->GetApplicationCallback();
-            CHECK_ERROR_RETURN_RET_LOG(callback == nullptr, CAMERA_OK,
-                "HStreamCaptureCallbackImpl::OnCaptureReady callback is nullptr");
+            if (callback == nullptr) {
+                MEDIA_INFO_LOG("HStreamCaptureCallbackImpl::OnCaptureEnded callback is nullptr");
+                photoOutput->Release();
+                return CAMERA_OK;
+            }
             callback->OnOfflineDeliveryFinished(captureId);
         }
     }
diff --git a/services/camera_service/include/hstream_capture.h b/services/camera_service/include/hstream_capture.h
index 48bcc73f..b7d25bd4 100644
--- a/services/camera_service/include/hstream_capture.h
+++ b/services/camera_service/include/hstream_capture.h
@@ -113,7 +113,6 @@ public:
     int32_t EnableOfflinePhoto(bool isEnable) override;
     bool IsHasEnableOfflinePhoto();
     void SwitchToOffline();
-    int32_t UnlinkInput() override;
     bool IsHasSwitchToOffline();
     void SetStreamOperator(wptr<HStreamOperator> hStreamOperator);
     int32_t CreateMediaLibrary(sptr<CameraPhotoProxy>& photoProxy, std::string& uri, int32_t& cameraShotType,
diff --git a/services/camera_service/include/hstream_operator.h b/services/camera_service/include/hstream_operator.h
index 7029745c..4b701263 100644
--- a/services/camera_service/include/hstream_operator.h
+++ b/services/camera_service/include/hstream_operator.h
@@ -212,6 +212,7 @@ public:
     int32_t OnCaptureReady(int32_t captureId, const std::vector<int32_t>& streamIds, uint64_t timestamp) override;
     int32_t OnResult(int32_t streamId, const std::vector<uint8_t>& result) override;
     int32_t UnlinkInputAndOutputs();
+    int32_t UnlinkOfflineInputAndOutputs();
     void RegisterDisplayListener(sptr<HStreamRepeat> repeat);
     void UnRegisterDisplayListener(sptr<HStreamRepeat> repeat);
     void ClearSketchRepeatStream();
@@ -220,6 +221,10 @@ public:
     void ClearMovingPhotoRepeatStream();
     void GetStreamOperator();
     bool IsOfflineCapture();
+    inline int32_t GetPid()
+    {
+        return static_cast<int32_t>(pid_);
+    }
     inline void ResetHdiStreamId()
     {
         hdiStreamIdGenerator_ = HDI_STREAM_ID_INIT;
diff --git a/services/camera_service/include/hstream_operator_manager.h b/services/camera_service/include/hstream_operator_manager.h
index 6e11cd02..f24d2572 100644
--- a/services/camera_service/include/hstream_operator_manager.h
+++ b/services/camera_service/include/hstream_operator_manager.h
@@ -38,6 +38,8 @@ public:
 
     int32_t GetOfflineOutputSize();
 
+    std::vector<sptr<HStreamOperator>> GetStreamOperatorByPid(pid_t pidRequest);
+
 private:
     HStreamOperatorManager();
     std::mutex mapMutex_;
diff --git a/services/camera_service/src/hcamera_service.cpp b/services/camera_service/src/hcamera_service.cpp
index 1537e939..00f6c1cb 100644
--- a/services/camera_service/src/hcamera_service.cpp
+++ b/services/camera_service/src/hcamera_service.cpp
@@ -887,6 +887,12 @@ int32_t HCameraService::CloseCameraForDestory(pid_t pid)
     for (auto device : devicesNeedClose) {
         device->Close();
     }
+
+    std::vector<sptr<HStreamOperator>> streamOperatorToRelease =
+        HStreamOperatorManager::GetInstance()->GetStreamOperatorByPid(pid);
+    for (auto streamoperator : streamOperatorToRelease) {
+        streamoperator->Release();
+    }
     return CAMERA_OK;
 }
 
diff --git a/services/camera_service/src/hstream_capture.cpp b/services/camera_service/src/hstream_capture.cpp
index 9c8d1a9f..ef4082b5 100644
--- a/services/camera_service/src/hstream_capture.cpp
+++ b/services/camera_service/src/hstream_capture.cpp
@@ -951,15 +951,6 @@ void HStreamCapture::SwitchToOffline()
     mSwitchToOfflinePhoto_ = true;
 }
 
-int32_t HStreamCapture::UnlinkInput()
-{
-    if (mSwitchToOfflinePhoto_) {
-        MEDIA_INFO_LOG("HStreamCapture::UnlinkInput, current is offline capture, cancel unlink");
-        return CAMERA_OK;
-    }
-    return HStreamCommon::UnlinkInput();
-}
-
 bool HStreamCapture::IsHasSwitchToOffline()
 {
     return mSwitchToOfflinePhoto_;
diff --git a/services/camera_service/src/hstream_operator.cpp b/services/camera_service/src/hstream_operator.cpp
index 32df5bd8..c732ff51 100644
--- a/services/camera_service/src/hstream_operator.cpp
+++ b/services/camera_service/src/hstream_operator.cpp
@@ -418,7 +418,9 @@ void  HStreamOperator::GetStreamOperator()
 
 bool HStreamOperator::IsOfflineCapture()
 {
-    auto allStream = streamContainer_.GetAllStreams();
+    std::list<sptr<HStreamCommon>> allStream = streamContainer_.GetAllStreams();
+    std::list<sptr<HStreamCommon>> allOfflineStreams = streamContainerOffline_.GetAllStreams();
+    allStream.insert(allStream.end(), allOfflineStreams.begin(), allOfflineStreams.end());
     for (auto& stream : allStream) {
         if (stream->GetStreamType() != StreamType::CAPTURE) {
             continue;
@@ -483,6 +485,27 @@ int32_t HStreamOperator::UnlinkInputAndOutputs()
     return rc;
 }
 
+int32_t HStreamOperator::UnlinkOfflineInputAndOutputs()
+{
+    CAMERA_SYNC_TRACE;
+    int32_t rc = CAMERA_UNKNOWN_ERROR;
+    std::vector<int32_t> fwkStreamIds;
+    std::vector<int32_t> hdiStreamIds;
+    auto allStream = streamContainerOffline_.GetAllStreams();
+    for (auto& stream : allStream) {
+        fwkStreamIds.emplace_back(stream->GetFwkStreamId());
+        hdiStreamIds.emplace_back(stream->GetHdiStreamId());
+        stream->UnlinkInput();
+    }
+    MEDIA_INFO_LOG("HStreamOperator::UnlinkOfflineInputAndOutputs() streamIds size() = %{public}zu,"
+        "streamIds:%{public}s, hdiStreamIds:%{public}s",
+        fwkStreamIds.size(), Container2String(fwkStreamIds.begin(), fwkStreamIds.end()).c_str(),
+        Container2String(hdiStreamIds.begin(), hdiStreamIds.end()).c_str());
+    ReleaseStreams(hdiStreamIds);
+    ResetHdiStreamId();
+    return rc;
+}
+
 void HStreamOperator::ExpandSketchRepeatStream()
 {
     MEDIA_DEBUG_LOG("Enter HStreamOperator::ExpandSketchRepeatStream()");
@@ -1038,6 +1061,7 @@ int32_t HStreamOperator::Release()
     #ifdef CAMERA_USE_SENSOR
     if (isSetMotionPhoto_) {
         UnRegisterSensorCallback();
+        isSetMotionPhoto_ = false;
     }
     #endif
     if (displayListener_) {
@@ -1045,13 +1069,14 @@ int32_t HStreamOperator::Release()
         displayListener_ = nullptr;
     }
     if (streamOperator_) {
+        UnlinkOfflineInputAndOutputs();
         streamOperator_ = nullptr;
         MEDIA_INFO_LOG("HStreamOperator::Release streamOperator_ is nullptr");
     }
     HStreamOperatorManager::GetInstance()->RemoveStreamOperator(streamOperatorId_);
     std::lock_guard<std::mutex> lock(movingPhotoStatusLock_);
-    livephotoListener_ = nullptr;
-    videoCache_ = nullptr;
+    CHECK_EXECUTE(livephotoListener_, livephotoListener_ = nullptr);
+    CHECK_EXECUTE(videoCache_, videoCache_ = nullptr);
     if (taskManager_) {
         taskManager_->ClearTaskResource();
         taskManager_ = nullptr;
@@ -1648,24 +1673,24 @@ int32_t HStreamOperator::UpdateStreams(std::vector<StreamInfo_V1_1>& streamInfos
 {
     sptr<OHOS::HDI::Camera::V1_2::IStreamOperator> streamOperatorV1_2;
     CHECK_ERROR_RETURN_RET_LOG(streamOperator_ == nullptr, CAMERA_UNKNOWN_ERROR,
-        "HStreamOperator::UpdateStreamInfos GetStreamOperator is null!");
+        "HStreamOperator::UpdateStreams GetStreamOperator is null!");
     uint32_t major;
     uint32_t minor;
     streamOperator_->GetVersion(major, minor);
-    MEDIA_INFO_LOG("UpdateStreamInfos: streamOperator GetVersion major:%{public}d, minor:%{public}d", major, minor);
+    MEDIA_INFO_LOG("UpdateStreams::UpdateStreams GetVersion major:%{public}d, minor:%{public}d", major, minor);
     if (major >= HDI_VERSION_1 && minor >= HDI_VERSION_2) {
         streamOperatorV1_2 = OHOS::HDI::Camera::V1_2::IStreamOperator::CastFrom(streamOperator_);
         if (streamOperatorV1_2 == nullptr) {
-            MEDIA_ERR_LOG("HCaptureSession::UpdateStreamInfos IStreamOperator cast to V1_2 error");
+            MEDIA_ERR_LOG("HStreamOperator::UpdateStreams IStreamOperator cast to V1_2 error");
             streamOperatorV1_2 = static_cast<OHOS::HDI::Camera::V1_2::IStreamOperator*>(streamOperator_.GetRefPtr());
         }
     }
     CamRetCode hdiRc = HDI::Camera::V1_0::CamRetCode::NO_ERROR;
     if (streamOperatorV1_2 != nullptr) {
-        MEDIA_DEBUG_LOG("HCaptureSession::UpdateStreamInfos streamOperator V1_2");
+        MEDIA_DEBUG_LOG("HStreamOperator::UpdateStreams streamOperator V1_2");
         hdiRc = (CamRetCode)(streamOperatorV1_2->UpdateStreams(streamInfos));
     } else {
-        MEDIA_DEBUG_LOG("HCaptureSession::UpdateStreamInfos failed, streamOperator V1_2 is null.");
+        MEDIA_DEBUG_LOG("HStreamOperator::UpdateStreams failed, streamOperator V1_2 is null.");
         return CAMERA_UNKNOWN_ERROR;
     }
     return HdiToServiceError(hdiRc);
@@ -1708,9 +1733,6 @@ int32_t HStreamOperator::OnCaptureEnded(int32_t captureId, const std::vector<Cap
             CastStream<HStreamRepeat>(curStream)->OnFrameEnded(captureInfo.frameCount_);
         } else if (curStream->GetStreamType() == StreamType::CAPTURE) {
             CastStream<HStreamCapture>(curStream)->OnCaptureEnded(captureId, captureInfo.frameCount_);
-            if (mlastCaptureId == captureId && streamContainerOffline_.Size() > 0) {
-                HStreamOperatorManager::GetInstance()->RemoveStreamOperator(streamOperatorId_);
-            }
         }
     }
     return CAMERA_OK;
diff --git a/services/camera_service/src/hstream_operator_manager.cpp b/services/camera_service/src/hstream_operator_manager.cpp
index 44b95a78..0fdb06fa 100644
--- a/services/camera_service/src/hstream_operator_manager.cpp
+++ b/services/camera_service/src/hstream_operator_manager.cpp
@@ -95,5 +95,20 @@ int32_t HStreamOperatorManager::GetOfflineOutputSize()
     }
     return offlineOutputCount;
 }
+
+std::vector<sptr<HStreamOperator>> HStreamOperatorManager::GetStreamOperatorByPid(pid_t pidRequest)
+{
+    std::lock_guard<std::mutex> lock(mapMutex_);
+    std::vector<sptr<HStreamOperator>> streamOperatorVec = {};
+    for (auto streamOperator : streamOperatorManagerMap_) {
+        if (pidRequest == (streamOperator.second)->GetPid()) {
+            streamOperatorVec.push_back(streamOperator.second);
+            MEDIA_INFO_LOG("HStreamOperatorManager::GetCameraByPid find");
+        }
+    }
+    MEDIA_INFO_LOG("HStreamOperatorManager::GetStreamOperatorByPid pid is %{public}d size is %{public}zu", pidRequest,
+        streamOperatorVec.size());
+    return streamOperatorVec;
+}
 } // namespace CameraStandard
 } // namespace OHOS
