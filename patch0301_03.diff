-{
-    std::lock_guard<std::mutex> lock(streamsLock_);
-    for (auto& pair : streams_) {
-        for (auto& stream : pair.second) {
-            CHECK_ERROR_RETURN_RET(stream->GetFwkStreamId() == streamId, stream);
-        }
-    }
-    return nullptr;
-}
-
-sptr<HStreamCommon> StreamContainer::GetHdiStream(int32_t streamId)
-{
-    std::lock_guard<std::mutex> lock(streamsLock_);
-    for (auto& pair : streams_) {
-        for (auto& stream : pair.second) {
-            CHECK_ERROR_RETURN_RET(stream->GetHdiStreamId() == streamId, stream);
-        }
-    }
-    return nullptr;
-}
-
-void StreamContainer::Clear()
-{
-    std::lock_guard<std::mutex> lock(streamsLock_);
-    streams_.clear();
-}
-
-size_t StreamContainer::Size()
-{
-    std::lock_guard<std::mutex> lock(streamsLock_);
-    size_t totalSize = 0;
-    for (auto& pair : streams_) {
-        totalSize += pair.second.size();
-    }
-    return totalSize;
-}
-
-std::list<sptr<HStreamCommon>> StreamContainer::GetStreams(const StreamType streamType)
-{
-    std::lock_guard<std::mutex> lock(streamsLock_);
-    std::list<sptr<HStreamCommon>> totalOrderedStreams;
-    for (auto& stream : streams_[streamType]) {
-        auto insertPos = std::find_if(totalOrderedStreams.begin(), totalOrderedStreams.end(),
-            [&stream](auto& it) { return stream->GetFwkStreamId() <= it->GetFwkStreamId(); });
-        totalOrderedStreams.emplace(insertPos, stream);
-    }
-    return totalOrderedStreams;
-}
-
-std::list<sptr<HStreamCommon>> StreamContainer::GetAllStreams()
-{
-    std::lock_guard<std::mutex> lock(streamsLock_);
-    std::list<sptr<HStreamCommon>> totalOrderedStreams;
-    for (auto& pair : streams_) {
-        for (auto& stream : pair.second) {
-            auto insertPos = std::find_if(totalOrderedStreams.begin(), totalOrderedStreams.end(),
-                [&stream](auto& it) { return stream->GetFwkStreamId() <= it->GetFwkStreamId(); });
-            totalOrderedStreams.emplace(insertPos, stream);
-        }
-    }
-    return totalOrderedStreams;
-}
-
-MovingPhotoListener::MovingPhotoListener(sptr<MovingPhotoSurfaceWrapper> surfaceWrapper, sptr<Surface> metaSurface,
-    shared_ptr<FixedSizeList<MetaElementType>> metaCache, uint32_t preCacheFrameCount, uint32_t postCacheFrameCount)
-    : movingPhotoSurfaceWrapper_(surfaceWrapper), metaSurface_(metaSurface), metaCache_(metaCache),
-      recorderBufferQueue_("videoBuffer", preCacheFrameCount), postCacheFrameCount_(postCacheFrameCount)
-{
-    shutterTime_ = 0;
-}
-
-MovingPhotoListener::~MovingPhotoListener()
-{
-    recorderBufferQueue_.SetActive(false);
-    metaCache_->clear();
-    recorderBufferQueue_.Clear();
-    MEDIA_ERR_LOG("HStreamRepeat::LivePhotoListener ~ end");
-}
-
-void MovingPhotoListener::RemoveDrainImageManager(sptr<SessionDrainImageCallback> callback)
-{
-    callbackMap_.Erase(callback);
-    MEDIA_INFO_LOG("RemoveDrainImageManager drainImageManagerVec_ Start %d", callbackMap_.Size());
-}
-
-void MovingPhotoListener::ClearCache(uint64_t timestamp)
-{
-    CHECK_ERROR_RETURN(!isNeededClear_.load());
-    MEDIA_INFO_LOG("ClearCache enter");
-    shutterTime_ = static_cast<int64_t>(timestamp);
-    while (!recorderBufferQueue_.Empty()) {
-        sptr<FrameRecord> popFrame = recorderBufferQueue_.Front();
-        MEDIA_DEBUG_LOG("surface_ release surface buffer %{public}llu, timestamp %{public}llu",
-            (long long unsigned)popFrame->GetTimeStamp(), (long long unsigned)timestamp);
-        if (popFrame->GetTimeStamp() > shutterTime_) {
-            isNeededClear_ = false;
-            MEDIA_INFO_LOG("ClearCache end");
-            return;
-        }
-        recorderBufferQueue_.Pop();
-        popFrame->ReleaseSurfaceBuffer(movingPhotoSurfaceWrapper_);
-        popFrame->ReleaseMetaBuffer(metaSurface_, true);
-    }
-}
-
-void MovingPhotoListener::SetClearFlag()
-{
-    MEDIA_INFO_LOG("need clear cache!");
-    isNeededClear_ = true;
-}
-
-void MovingPhotoListener::StopDrainOut()
-{
-    MEDIA_INFO_LOG("StopDrainOut drainImageManagerVec_ Start %d", callbackMap_.Size());
-    callbackMap_.Iterate([](const sptr<SessionDrainImageCallback> callback, sptr<DrainImageManager> manager) {
-        manager->DrainFinish(false);
-    });
-    callbackMap_.Clear();
-}
-
-void MovingPhotoListener::OnBufferArrival(sptr<SurfaceBuffer> buffer, int64_t timestamp, GraphicTransformType transform)
-{
-    MEDIA_DEBUG_LOG("OnBufferArrival timestamp %{public}llu", (long long unsigned)timestamp);
-    if (recorderBufferQueue_.Full()) {
-        MEDIA_DEBUG_LOG("surface_ release surface buffer");
-        sptr<FrameRecord> popFrame = recorderBufferQueue_.Pop();
-        popFrame->ReleaseSurfaceBuffer(movingPhotoSurfaceWrapper_);
-        popFrame->ReleaseMetaBuffer(metaSurface_, true);
-        MEDIA_DEBUG_LOG("surface_ release surface buffer: %{public}s, refCount: %{public}d",
-            popFrame->GetFrameId().c_str(), popFrame->GetSptrRefCount());
-    }
-    MEDIA_DEBUG_LOG("surface_ push buffer %{public}d x %{public}d, stride is %{public}d",
-        buffer->GetSurfaceBufferWidth(), buffer->GetSurfaceBufferHeight(), buffer->GetStride());
-    sptr<FrameRecord> frameRecord = new (std::nothrow) FrameRecord(buffer, timestamp, transform);
-    CHECK_ERROR_RETURN_LOG(frameRecord == nullptr, "MovingPhotoListener::OnBufferAvailable create FrameRecord fail!");
-    if (isNeededClear_ && isNeededPop_) {
-        if (timestamp < shutterTime_) {
-            frameRecord->ReleaseSurfaceBuffer(movingPhotoSurfaceWrapper_);
-            MEDIA_INFO_LOG("Drop this frame in cache");
-            return;
-        } else {
-            isNeededClear_ = false;
-            isNeededPop_ = false;
-            MEDIA_INFO_LOG("ClearCache end");
-        }
-    }
-    recorderBufferQueue_.Push(frameRecord);
-    auto metaPair = metaCache_->find_if([timestamp](const MetaElementType& value) { return value.first == timestamp; });
-    if (metaPair.has_value()) {
-        MEDIA_DEBUG_LOG("frame has meta");
-        frameRecord->SetMetaBuffer(metaPair.value().second);
-    }
-    vector<sptr<SessionDrainImageCallback>> callbacks;
-    callbackMap_.Iterate([frameRecord, &callbacks](const sptr<SessionDrainImageCallback> callback,
-                             sptr<DrainImageManager> manager) { callbacks.push_back(callback); });
-    for (sptr<SessionDrainImageCallback> drainImageCallback : callbacks) {
-        sptr<DrainImageManager> drainImageManager;
-        if (callbackMap_.Find(drainImageCallback, drainImageManager)) {
-            std::lock_guard<std::mutex> lock(drainImageManager->drainImageLock_);
-            drainImageManager->DrainImage(frameRecord);
-        }
-    }
-}
-
-void MovingPhotoListener::DrainOutImage(sptr<SessionDrainImageCallback> drainImageCallback)
-{
-    sptr<DrainImageManager> drainImageManager =
-        new DrainImageManager(drainImageCallback, recorderBufferQueue_.Size() + postCacheFrameCount_);
-    {
-        MEDIA_INFO_LOG("DrainOutImage enter %{public}zu", recorderBufferQueue_.Size());
-        callbackMap_.Insert(drainImageCallback, drainImageManager);
-    }
-    // Convert recorderBufferQueue_ to a vector
-    std::vector<sptr<FrameRecord>> frameList = recorderBufferQueue_.GetAllElements();
-    CHECK_EXECUTE(!frameList.empty(), frameList.back()->SetCoverFrame());
-    std::lock_guard<std::mutex> lock(drainImageManager->drainImageLock_);
-    for (const auto& frame : frameList) {
-        MEDIA_DEBUG_LOG("DrainOutImage enter DrainImage");
-        drainImageManager->DrainImage(frame);
-    }
-}
-
-void MovingPhotoMetaListener::OnBufferAvailable()
-{
-    MEDIA_DEBUG_LOG("metaSurface_ OnBufferAvailable %{public}u", surface_->GetQueueSize());
-    CHECK_ERROR_RETURN_LOG(!surface_, "streamRepeat surface is null");
-    int64_t timestamp;
-    OHOS::Rect damage;
-    sptr<SurfaceBuffer> buffer;
-    sptr<SyncFence> syncFence = SyncFence::INVALID_FENCE;
-    SurfaceError surfaceRet = surface_->AcquireBuffer(buffer, syncFence, timestamp, damage);
-    CHECK_ERROR_RETURN_LOG(surfaceRet != SURFACE_ERROR_OK, "Failed to acquire meta surface buffer");
-    surfaceRet = surface_->DetachBufferFromQueue(buffer);
-    CHECK_ERROR_RETURN_LOG(surfaceRet != SURFACE_ERROR_OK, "Failed to detach meta buffer. %{public}d", surfaceRet);
-    metaCache_->add({ timestamp, buffer });
-}
-
-MovingPhotoMetaListener::MovingPhotoMetaListener(
-    sptr<Surface> surface, shared_ptr<FixedSizeList<MetaElementType>> metaCache)
-    : surface_(surface), metaCache_(metaCache)
-{}
-
-MovingPhotoMetaListener::~MovingPhotoMetaListener()
-{
-    MEDIA_ERR_LOG("HStreamRepeat::MovingPhotoMetaListener ~ end");
-}
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/services/camera_service/src/hstream_capture.cpp b/services/camera_service/src/hstream_capture.cpp
index d5ff66b3..f5c3688e 100644
--- a/services/camera_service/src/hstream_capture.cpp
+++ b/services/camera_service/src/hstream_capture.cpp
@@ -31,6 +31,9 @@
 #include "media_library/photo_asset_proxy.h"
 #include "camera_report_dfx_uitls.h"
 #include "bms_adapter.h"
+#include "picture.h"
+#include "hstream_operator_manager.h"
+#include "hstream_operator.h"
 
 namespace OHOS {
 namespace CameraStandard {
@@ -572,7 +575,7 @@ void HStreamCapture::SetRotation(const std::shared_ptr<OHOS::Camera::CameraMetad
     if (result == CAM_META_SUCCESS && item.count > 0) {
         rotationValue = item.data.i32[0];
     }
-    MEDIA_INFO_LOG("set rotation app rotationValue %{public}d", rotationValue);
+    MEDIA_INFO_LOG("set rotation app rotationValue %{public}d", rotationValue); // 0 270 270+270=180
     rotationMap_.EnsureInsert(captureId, rotationValue);
     // real rotation
     if (enableCameraPhotoRotation_) {
@@ -612,7 +615,7 @@ void HStreamCapture::SetRotation(const std::shared_ptr<OHOS::Camera::CameraMetad
 int32_t HStreamCapture::CancelCapture()
 {
     CAMERA_SYNC_TRACE;
-    // Cancel capture is dummy till continuous/burst mode is supported
+    // Cancel capture dummy till continuous/burst mode is supported
     StopStream();
     return CAMERA_OK;
 }
@@ -697,7 +700,13 @@ int32_t HStreamCapture::ReleaseStream(bool isDelay)
         std::lock_guard<std::mutex> lock(callbackLock_);
         streamCaptureCallback_ = nullptr;
     }
-    return HStreamCommon::ReleaseStream(isDelay);
+    int32_t errorCode = HStreamCommon::ReleaseStream(isDelay);
+    auto hStreamOperatorSptr_ = hStreamOperator_.promote();
+    if (hStreamOperatorSptr_ && mSwitchToOfflinePhoto_) {
+        hStreamOperatorSptr_->Release();
+    }
+    mSwitchToOfflinePhoto_ = false;
+    return errorCode;
 }
 
 int32_t HStreamCapture::SetCallback(sptr<IStreamCaptureCallback> &callback)
@@ -737,7 +746,10 @@ int32_t HStreamCapture::OnCaptureEnded(int32_t captureId, int32_t frameCount)
     CAMERA_SYNC_TRACE;
     std::lock_guard<std::mutex> lock(callbackLock_);
     CHECK_EXECUTE(streamCaptureCallback_ != nullptr, streamCaptureCallback_->OnCaptureEnded(captureId, frameCount));
-    CameraReportUtils::GetInstance().SetCapturePerfEndInfo(captureId);
+    MEDIA_INFO_LOG("HStreamCapture::Capture, notify OnCaptureEnded with capture ID: %{public}d", captureId);
+    int32_t offlineOutputCnt = mSwitchToOfflinePhoto_ ?
+        HStreamOperatorManager::GetInstance()->GetOfflineOutputSize() : 0;
+    CameraReportUtils::GetInstance().SetCapturePerfEndInfo(captureId, mSwitchToOfflinePhoto_, offlineOutputCnt);
     auto preparedCaptureId = GetPreparedCaptureId();
     if (preparedCaptureId != CAPTURE_ID_UNSET) {
         MEDIA_INFO_LOG("HStreamCapture::OnCaptureEnded capturId = %{public}d already used, need release",
@@ -811,6 +823,27 @@ int32_t HStreamCapture::OnCaptureReady(int32_t captureId, uint64_t timestamp)
     return CAMERA_OK;
 }
 
+int32_t HStreamCapture::EnableOfflinePhoto(bool isEnable)
+{
+    mEnableOfflinePhoto_ = isEnable;
+    return CAMERA_OK;
+}
+
+bool HStreamCapture::IsHasEnableOfflinePhoto()
+{
+    return mEnableOfflinePhoto_;
+}
+
+void HStreamCapture::SwitchToOffline()
+{
+    mSwitchToOfflinePhoto_ = true;
+}
+
+bool HStreamCapture::IsHasSwitchToOffline()
+{
+    return mSwitchToOfflinePhoto_;
+}
+
 void HStreamCapture::DumpStreamInfo(CameraInfoDumper& infoDumper)
 {
     infoDumper.Title("capture stream");
@@ -913,5 +946,31 @@ int32_t HStreamCapture::UpdateMediaLibraryPhotoAssetProxy(sptr<CameraPhotoProxy>
     MEDIA_DEBUG_LOG("HStreamCapture UpdateMediaLibraryPhotoAssetProxy X captureId(%{public}d)", photoProxy->captureId_);
     return CAMERA_OK;
 }
+
+void HStreamCapture::SetStreamOperator(wptr<HStreamOperator> hStreamOperator)
+{
+    hStreamOperator_ = hStreamOperator;
+}
+
+int32_t HStreamCapture::CreateMediaLibrary(std::unique_ptr<Media::Picture> picture, sptr<CameraPhotoProxy>& photoProxy,
+    std::string& uri, int32_t& cameraShotType, std::string& burstKey, int64_t timestamp)
+{
+    auto hStreamOperatorSptr_ = hStreamOperator_.promote();
+    if (hStreamOperatorSptr_) {
+        hStreamOperatorSptr_->CreateMediaLibrary(std::move(picture), photoProxy,
+            uri, cameraShotType, burstKey, timestamp);
+    }
+     return CAMERA_OK;
+}
+
+int32_t HStreamCapture::CreateMediaLibrary(sptr<CameraPhotoProxy>& photoProxy, std::string& uri,
+    int32_t& cameraShotType, std::string& burstKey, int64_t timestamp)
+{
+    auto hStreamOperatorSptr_ = hStreamOperator_.promote();
+    if (hStreamOperatorSptr_) {
+        hStreamOperatorSptr_->CreateMediaLibrary(photoProxy, uri, cameraShotType, burstKey, timestamp);
+    }
+    return CAMERA_OK;
+}
 } // namespace CameraStandard
 } // namespace OHOS
diff --git a/services/camera_service/src/hstream_metadata.cpp b/services/camera_service/src/hstream_metadata.cpp
index da91224f..500dd6cf 100644
--- a/services/camera_service/src/hstream_metadata.cpp
+++ b/services/camera_service/src/hstream_metadata.cpp
@@ -23,6 +23,7 @@
 #include "metadata_utils.h"
 #include <cstdint>
 #include <unordered_set>
+#include "dp_utils.h"
 
 namespace OHOS {
 namespace CameraStandard {
diff --git a/services/camera_service/src/hstream_operator.cpp b/services/camera_service/src/hstream_operator.cpp
new file mode 100755
index 00000000..fc69843b
--- /dev/null
+++ b/services/camera_service/src/hstream_operator.cpp
@@ -0,0 +1,2083 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hstream_operator.h"
+
+#include <algorithm>
+#include <atomic>
+#include <cerrno>
+#include <cinttypes>
+#include <cstddef>
+#include <cstdint>
+#include <functional>
+#include <memory>
+#include <mutex>
+#include <new>
+#include <sched.h>
+#include <string>
+#include <sync_fence.h>
+#include <utility>
+#include <vector>
+
+#include "avcodec_task_manager.h"
+#include "blocking_queue.h"
+#include "bundle_mgr_interface.h"
+#include "camera_dynamic_loader.h"
+#include "camera_info_dumper.h"
+#include "camera_log.h"
+#include "camera_report_uitls.h"
+#include "camera_server_photo_proxy.h"
+#include "camera_service_ipc_interface_code.h"
+#include "camera_timer.h"
+#include "camera_util.h"
+#include "datetime_ex.h"
+#include "deferred_processing_service.h"
+#include "display/composer/v1_1/display_composer_type.h"
+#include "display_manager.h"
+#include "errors.h"
+#include "fixed_size_list.h"
+#include "hcamera_device_manager.h"
+#include "hcamera_restore_param.h"
+#include "hstream_capture.h"
+#include "hstream_common.h"
+#include "hstream_depth_data.h"
+#include "hstream_metadata.h"
+#include "hstream_repeat.h"
+#include "icamera_util.h"
+#include "icapture_session.h"
+#include "iconsumer_surface.h"
+#include "image_type.h"
+#include "ipc_skeleton.h"
+#include "iservice_registry.h"
+#include "istream_common.h"
+#include "media_library/photo_asset_interface.h"
+#include "media_library/photo_asset_proxy.h"
+#include "metadata_utils.h"
+#include "moving_photo/moving_photo_surface_wrapper.h"
+#include "moving_photo_video_cache.h"
+#include "parameters.h"
+#include "picture.h"
+#include "refbase.h"
+#include "smooth_zoom.h"
+#include "surface.h"
+#include "surface_buffer.h"
+#include "system_ability_definition.h"
+#include "v1_0/types.h"
+#include "camera_report_dfx_uitls.h"
+#include "hstream_operator_manager.h"
+#include "res_type.h"
+#include "res_sched_client.h"
+
+using namespace OHOS::AAFwk;
+namespace OHOS {
+namespace CameraStandard {
+using namespace OHOS::HDI::Display::Composer::V1_1;
+namespace {
+#ifdef CAMERA_USE_SENSOR
+constexpr int32_t POSTURE_INTERVAL = 100000000; //100ms
+constexpr int VALID_INCLINATION_ANGLE_THRESHOLD_COEFFICIENT = 3;
+#endif
+static GravityData gravityData = {0.0, 0.0, 0.0};
+static int32_t sensorRotation = 0;
+} // namespace
+
+sptr<HStreamOperator> HStreamOperator::NewInstance(const uint32_t callerToken, int32_t opMode)
+{
+    sptr<HStreamOperator> hStreamOperator = new HStreamOperator();
+    CHECK_ERROR_RETURN_RET(hStreamOperator->Initialize(callerToken, opMode) == CAMERA_OK, hStreamOperator);
+    return nullptr;
+}
+
+int32_t HStreamOperator::Initialize(const uint32_t callerToken, int32_t opMode)
+{
+    pid_ = IPCSkeleton::GetCallingPid();
+    uid_ = static_cast<uint32_t>(IPCSkeleton::GetCallingUid());
+    callerToken_ = callerToken;
+    opMode_ = opMode;
+    MEDIA_INFO_LOG(
+        "HStreamOperator::opMode_= %{public}d", opMode_);
+    return CAMERA_OK;
+}
+
+HStreamOperator::HStreamOperator()
+{
+    pid_ = 0;
+    uid_ = 0;
+    callerToken_ = 0;
+    opMode_ = 0;
+}
+
+HStreamOperator::HStreamOperator(const uint32_t callingTokenId, int32_t opMode)
+{
+    Initialize(callingTokenId, opMode);
+}
+
+HStreamOperator::~HStreamOperator()
+{
+    CAMERA_SYNC_TRACE;
+    Release();
+}
+
+int32_t HStreamOperator::GetCurrentStreamInfos(std::vector<StreamInfo_V1_1>& streamInfos)
+{
+    auto streams = streamContainer_.GetAllStreams();
+    for (auto& stream : streams) {
+        if (stream) {
+            StreamInfo_V1_1 curStreamInfo;
+            stream->SetStreamInfo(curStreamInfo);
+            CHECK_EXECUTE(stream->GetStreamType() != StreamType::METADATA, streamInfos.push_back(curStreamInfo));
+        }
+    }
+    return CAMERA_OK;
+}
+
+int32_t HStreamOperator::AddOutputStream(sptr<HStreamCommon> stream)
+{
+    CAMERA_SYNC_TRACE;
+    CHECK_ERROR_RETURN_RET_LOG(stream == nullptr, CAMERA_INVALID_ARG,
+        "HStreamOperator::AddOutputStream stream is null");
+    MEDIA_INFO_LOG("HStreamOperator::AddOutputStream streamId:%{public}d streamType:%{public}d",
+        stream->GetFwkStreamId(), stream->GetStreamType());
+    CHECK_ERROR_RETURN_RET_LOG(
+        stream->GetFwkStreamId() == STREAM_ID_UNSET && stream->GetStreamType() != StreamType::METADATA,
+        CAMERA_INVALID_ARG, "HStreamOperator::AddOutputStream stream is released!");
+    bool isAddSuccess = streamContainer_.AddStream(stream);
+    CHECK_ERROR_RETURN_RET_LOG(!isAddSuccess, CAMERA_INVALID_SESSION_CFG,
+        "HStreamOperator::AddOutputStream add stream fail");
+    if (stream->GetStreamType() == StreamType::CAPTURE) {
+        auto captureStream = CastStream<HStreamCapture>(stream);
+        captureStream->SetMode(opMode_);
+        captureStream->SetColorSpace(currCaptureColorSpace_);
+        CameraDynamicLoader::LoadDynamiclibAsync(MEDIA_LIB_SO); // cache dynamiclib
+    } else {
+        stream->SetColorSpace(currColorSpace_);
+    }
+    return CAMERA_OK;
+}
+
+void HStreamOperator::StartMovingPhotoStream(const std::shared_ptr<OHOS::Camera::CameraMetadata>& settings)
+{
+    int32_t errorCode = 0;
+    auto repeatStreams = streamContainer_.GetStreams(StreamType::REPEAT);
+    bool isPreviewStarted = false;
+    for (auto& item : repeatStreams) {
+        auto curStreamRepeat = CastStream<HStreamRepeat>(item);
+        auto repeatType = curStreamRepeat->GetRepeatStreamType();
+        if (repeatType != RepeatStreamType::PREVIEW) {
+            continue;
+        }
+        if (curStreamRepeat->GetPreparedCaptureId() != CAPTURE_ID_UNSET && curStreamRepeat->producer_ != nullptr) {
+            isPreviewStarted = true;
+            break;
+        }
+    }
+    CHECK_ERROR_RETURN_LOG(!isPreviewStarted, "EnableMovingPhoto, preview is not streaming");
+    for (auto& item : repeatStreams) {
+        auto curStreamRepeat = CastStream<HStreamRepeat>(item);
+        auto repeatType = curStreamRepeat->GetRepeatStreamType();
+        if (repeatType != RepeatStreamType::LIVEPHOTO) {
+            continue;
+        }
+        if (isSetMotionPhoto_) {
+            errorCode = curStreamRepeat->Start(settings);
+            #ifdef MOVING_PHOTO_ADD_AUDIO
+            std::lock_guard<std::mutex> lock(movingPhotoStatusLock_);
+            audioCapturerSession_ != nullptr && audioCapturerSession_->StartAudioCapture();
+            #endif
+        } else {
+            errorCode = curStreamRepeat->Stop();
+            StopMovingPhoto();
+        }
+        break;
+    }
+    MEDIA_INFO_LOG("HStreamOperator::StartMovingPhotoStream result:%{public}d", errorCode);
+}
+
+class DisplayRotationListener : public OHOS::Rosen::DisplayManager::IDisplayListener {
+public:
+    explicit DisplayRotationListener() {};
+    virtual ~DisplayRotationListener() = default;
+    void OnCreate(OHOS::Rosen::DisplayId) override {}
+    void OnDestroy(OHOS::Rosen::DisplayId) override {}
+    void OnChange(OHOS::Rosen::DisplayId displayId) override
+    {
+        sptr<Rosen::Display> display = Rosen::DisplayManager::GetInstance().GetDefaultDisplay();
+        if (display == nullptr) {
+            MEDIA_INFO_LOG("Get display info failed, display:%{public}" PRIu64 "", displayId);
+            display = Rosen::DisplayManager::GetInstance().GetDisplayById(0);
+            CHECK_ERROR_RETURN_LOG(display == nullptr, "Get display info failed, display is nullptr");
+        }
+        {
+            Rosen::Rotation currentRotation = display->GetRotation();
+            std::lock_guard<std::mutex> lock(mStreamManagerLock_);
+            for (auto& repeatStream : repeatStreamList_) {
+                CHECK_EXECUTE(repeatStream, repeatStream->SetStreamTransform(static_cast<int>(currentRotation)));
+            }
+        }
+    }
+
+    void AddHstreamRepeatForListener(sptr<HStreamRepeat> repeatStream)
+    {
+        std::lock_guard<std::mutex> lock(mStreamManagerLock_);
+        CHECK_EXECUTE(repeatStream, repeatStreamList_.push_back(repeatStream));
+    }
+
+    void RemoveHstreamRepeatForListener(sptr<HStreamRepeat> repeatStream)
+    {
+        std::lock_guard<std::mutex> lock(mStreamManagerLock_);
+        if (repeatStream) {
+            repeatStreamList_.erase(
+                std::remove(repeatStreamList_.begin(), repeatStreamList_.end(), repeatStream), repeatStreamList_.end());
+        }
+    }
+
+public:
+    std::list<sptr<HStreamRepeat>> repeatStreamList_;
+    std::mutex mStreamManagerLock_;
+};
+
+void HStreamOperator::RegisterDisplayListener(sptr<HStreamRepeat> repeat)
+{
+    if (displayListener_ == nullptr) {
+        displayListener_ = new DisplayRotationListener();
+        OHOS::Rosen::DisplayManager::GetInstance().RegisterDisplayListener(displayListener_);
+    }
+    displayListener_->AddHstreamRepeatForListener(repeat);
+}
+
+void HStreamOperator::UnRegisterDisplayListener(sptr<HStreamRepeat> repeatStream)
+{
+    CHECK_EXECUTE(displayListener_, displayListener_->RemoveHstreamRepeatForListener(repeatStream));
+}
+
+int32_t HStreamOperator::SetPreviewRotation(std::string &deviceClass)
+{
+    enableStreamRotate_ = true;
+    deviceClass_ = deviceClass;
+    return CAMERA_OK;
+}
+
+int32_t HStreamOperator::AddOutput(StreamType streamType, sptr<IStreamCommon> stream)
+{
+    int32_t errorCode = CAMERA_INVALID_ARG;
+    if (stream == nullptr) {
+        MEDIA_ERR_LOG("HStreamOperator::AddOutput stream is null");
+        CameraReportUtils::ReportCameraError(
+            "HStreamOperator::AddOutput", errorCode, false, CameraReportUtils::GetCallerInfo());
+        return errorCode;
+    }
+    // Temp hack to fix the library linking issue
+    sptr<IConsumerSurface> captureSurface = IConsumerSurface::Create();
+    if (streamType == StreamType::CAPTURE) {
+        HStreamCapture* captureSteam = static_cast<HStreamCapture*>(stream.GetRefPtr());
+        errorCode = AddOutputStream(captureSteam);
+        captureSteam->SetStreamOperator(this);
+    } else if (streamType == StreamType::REPEAT) {
+        HStreamRepeat* repeatSteam = static_cast<HStreamRepeat*>(stream.GetRefPtr());
+        if (enableStreamRotate_ && repeatSteam != nullptr &&
+            repeatSteam->GetRepeatStreamType() == RepeatStreamType::PREVIEW) {
+            RegisterDisplayListener(repeatSteam);
+            repeatSteam->SetPreviewRotation(deviceClass_);
+        }
+        errorCode = AddOutputStream(repeatSteam);
+    } else if (streamType == StreamType::METADATA) {
+        errorCode = AddOutputStream(static_cast<HStreamMetadata*>(stream.GetRefPtr()));
+    } else if (streamType == StreamType::DEPTH) {
+        errorCode = AddOutputStream(static_cast<HStreamDepthData*>(stream.GetRefPtr()));
+    }
+    MEDIA_INFO_LOG("CaptureSession::AddOutput with with %{public}d, rc = %{public}d", streamType, errorCode);
+    return errorCode;
+}
+
+int32_t HStreamOperator::RemoveOutput(StreamType streamType, sptr<IStreamCommon> stream)
+{
+    int32_t errorCode = CAMERA_INVALID_ARG;
+    if (stream == nullptr) {
+        MEDIA_ERR_LOG("HStreamOperator::RemoveOutput stream is null");
+        CameraReportUtils::ReportCameraError(
+            "HStreamOperator::RemoveOutput", errorCode, false, CameraReportUtils::GetCallerInfo());
+        return errorCode;
+    }
+    if (streamType == StreamType::CAPTURE) {
+        errorCode = RemoveOutputStream(static_cast<HStreamCapture*>(stream.GetRefPtr()));
+    } else if (streamType == StreamType::REPEAT) {
+        HStreamRepeat* repeatSteam = static_cast<HStreamRepeat*>(stream.GetRefPtr());
+        if (enableStreamRotate_ && repeatSteam != nullptr &&
+            repeatSteam->GetRepeatStreamType() == RepeatStreamType::PREVIEW) {
+            UnRegisterDisplayListener(repeatSteam);
+        }
+        errorCode = RemoveOutputStream(repeatSteam);
+    } else if (streamType == StreamType::METADATA) {
+        errorCode = RemoveOutputStream(static_cast<HStreamMetadata*>(stream.GetRefPtr()));
+    }
+    return errorCode;
+}
+
+int32_t HStreamOperator::RemoveOutputStream(sptr<HStreamCommon> stream)
+{
+    CAMERA_SYNC_TRACE;
+    CHECK_ERROR_RETURN_RET_LOG(stream == nullptr, CAMERA_INVALID_ARG,
+        "HStreamOperator::RemoveOutputStream stream is null");
+    MEDIA_INFO_LOG("HStreamOperator::RemoveOutputStream,streamType:%{public}d, streamId:%{public}d",
+        stream->GetStreamType(), stream->GetFwkStreamId());
+    bool isRemoveSuccess = streamContainer_.RemoveStream(stream);
+    CHECK_ERROR_RETURN_RET_LOG(!isRemoveSuccess, CAMERA_INVALID_SESSION_CFG,
+        "HStreamOperator::RemoveOutputStream Invalid output");
+    if (stream->GetStreamType() != StreamType::CAPTURE) {
+        return CAMERA_OK;
+    }
+    HStreamCapture* captureSteam = static_cast<HStreamCapture*>(stream.GetRefPtr());
+    if (captureSteam != nullptr && captureSteam->IsHasEnableOfflinePhoto()) {
+        bool isAddSuccess = streamContainerOffline_.AddStream(stream);
+        MEDIA_INFO_LOG("HStreamOperator::RemoveOutputStream,streamsize:%{public}zu",
+            streamContainerOffline_.Size());
+        if (streamContainerOffline_.Size() > 0) {
+            auto allStream = streamContainerOffline_.GetAllStreams();
+            for (auto& streamTemp : allStream) {
+                MEDIA_INFO_LOG("HStreamOperator::RemoveOutputStream fkwstreamid is %{public}d hdistreamid"
+                    "is %{public}d", streamTemp->GetFwkStreamId(), streamTemp->GetHdiStreamId());
+            }
+        }
+        captureSteam->SwitchToOffline();
+        CHECK_ERROR_RETURN_RET_LOG(!isAddSuccess, CAMERA_INVALID_SESSION_CFG,
+            "HStreamOperator::AddOutputStream add stream fail");
+    }
+    return CAMERA_OK;
+}
+
+std::list<sptr<HStreamCommon>> HStreamOperator::GetAllStreams()
+{
+    return streamContainer_.GetAllStreams();
+}
+
+int32_t HStreamOperator::GetStreamsSize()
+{
+    return streamContainer_.Size() ;
+}
+
+void  HStreamOperator::GetStreamOperator()
+{
+    if (cameraDevice_ == nullptr) {
+        MEDIA_INFO_LOG("HStreamOperator::GetStreamOperator cameraDevice_ is nullptr");
+        return;
+    }
+    cameraDevice_->GetStreamOperator(this, streamOperator_);
+}
+
+int32_t HStreamOperator::LinkInputAndOutputs(const std::shared_ptr<OHOS::Camera::CameraMetadata>& settings,
+    int32_t opMode)
+{
+    int32_t rc;
+    std::vector<StreamInfo_V1_1> allStreamInfos;
+    auto allStream = streamContainer_.GetAllStreams();
+    for (auto& stream : allStream) {
+        rc = stream->LinkInput(streamOperator_, settings);
+        if (rc == CAMERA_OK) {
+            CHECK_EXECUTE(stream->GetHdiStreamId() == STREAM_ID_UNSET,
+                stream->SetHdiStreamId(GenerateHdiStreamId()));
+        }
+        MEDIA_INFO_LOG(
+            "HStreamOperator::LinkInputAndOutputs streamType:%{public}d, streamId:%{public}d ,hdiStreamId:%{public}d",
+            stream->GetStreamType(), stream->GetFwkStreamId(), stream->GetHdiStreamId());
+        CHECK_ERROR_RETURN_RET_LOG(rc != CAMERA_OK, rc, "HStreamOperator::LinkInputAndOutputs IsValidMode false");
+        StreamInfo_V1_1 curStreamInfo;
+        stream->SetStreamInfo(curStreamInfo);
+        CHECK_EXECUTE(stream->GetStreamType() != StreamType::METADATA,
+            allStreamInfos.push_back(curStreamInfo));
+    }
+
+    rc = CreateAndCommitStreams(allStreamInfos, settings, opMode);
+    MEDIA_INFO_LOG("HStreamOperator::LinkInputAndOutputs execute success");
+    return rc;
+}
+
+int32_t HStreamOperator::UnlinkInputAndOutputs()
+{
+    CAMERA_SYNC_TRACE;
+    int32_t rc = CAMERA_UNKNOWN_ERROR;
+    std::vector<int32_t> fwkStreamIds;
+    std::vector<int32_t> hdiStreamIds;
+    auto allStream = streamContainer_.GetAllStreams();
+    for (auto& stream : allStream) {
+        fwkStreamIds.emplace_back(stream->GetFwkStreamId());
+        hdiStreamIds.emplace_back(stream->GetHdiStreamId());
+        stream->UnlinkInput();
+    }
+    MEDIA_INFO_LOG("HStreamOperator::UnlinkInputAndOutputs() streamIds size() = %{public}zu, streamIds:%{public}s, "
+        "hdiStreamIds:%{public}s",
+        fwkStreamIds.size(), Container2String(fwkStreamIds.begin(), fwkStreamIds.end()).c_str(),
+        Container2String(hdiStreamIds.begin(), hdiStreamIds.end()).c_str());
+    ReleaseStreams(hdiStreamIds);
+    std::vector<StreamInfo_V1_1> emptyStreams;
+    UpdateStreams(emptyStreams);
+    ResetHdiStreamId();
+    return rc;
+}
+
+void HStreamOperator::ExpandSketchRepeatStream()
+{
+    MEDIA_DEBUG_LOG("Enter HStreamOperator::ExpandSketchRepeatStream()");
+    std::set<sptr<HStreamCommon>> sketchStreams;
+    auto repeatStreams = streamContainer_.GetStreams(StreamType::REPEAT);
+    for (auto& stream : repeatStreams) {
+        if (stream == nullptr) {
+            continue;
+        }
+        auto streamRepeat = CastStream<HStreamRepeat>(stream);
+        if (streamRepeat->GetRepeatStreamType() == RepeatStreamType::SKETCH) {
+            continue;
+        }
+        sptr<HStreamRepeat> sketchStream = streamRepeat->GetSketchStream();
+        if (sketchStream == nullptr) {
+            continue;
+        }
+        sketchStreams.insert(sketchStream);
+    }
+    MEDIA_DEBUG_LOG("HStreamOperator::ExpandSketchRepeatStream() sketch size is:%{public}zu", sketchStreams.size());
+    for (auto& stream : sketchStreams) {
+        AddOutputStream(stream);
+    }
+    MEDIA_DEBUG_LOG("Exit HStreamOperator::ExpandSketchRepeatStream()");
+}
+
+void HStreamOperator::ExpandMovingPhotoRepeatStream()
+{
+    CAMERA_SYNC_TRACE;
+    MEDIA_DEBUG_LOG("ExpandMovingPhotoRepeatStream enter");
+    auto repeatStreams = streamContainer_.GetStreams(StreamType::REPEAT);
+    for (auto& stream : repeatStreams) {
+        if (stream == nullptr) {
+            continue;
+        }
+        auto streamRepeat = CastStream<HStreamRepeat>(stream);
+        if (streamRepeat && streamRepeat->GetRepeatStreamType() == RepeatStreamType::PREVIEW) {
+            std::lock_guard<std::mutex> lock(movingPhotoStatusLock_);
+            auto movingPhotoSurfaceWrapper =
+                MovingPhotoSurfaceWrapper::CreateMovingPhotoSurfaceWrapper(streamRepeat->width_, streamRepeat->height_);
+            if (movingPhotoSurfaceWrapper == nullptr) {
+                MEDIA_ERR_LOG("HStreamOperator::ExpandMovingPhotoRepeatStream CreateMovingPhotoSurfaceWrapper fail.");
+                continue;
+            }
+            auto producer = movingPhotoSurfaceWrapper->GetProducer();
+            metaSurface_ = Surface::CreateSurfaceAsConsumer("movingPhotoMeta");
+            auto metaCache = make_shared<FixedSizeList<pair<int64_t, sptr<SurfaceBuffer>>>>(3);
+            CHECK_WARNING_CONTINUE_LOG(producer == nullptr, "get producer fail.");
+            livephotoListener_ = new (std::nothrow) MovingPhotoListener(movingPhotoSurfaceWrapper,
+                metaSurface_, metaCache, preCacheFrameCount_, postCacheFrameCount_);
+            CHECK_WARNING_CONTINUE_LOG(livephotoListener_ == nullptr, "failed to new livephotoListener_!");
+            movingPhotoSurfaceWrapper->SetSurfaceBufferListener(livephotoListener_);
+            livephotoMetaListener_ = new(std::nothrow) MovingPhotoMetaListener(metaSurface_, metaCache);
+            CHECK_WARNING_CONTINUE_LOG(livephotoMetaListener_ == nullptr, "failed to new livephotoMetaListener_!");
+            metaSurface_->RegisterConsumerListener((sptr<IBufferConsumerListener> &)livephotoMetaListener_);
+            CreateMovingPhotoStreamRepeat(streamRepeat->format_, streamRepeat->width_, streamRepeat->height_, producer);
+            std::lock_guard<std::mutex> streamLock(livePhotoStreamLock_);
+            AddOutputStream(livePhotoStreamRepeat_);
+            if (!audioCapturerSession_) {
+                audioCapturerSession_ = new AudioCapturerSession();
+            }
+            if (!taskManager_ && audioCapturerSession_) {
+                taskManager_ = new AvcodecTaskManager(audioCapturerSession_, VideoCodecType::VIDEO_ENCODE_TYPE_HEVC);
+                taskManager_->SetVideoBufferDuration(preCacheFrameCount_, postCacheFrameCount_);
+            }
+            if (!videoCache_ && taskManager_) {
+                videoCache_ = new MovingPhotoVideoCache(taskManager_);
+            }
+            break;
+        }
+    }
+    MEDIA_DEBUG_LOG("ExpandMovingPhotoRepeatStream Exit");
+}
+
+int32_t HStreamOperator::CreateMovingPhotoStreamRepeat(
+    int32_t format, int32_t width, int32_t height, sptr<OHOS::IBufferProducer> producer)
+{
+    CAMERA_SYNC_TRACE;
+    std::lock_guard<std::mutex> lock(livePhotoStreamLock_);
+    CHECK_ERROR_RETURN_RET_LOG(
+        width <= 0 || height <= 0, CAMERA_INVALID_ARG, "HCameraService::CreateLivePhotoStreamRepeat args is illegal");
+    CHECK_EXECUTE(livePhotoStreamRepeat_ != nullptr, livePhotoStreamRepeat_->Release());
+    auto streamRepeat = new (std::nothrow) HStreamRepeat(producer, format, width, height, RepeatStreamType::LIVEPHOTO);
+    CHECK_ERROR_RETURN_RET_LOG(streamRepeat == nullptr, CAMERA_ALLOC_ERROR, "HStreamRepeat allocation failed");
+    MEDIA_DEBUG_LOG("para is:%{public}dx%{public}d,%{public}d", width, height, format);
+    livePhotoStreamRepeat_ = streamRepeat;
+    streamRepeat->SetMetaProducer(metaSurface_->GetProducer());
+    streamRepeat->SetMirror(isMovingPhotoMirror_);
+    MEDIA_INFO_LOG("HCameraService::CreateLivePhotoStreamRepeat end");
+    return CAMERA_OK;
+}
+
+const sptr<HStreamCommon> HStreamOperator::GetStreamByStreamID(int32_t streamId)
+{
+    auto stream = streamContainer_.GetStream(streamId) != nullptr ? streamContainer_.GetStream(streamId) :
+        streamContainer_.GetStream(streamId);
+
+    CHECK_ERROR_PRINT_LOG(stream == nullptr,
+        "HStreamOperator::GetStreamByStreamID get stream fail, streamId is:%{public}d", streamId);
+    return stream;
+}
+
+const sptr<HStreamCommon> HStreamOperator::GetHdiStreamByStreamID(int32_t streamId)
+{
+    auto stream = streamContainer_.GetHdiStream(streamId) != nullptr ? streamContainer_.GetHdiStream(streamId) :
+        streamContainerOffline_.GetHdiStream(streamId);
+    CHECK_ERROR_PRINT_LOG(stream == nullptr,
+        "HStreamOperator::GetHdiStreamByStreamID get stream fail, streamId is:%{public}d", streamId);
+    return stream;
+}
+
+void HStreamOperator::ClearSketchRepeatStream()
+{
+    MEDIA_DEBUG_LOG("Enter HStreamOperator::ClearSketchRepeatStream()");
+
+    // Already added session lock in BeginConfig()
+    auto repeatStreams = streamContainer_.GetStreams(StreamType::REPEAT);
+    for (auto& repeatStream : repeatStreams) {
+        if (repeatStream == nullptr) {
+            continue;
+        }
+        auto sketchStream = CastStream<HStreamRepeat>(repeatStream);
+        if (sketchStream->GetRepeatStreamType() != RepeatStreamType::SKETCH) {
+            continue;
+        }
+        MEDIA_DEBUG_LOG(
+            "HStreamOperator::ClearSketchRepeatStream() stream id is:%{public}d", sketchStream->GetFwkStreamId());
+        RemoveOutputStream(repeatStream);
+    }
+    MEDIA_DEBUG_LOG("Exit HStreamOperator::ClearSketchRepeatStream()");
+}
+
+void HStreamOperator::ClearMovingPhotoRepeatStream()
+{
+    CAMERA_SYNC_TRACE;
+    MEDIA_DEBUG_LOG("Enter HStreamOperator::ClearMovingPhotoRepeatStream()");
+    // Already added session lock in BeginConfig()
+    auto repeatStreams = streamContainer_.GetStreams(StreamType::REPEAT);
+    for (auto& repeatStream : repeatStreams) {
+        if (repeatStream == nullptr) {
+            continue;
+        }
+        auto movingPhotoStream = CastStream<HStreamRepeat>(repeatStream);
+        if (movingPhotoStream->GetRepeatStreamType() != RepeatStreamType::LIVEPHOTO) {
+            continue;
+        }
+        StopMovingPhoto();
+        std::lock_guard<std::mutex> lock(movingPhotoStatusLock_);
+        livephotoListener_ = nullptr;
+        videoCache_ = nullptr;
+        MEDIA_DEBUG_LOG("HStreamOperator::ClearLivePhotoRepeatStream() stream id is:%{public}d",
+            movingPhotoStream->GetFwkStreamId());
+        RemoveOutputStream(repeatStream);
+    }
+    MEDIA_DEBUG_LOG("Exit HStreamOperator::ClearLivePhotoRepeatStream()");
+}
+
+void HStreamOperator::StopMovingPhoto() __attribute__((no_sanitize("cfi")))
+{
+    CAMERA_SYNC_TRACE;
+    MEDIA_DEBUG_LOG("Enter HStreamOperator::StopMovingPhoto");
+    std::lock_guard<std::mutex> lock(movingPhotoStatusLock_);
+    CHECK_EXECUTE(livephotoListener_, livephotoListener_->StopDrainOut());
+    CHECK_EXECUTE(videoCache_, videoCache_->ClearCache());
+#ifdef MOVING_PHOTO_ADD_AUDIO
+    CHECK_EXECUTE(audioCapturerSession_, audioCapturerSession_->Stop());
+#endif
+    CHECK_EXECUTE(taskManager_, taskManager_->Stop());
+}
+
+int32_t HStreamOperator::GetActiveColorSpace(ColorSpace& colorSpace)
+{
+    colorSpace = currColorSpace_;
+    return CAMERA_OK;
+}
+
+int32_t HStreamOperator::SetColorSpace(ColorSpace colorSpace, ColorSpace captureColorSpace, bool isNeedUpdate)
+{
+    int32_t result = CAMERA_OK;
+    CHECK_ERROR_RETURN_RET_LOG(colorSpace == currColorSpace_ && captureColorSpace == currCaptureColorSpace_, result,
+        "HStreamOperator::SetColorSpace() colorSpace no need to update.");
+    currColorSpace_ = colorSpace;
+    currCaptureColorSpace_ = captureColorSpace;
+    result = CheckIfColorSpaceMatchesFormat(colorSpace);
+    if (result != CAMERA_OK) {
+        if (isNeedUpdate) {
+            MEDIA_ERR_LOG("HStreamOperator::SetColorSpace() Failed, format and colorSpace not match.");
+            return result;
+        } else {
+            MEDIA_ERR_LOG(
+                "HStreamOperator::SetColorSpace() %{public}d, format and colorSpace: %{public}d not match.",
+                result, colorSpace);
+            currColorSpace_ = ColorSpace::BT709;
+        }
+    }
+    MEDIA_INFO_LOG("HStreamOperator::SetColorSpace() colorSpace: %{public}d, captureColorSpace: %{public}d, "
+        "isNeedUpdate: %{public}d", currColorSpace_, captureColorSpace, isNeedUpdate);
+    SetColorSpaceForStreams();
+    return result;
+}
+
+void HStreamOperator::SetColorSpaceForStreams()
+{
+    auto streams = streamContainer_.GetAllStreams();
+    for (auto& stream : streams) {
+        MEDIA_DEBUG_LOG("HStreamOperator::SetColorSpaceForStreams() streams type %{public}d", stream->GetStreamType());
+        if (stream->GetStreamType() == StreamType::CAPTURE) {
+            stream->SetColorSpace(currCaptureColorSpace_);
+        } else {
+            stream->SetColorSpace(currColorSpace_);
+        }
+    }
+}
+
+void HStreamOperator::CancelStreamsAndGetStreamInfos(std::vector<StreamInfo_V1_1>& streamInfos)
+{
+    MEDIA_INFO_LOG("HStreamOperator::CancelStreamsAndGetStreamInfos enter.");
+    StreamInfo_V1_1 curStreamInfo;
+    auto streams = streamContainer_.GetAllStreams();
+    for (auto& stream : streams) {
+        if (stream && stream->GetStreamType() == StreamType::METADATA) {
+            continue;
+        }
+        if (stream && stream->GetStreamType() == StreamType::CAPTURE && isSessionStarted_) {
+            static_cast<HStreamCapture*>(stream.GetRefPtr())->CancelCapture();
+        } else if (stream && stream->GetStreamType() == StreamType::REPEAT && isSessionStarted_) {
+            static_cast<HStreamRepeat*>(stream.GetRefPtr())->Stop();
+        }
+        if (stream) {
+            stream->SetStreamInfo(curStreamInfo);
+            streamInfos.push_back(curStreamInfo);
+        }
+    }
+}
+
+void HStreamOperator::RestartStreams(const std::shared_ptr<OHOS::Camera::CameraMetadata>& settings)
+{
+    MEDIA_INFO_LOG("HStreamOperator::RestartStreams() enter.");
+    auto streams = streamContainer_.GetAllStreams();
+    for (auto& stream : streams) {
+        if (stream && stream->GetStreamType() == StreamType::REPEAT &&
+            CastStream<HStreamRepeat>(stream)->GetRepeatStreamType() == RepeatStreamType::PREVIEW) {
+            CastStream<HStreamRepeat>(stream)->Start(settings);
+        }
+    }
+}
+
+int32_t HStreamOperator::UpdateStreamInfos(const std::shared_ptr<OHOS::Camera::CameraMetadata>& settings)
+{
+    std::vector<StreamInfo_V1_1> streamInfos;
+    CancelStreamsAndGetStreamInfos(streamInfos);
+    int errorCode = UpdateStreams(streamInfos);
+    if (errorCode == CAMERA_OK) {
+        RestartStreams(settings);
+    } else {
+        MEDIA_DEBUG_LOG("HStreamOperator::UpdateStreamInfos err %{public}d", errorCode);
+    }
+    return errorCode;
+}
+
+int32_t HStreamOperator::CheckIfColorSpaceMatchesFormat(ColorSpace colorSpace)
+{
+    if (!(colorSpace == ColorSpace::BT2020_HLG || colorSpace == ColorSpace::BT2020_PQ ||
+        colorSpace == ColorSpace::BT2020_HLG_LIMIT || colorSpace == ColorSpace::BT2020_PQ_LIMIT)) {
+        return CAMERA_OK;
+    }
+
+    // 选择BT2020，需要匹配10bit的format；若不匹配，返回error
+    auto streams = streamContainer_.GetAllStreams();
+    for (auto& curStream : streams) {
+        if (!curStream) {
+            continue;
+        }
+        // 当前拍照流不支持BT2020，无需校验format
+        if (curStream->GetStreamType() != StreamType::REPEAT) {
+            continue;
+        }
+        StreamInfo_V1_1 curStreamInfo;
+        curStream->SetStreamInfo(curStreamInfo);
+        MEDIA_INFO_LOG("HStreamOperator::CheckFormat, stream repeatType: %{public}d, format: %{public}d",
+            static_cast<HStreamRepeat*>(curStream.GetRefPtr())->GetRepeatStreamType(), curStreamInfo.v1_0.format_);
+        CHECK_ERROR_RETURN_RET_LOG(
+            !(curStreamInfo.v1_0.format_ == OHOS::HDI::Display::Composer::V1_1::PIXEL_FMT_YCBCR_P010 ||
+                curStreamInfo.v1_0.format_ == OHOS::HDI::Display::Composer::V1_1::PIXEL_FMT_YCRCB_P010),
+            CAMERA_OPERATION_NOT_ALLOWED, "HCaptureSession::CheckFormat, stream format not match");
+    }
+    return CAMERA_OK;
+}
+
+int32_t HStreamOperator::GetMovingPhotoBufferDuration()
+{
+    uint32_t preBufferDuration = 0;
+    uint32_t postBufferDuration = 0;
+    constexpr int32_t MILLSEC_MULTIPLE = 1000;
+    CHECK_ERROR_RETURN_RET_LOG(
+        cameraDevice_ == nullptr, 0, "HCaptureSession::GetMovingPhotoBufferDuration() cameraDevice is null");
+    std::shared_ptr<OHOS::Camera::CameraMetadata> ability = cameraDevice_->GetDeviceAbility();
+    CHECK_ERROR_RETURN_RET(ability == nullptr, 0);
+    camera_metadata_item_t item;
+    int ret = OHOS::Camera::FindCameraMetadataItem(ability->get(), OHOS_MOVING_PHOTO_BUFFER_DURATION, &item);
+    CHECK_ERROR_RETURN_RET_LOG(
+        ret != CAM_META_SUCCESS, 0, "HCaptureSession::GetMovingPhotoBufferDuration get buffer duration failed");
+    preBufferDuration = item.data.ui32[0];
+    postBufferDuration = item.data.ui32[1];
+    preCacheFrameCount_ = preBufferDuration == 0
+                              ? preCacheFrameCount_
+                              : static_cast<uint32_t>(float(preBufferDuration) / MILLSEC_MULTIPLE * VIDEO_FRAME_RATE);
+    postCacheFrameCount_ = preBufferDuration == 0
+                               ? postCacheFrameCount_
+                               : static_cast<uint32_t>(float(postBufferDuration) / MILLSEC_MULTIPLE * VIDEO_FRAME_RATE);
+    MEDIA_INFO_LOG(
+        "HCaptureSession::GetMovingPhotoBufferDuration preBufferDuration : %{public}u, "
+        "postBufferDuration : %{public}u, preCacheFrameCount_ : %{public}u, postCacheFrameCount_ : %{public}u",
+        preBufferDuration, postBufferDuration, preCacheFrameCount_, postCacheFrameCount_);
+    return CAMERA_OK;
+}
+
+
+void HStreamOperator::GetMovingPhotoStartAndEndTime()
+{
+    // auto thisPtr = hStreamOperator_;
+    CHECK_ERROR_RETURN_LOG(cameraDevice_ == nullptr, "HCaptureSession::GetMovingPhotoStartAndEndTime device is null");
+    cameraDevice_->SetMovingPhotoStartTimeCallback([this](int32_t captureId, int64_t startTimeStamp) {//thisPtr
+        MEDIA_INFO_LOG("SetMovingPhotoStartTimeCallback function enter");
+        // auto sessionPtr = thisPtr.promote();
+        // CHECK_ERROR_RETURN_LOG(sessionPtr == nullptr, "Set start time callback sessionPtr is null");
+        CHECK_ERROR_RETURN_LOG(this->taskManager_ == nullptr, "Set start time callback taskManager_ is null");
+        std::lock_guard<mutex> lock(this->taskManager_->startTimeMutex_);
+        if (this->taskManager_->mPStartTimeMap_.count(captureId) == 0) {
+            MEDIA_INFO_LOG("Save moving photo start info, captureId : %{public}d, start timestamp : %{public}" PRIu64,
+                captureId, startTimeStamp);
+            this->taskManager_->mPStartTimeMap_.insert(make_pair(captureId, startTimeStamp));
+        }
+    });
+
+    cameraDevice_->SetMovingPhotoEndTimeCallback([this](int32_t captureId, int64_t endTimeStamp) {//thisPtr
+        // auto sessionPtr = thisPtr.promote();
+        // CHECK_ERROR_RETURN_LOG(sessionPtr == nullptr, "Set end time callback sessionPtr is null");
+        CHECK_ERROR_RETURN_LOG(this->taskManager_ == nullptr, "Set end time callback taskManager_ is null");
+        std::lock_guard<mutex> lock(this->taskManager_->endTimeMutex_);
+        if (this->taskManager_->mPEndTimeMap_.count(captureId) == 0) {
+            MEDIA_INFO_LOG("Save moving photo end info, captureId : %{public}d, end timestamp : %{public}" PRIu64,
+                captureId, endTimeStamp);
+            this->taskManager_->mPEndTimeMap_.insert(make_pair(captureId, endTimeStamp));
+        }
+    });
+}
+
+int32_t HStreamOperator::EnableMovingPhoto(const std::shared_ptr<OHOS::Camera::CameraMetadata>& settings,
+    bool isEnable, int32_t sensorOritation)
+{
+    MEDIA_INFO_LOG("HStreamOperator::EnableMovingPhoto is %{public}d", isEnable);
+    isSetMotionPhoto_ = isEnable;
+    deviceSensorOritation_ = sensorOritation;
+    #ifdef CAMERA_USE_SENSOR
+    if (isSetMotionPhoto_) {
+        RegisterSensorCallback();
+    } else {
+        UnRegisterSensorCallback();
+    }
+    #endif
+    StartMovingPhotoStream(settings);
+    CHECK_EXECUTE(cameraDevice_ != nullptr, cameraDevice_->EnableMovingPhoto(isEnable));
+    GetMovingPhotoBufferDuration();
+    GetMovingPhotoStartAndEndTime();
+    return CAMERA_OK;
+}
+
+void HStreamOperator::StartMovingPhoto(const std::shared_ptr<OHOS::Camera::CameraMetadata>& settings,
+    sptr<HStreamRepeat>& curStreamRepeat)
+{
+    auto thisPtr = wptr<HStreamOperator>(this);
+    curStreamRepeat->SetMovingPhotoStartCallback([thisPtr, settings]() {
+        auto sessionPtr = thisPtr.promote();
+        if (sessionPtr != nullptr) {
+            MEDIA_INFO_LOG("StartMovingPhotoStream when addDeferedSurface");
+            sessionPtr->StartMovingPhotoStream(settings);
+        }
+    });
+}
+
+int32_t HStreamOperator::StartPreviewStream(const std::shared_ptr<OHOS::Camera::CameraMetadata>& settings,
+    camera_position_enum_t cameraPosition)
+{
+    int32_t errorCode = CAMERA_OK;
+    auto repeatStreams = streamContainer_.GetStreams(StreamType::REPEAT);
+    bool hasDerferedPreview = false;
+    // start preview
+    for (auto& item : repeatStreams) {
+        auto curStreamRepeat = CastStream<HStreamRepeat>(item);
+        auto repeatType = curStreamRepeat->GetRepeatStreamType();
+        if (repeatType != RepeatStreamType::PREVIEW) {
+            continue;
+        }
+        if (curStreamRepeat->GetPreparedCaptureId() != CAPTURE_ID_UNSET) {
+            continue;
+        }
+        curStreamRepeat->SetUsedAsPosition(cameraPosition);
+        errorCode = curStreamRepeat->Start(settings);
+        hasDerferedPreview = curStreamRepeat->producer_ == nullptr;
+        if (isSetMotionPhoto_ && hasDerferedPreview) {
+            StartMovingPhoto(settings, curStreamRepeat);
+        }
+        if (errorCode != CAMERA_OK) {
+            MEDIA_ERR_LOG("HStreamOperator::Start(), Failed to start preview, rc: %{public}d", errorCode);
+            break;
+        }
+    }
+    // start movingPhoto
+    for (auto& item : repeatStreams) {
+        auto curStreamRepeat = CastStream<HStreamRepeat>(item);
+        auto repeatType = curStreamRepeat->GetRepeatStreamType();
+        if (repeatType != RepeatStreamType::LIVEPHOTO) {
+            continue;
+        }
+        int32_t movingPhotoErrorCode = CAMERA_OK;
+        if (isSetMotionPhoto_ && !hasDerferedPreview) {
+            movingPhotoErrorCode = curStreamRepeat->Start(settings);
+            #ifdef MOVING_PHOTO_ADD_AUDIO
+            std::lock_guard<std::mutex> lock(movingPhotoStatusLock_);
+            audioCapturerSession_ != nullptr && audioCapturerSession_->StartAudioCapture();
+            #endif
+        }
+        if (movingPhotoErrorCode != CAMERA_OK) {
+            MEDIA_ERR_LOG("Failed to start movingPhoto, rc: %{public}d", movingPhotoErrorCode);
+            break;
+        }
+    }
+    return errorCode;
+}
+
+int32_t HStreamOperator::Stop()
+{
+    CAMERA_SYNC_TRACE;
+    int32_t errorCode = CAMERA_OK;
+    MEDIA_INFO_LOG("HStreamOperator::Stop prepare execute");
+    auto allStreams = streamContainer_.GetAllStreams();
+    for (auto& item : allStreams) {
+        if (item->GetStreamType() == StreamType::REPEAT) {
+            auto repeatStream = CastStream<HStreamRepeat>(item);
+            if (repeatStream->GetRepeatStreamType() == RepeatStreamType::PREVIEW) {
+                errorCode = repeatStream->Stop();
+            } else if (repeatStream->GetRepeatStreamType() == RepeatStreamType::LIVEPHOTO) {
+                repeatStream->Stop();
+                StopMovingPhoto();
+            } else {
+                repeatStream->Stop();
+            }
+        } else if (item->GetStreamType() == StreamType::METADATA) {
+            CastStream<HStreamMetadata>(item)->Stop();
+        } else if (item->GetStreamType() == StreamType::CAPTURE) {
+            CastStream<HStreamCapture>(item)->CancelCapture();
+        } else if (item->GetStreamType() == StreamType::DEPTH) {
+            CastStream<HStreamDepthData>(item)->Stop();
+        } else {
+            MEDIA_ERR_LOG("HStreamOperator::Stop(), get unknow stream, streamType: %{public}d, streamId:%{public}d",
+                item->GetStreamType(), item->GetFwkStreamId());
+        }
+        if (errorCode != CAMERA_OK) {
+            MEDIA_ERR_LOG("HStreamOperator::Stop(), Failed to stop stream, rc: %{public}d, streamId:%{public}d",
+                errorCode, item->GetFwkStreamId());
+        }
+    }
+    MEDIA_INFO_LOG("HStreamOperator::Stop execute success");
+    return errorCode;
+}
+
+void HStreamOperator::ReleaseStreams()
+{
+    CAMERA_SYNC_TRACE;
+    std::vector<int32_t> fwkStreamIds;
+    std::vector<int32_t> hdiStreamIds;
+    auto allStream = streamContainer_.GetAllStreams();
+    for (auto& stream : allStream) {
+        if (stream->GetStreamType() == StreamType::CAPTURE &&
+            CastStream<HStreamCapture>(stream)->IsHasSwitchToOffline()) {
+            continue;
+        }
+        auto fwkStreamId = stream->GetFwkStreamId();
+        if (fwkStreamId != STREAM_ID_UNSET) {
+            fwkStreamIds.emplace_back(fwkStreamId);
+        }
+        auto hdiStreamId = stream->GetHdiStreamId();
+        if (hdiStreamId != STREAM_ID_UNSET) {
+            hdiStreamIds.emplace_back(hdiStreamId);
+        }
+        stream->ReleaseStream(true);
+        streamContainer_.RemoveStream(stream);
+    }
+    MEDIA_INFO_LOG("HStreamOperator::ReleaseStreams() streamIds size() = %{public}zu, fwkStreamIds:%{public}s, "
+        "hdiStreamIds:%{public}s,",
+        fwkStreamIds.size(), Container2String(fwkStreamIds.begin(), fwkStreamIds.end()).c_str(),
+        Container2String(hdiStreamIds.begin(), hdiStreamIds.end()).c_str());
+    if (!hdiStreamIds.empty()) {
+        ReleaseStreams(hdiStreamIds);
+    }
+    if (GetAllOutptSize() == 0) {
+        Release();
+    }
+}
+
+int32_t HStreamOperator::GetOfflineOutptSize()
+{
+    std::list<sptr<HStreamCommon>> captureStreams = streamContainer_.GetStreams(StreamType::CAPTURE);
+    std::list<sptr<HStreamCommon>> captureStreamsOffline = streamContainerOffline_.GetStreams(StreamType::CAPTURE);
+    captureStreams.insert(captureStreams.end(), captureStreamsOffline.begin(), captureStreamsOffline.end());
+    int32_t offlineCount = 0;
+    for (auto& stream : captureStreams) {
+        if (stream->GetStreamType() == StreamType::CAPTURE &&
+            CastStream<HStreamCapture>(stream)->IsHasEnableOfflinePhoto()) {
+            offlineCount++;
+        } else {
+            continue;
+        }
+    }
+    return offlineCount;
+}
+
+int32_t HStreamOperator::GetAllOutptSize()
+{
+    int32_t outputCount = streamContainerOffline_.Size() + streamContainer_.Size();
+    return outputCount;
+}
+
+int32_t HStreamOperator::ReleaseStreams(std::vector<int32_t>& releaseStreamIds)
+{
+    CAMERA_SYNC_TRACE;
+    if (streamOperator_ != nullptr && !releaseStreamIds.empty()) {
+        MEDIA_INFO_LOG("HStreamOperator::ReleaseStreams %{public}s",
+            Container2String(releaseStreamIds.begin(), releaseStreamIds.end()).c_str());
+        int32_t rc = streamOperator_->ReleaseStreams(releaseStreamIds);
+        if (rc != HDI::Camera::V1_0::NO_ERROR) {
+            MEDIA_ERR_LOG("HCameraDevice::ClearStreamOperator ReleaseStreams fail, error Code:%{public}d", rc);
+            CameraReportUtils::ReportCameraError(
+                "HCameraDevice::ReleaseStreams", rc, true, CameraReportUtils::GetCallerInfo());
+        }
+    }
+    return CAMERA_OK;
+}
+
+int32_t HStreamOperator::Release()
+{
+    CAMERA_SYNC_TRACE;
+    int32_t errorCode = CAMERA_OK;
+    #ifdef CAMERA_USE_SENSOR
+    if (isSetMotionPhoto_) {
+        UnRegisterSensorCallback();
+    }
+    #endif
+    if (displayListener_) {
+        OHOS::Rosen::DisplayManager::GetInstance().UnregisterDisplayListener(displayListener_);
+        displayListener_ = nullptr;
+    }
+    if (streamOperator_) {
+        streamOperator_ = nullptr;
+        MEDIA_INFO_LOG("HStreamOperator::Release streamOperator_ is nullptr");
+    }
+    HStreamOperatorManager::GetInstance()->RemoveStreamOperator(streamOperatorId_);
+    std::lock_guard<std::mutex> lock(movingPhotoStatusLock_);
+    livephotoListener_ = nullptr;
+    videoCache_ = nullptr;
+    if (taskManager_) {
+        taskManager_->ClearTaskResource();
+        taskManager_ = nullptr;
+    }
+    MEDIA_INFO_LOG("HStreamOperator::Release execute success");
+    return errorCode;
+}
+
+int32_t HStreamOperator::CreateAndCommitStreams(std::vector<HDI::Camera::V1_1::StreamInfo_V1_1>& streamInfos,
+    const std::shared_ptr<OHOS::Camera::CameraMetadata>& deviceSettings, int32_t operationMode)
+{
+    int retCode = CreateStreams(streamInfos);
+    CHECK_ERROR_RETURN_RET(retCode != CAMERA_OK, retCode);
+    return CommitStreams(deviceSettings, operationMode);
+}
+
+int32_t HStreamOperator::CommitStreams(
+    const std::shared_ptr<OHOS::Camera::CameraMetadata>& deviceSettings, int32_t operationMode)
+{
+    CamRetCode hdiRc = HDI::Camera::V1_0::NO_ERROR;
+    uint32_t major;
+    uint32_t minor;
+    sptr<OHOS::HDI::Camera::V1_0::IStreamOperator> streamOperator;
+    sptr<OHOS::HDI::Camera::V1_1::IStreamOperator> streamOperatorV1_1;
+    std::lock_guard<std::mutex> lock(opMutex_);
+    streamOperator = streamOperator_;
+    CHECK_ERROR_RETURN_RET_LOG(streamOperator == nullptr, CAMERA_UNKNOWN_ERROR,
+        "HStreamOperator::CommitStreams GetStreamOperator is null!");
+    // get higher streamOperator version
+    streamOperator->GetVersion(major, minor);
+    MEDIA_INFO_LOG(
+        "HStreamOperator::CommitStreams streamOperator GetVersion major:%{public}d, minor:%{public}d", major, minor);
+    if (major >= HDI_VERSION_1 && minor >= HDI_VERSION_1) {
+        MEDIA_DEBUG_LOG("HStreamOperator::CommitStreams IStreamOperator cast to V1_1");
+        streamOperatorV1_1 = OHOS::HDI::Camera::V1_1::IStreamOperator::CastFrom(streamOperator);
+        if (streamOperatorV1_1 == nullptr) {
+            MEDIA_ERR_LOG("HStreamOperator::CommitStreams IStreamOperator cast to V1_1 error");
+            streamOperatorV1_1 = static_cast<OHOS::HDI::Camera::V1_1::IStreamOperator*>(streamOperator.GetRefPtr());
+        }
+    }
+
+    std::vector<uint8_t> setting;
+    OHOS::Camera::MetadataUtils::ConvertMetadataToVec(deviceSettings, setting);
+    MEDIA_INFO_LOG("HStreamOperator::CommitStreams, commit mode %{public}d", operationMode);
+    if (streamOperatorV1_1 != nullptr) {
+        MEDIA_DEBUG_LOG("HStreamOperator::CommitStreams IStreamOperator V1_1");
+        hdiRc = (CamRetCode)(streamOperatorV1_1->CommitStreams_V1_1(
+            static_cast<OHOS::HDI::Camera::V1_1::OperationMode_V1_1>(operationMode), setting));
+    } else {
+        MEDIA_DEBUG_LOG("HStreamOperator::CommitStreams IStreamOperator V1_0");
+        OperationMode opMode = OperationMode::NORMAL;
+        hdiRc = (CamRetCode)(streamOperator->CommitStreams(opMode, setting));
+    }
+    if (hdiRc != HDI::Camera::V1_0::NO_ERROR) {
+        MEDIA_ERR_LOG("HStreamOperator::CommitStreams failed with error Code:%d", hdiRc);
+        CameraReportUtils::ReportCameraError(
+            "HStreamOperator::CommitStreams", hdiRc, true, CameraReportUtils::GetCallerInfo());
+    }
+    MEDIA_DEBUG_LOG("HStreamOperator::CommitStreams end");
+    return HdiToServiceError(hdiRc);
+}
+
+int32_t HStreamOperator::EnableMovingPhotoMirror(bool isMirror, bool isConfig)
+{
+    if (!isConfig) {
+        isMovingPhotoMirror_ = isMirror;
+        return CAMERA_OK;
+    }
+    if (!isSetMotionPhoto_ || isMirror == isMovingPhotoMirror_) {
+        return CAMERA_OK;
+    }
+    auto repeatStreams = streamContainer_.GetStreams(StreamType::REPEAT);
+    for (auto& stream : repeatStreams) {
+        if (stream == nullptr) {
+            continue;
+        }
+        auto streamRepeat = CastStream<HStreamRepeat>(stream);
+        if (streamRepeat->GetRepeatStreamType() == RepeatStreamType::LIVEPHOTO) {
+            MEDIA_INFO_LOG("restart movingphoto stream.");
+            if (streamRepeat->SetMirrorForLivePhoto(isMirror, opMode_)) {
+                isMovingPhotoMirror_ = isMirror;
+                // set clear cache flag
+                std::lock_guard<std::mutex> lock(movingPhotoStatusLock_);
+                livephotoListener_->SetClearFlag();
+            }
+            break;
+        }
+    }
+    return CAMERA_OK;
+}
+
+void HStreamOperator::GetOutputStatus(int32_t &status)
+{
+    auto repeatStreams = streamContainer_.GetStreams(StreamType::REPEAT);
+    for (auto& stream : repeatStreams) {
+        if (stream == nullptr) {
+            continue;
+        }
+        auto streamRepeat = CastStream<HStreamRepeat>(stream);
+        if (streamRepeat->GetRepeatStreamType() == RepeatStreamType::VIDEO) {
+            if (streamRepeat->GetPreparedCaptureId() != CAPTURE_ID_UNSET) {
+                const int32_t videoStartStatus = 2;
+                status = videoStartStatus;
+            }
+        }
+    }
+}
+
+
+#ifdef CAMERA_USE_SENSOR
+void HStreamOperator::RegisterSensorCallback()
+{
+    std::lock_guard<std::mutex> lock(sensorLock_);
+    if (isRegisterSensorSuccess_) {
+        MEDIA_INFO_LOG("HCaptureSession::RegisterSensorCallback isRegisterSensorSuccess return");
+        return;
+    }
+    MEDIA_INFO_LOG("HCaptureSession::RegisterSensorCallback start");
+    user.callback = GravityDataCallbackImpl;
+    int32_t subscribeRet = SubscribeSensor(SENSOR_TYPE_ID_GRAVITY, &user);
+    MEDIA_INFO_LOG("RegisterSensorCallback, subscribeRet: %{public}d", subscribeRet);
+    int32_t setBatchRet = SetBatch(SENSOR_TYPE_ID_GRAVITY, &user, POSTURE_INTERVAL, 0);
+    MEDIA_INFO_LOG("RegisterSensorCallback, setBatchRet: %{public}d", setBatchRet);
+    int32_t activateRet = ActivateSensor(SENSOR_TYPE_ID_GRAVITY, &user);
+    MEDIA_INFO_LOG("RegisterSensorCallback, activateRet: %{public}d", activateRet);
+    if (subscribeRet != CAMERA_OK || setBatchRet != CAMERA_OK || activateRet != CAMERA_OK) {
+        isRegisterSensorSuccess_ = false;
+        MEDIA_INFO_LOG("RegisterSensorCallback failed.");
+    } else {
+        isRegisterSensorSuccess_ = true;
+    }
+}
+
+void HStreamOperator::UnRegisterSensorCallback()
+{
+    std::lock_guard<std::mutex> lock(sensorLock_);
+    int32_t deactivateRet = DeactivateSensor(SENSOR_TYPE_ID_GRAVITY, &user);
+    int32_t unsubscribeRet = UnsubscribeSensor(SENSOR_TYPE_ID_GRAVITY, &user);
+    if (deactivateRet == CAMERA_OK && unsubscribeRet == CAMERA_OK) {
+        MEDIA_INFO_LOG("HCameraService.UnRegisterSensorCallback success.");
+        isRegisterSensorSuccess_ = false;
+    } else {
+        MEDIA_INFO_LOG("HCameraService.UnRegisterSensorCallback failed.");
+    }
+}
+
+void HStreamOperator::GravityDataCallbackImpl(SensorEvent* event)
+{
+    MEDIA_DEBUG_LOG("GravityDataCallbackImpl prepare execute");
+    CHECK_ERROR_RETURN_LOG(event == nullptr, "SensorEvent is nullptr.");
+    CHECK_ERROR_RETURN_LOG(event[0].data == nullptr, "SensorEvent[0].data is nullptr.");
+    CHECK_ERROR_RETURN_LOG(event->sensorTypeId != SENSOR_TYPE_ID_GRAVITY, "SensorCallback error type.");
+    // this data will be delete when callback execute finish
+    GravityData* nowGravityData = reinterpret_cast<GravityData*>(event->data);
+    gravityData = { nowGravityData->x, nowGravityData->y, nowGravityData->z };
+    sensorRotation = CalcSensorRotation(CalcRotationDegree(gravityData));
+}
+
+int32_t HStreamOperator::CalcSensorRotation(int32_t sensorDegree)
+{
+    // Use ROTATION_0 when degree range is [0, 30]∪[330, 359]
+    if (sensorDegree >= 0 && (sensorDegree <= 30 || sensorDegree >= 330)) {
+        return STREAM_ROTATE_0;
+    } else if (sensorDegree >= 60 && sensorDegree <= 120) { // Use ROTATION_90 when degree range is [60, 120]
+        return STREAM_ROTATE_90;
+    } else if (sensorDegree >= 150 && sensorDegree <= 210) { // Use ROTATION_180 when degree range is [150, 210]