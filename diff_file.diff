diff --git a/frameworks/native/camera/test/unittest/framework_native/device/src/camera_device_unittest.cpp b/frameworks/native/camera/test/unittest/framework_native/device/src/camera_device_unittest.cpp
index 99d38b17..63b652ea 100644
--- a/frameworks/native/camera/test/unittest/framework_native/device/src/camera_device_unittest.cpp
+++ b/frameworks/native/camera/test/unittest/framework_native/device/src/camera_device_unittest.cpp
@@ -182,5 +182,35 @@ HWTEST_F(CameraDeviceUnit, camera_device_unittest_007, TestSize.Level0)
     cameras[0]->lensEquivalentFocalLength_ = {15, 20};
     EXPECT_EQ(cameras[0]->GetLensEquivalentFocalLength(), cameras[0]->lensEquivalentFocalLength_);
 }
+
+
+/*
+ * Feature: Framework
+ * Function: Test cameradevice with GetZoomRatioRange when zoomRatioRange_ is empty
+ * SubFunction: NA
+ * FunctionPoints: NA
+ * EnvConditions: NA
+ * CaseDescription: Test GetZoomRatioRange when zoomRatioRange_ is empty
+ */
+HWTEST_F(CameraDeviceUnit, camera_device_unittest_008, TestSize.Level0)
+{
+    std::vector<sptr<CameraDevice>> cameras = cameraManager_->GetSupportedCameras();
+    cameras[0]->zoomRatioRange_.clear();
+    EXPECT_EQ(cameras[0]->GetZoomRatioRange(), cameras[0]->zoomRatioRange_);
+}
+
+/*
+ * Feature: Framework
+ * Function: Test cameradevice with GetisRetractable
+ * SubFunction: NA
+ * FunctionPoints: NA
+ * EnvConditions: NA
+ * CaseDescription: Test GetisRetractable
+ */
+HWTEST_F(CameraDeviceUnit, camera_device_unittest_009, TestSize.Level0)
+{
+    std::vector<sptr<CameraDevice>> cameras = cameraManager_->GetSupportedCameras();
+    EXPECT_EQ(cameras[0]->GetisRetractable(), cameras[0]->isRetractable_);
+}
 }
 }
diff --git a/frameworks/native/camera/test/unittest/framework_native/manager/include/camera_framework_manager_unittest.h b/frameworks/native/camera/test/unittest/framework_native/manager/include/camera_framework_manager_unittest.h
index cd980d3e..48f3c6f3 100644
--- a/frameworks/native/camera/test/unittest/framework_native/manager/include/camera_framework_manager_unittest.h
+++ b/frameworks/native/camera/test/unittest/framework_native/manager/include/camera_framework_manager_unittest.h
@@ -23,6 +23,14 @@
 namespace OHOS {
 namespace CameraStandard {
 
+class CameraManagerCallbackTest : public CameraManagerCallback {
+public:
+    CameraManagerCallbackTest() = default;
+    virtual ~CameraManagerCallbackTest() = default;
+    virtual void OnCameraStatusChanged(const CameraStatusInfo &cameraStatusInfo) const {};
+    virtual void OnFlashlightStatusChanged(const std::string &cameraID, const FlashStatus flashStatus) const {};
+};
+
 class CameraMuteListenerTest : public CameraMuteListener {
 public:
     CameraMuteListenerTest() = default;
diff --git a/frameworks/native/camera/test/unittest/framework_native/manager/src/camera_framework_manager_unittest.cpp b/frameworks/native/camera/test/unittest/framework_native/manager/src/camera_framework_manager_unittest.cpp
index 68fe3567..9e0645c9 100644
--- a/frameworks/native/camera/test/unittest/framework_native/manager/src/camera_framework_manager_unittest.cpp
+++ b/frameworks/native/camera/test/unittest/framework_native/manager/src/camera_framework_manager_unittest.cpp
@@ -1890,5 +1890,134 @@ HWTEST_F(CameraFrameWorkManagerUnit, camera_framework_manager_unittest_083, Test
     EXPECT_EQ(cameraManager_->CreateCustomPreviewOutput(producer, format, width, height), nullptr);
     cameraManager_->IsCameraMuteSupported();
 }
+
+/*
+ * Feature: Framework
+ * Function: Test create video output when frames not exist
+ * SubFunction: NA
+ * FunctionPoints: NA
+ * EnvConditions: NA
+ * CaseDescription: Test create video output when frames not exist
+ */
+HWTEST_F(CameraFrameWorkManagerUnit, camera_framework_manager_unittest_084, TestSize.Level0)
+{
+    int32_t width = VIDEO_DEFAULT_WIDTH;
+    int32_t height = VIDEO_DEFAULT_HEIGHT;
+    sptr<Surface> surface = Surface::CreateSurfaceAsConsumer();
+    CameraFormat videoFormat = CAMERA_FORMAT_YUV_420_SP;
+    Size videoSize;
+    videoSize.width = width;
+    videoSize.height = height;
+    std::vector<int32_t> videoFramerates;
+    VideoProfile videoProfile = VideoProfile(videoFormat, videoSize, videoFramerates);
+    sptr<VideoOutput> video = cameraManager_->CreateVideoOutput(videoProfile, surface);
+    ASSERT_NE(video, nullptr);
+    video->Release();
+}
+
+/*
+ * Feature: Framework
+ * Function: Test UnregisterCameraMuteListener when unregister the last listener
+ * SubFunction: NA
+ * FunctionPoints: NA
+ * EnvConditions: NA
+ * CaseDescription: Test UnregisterCameraMuteListener when unregister the last listener
+ */
+HWTEST_F(CameraFrameWorkManagerUnit, camera_framework_manager_unittest_085, TestSize.Level0)
+{
+    cameraManager_->GetCameraMuteListenerManager()->ClearListeners();
+    EXPECT_EQ(cameraManager_->GetCameraMuteListenerManager()->GetListenerCount(), 0);
+
+    std::shared_ptr<CameraMuteListener> listener = std::make_shared<CameraMuteListenerTest>();
+    cameraManager_->RegisterCameraMuteListener(listener);
+    EXPECT_EQ(cameraManager_->GetCameraMuteListenerManager()->GetListenerCount(), 1);
+
+    cameraManager_->UnregisterCameraMuteListener(listener);
+    EXPECT_EQ(cameraManager_->GetCameraMuteListenerManager()->GetListenerCount(), 0);
+}
+
+/*
+ * Feature: Framework
+ * Function: Test cameraManager SaveOldCameraId and GetOldCameraIdfromReal
+ * SubFunction: NA
+ * FunctionPoints: NA
+ * EnvConditions: NA
+ * CaseDescription: Test cameraManager SaveOldCameraId and GetOldCameraIdfromReal
+ */
+HWTEST_F(CameraFrameWorkManagerUnit, camera_framework_manager_unittest_086, TestSize.Level0)
+{
+    std::string nocamera = "nocamera";
+    cameraManager_->SaveOldCameraId(nocamera, nocamera);
+    EXPECT_EQ(cameraManager_->GetOldCameraIdfromReal(nocamera), nocamera);
+    cameraManager_->realtoVirtual_.clear();
+}
+
+/*
+ * Feature: Framework
+ * Function: Test CreateCaptureSession with a single CaptureSession argument
+ * SubFunction: NA
+ * FunctionPoints: NA
+ * EnvConditions: NA
+ * CaseDescription: Test CreateCaptureSession with a single CaptureSession argument
+ */
+HWTEST_F(CameraFrameWorkManagerUnit, camera_framework_manager_unittest_087, TestSize.Level0)
+{
+    sptr<CaptureSession> session;
+    EXPECT_EQ(cameraManager_->CreateCaptureSession(&session), 0);
+    EXPECT_NE(session, nullptr);
+}
+
+/*
+ * Feature: Framework
+ * Function: Test GetCameraOutputStatus when service proxy is not nullptr
+ * SubFunction: NA
+ * FunctionPoints: NA
+ * EnvConditions: NA
+ * CaseDescription: Test GetCameraOutputStatus when service proxy is not nullptr
+ */
+HWTEST_F(CameraFrameWorkManagerUnit, camera_framework_manager_unittest_088, TestSize.Level0)
+{
+    int32_t status = 0;
+    cameraManager_->RefreshServiceProxy();
+    ASSERT_NE(cameraManager_->GetServiceProxy(), nullptr);
+    cameraManager_->GetCameraOutputStatus(0, status);
+
+    std::vector<sptr<CameraInfo>> getCameras = cameraManager_->GetCameras();
+    EXPECT_TRUE(getCameras.empty());
+}
+
+
+/*
+ * Feature: Framework
+ * Function: Test GetCameraOutputStatus when service proxy is not nullptr
+ * SubFunction: NA
+ * FunctionPoints: NA
+ * EnvConditions: NA
+ * CaseDescription: Test GetCameraOutputStatus when service proxy is not nullptr
+ */
+HWTEST_F(CameraFrameWorkManagerUnit, camera_framework_manager_unittest_089, TestSize.Level0)
+{
+    std::vector<sptr<CameraDevice>> cameras = cameraManager_->GetSupportedCameras();
+    ASSERT_FALSE(cameras.empty());
+
+    std::shared_ptr<CameraManagerCallback> statusCallback = std::make_shared<CameraManagerCallbackTest>();
+    cameraManager_->RegisterCameraStatusCallback(statusCallback);
+    EXPECT_GT(cameraManager_->GetCameraStatusListenerManager()->GetListenerCount(), 0);
+
+    std::shared_ptr<CameraMuteListener> muteListener = std::make_shared<CameraMuteListenerTest>();
+    cameraManager_->RegisterCameraMuteListener(muteListener);
+    EXPECT_GT(cameraManager_->GetCameraMuteListenerManager()->GetListenerCount(), 0);
+
+    std::shared_ptr<TorchListener> torchListener = std::make_shared<TorchListenerTest>();
+    cameraManager_->RegisterTorchListener(torchListener);
+    EXPECT_GT(cameraManager_->GetTorchServiceListenerManager()->GetListenerCount(), 0);
+
+    std::shared_ptr<FoldListener> foldListener = std::make_shared<FoldListenerTest>();
+    cameraManager_->RegisterFoldListener(foldListener);
+    EXPECT_GT(cameraManager_->GetFoldStatusListenerManager()->GetListenerCount(), 0);
+
+    cameraManager_->OnCameraServerAlive();
+    EXPECT_NE(cameraManager_->deathRecipient_, nullptr);
+}
 }
 }
\ No newline at end of file
diff --git a/frameworks/native/camera/test/unittest/framework_native/session/src/capture_session_unittest.cpp b/frameworks/native/camera/test/unittest/framework_native/session/src/capture_session_unittest.cpp
index 5005fce2..36d42baf 100644
--- a/frameworks/native/camera/test/unittest/framework_native/session/src/capture_session_unittest.cpp
+++ b/frameworks/native/camera/test/unittest/framework_native/session/src/capture_session_unittest.cpp
@@ -9210,6 +9210,142 @@ HWTEST_F(CaptureSessionUnitTest, camera_framework_unittest_166, TestSize.Level0)
     EXPECT_EQ(previewOutput->IsXComponentSwap(), false);
 }
 
+
+/*
+ * Feature: Framework
+ * Function: Test ConfigureMovieFileOutput and ConfigureUnifyMovieFileOutput
+ * SubFunction: NA
+ * FunctionPoints: NA
+ * EnvConditions: NA
+ * CaseDescription: Test ConfigureMovieFileOutput and ConfigureUnifyMovieFileOutput
+ */
+HWTEST_F(CaptureSessionUnitTest, camera_framework_unittest_167, TestSize.Level0)
+{
+    sptr<CaptureInput> input = cameraManager_->CreateCameraInput(cameras_[0]);
+    sptr<Surface> surface = Surface::CreateSurfaceAsConsumer();
+    ASSERT_NE(input, nullptr);
+    input->Open();
+    UpdateCameraOutputCapability();
+    sptr<CaptureSession> session = cameraManager_->CreateCaptureSession();
+    ASSERT_NE(session, nullptr);
+ 
+    uint32_t widthGreaterThantheRange = 1280;
+    uint32_t heightGreaterThantheRange = 720;
+    Size size = { widthGreaterThantheRange, heightGreaterThantheRange };
+    std::vector<int32_t> framerates = {60, 60};
+    VideoProfile profile(CAMERA_FORMAT_YUV_420_SP, size, framerates);
+
+    sptr<CaptureOutput> output = nullptr;
+    sptr<MovieFileOutput> movieFileOutput = nullptr;
+    cameraManager_->CreateMovieFileOutput(profile, &movieFileOutput);
+    ASSERT_NE(movieFileOutput, nullptr);
+
+    output = movieFileOutput;
+    EXPECT_EQ(session->ConfigureMovieFileOutput(output), 0);
+
+    sptr<UnifyMovieFileOutput> unifyMovieFileOutput = nullptr;
+    cameraManager_->CreateMovieFileOutput(profile, &unifyMovieFileOutput);
+    ASSERT_NE(unifyMovieFileOutput, nullptr);
+
+    output = movieFileOutput;
+    EXPECT_EQ(session->ConfigureUnifyMovieFileOutput(output), 0);
+
+}
+
+
+/*
+ * Feature: Framework
+ * Function: Test captureSession with CanAddOutput
+ * SubFunction: NA
+ * FunctionPoints: NA
+ * EnvConditions: NA
+ * CaseDescription: Test CanAddOutput for branches of movie file
+ */
+HWTEST_F(CaptureSessionUnitTest, camera_framework_unittest_168, TestSize.Level0)
+{
+    sptr<CaptureInput> input = cameraManager_->CreateCameraInput(cameras_[0]);
+    ASSERT_NE(input, nullptr);
+    input->Open();
+    UpdateCameraOutputCapability();
+    sptr<CaptureSession> session = cameraManager_->CreateCaptureSession();
+    ASSERT_NE(session, nullptr);
+
+    uint32_t widthGreaterThantheRange = 1280;
+    uint32_t heightGreaterThantheRange = 720;
+    Size size = { widthGreaterThantheRange, heightGreaterThantheRange };
+    std::vector<int32_t> framerates = {60, 60};
+    VideoProfile profile(CAMERA_FORMAT_YUV_420_SP, size, framerates);
+
+    sptr<MovieFileOutput> movieFileOutput = nullptr;
+    cameraManager_->CreateMovieFileOutput(profile, &movieFileOutput);
+    ASSERT_NE(movieFileOutput, nullptr);
+
+    sptr<CaptureOutput> output = movieFileOutput;
+
+    EXPECT_EQ(session->BeginConfig(), 0);
+    EXPECT_EQ(session->AddInput(input), 0);
+    EXPECT_EQ(session->AddOutput(output), 0);
+    EXPECT_EQ(session->CommitConfig(), 0);
+
+    EXPECT_NE(input->GetCameraDeviceInfo(), nullptr);
+    session->SetInputDevice(input);
+    EXPECT_NE(session->GetInputDevice()->GetCameraDeviceInfo(), nullptr);
+    movieFileOutput->outputType_ = CAPTURE_OUTPUT_TYPE_MOVIE_FILE;
+    EXPECT_FALSE(session->CanAddOutput(output));
+
+    input->Close();
+    output->Release();
+    input->Release();
+    session->Release();
+}
+
+
+/*
+ * Feature: Framework
+ * Function: Test captureSession with CanAddOutput
+ * SubFunction: NA
+ * FunctionPoints: NA
+ * EnvConditions: NA
+ * CaseDescription: Test CanAddOutput for branches of unified movie file
+ */
+HWTEST_F(CaptureSessionUnitTest, camera_framework_unittest_169, TestSize.Level0)
+{
+    sptr<CaptureInput> input = cameraManager_->CreateCameraInput(cameras_[0]);
+    ASSERT_NE(input, nullptr);
+    input->Open();
+    UpdateCameraOutputCapability();
+    sptr<CaptureSession> session = cameraManager_->CreateCaptureSession();
+    ASSERT_NE(session, nullptr);
+
+    uint32_t widthGreaterThantheRange = 1280;
+    uint32_t heightGreaterThantheRange = 720;
+    Size size = { widthGreaterThantheRange, heightGreaterThantheRange };
+    std::vector<int32_t> framerates = {60, 60};
+    VideoProfile profile(CAMERA_FORMAT_YUV_420_SP, size, framerates);
+
+    sptr<UnifyMovieFileOutput> unifyMovieFileOutput = nullptr; 
+    cameraManager_->CreateMovieFileOutput(profile, &unifyMovieFileOutput);
+    ASSERT_NE(unifyMovieFileOutput, nullptr);
+
+    sptr<CaptureOutput> output = unifyMovieFileOutput;
+
+    EXPECT_EQ(session->BeginConfig(), 0);
+    EXPECT_EQ(session->AddInput(input), 0);
+    EXPECT_EQ(session->AddOutput(output), 0);
+    EXPECT_EQ(session->CommitConfig(), 0);
+
+    EXPECT_NE(input->GetCameraDeviceInfo(), nullptr);
+    session->SetInputDevice(input);
+    EXPECT_NE(session->GetInputDevice()->GetCameraDeviceInfo(), nullptr);
+    unifyMovieFileOutput->outputType_ = CAPTURE_OUTPUT_TYPE_UNIFY_MOVIE_FILE;
+    EXPECT_FALSE(session->CanAddOutput(output));
+
+    input->Close();
+    output->Release();
+    input->Release();
+    session->Release();
+}
+
 /*
  * Feature: Framework
  * Function: Test PressureStatusCallback.
