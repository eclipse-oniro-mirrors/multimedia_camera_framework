     });
     if (errorCode == CAMERA_OK) {
         CAMERA_SYSEVENT_STATISTIC(CreateMsg("CaptureSession::AddOutput with %d", streamType));
@@ -532,9 +415,12 @@ int32_t HCaptureSession::RemoveOutputStream(sptr<HStreamCommon> stream)
         stream == nullptr, CAMERA_INVALID_ARG, "HCaptureSession::RemoveOutputStream stream is null");
     MEDIA_INFO_LOG("HCaptureSession::RemoveOutputStream,streamType:%{public}d, streamId:%{public}d",
         stream->GetStreamType(), stream->GetFwkStreamId());
-    bool isRemoveSuccess = streamContainer_.RemoveStream(stream);
-    CHECK_ERROR_RETURN_RET_LOG(
-        !isRemoveSuccess, CAMERA_INVALID_SESSION_CFG, "HCaptureSession::RemoveOutputStream Invalid output");
+    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    CHECK_ERROR_RETURN_RET_LOG(hStreamOperatorSptr == nullptr, CAMERA_INVALID_ARG,
+        "hStreamOperatorSptr is null");
+    int32_t errorCode = hStreamOperatorSptr->RemoveOutputStream(stream);
+    CHECK_ERROR_RETURN_RET_LOG(errorCode != CAMERA_OK, CAMERA_INVALID_SESSION_CFG,
+        "HCaptureSession::RemoveOutputStream Invalid output");
     return CAMERA_OK;
 }
 
@@ -554,19 +440,9 @@ int32_t HCaptureSession::RemoveOutput(StreamType streamType, sptr<IStreamCommon>
             errorCode = CAMERA_INVALID_STATE;
             return;
         }
-        if (streamType == StreamType::CAPTURE) {
-            errorCode = RemoveOutputStream(static_cast<HStreamCapture*>(stream.GetRefPtr()));
-            CameraDynamicLoader::FreeDynamiclib(MEDIA_LIB_SO);
-        } else if (streamType == StreamType::REPEAT) {
-            HStreamRepeat* repeatSteam = static_cast<HStreamRepeat*>(stream.GetRefPtr());
-            if (enableStreamRotate_ && repeatSteam != nullptr &&
-                repeatSteam->GetRepeatStreamType() == RepeatStreamType::PREVIEW) {
-                UnregisterDisplayListener(repeatSteam);
-            }
-            errorCode = RemoveOutputStream(repeatSteam);
-        } else if (streamType == StreamType::METADATA) {
-            errorCode = RemoveOutputStream(static_cast<HStreamMetadata*>(stream.GetRefPtr()));
-        }
+        auto hStreamOperatorSptr = hStreamOperator_.promote();
+        CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr, "hStreamOperatorSptr is null");
+        errorCode = hStreamOperatorSptr->RemoveOutput(streamType, stream);
     });
     if (errorCode == CAMERA_OK) {
         CAMERA_SYSEVENT_STATISTIC(CreateMsg("CaptureSession::RemoveOutput with %d", streamType));
@@ -587,45 +463,27 @@ int32_t HCaptureSession::ValidateSessionInputs()
 
 int32_t HCaptureSession::ValidateSessionOutputs()
 {
-    CHECK_ERROR_RETURN_RET_LOG(streamContainer_.Size() == 0, CAMERA_INVALID_SESSION_CFG,
-        "HCaptureSession::ValidateSessionOutputs No outputs present");
+    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    CHECK_ERROR_RETURN_RET_LOG((hStreamOperatorSptr == nullptr || hStreamOperatorSptr->GetStreamsSize() == 0),
+        CAMERA_INVALID_SESSION_CFG, "HCaptureSession::ValidateSessionOutputs No outputs present");
     return CAMERA_OK;
 }
 
 int32_t HCaptureSession::LinkInputAndOutputs()
 {
     int32_t rc;
-    std::vector<StreamInfo_V1_1> allStreamInfos;
-    sptr<OHOS::HDI::Camera::V1_0::IStreamOperator> streamOperator;
+    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    CHECK_ERROR_RETURN_RET_LOG(hStreamOperatorSptr == nullptr, CAMERA_INVALID_SESSION_CFG,
+        "HCaptureSession::ValidateSessionOutputs No outputs present");
     auto device = GetCameraDevice();
-    MEDIA_INFO_LOG("HCaptureSession::LinkInputAndOutputs prepare execute");
-    CHECK_ERROR_RETURN_RET_LOG(
-        device == nullptr, CAMERA_INVALID_SESSION_CFG, "HCaptureSession::LinkInputAndOutputs device is null");
+    CHECK_ERROR_RETURN_RET_LOG(device == nullptr, CAMERA_INVALID_SESSION_CFG,
+        "HCaptureSession::LinkInputAndOutputs device is null");
     auto settings = device->GetDeviceAbility();
-    CHECK_ERROR_RETURN_RET_LOG(
-        settings == nullptr, CAMERA_UNKNOWN_ERROR, "HCaptureSession::LinkInputAndOutputs deviceAbility is null");
-    streamOperator = device->GetStreamOperator();
-    auto allStream = streamContainer_.GetAllStreams();
-    MEDIA_INFO_LOG("HCaptureSession::LinkInputAndOutputs allStream size:%{public}zu", allStream.size());
+    CHECK_ERROR_RETURN_RET_LOG(settings == nullptr, CAMERA_UNKNOWN_ERROR,
+        "HCaptureSession::LinkInputAndOutputs deviceAbility is null");
     CHECK_ERROR_RETURN_RET_LOG(!IsValidMode(opMode_, settings), CAMERA_INVALID_SESSION_CFG,
         "HCaptureSession::LinkInputAndOutputs IsValidMode false");
-    for (auto& stream : allStream) {
-        rc = stream->LinkInput(streamOperator, settings);
-        if (rc == CAMERA_OK) {
-            CHECK_EXECUTE(stream->GetHdiStreamId() == STREAM_ID_UNSET,
-                stream->SetHdiStreamId(device->GenerateHdiStreamId()));
-        }
-        MEDIA_INFO_LOG(
-            "HCaptureSession::LinkInputAndOutputs streamType:%{public}d, streamId:%{public}d ,hdiStreamId:%{public}d",
-            stream->GetStreamType(), stream->GetFwkStreamId(), stream->GetHdiStreamId());
-        CHECK_ERROR_RETURN_RET_LOG(rc != CAMERA_OK, rc, "HCaptureSession::LinkInputAndOutputs IsValidMode false");
-        StreamInfo_V1_1 curStreamInfo;
-        stream->SetStreamInfo(curStreamInfo);
-        CHECK_EXECUTE(stream->GetStreamType() != StreamType::METADATA,
-            allStreamInfos.push_back(curStreamInfo));
-    }
-
-    rc = device->CreateAndCommitStreams(allStreamInfos, settings, GetopMode());
+    rc = hStreamOperatorSptr->LinkInputAndOutputs(settings, GetopMode());
     MEDIA_INFO_LOG("HCaptureSession::LinkInputAndOutputs execute success");
     return rc;
 }
@@ -634,73 +492,24 @@ int32_t HCaptureSession::UnlinkInputAndOutputs()
 {
     CAMERA_SYNC_TRACE;
     int32_t rc = CAMERA_UNKNOWN_ERROR;
-    std::vector<int32_t> fwkStreamIds;
-    std::vector<int32_t> hdiStreamIds;
-    auto allStream = streamContainer_.GetAllStreams();
-    for (auto& stream : allStream) {
-        fwkStreamIds.emplace_back(stream->GetFwkStreamId());
-        hdiStreamIds.emplace_back(stream->GetHdiStreamId());
-        stream->UnlinkInput();
-    }
-    MEDIA_INFO_LOG("HCaptureSession::UnlinkInputAndOutputs() streamIds size() = %{public}zu, streamIds:%{public}s, "
-                   "hdiStreamIds:%{public}s",
-        fwkStreamIds.size(), Container2String(fwkStreamIds.begin(), fwkStreamIds.end()).c_str(),
-        Container2String(hdiStreamIds.begin(), hdiStreamIds.end()).c_str());
-
-    // HDI release streams, do not clear streamContainer_
-    auto cameraDevice = GetCameraDevice();
-    if ((cameraDevice != nullptr)) {
-        cameraDevice->ReleaseStreams(hdiStreamIds);
-        std::vector<StreamInfo_V1_1> emptyStreams;
-        cameraDevice->UpdateStreams(emptyStreams);
-        cameraDevice->ResetHdiStreamId();
-    }
+    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    CHECK_ERROR_RETURN_RET_LOG(hStreamOperatorSptr == nullptr,  rc,
+        "HCaptureSession::ValidateSessionOutputs No outputs present");
+    rc = hStreamOperatorSptr->UnlinkInputAndOutputs();
+        // HDI release streams, do not clear streamContainer_
     return rc;
 }
 
 void HCaptureSession::ExpandSketchRepeatStream()
 {
     MEDIA_DEBUG_LOG("Enter HCaptureSession::ExpandSketchRepeatStream()");
-    std::set<sptr<HStreamCommon>> sketchStreams;
-    auto repeatStreams = streamContainer_.GetStreams(StreamType::REPEAT);
-    for (auto& stream : repeatStreams) {
-        if (stream == nullptr) {
-            continue;
-        }
-        auto streamRepeat = CastStream<HStreamRepeat>(stream);
-        if (streamRepeat->GetRepeatStreamType() == RepeatStreamType::SKETCH) {
-            continue;
-        }
-        sptr<HStreamRepeat> sketchStream = streamRepeat->GetSketchStream();
-        if (sketchStream == nullptr) {
-            continue;
-        }
-        sketchStreams.insert(sketchStream);
-    }
-    MEDIA_DEBUG_LOG("HCaptureSession::ExpandSketchRepeatStream() sketch size is:%{public}zu", sketchStreams.size());
-    for (auto& stream : sketchStreams) {
-        AddOutputStream(stream);
-    }
+    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr,
+        "HCaptureSession::ValidateSessionOutputs No outputs present");
+    hStreamOperatorSptr->ExpandSketchRepeatStream();
     MEDIA_DEBUG_LOG("Exit HCaptureSession::ExpandSketchRepeatStream()");
 }
 
-VideoCodecType GetVideoCodecType(StreamContainer& streamContainer)
-{
-    auto captureStreams = streamContainer.GetStreams(StreamType::CAPTURE);
-    MEDIA_INFO_LOG("GetVideoCodecType capture stream size = %{public}zu", captureStreams.size());
-    VideoCodecType videoCodecType = VIDEO_ENCODE_TYPE_AVC;
-    for (auto& stream : captureStreams) {
-        auto streamCapture = CastStream<HStreamCapture>(stream);
-        if (streamCapture == nullptr) {
-            continue;
-        }
-        videoCodecType = static_cast<VideoCodecType>(streamCapture->GetMovingPhotoVideoCodecType());
-        break;
-    }
-    MEDIA_INFO_LOG("ExpandMovingPhotoRepeatStream GetVideoCodecType videoCodecType = %{public}d", videoCodecType);
-    return videoCodecType;
-}
-
 void HCaptureSession::ExpandMovingPhotoRepeatStream()
 {
     CAMERA_SYNC_TRACE;
@@ -709,103 +518,20 @@ void HCaptureSession::ExpandMovingPhotoRepeatStream()
         MEDIA_DEBUG_LOG("movingPhoto is not supported");
         return;
     }
-    auto repeatStreams = streamContainer_.GetStreams(StreamType::REPEAT);
-    for (auto& stream : repeatStreams) {
-        if (stream == nullptr) {
-            continue;
-        }
-        auto streamRepeat = CastStream<HStreamRepeat>(stream);
-        if (streamRepeat && streamRepeat->GetRepeatStreamType() == RepeatStreamType::PREVIEW) {
-            std::lock_guard<std::mutex> lock(movingPhotoStatusLock_);
-            auto movingPhotoSurfaceWrapper =
-                MovingPhotoSurfaceWrapper::CreateMovingPhotoSurfaceWrapper(streamRepeat->width_, streamRepeat->height_);
-            if (movingPhotoSurfaceWrapper == nullptr) {
-                MEDIA_ERR_LOG("HCaptureSession::ExpandMovingPhotoRepeatStream CreateMovingPhotoSurfaceWrapper fail.");
-                continue;
-            }
-            auto producer = movingPhotoSurfaceWrapper->GetProducer();
-            metaSurface_ = Surface::CreateSurfaceAsConsumer("movingPhotoMeta");
-            auto metaCache = make_shared<FixedSizeList<pair<int64_t, sptr<SurfaceBuffer>>>>(3);
-            CHECK_WARNING_CONTINUE_LOG(producer == nullptr, "get producer fail.");
-            livephotoListener_ = new (std::nothrow) MovingPhotoListener(
-                movingPhotoSurfaceWrapper, metaSurface_, metaCache, preCacheFrameCount_, postCacheFrameCount_);
-            CHECK_WARNING_CONTINUE_LOG(livephotoListener_ == nullptr, "failed to new livephotoListener_!");
-            movingPhotoSurfaceWrapper->SetSurfaceBufferListener(livephotoListener_);
-            livephotoMetaListener_ = new (std::nothrow) MovingPhotoMetaListener(metaSurface_, metaCache);
-            CHECK_WARNING_CONTINUE_LOG(livephotoMetaListener_ == nullptr, "failed to new livephotoMetaListener_!");
-            metaSurface_->RegisterConsumerListener((sptr<IBufferConsumerListener>&)livephotoMetaListener_);
-            CreateMovingPhotoStreamRepeat(streamRepeat->format_, streamRepeat->width_, streamRepeat->height_, producer);
-            std::lock_guard<std::mutex> streamLock(livePhotoStreamLock_);
-            AddOutputStream(livePhotoStreamRepeat_);
-            if (!audioCapturerSession_) {
-                audioCapturerSession_ = new AudioCapturerSession();
-            }
-            if (!taskManager_ && audioCapturerSession_) {
-                taskManager_ = new AvcodecTaskManager(audioCapturerSession_, VideoCodecType::VIDEO_ENCODE_TYPE_HEVC);
-                taskManager_->SetVideoBufferDuration(preCacheFrameCount_, postCacheFrameCount_);
-            }
-            if (!videoCache_ && taskManager_) {
-                videoCache_ = new MovingPhotoVideoCache(taskManager_);
-            }
-            break;
-        }
-    }
+    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr,
+        "HCaptureSession::ValidateSessionOutputs No outputs present");
+    hStreamOperatorSptr->ExpandMovingPhotoRepeatStream();
     MEDIA_DEBUG_LOG("ExpandMovingPhotoRepeatStream Exit");
 }
 
-int32_t HCaptureSession::CreateMovingPhotoStreamRepeat(
-    int32_t format, int32_t width, int32_t height, sptr<OHOS::IBufferProducer> producer)
-{
-    CAMERA_SYNC_TRACE;
-    std::lock_guard<std::mutex> lock(livePhotoStreamLock_);
-    CHECK_ERROR_RETURN_RET_LOG(
-        width <= 0 || height <= 0, CAMERA_INVALID_ARG, "HCameraService::CreateLivePhotoStreamRepeat args is illegal");
-    CHECK_EXECUTE(livePhotoStreamRepeat_ != nullptr, livePhotoStreamRepeat_->Release());
-    auto streamRepeat = new (std::nothrow) HStreamRepeat(producer, format, width, height, RepeatStreamType::LIVEPHOTO);
-    CHECK_ERROR_RETURN_RET_LOG(streamRepeat == nullptr, CAMERA_ALLOC_ERROR, "HStreamRepeat allocation failed");
-    MEDIA_DEBUG_LOG("para is:%{public}dx%{public}d,%{public}d", width, height, format);
-    livePhotoStreamRepeat_ = streamRepeat;
-    streamRepeat->SetMetaProducer(metaSurface_->GetProducer());
-    streamRepeat->SetMirror(isMovingPhotoMirror_);
-    MEDIA_INFO_LOG("HCameraService::CreateLivePhotoStreamRepeat end");
-    return CAMERA_OK;
-}
-
-const sptr<HStreamCommon> HCaptureSession::GetStreamByStreamID(int32_t streamId)
-{
-    auto stream = streamContainer_.GetStream(streamId);
-    CHECK_ERROR_PRINT_LOG(
-        stream == nullptr, "HCaptureSession::GetStreamByStreamID get stream fail, streamId is:%{public}d", streamId);
-    return stream;
-}
-
-const sptr<HStreamCommon> HCaptureSession::GetHdiStreamByStreamID(int32_t streamId)
-{
-    auto stream = streamContainer_.GetHdiStream(streamId);
-    CHECK_ERROR_PRINT_LOG(
-        stream == nullptr, "HCaptureSession::GetHdiStreamByStreamID get stream fail, streamId is:%{public}d", streamId);
-    return stream;
-}
-
 void HCaptureSession::ClearSketchRepeatStream()
 {
     MEDIA_DEBUG_LOG("Enter HCaptureSession::ClearSketchRepeatStream()");
 
-    // Already added session lock in BeginConfig()
-    auto repeatStreams = streamContainer_.GetStreams(StreamType::REPEAT);
-    for (auto& repeatStream : repeatStreams) {
-        if (repeatStream == nullptr) {
-            continue;
-        }
-        auto sketchStream = CastStream<HStreamRepeat>(repeatStream);
-        if (sketchStream->GetRepeatStreamType() != RepeatStreamType::SKETCH) {
-            continue;
-        }
-        MEDIA_DEBUG_LOG(
-            "HCaptureSession::ClearSketchRepeatStream() stream id is:%{public}d", sketchStream->GetFwkStreamId());
-        RemoveOutputStream(repeatStream);
-    }
-    MEDIA_DEBUG_LOG("Exit HCaptureSession::ClearSketchRepeatStream()");
+    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr, "hStreamOperator is nullptr");
+    return hStreamOperatorSptr->ClearSketchRepeatStream();
 }
 
 void HCaptureSession::ClearMovingPhotoRepeatStream()
@@ -813,37 +539,9 @@ void HCaptureSession::ClearMovingPhotoRepeatStream()
     CAMERA_SYNC_TRACE;
     MEDIA_DEBUG_LOG("Enter HCaptureSession::ClearMovingPhotoRepeatStream()");
     // Already added session lock in BeginConfig()
-    auto repeatStreams = streamContainer_.GetStreams(StreamType::REPEAT);
-    for (auto& repeatStream : repeatStreams) {
-        if (repeatStream == nullptr) {
-            continue;
-        }
-        auto movingPhotoStream = CastStream<HStreamRepeat>(repeatStream);
-        if (movingPhotoStream->GetRepeatStreamType() != RepeatStreamType::LIVEPHOTO) {
-            continue;
-        }
-        StopMovingPhoto();
-        std::lock_guard<std::mutex> lock(movingPhotoStatusLock_);
-        livephotoListener_ = nullptr;
-        videoCache_ = nullptr;
-        MEDIA_DEBUG_LOG("HCaptureSession::ClearLivePhotoRepeatStream() stream id is:%{public}d",
-            movingPhotoStream->GetFwkStreamId());
-        RemoveOutputStream(repeatStream);
-    }
-    MEDIA_DEBUG_LOG("Exit HCaptureSession::ClearLivePhotoRepeatStream()");
-}
-
-void HCaptureSession::StopMovingPhoto() __attribute__((no_sanitize("cfi")))
-{
-    CAMERA_SYNC_TRACE;
-    MEDIA_DEBUG_LOG("Enter HCaptureSession::StopMovingPhoto");
-    std::lock_guard<std::mutex> lock(movingPhotoStatusLock_);
-    CHECK_EXECUTE(livephotoListener_, livephotoListener_->StopDrainOut());
-    CHECK_EXECUTE(videoCache_, videoCache_->ClearCache());
-#ifdef MOVING_PHOTO_ADD_AUDIO
-    CHECK_EXECUTE(audioCapturerSession_, audioCapturerSession_->Stop());
-#endif
-    CHECK_EXECUTE(taskManager_, taskManager_->Stop());
+    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr, "hStreamOperator is nullptr");
+    return hStreamOperatorSptr->ClearMovingPhotoRepeatStream();
 }
 
 int32_t HCaptureSession::ValidateSession()
@@ -855,6 +553,12 @@ int32_t HCaptureSession::ValidateSession()
     return errorCode;
 }
 
+int32_t HCaptureSession::SetCommitConfigFlag(bool isNeedCommitting)
+{
+    isNeedCommitting_ = isNeedCommitting;
+    return CAMERA_OK;
+}
+
 int32_t HCaptureSession::CommitConfig()
 {
     CAMERA_SYNC_TRACE;
@@ -867,6 +571,13 @@ int32_t HCaptureSession::CommitConfig()
             errorCode = CAMERA_INVALID_STATE;
             return;
         }
+        if (isNeedCommitting_) {
+            stateMachine_.Transfer(CaptureSessionState::SESSION_CONFIG_COMMITTED);
+            return;
+        }
+        auto hStreamOperatorSptr = hStreamOperator_.promote();
+        CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr, "hStreamOperator is nullptr");
+        hStreamOperatorSptr->GetStreamOperator();
         errorCode = ValidateSession();
         CHECK_ERROR_RETURN(errorCode != CAMERA_OK);
         if (!IsNeedDynamicConfig()) {
@@ -904,15 +615,15 @@ int32_t HCaptureSession::CommitConfig()
 
 int32_t HCaptureSession::GetActiveColorSpace(ColorSpace& colorSpace)
 {
-    colorSpace = currColorSpace_;
+    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    CHECK_ERROR_RETURN_RET_LOG(hStreamOperatorSptr == nullptr, CAMERA_OK, "hStreamOperator is nullptr");
+    hStreamOperatorSptr->GetActiveColorSpace(colorSpace);
     return CAMERA_OK;
 }
 
 int32_t HCaptureSession::SetColorSpace(ColorSpace colorSpace, ColorSpace captureColorSpace, bool isNeedUpdate)
 {
     int32_t result = CAMERA_OK;
-    CHECK_ERROR_RETURN_RET_LOG(colorSpace == currColorSpace_ && captureColorSpace == currCaptureColorSpace_, result,
-        "HCaptureSession::SetColorSpace() colorSpace no need to update.");
     stateMachine_.StateGuard(
         [&result, this, &colorSpace, &captureColorSpace, &isNeedUpdate](CaptureSessionState currentState) {
             if (!(currentState == CaptureSessionState::SESSION_CONFIG_INPROGRESS ||
@@ -922,133 +633,23 @@ int32_t HCaptureSession::SetColorSpace(ColorSpace colorSpace, ColorSpace capture
                 return;
             }
 
-            currColorSpace_ = colorSpace;
-            currCaptureColorSpace_ = captureColorSpace;
-            result = CheckIfColorSpaceMatchesFormat(colorSpace);
-            if (result != CAMERA_OK) {
-                if (isNeedUpdate) {
-                    MEDIA_ERR_LOG("HCaptureSession::SetColorSpace() Failed, format and colorSpace not match.");
-                    return;
-                } else {
-                    MEDIA_ERR_LOG(
-                        "HCaptureSession::SetColorSpace() %{public}d, format and colorSpace: %{public}d not match.",
-                        result, colorSpace);
-                    currColorSpace_ = ColorSpace::BT709;
-                }
+            auto hStreamOperatorSptr = hStreamOperator_.promote();
+            CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr, "hStreamOperator is nullptr");
+            result = hStreamOperatorSptr->SetColorSpace(colorSpace, captureColorSpace, isNeedUpdate);
+            if (isNeedUpdate &&  result != CAMERA_OK) {
+                return;
             }
-            MEDIA_INFO_LOG("HCaptureSession::SetColorSpace() colorSpace: %{public}d, captureColorSpace: %{public}d, "
-                           "isNeedUpdate: %{public}d",
-                currColorSpace_, captureColorSpace, isNeedUpdate);
-            SetColorSpaceForStreams();
-
             if (isNeedUpdate) {
-                result = UpdateStreamInfos();
+                auto device = GetCameraDevice();
+                std::shared_ptr<OHOS::Camera::CameraMetadata> settings = device->CloneCachedSettings();
+                MEDIA_INFO_LOG("HCaptureSession::SetColorSpace() CloneCachedSettings");
+                DumpMetadata(settings);
+                result = hStreamOperatorSptr->UpdateStreamInfos(settings);
             }
         });
     return result;
 }
 
-void HCaptureSession::SetColorSpaceForStreams()
-{
-    auto streams = streamContainer_.GetAllStreams();
-    for (auto& stream : streams) {
-        MEDIA_DEBUG_LOG("HCaptureSession::SetColorSpaceForStreams() streams type %{public}d", stream->GetStreamType());
-        if (stream->GetStreamType() == StreamType::CAPTURE) {
-            stream->SetColorSpace(currCaptureColorSpace_);
-        } else {
-            stream->SetColorSpace(currColorSpace_);
-        }
-    }
-}
-
-void HCaptureSession::CancelStreamsAndGetStreamInfos(std::vector<StreamInfo_V1_1>& streamInfos)
-{
-    MEDIA_INFO_LOG("HCaptureSession::CancelStreamsAndGetStreamInfos enter.");
-    StreamInfo_V1_1 curStreamInfo;
-    auto streams = streamContainer_.GetAllStreams();
-    for (auto& stream : streams) {
-        if (stream && stream->GetStreamType() == StreamType::METADATA) {
-            continue;
-        }
-        if (stream && stream->GetStreamType() == StreamType::CAPTURE && isSessionStarted_) {
-            static_cast<HStreamCapture*>(stream.GetRefPtr())->CancelCapture();
-        } else if (stream && stream->GetStreamType() == StreamType::REPEAT && isSessionStarted_) {
-            static_cast<HStreamRepeat*>(stream.GetRefPtr())->Stop();
-        }
-        if (stream) {
-            stream->SetStreamInfo(curStreamInfo);
-            streamInfos.push_back(curStreamInfo);
-        }
-    }
-}
-
-void HCaptureSession::RestartStreams()
-{
-    MEDIA_INFO_LOG("HCaptureSession::RestartStreams() enter.");
-    if (!isSessionStarted_) {
-        MEDIA_DEBUG_LOG("HCaptureSession::RestartStreams() session is not started yet.");
-        return;
-    }
-    auto cameraDevice = GetCameraDevice();
-    CHECK_ERROR_RETURN(cameraDevice == nullptr);
-    auto streams = streamContainer_.GetAllStreams();
-    for (auto& stream : streams) {
-        if (stream && stream->GetStreamType() == StreamType::REPEAT &&
-            CastStream<HStreamRepeat>(stream)->GetRepeatStreamType() == RepeatStreamType::PREVIEW) {
-            std::shared_ptr<OHOS::Camera::CameraMetadata> settings = cameraDevice->CloneCachedSettings();
-            MEDIA_INFO_LOG("HCaptureSession::RestartStreams() CloneCachedSettings");
-            DumpMetadata(settings);
-            CastStream<HStreamRepeat>(stream)->Start(settings);
-        }
-    }
-}
-
-int32_t HCaptureSession::UpdateStreamInfos()
-{
-    std::vector<StreamInfo_V1_1> streamInfos;
-    CancelStreamsAndGetStreamInfos(streamInfos);
-
-    auto cameraDevice = GetCameraDevice();
-    CHECK_ERROR_RETURN_RET_LOG(
-        cameraDevice == nullptr, CAMERA_UNKNOWN_ERROR, "HCaptureSession::UpdateStreamInfos() cameraDevice is null");
-    int errorCode = cameraDevice->UpdateStreams(streamInfos);
-    if (errorCode == CAMERA_OK) {
-        RestartStreams();
-    } else {
-        MEDIA_DEBUG_LOG("HCaptureSession::UpdateStreamInfos err %{public}d", errorCode);
-    }
-    return errorCode;
-}
-
-int32_t HCaptureSession::CheckIfColorSpaceMatchesFormat(ColorSpace colorSpace)
-{
-    if (!(colorSpace == ColorSpace::BT2020_HLG || colorSpace == ColorSpace::BT2020_PQ ||
-            colorSpace == ColorSpace::BT2020_HLG_LIMIT || colorSpace == ColorSpace::BT2020_PQ_LIMIT)) {
-        return CAMERA_OK;
-    }
-
-    // 选择BT2020，需要匹配10bit的format；若不匹配，返回error
-    auto streams = streamContainer_.GetAllStreams();
-    for (auto& curStream : streams) {
-        if (!curStream) {
-            continue;
-        }
-        // 当前拍照流不支持BT2020，无需校验format
-        if (curStream->GetStreamType() != StreamType::REPEAT) {
-            continue;
-        }
-        StreamInfo_V1_1 curStreamInfo;
-        curStream->SetStreamInfo(curStreamInfo);
-        MEDIA_INFO_LOG("HCaptureSession::CheckFormat, stream repeatType: %{public}d, format: %{public}d",
-            static_cast<HStreamRepeat*>(curStream.GetRefPtr())->GetRepeatStreamType(), curStreamInfo.v1_0.format_);
-        CHECK_ERROR_RETURN_RET_LOG(
-            !(curStreamInfo.v1_0.format_ == OHOS::HDI::Display::Composer::V1_1::PIXEL_FMT_YCBCR_P010 ||
-                curStreamInfo.v1_0.format_ == OHOS::HDI::Display::Composer::V1_1::PIXEL_FMT_YCRCB_P010),
-            CAMERA_OPERATION_NOT_ALLOWED, "HCaptureSession::CheckFormat, stream format not match");
-    }
-    return CAMERA_OK;
-}
-
 int32_t HCaptureSession::GetSessionState(CaptureSessionState& sessionState)
 {
     sessionState = stateMachine_.GetCurrentState();
@@ -1152,35 +753,6 @@ int32_t HCaptureSession::GetSensorOritation()
     return sensorOrientation;
 }
 
-int32_t HCaptureSession::GetMovingPhotoBufferDuration()
-{
-    auto cameraDevice = GetCameraDevice();
-    uint32_t preBufferDuration = 0;
-    uint32_t postBufferDuration = 0;
-    constexpr int32_t MILLSEC_MULTIPLE = 1000;
-    CHECK_ERROR_RETURN_RET_LOG(
-        cameraDevice == nullptr, 0, "HCaptureSession::GetMovingPhotoBufferDuration() cameraDevice is null");
-    std::shared_ptr<OHOS::Camera::CameraMetadata> ability = cameraDevice->GetDeviceAbility();
-    CHECK_ERROR_RETURN_RET(ability == nullptr, 0);
-    camera_metadata_item_t item;
-    int ret = OHOS::Camera::FindCameraMetadataItem(ability->get(), OHOS_MOVING_PHOTO_BUFFER_DURATION, &item);
-    CHECK_ERROR_RETURN_RET_LOG(
-        ret != CAM_META_SUCCESS, 0, "HCaptureSession::GetMovingPhotoBufferDuration get buffer duration failed");
-    preBufferDuration = item.data.ui32[0];
-    postBufferDuration = item.data.ui32[1];
-    preCacheFrameCount_ = preBufferDuration == 0
-                              ? preCacheFrameCount_
-                              : static_cast<uint32_t>(float(preBufferDuration) / MILLSEC_MULTIPLE * VIDEO_FRAME_RATE);
-    postCacheFrameCount_ = preBufferDuration == 0
-                               ? postCacheFrameCount_
-                               : static_cast<uint32_t>(float(postBufferDuration) / MILLSEC_MULTIPLE * VIDEO_FRAME_RATE);
-    MEDIA_INFO_LOG(
-        "HCaptureSession::GetMovingPhotoBufferDuration preBufferDuration : %{public}u, "
-        "postBufferDuration : %{public}u, preCacheFrameCount_ : %{public}u, postCacheFrameCount_ : %{public}u",
-        preBufferDuration, postBufferDuration, preCacheFrameCount_, postCacheFrameCount_);
-    return CAMERA_OK;
-}
-
 int32_t HCaptureSession::GetRangeId(float& zoomRatio, std::vector<float>& crossZoom)
 {
     int32_t rangId = 0;
@@ -1350,19 +922,14 @@ void HCaptureSession::ProcessMetaZoomArray(std::vector<uint32_t>& zoomAndTimeArr
 
 int32_t HCaptureSession::EnableMovingPhoto(bool isEnable)
 {
-    isSetMotionPhoto_ = isEnable;
-    StartMovingPhotoStream();
-#ifdef CAMERA_USE_SENSOR
-    if (isSetMotionPhoto_) {
-        RegisterSensorCallback();
-    } else {
-        UnregisterSensorCallback();
+    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    CHECK_ERROR_RETURN_RET_LOG(hStreamOperatorSptr == nullptr, CAMERA_OK, "hStreamOperatorSptr is null");
+    std::shared_ptr<OHOS::Camera::CameraMetadata> settings = nullptr;
+    auto cameraDevice = GetCameraDevice();
+    if (cameraDevice != nullptr) {
+        settings = cameraDevice->CloneCachedSettings();
     }
-#endif
-    auto device = GetCameraDevice();
-    CHECK_EXECUTE(device != nullptr, device->EnableMovingPhoto(isEnable));
-    GetMovingPhotoBufferDuration();
-    GetMovingPhotoStartAndEndTime();
+    hStreamOperatorSptr->EnableMovingPhoto(settings, isEnable, GetSensorOritation());
     return CAMERA_OK;
 }
 
@@ -1391,7 +958,9 @@ int32_t HCaptureSession::Start()
             UpdateMuteSetting(cameraDevice->GetDeviceMuteMode(), settings);
         }
         camera_position_enum_t cameraPosition = static_cast<camera_position_enum_t>(usedAsPositionU8);
-        errorCode = StartPreviewStream(settings, cameraPosition);
+        auto hStreamOperatorSptr = hStreamOperator_.promote();
+        CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr, "hStreamOperatorSptr is null");
+        errorCode = hStreamOperatorSptr->StartPreviewStream(settings, cameraPosition);
         if (errorCode == CAMERA_OK) {
             isSessionStarted_ = true;
         }
@@ -1408,97 +977,6 @@ void HCaptureSession::UpdateMuteSetting(bool muteMode, std::shared_ptr<OHOS::Cam
     settings->addEntry(OHOS_CONTROL_MUTE_MODE, &mode, count);
 }
 
-void HCaptureSession::StartMovingPhoto(sptr<HStreamRepeat>& curStreamRepeat)
-{
-    auto thisPtr = wptr<HCaptureSession>(this);
-    curStreamRepeat->SetMovingPhotoStartCallback([thisPtr]() {
-        auto sessionPtr = thisPtr.promote();
-        if (sessionPtr != nullptr) {
-            MEDIA_INFO_LOG("StartMovingPhotoStream when addDeferedSurface");
-            sessionPtr->StartMovingPhotoStream();
-        }
-    });
-}
-
-void HCaptureSession::GetMovingPhotoStartAndEndTime()
-{
-    auto thisPtr = wptr<HCaptureSession>(this);
-    auto cameraDevice = GetCameraDevice();
-    CHECK_ERROR_RETURN_LOG(cameraDevice == nullptr, "HCaptureSession::GetMovingPhotoStartAndEndTime device is null");
-    cameraDevice->SetMovingPhotoStartTimeCallback([thisPtr](int32_t captureId, int64_t startTimeStamp) {
-        MEDIA_INFO_LOG("SetMovingPhotoStartTimeCallback function enter");
-        auto sessionPtr = thisPtr.promote();
-        CHECK_ERROR_RETURN_LOG(sessionPtr == nullptr, "Set start time callback sessionPtr is null");
-        CHECK_ERROR_RETURN_LOG(sessionPtr->taskManager_ == nullptr, "Set start time callback taskManager_ is null");
-        std::lock_guard<mutex> lock(sessionPtr->taskManager_->startTimeMutex_);
-        if (sessionPtr->taskManager_->mPStartTimeMap_.count(captureId) == 0) {
-            MEDIA_INFO_LOG("Save moving photo start info, captureId : %{public}d, start timestamp : %{public}" PRIu64,
-                captureId, startTimeStamp);
-            sessionPtr->taskManager_->mPStartTimeMap_.insert(make_pair(captureId, startTimeStamp));
-        }
-    });
-
-    cameraDevice->SetMovingPhotoEndTimeCallback([thisPtr](int32_t captureId, int64_t endTimeStamp) {
-        auto sessionPtr = thisPtr.promote();
-        CHECK_ERROR_RETURN_LOG(sessionPtr == nullptr, "Set end time callback sessionPtr is null");
-        CHECK_ERROR_RETURN_LOG(sessionPtr->taskManager_ == nullptr, "Set end time callback taskManager_ is null");
-        std::lock_guard<mutex> lock(sessionPtr->taskManager_->endTimeMutex_);
-        if (sessionPtr->taskManager_->mPEndTimeMap_.count(captureId) == 0) {
-            MEDIA_INFO_LOG("Save moving photo end info, captureId : %{public}d, end timestamp : %{public}" PRIu64,
-                captureId, endTimeStamp);
-            sessionPtr->taskManager_->mPEndTimeMap_.insert(make_pair(captureId, endTimeStamp));
-        }
-    });
-}
-
-int32_t HCaptureSession::StartPreviewStream(
-    const std::shared_ptr<OHOS::Camera::CameraMetadata>& settings, camera_position_enum_t cameraPosition)
-{
-    int32_t errorCode = CAMERA_OK;
-    auto repeatStreams = streamContainer_.GetStreams(StreamType::REPEAT);
-    bool hasDerferedPreview = false;
-    // start preview
-    for (auto& item : repeatStreams) {
-        auto curStreamRepeat = CastStream<HStreamRepeat>(item);
-        auto repeatType = curStreamRepeat->GetRepeatStreamType();
-        if (repeatType != RepeatStreamType::PREVIEW) {
-            continue;
-        }
-        if (curStreamRepeat->GetPreparedCaptureId() != CAPTURE_ID_UNSET) {
-            continue;
-        }
-        curStreamRepeat->SetUsedAsPosition(cameraPosition);
-        errorCode = curStreamRepeat->Start(settings);
-        hasDerferedPreview = curStreamRepeat->producer_ == nullptr;
-        CHECK_EXECUTE(isSetMotionPhoto_ && hasDerferedPreview, StartMovingPhoto(curStreamRepeat));
-        if (errorCode != CAMERA_OK) {
-            MEDIA_ERR_LOG("HCaptureSession::Start(), Failed to start preview, rc: %{public}d", errorCode);
-            break;
-        }
-    }
-    // start movingPhoto
-    for (auto& item : repeatStreams) {
-        auto curStreamRepeat = CastStream<HStreamRepeat>(item);
-        auto repeatType = curStreamRepeat->GetRepeatStreamType();
-        if (repeatType != RepeatStreamType::LIVEPHOTO) {
-            continue;
-        }
-        int32_t movingPhotoErrorCode = CAMERA_OK;
-        if (isSetMotionPhoto_ && !hasDerferedPreview) {
-            movingPhotoErrorCode = curStreamRepeat->Start(settings);
-#ifdef MOVING_PHOTO_ADD_AUDIO
-            std::lock_guard<std::mutex> lock(movingPhotoStatusLock_);
-            audioCapturerSession_ != nullptr && audioCapturerSession_->StartAudioCapture();
-#endif
-        }
-        if (movingPhotoErrorCode != CAMERA_OK) {
-            MEDIA_ERR_LOG("Failed to start movingPhoto, rc: %{public}d", movingPhotoErrorCode);
-            break;
-        }
-    }
-    return errorCode;
-}
-
 int32_t HCaptureSession::Stop()
 {
     CAMERA_SYNC_TRACE;
@@ -1511,32 +989,13 @@ int32_t HCaptureSession::Stop()
             errorCode = CAMERA_INVALID_STATE;
             return;
         }
-        auto allStreams = streamContainer_.GetAllStreams();
-        for (auto& item : allStreams) {
-            if (item->GetStreamType() == StreamType::REPEAT) {
-                auto repeatStream = CastStream<HStreamRepeat>(item);
-                if (repeatStream->GetRepeatStreamType() == RepeatStreamType::PREVIEW) {
-                    errorCode = repeatStream->Stop();
-                } else if (repeatStream->GetRepeatStreamType() == RepeatStreamType::LIVEPHOTO) {
-                    repeatStream->Stop();
-                    StopMovingPhoto();
-                } else {
-                    repeatStream->Stop();
-                }
-            } else if (item->GetStreamType() == StreamType::METADATA) {
-                CastStream<HStreamMetadata>(item)->Stop();
-            } else if (item->GetStreamType() == StreamType::CAPTURE) {
-                CastStream<HStreamCapture>(item)->CancelCapture();
-            } else if (item->GetStreamType() == StreamType::DEPTH) {
-                CastStream<HStreamDepthData>(item)->Stop();
-            } else {
-                MEDIA_ERR_LOG("HCaptureSession::Stop(), get unknow stream, streamType: %{public}d, streamId:%{public}d",
-                    item->GetStreamType(), item->GetFwkStreamId());
-            }
-            CHECK_ERROR_PRINT_LOG(errorCode != CAMERA_OK,
-                "HCaptureSession::Stop(), Failed to stop stream, rc: %{public}d, streamId:%{public}d",
-                errorCode, item->GetFwkStreamId());
+               auto hStreamOperatorSptr = hStreamOperator_.promote();
+        if (hStreamOperatorSptr == nullptr) {
+            MEDIA_ERR_LOG("hStreamOperatorSptr is null");
+            errorCode = CAMERA_INVALID_STATE;
+            return;
         }
+        errorCode = hStreamOperatorSptr->Stop();
         if (errorCode == CAMERA_OK) {
             isSessionStarted_ = false;
         }
@@ -1546,28 +1005,6 @@ int32_t HCaptureSession::Stop()
     return errorCode;
 }
 
-void HCaptureSession::ReleaseStreams()
-{
-    CAMERA_SYNC_TRACE;
-    std::vector<int32_t> fwkStreamIds;
-    std::vector<int32_t> hdiStreamIds;
-    auto allStream = streamContainer_.GetAllStreams();
-    for (auto& stream : allStream) {
-        auto fwkStreamId = stream->GetFwkStreamId();
-        CHECK_EXECUTE(fwkStreamId != STREAM_ID_UNSET, fwkStreamIds.emplace_back(fwkStreamId));
-        auto hdiStreamId = stream->GetHdiStreamId();
-        CHECK_EXECUTE(hdiStreamId != STREAM_ID_UNSET, hdiStreamIds.emplace_back(hdiStreamId));
-        stream->ReleaseStream(true);
-    }
-    streamContainer_.Clear();
-    MEDIA_INFO_LOG("HCaptureSession::ReleaseStreams() streamIds size() = %{public}zu, fwkStreamIds:%{public}s, "
-                   "hdiStreamIds:%{public}s,",
-        fwkStreamIds.size(), Container2String(fwkStreamIds.begin(), fwkStreamIds.end()).c_str(),
-        Container2String(hdiStreamIds.begin(), hdiStreamIds.end()).c_str());
-    auto cameraDevice = GetCameraDevice();
-    CHECK_EXECUTE((cameraDevice != nullptr) && !hdiStreamIds.empty(), cameraDevice->ReleaseStreams(hdiStreamIds));
-}
-
 int32_t HCaptureSession::Release(CaptureSessionReleaseType type)
 {
     CAMERA_SYNC_TRACE;
@@ -1585,11 +1022,13 @@ int32_t HCaptureSession::Release(CaptureSessionReleaseType type)
             errorCode = CAMERA_INVALID_STATE;
             return;
         }
+        auto hStreamOperatorSptr = hStreamOperator_.promote();
+        CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr, "hStreamOperatorSptr is null");
         // stop movingPhoto
-        StopMovingPhoto();
+        hStreamOperatorSptr->StopMovingPhoto();
 
         // Clear outputs
-        ReleaseStreams();
+        hStreamOperatorSptr->ReleaseStreams();
 
         // Clear inputs
         auto cameraDevice = GetCameraDevice();
@@ -1597,29 +1036,10 @@ int32_t HCaptureSession::Release(CaptureSessionReleaseType type)
             cameraDevice->Release();
             SetCameraDevice(nullptr);
         }
-
-        // Clear current session
-        if (type != CaptureSessionReleaseType::RELEASE_TYPE_OBJ_DIED) {
-            HCameraSessionManager::GetInstance().RemoveSession(this);
-            MEDIA_DEBUG_LOG("HCaptureSession::Release clear pid left sessions(%{public}zu).",
-                HCameraSessionManager::GetInstance().GetTotalSessionSize());
-        }
-#ifdef CAMERA_USE_SENSOR
-        CHECK_EXECUTE(isSetMotionPhoto_, UnregisterSensorCallback());
-#endif
+        sptr<ICaptureSessionCallback> emptyCallback = nullptr;
+        SetCallback(emptyCallback);
         stateMachine_.Transfer(CaptureSessionState::SESSION_RELEASED);
         isSessionStarted_ = false;
-        if (displayListener_) {
-            OHOS::Rosen::DisplayManager::GetInstance().UnregisterDisplayListener(displayListener_);
-            displayListener_ = nullptr;
-        }
-        std::lock_guard<std::mutex> lock(movingPhotoStatusLock_);
-        livephotoListener_ = nullptr;
-        videoCache_ = nullptr;
-        if (taskManager_) {
-            taskManager_->ClearTaskResource();
-            taskManager_ = nullptr;
-        }
     });
     MEDIA_INFO_LOG("HCaptureSession::Release execute success");
     return errorCode;
@@ -1705,7 +1125,9 @@ void HCaptureSession::DumpSessionInfo(CameraInfoDumper& infoDumper)
 {
     infoDumper.Msg("Client pid:[" + std::to_string(pid_) + "]    Client uid:[" + std::to_string(uid_) + "]");
     infoDumper.Msg("session state:[" + GetSessionState() + "]");
-    for (auto& stream : streamContainer_.GetAllStreams()) {
+    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr, "hStreamOperatorSptr is null");
+    for (auto& stream : hStreamOperatorSptr->GetAllStreams()) {
         infoDumper.Push();
         stream->DumpStreamInfo(infoDumper);
         infoDumper.Pop();
@@ -1714,140 +1136,17 @@ void HCaptureSession::DumpSessionInfo(CameraInfoDumper& infoDumper)
 
 int32_t HCaptureSession::EnableMovingPhotoMirror(bool isMirror, bool isConfig)
 {
-    if (!isConfig) {
-        isMovingPhotoMirror_ = isMirror;
-        return CAMERA_OK;
-    }
-    if (!isSetMotionPhoto_ || isMirror == isMovingPhotoMirror_) {
-        return CAMERA_OK;
-    }
-    auto repeatStreams = streamContainer_.GetStreams(StreamType::REPEAT);
-    for (auto& stream : repeatStreams) {
-        if (stream == nullptr) {
-            continue;
-        }
-        auto streamRepeat = CastStream<HStreamRepeat>(stream);
-        if (streamRepeat->GetRepeatStreamType() == RepeatStreamType::LIVEPHOTO) {
-            MEDIA_INFO_LOG("restart movingphoto stream.");
-            if (streamRepeat->SetMirrorForLivePhoto(isMirror, opMode_)) {
-                isMovingPhotoMirror_ = isMirror;
-                // set clear cache flag
-                std::lock_guard<std::mutex> lock(movingPhotoStatusLock_);
-                livephotoListener_->SetClearFlag();
-            }
-            break;
-        }
-    }
+    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    CHECK_ERROR_RETURN_RET_LOG(hStreamOperatorSptr == nullptr, CAMERA_OK, "hStreamOperatorSptr is null");
+    hStreamOperatorSptr->EnableMovingPhotoMirror(isMirror, isConfig);
     return CAMERA_OK;
 }
 
 void HCaptureSession::GetOutputStatus(int32_t& status)
 {
-    auto repeatStreams = streamContainer_.GetStreams(StreamType::REPEAT);
-    for (auto& stream : repeatStreams) {
-        if (stream == nullptr) {
-            continue;
-        }
-        auto streamRepeat = CastStream<HStreamRepeat>(stream);
-        if (streamRepeat->GetRepeatStreamType() == RepeatStreamType::VIDEO) {
-            if (streamRepeat->GetPreparedCaptureId() != CAPTURE_ID_UNSET) {
-                const int32_t videoStartStatus = 2;
-                status = videoStartStatus;
-            }
-        }
-    }
-}
-
-#ifdef CAMERA_USE_SENSOR
-void HCaptureSession::RegisterSensorCallback()
-{
-    std::lock_guard<std::mutex> lock(sensorLock_);
-    if (isRegisterSensorSuccess_) {
-        MEDIA_INFO_LOG("HCaptureSession::RegisterSensorCallback isRegisterSensorSuccess return");
-        return;
-    }
-    MEDIA_INFO_LOG("HCaptureSession::RegisterSensorCallback start");
-    user.callback = GravityDataCallbackImpl;
-    int32_t subscribeRet = SubscribeSensor(SENSOR_TYPE_ID_GRAVITY, &user);
-    MEDIA_INFO_LOG("RegisterSensorCallback, subscribeRet: %{public}d", subscribeRet);
-    int32_t setBatchRet = SetBatch(SENSOR_TYPE_ID_GRAVITY, &user, POSTURE_INTERVAL, 0);
-    MEDIA_INFO_LOG("RegisterSensorCallback, setBatchRet: %{public}d", setBatchRet);
-    int32_t activateRet = ActivateSensor(SENSOR_TYPE_ID_GRAVITY, &user);
-    MEDIA_INFO_LOG("RegisterSensorCallback, activateRet: %{public}d", activateRet);
-    if (subscribeRet != CAMERA_OK || setBatchRet != CAMERA_OK || activateRet != CAMERA_OK) {
-        isRegisterSensorSuccess_ = false;
-        MEDIA_INFO_LOG("RegisterSensorCallback failed.");
-    } else {
-        isRegisterSensorSuccess_ = true;
-    }
-}
-
-void HCaptureSession::UnregisterSensorCallback()
-{
-    std::lock_guard<std::mutex> lock(sensorLock_);
-    int32_t deactivateRet = DeactivateSensor(SENSOR_TYPE_ID_GRAVITY, &user);
-    int32_t unsubscribeRet = UnsubscribeSensor(SENSOR_TYPE_ID_GRAVITY, &user);
-    if (deactivateRet == CAMERA_OK && unsubscribeRet == CAMERA_OK) {
-        MEDIA_INFO_LOG("HCameraService.UnregisterSensorCallback success.");
-        isRegisterSensorSuccess_ = false;
-    } else {
-        MEDIA_INFO_LOG("HCameraService.UnregisterSensorCallback failed.");
-    }
-}
-
-void HCaptureSession::GravityDataCallbackImpl(SensorEvent* event)
-{
-    MEDIA_INFO_LOG("GravityDataCallbackImpl prepare execute");
-    CHECK_ERROR_RETURN_LOG(event == nullptr, "SensorEvent is nullptr.");
-    CHECK_ERROR_RETURN_LOG(event[0].data == nullptr, "SensorEvent[0].data is nullptr.");
-    CHECK_ERROR_RETURN_LOG(event->sensorTypeId != SENSOR_TYPE_ID_GRAVITY, "SensorCallback error type.");
-    // this data will be delete when callback execute finish
-    GravityData* nowGravityData = reinterpret_cast<GravityData*>(event->data);
-    gravityData = { nowGravityData->x, nowGravityData->y, nowGravityData->z };
-    sensorRotation = CalcSensorRotation(CalcRotationDegree(gravityData));
-}
-
-int32_t HCaptureSession::CalcSensorRotation(int32_t sensorDegree)
-{
-    // Use ROTATION_0 when degree range is [0, 30]∪[330, 359]
-    if (sensorDegree >= 0 && (sensorDegree <= 30 || sensorDegree >= 330)) {
-        return STREAM_ROTATE_0;
-    } else if (sensorDegree >= 60 && sensorDegree <= 120) { // Use ROTATION_90 when degree range is [60, 120]
-        return STREAM_ROTATE_90;
-    } else if (sensorDegree >= 150 && sensorDegree <= 210) { // Use ROTATION_180 when degree range is [150, 210]
-        return STREAM_ROTATE_180;
-    } else if (sensorDegree >= 240 && sensorDegree <= 300) { // Use ROTATION_270 when degree range is [240, 300]
-        return STREAM_ROTATE_270;
-    } else {
-        return sensorRotation;
-    }
-}
-
-int32_t HCaptureSession::CalcRotationDegree(GravityData data)
-{
-    float x = data.x;
-    float y = data.y;
-    float z = data.z;
-    int degree = -1;
-    CHECK_ERROR_RETURN_RET((x * x + y * y) * VALID_INCLINATION_ANGLE_THRESHOLD_COEFFICIENT < z * z, degree);
-    // arccotx = pi / 2 - arctanx, 90 is used to calculate acot(in degree); degree = rad / pi * 180
-    degree = 90 - static_cast<int>(round(atan2(y, -x) / M_PI * 180));
-    // Normalize the degree to the range of 0~360
-    return degree >= 0 ? degree % 360 : degree % 360 + 360;
-}
-#endif
-
-void HCaptureSession::StartMovingPhotoEncode(int32_t rotation, uint64_t timestamp, int32_t format, int32_t captureId)
-{
-    CHECK_ERROR_RETURN(!isSetMotionPhoto_);
-    int32_t addMirrorRotation = 0;
-    MEDIA_INFO_LOG("sensorRotation is %{public}d", sensorRotation);
-    if ((sensorRotation == STREAM_ROTATE_0 || sensorRotation == STREAM_ROTATE_180) && isMovingPhotoMirror_) {
-        addMirrorRotation = STREAM_ROTATE_180;
-    }
-    int32_t realRotation = GetSensorOritation() + rotation + addMirrorRotation;
-    realRotation = realRotation % ROTATION_360;
-    StartRecord(timestamp, realRotation, captureId);
+    auto hStreamOperatorSptr = hStreamOperator_.promote();
+    CHECK_ERROR_RETURN_LOG(hStreamOperatorSptr == nullptr, "hStreamOperatorSptr is null");
+    hStreamOperatorSptr->GetOutputStatus(status);
 }
 
 std::string HCaptureSession::CreateDisplayName()
@@ -1906,237 +1205,6 @@ std::string HCaptureSession::CreateBurstDisplayName(int32_t imageSeqId, int32_t
     return formattedTime;
 }
 
-void HCaptureSession::SetCameraPhotoProxyInfo(
-    sptr<CameraServerPhotoProxy> cameraPhotoProxy, int32_t& cameraShotType, bool& isBursting, std::string& burstKey)
-{
-    cameraPhotoProxy->SetShootingMode(opMode_);
-    int32_t captureId = cameraPhotoProxy->GetCaptureId();
-    std::string imageId = cameraPhotoProxy->GetPhotoId();
-    isBursting = false;
-    bool isCoverPhoto = false;
-    int32_t invalidBurstSeqId = -1;
-    auto captureStreams = streamContainer_.GetStreams(StreamType::CAPTURE);
-    for (auto& stream : captureStreams) {
-        CHECK_WARNING_CONTINUE_LOG(stream == nullptr, "stream is null");
-        MEDIA_INFO_LOG("CreateMediaLibrary get captureStream");
-        auto streamCapture = CastStream<HStreamCapture>(stream);
-        isBursting = streamCapture->IsBurstCapture(captureId);
-        if (isBursting) {
-            burstKey = streamCapture->GetBurstKey(captureId);
-            streamCapture->SetBurstImages(captureId, imageId);
-            isCoverPhoto = streamCapture->IsBurstCover(captureId);
-            int32_t burstSeqId = cameraPhotoProxy->GetBurstSeqId();
-            int32_t imageSeqId = streamCapture->GetCurBurstSeq(captureId);
-            int32_t displaySeqId = (burstSeqId != invalidBurstSeqId) ? burstSeqId : imageSeqId;
-            cameraPhotoProxy->SetDisplayName(CreateBurstDisplayName(imageSeqId, displaySeqId));
-            streamCapture->CheckResetBurstKey(captureId);
-            MEDIA_INFO_LOG("isBursting burstKey:%{public}s isCoverPhoto:%{public}d", burstKey.c_str(), isCoverPhoto);
-            int32_t burstShotType = 3;
-            cameraShotType = burstShotType;
-            cameraPhotoProxy->SetBurstInfo(burstKey, isCoverPhoto);
-            break;
-        }
-        MEDIA_INFO_LOG("CreateMediaLibrary not Bursting");
-    }
-}
-
-int32_t HCaptureSession::CreateMediaLibrary(sptr<CameraPhotoProxy>& photoProxy, std::string& uri,
-    int32_t& cameraShotType, std::string& burstKey, int64_t timestamp)
-{
-    CAMERA_SYNC_TRACE;
-    constexpr int32_t movingPhotoShotType = 2;
-    constexpr int32_t imageShotType = 0;
-    cameraShotType = isSetMotionPhoto_ ? movingPhotoShotType : imageShotType;
-    MessageParcel data;
-    photoProxy->WriteToParcel(data);
-    photoProxy->CameraFreeBufferHandle();
-    sptr<CameraServerPhotoProxy> cameraPhotoProxy = new CameraServerPhotoProxy();
-    cameraPhotoProxy->ReadFromParcel(data);
-    cameraPhotoProxy->SetDisplayName(CreateDisplayName());
-    int32_t captureId = cameraPhotoProxy->GetCaptureId();
-    bool isBursting = false;
-    string pictureId = cameraPhotoProxy->GetTitle() + "." + cameraPhotoProxy->GetExtension();
-    CameraReportDfxUtils::GetInstance()->SetPictureId(captureId, pictureId);
-    CameraReportDfxUtils::GetInstance()->SetPrepareProxyEndInfo(captureId);
-    CameraReportDfxUtils::GetInstance()->SetAddProxyStartInfo(captureId);
-    SetCameraPhotoProxyInfo(cameraPhotoProxy, cameraShotType, isBursting, burstKey);
-    auto photoAssetProxy = PhotoAssetProxy::GetPhotoAssetProxy(cameraShotType, IPCSkeleton::GetCallingUid());
-    CHECK_ERROR_RETURN_RET_LOG(
-        photoAssetProxy == nullptr, CAMERA_ALLOC_ERROR, "HCaptureSession::CreateMediaLibrary get photoAssetProxy fail");
-    photoAssetProxy->AddPhotoProxy((sptr<PhotoProxy>&)cameraPhotoProxy);
-    uri = photoAssetProxy->GetPhotoAssetUri();
-    if (!isBursting && isSetMotionPhoto_ && taskManager_) {
-        MEDIA_INFO_LOG("taskManager setVideoFd start");
-        taskManager_->SetVideoFd(timestamp, photoAssetProxy, captureId);
-    } else {
-        photoAssetProxy.reset();
-    }
-    CameraReportDfxUtils::GetInstance()->SetAddProxyEndInfo(captureId);
-    return CAMERA_OK;
-}
-
-static std::unordered_map<std::string, float> exifOrientationDegree = {
-    { "Top-left", 0 },
-    { "Top-right", 90 },
-    { "Bottom-right", 180 },
-    { "Right-top", 90 },
-    { "Left-bottom", 270 },
-};
-
-inline float TransExifOrientationToDegree(const std::string& orientation)
-{
-    float degree = .0;
-    if (exifOrientationDegree.count(orientation)) {
-        degree = exifOrientationDegree[orientation];
-    }
-    return degree;
-}
-
-inline void RotatePixelMap(std::shared_ptr<Media::PixelMap> pixelMap, const std::string& exifOrientation)
-{
-    float degree = TransExifOrientationToDegree(exifOrientation);
-    if (pixelMap) {
-        MEDIA_INFO_LOG("RotatePicture degree is %{public}f", degree);
-        pixelMap->rotate(degree);
-    } else {
-        MEDIA_ERR_LOG("RotatePicture Failed pixelMap is nullptr");
-    }
-}
-
-std::string GetAndSetExifOrientation(OHOS::Media::ImageMetadata* exifData)
-{
-    std::string orientation = "";
-    if (exifData != nullptr) {
-        exifData->GetValue("Orientation", orientation);
-        std::string defalutExifOrientation = "1";
-        exifData->SetValue("Orientation", defalutExifOrientation);
-        MEDIA_INFO_LOG("GetExifOrientation orientation:%{public}s", orientation.c_str());
-        exifData->RemoveExifThumbnail();
-        MEDIA_INFO_LOG("RemoveExifThumbnail");
-    } else {
-        MEDIA_ERR_LOG("GetExifOrientation exifData is nullptr");
-    }
-    return orientation;
-}
-
-void RotatePicture(std::shared_ptr<Media::Picture> picture)
-{
-    CAMERA_SYNC_TRACE;
-    std::string orientation =
-        GetAndSetExifOrientation(reinterpret_cast<OHOS::Media::ImageMetadata*>(picture->GetExifMetadata().get()));
-    RotatePixelMap(picture->GetMainPixel(), orientation);
-    auto gainMap = picture->GetAuxiliaryPicture(Media::AuxiliaryPictureType::GAINMAP);
-    if (gainMap) {
-        RotatePixelMap(gainMap->GetContentPixel(), orientation);
-    }
-    auto depthMap = picture->GetAuxiliaryPicture(Media::AuxiliaryPictureType::DEPTH_MAP);
-    if (depthMap) {
-        RotatePixelMap(depthMap->GetContentPixel(), orientation);
-    }
-}
-
-std::shared_ptr<PhotoAssetIntf> HCaptureSession::ProcessPhotoProxy(int32_t captureId,
-    std::shared_ptr<Media::Picture> picturePtr, bool isBursting,
-    sptr<CameraServerPhotoProxy> cameraPhotoProxy, std::string &uri)
-{
-    CAMERA_SYNC_TRACE;
-    CHECK_ERROR_RETURN_RET_LOG(picturePtr == nullptr, nullptr, "picturePtr is null");
-    sptr<HStreamCapture> captureStream = nullptr;
-    for (auto& stream : streamContainer_.GetStreams(StreamType::CAPTURE)) {
-        captureStream = CastStream<HStreamCapture>(stream);
-        if (captureStream != nullptr) {
-            break;
-        }
-    }
-    CHECK_ERROR_RETURN_RET_LOG(captureStream == nullptr, nullptr, "stream is null");
-    std::shared_ptr<PhotoAssetIntf> photoAssetProxy = nullptr;
-    std::thread taskThread;
-    if (isBursting) {
-        int32_t cameraShotType = 3;
-        photoAssetProxy = PhotoAssetProxy::GetPhotoAssetProxy(cameraShotType, IPCSkeleton::GetCallingUid());
-    } else {
-        photoAssetProxy = captureStream->GetPhotoAssetInstance(captureId);
-    }
-    CHECK_ERROR_RETURN_RET_LOG(photoAssetProxy == nullptr, nullptr, "photoAssetProxy is null");
-    if (!isBursting && picturePtr) {
-        MEDIA_DEBUG_LOG("CreateMediaLibrary RotatePicture E");
-        taskThread = std::thread(RotatePicture, picturePtr);
-    }
-    bool isProfessionalPhoto = (opMode_ == static_cast<int32_t>(HDI::Camera::V1_3::OperationMode::PROFESSIONAL_PHOTO));
-    if (isBursting || captureStream->GetAddPhotoProxyEnabled() == false || isProfessionalPhoto) {
-        MEDIA_DEBUG_LOG("CreateMediaLibrary AddPhotoProxy E");
-        string pictureId = cameraPhotoProxy->GetTitle() + "." + cameraPhotoProxy->GetExtension();
-        CameraReportDfxUtils::GetInstance()->SetPictureId(captureId, pictureId);
-        photoAssetProxy->AddPhotoProxy((sptr<PhotoProxy>&)cameraPhotoProxy);
-        MEDIA_DEBUG_LOG("CreateMediaLibrary AddPhotoProxy X");
-    }
-    uri = photoAssetProxy->GetPhotoAssetUri();
-    if (!isBursting && taskThread.joinable()) {
-        taskThread.join();
-        MEDIA_DEBUG_LOG("CreateMediaLibrary RotatePicture X");
-    }
-    MEDIA_DEBUG_LOG("CreateMediaLibrary NotifyLowQualityImage E");
-    DeferredProcessing::DeferredProcessingService::GetInstance().NotifyLowQualityImage(
-        photoAssetProxy->GetUserId(), uri, picturePtr);
-    MEDIA_DEBUG_LOG("CreateMediaLibrary NotifyLowQualityImage X");
-    return photoAssetProxy;
-}
-
-void HCaptureSession::ConfigPayload(uint32_t pid, uint32_t tid, const char *bundleName, int32_t qosLevel,
-    std::unordered_map<std::string, std::string> &mapPayload)
-{
-    std::string strBundleName = bundleName;
-    std::string strPid = std::to_string(pid);
-    std::string strTid = std::to_string(tid);
-    std::string strQos = std::to_string(qosLevel);
-    mapPayload["pid"] = strPid;
-    mapPayload[strTid] = strQos;
-    mapPayload["bundleName"] = strBundleName;
-    MEDIA_INFO_LOG("mapPayload pid: %{public}s. tid: %{public}s. Qos: %{public}s",
-        strPid.c_str(), strTid.c_str(), strQos.c_str());
-}
-
-int32_t HCaptureSession::CreateMediaLibrary(std::unique_ptr<Media::Picture> picture, sptr<CameraPhotoProxy>& photoProxy,
-    std::string& uri, int32_t& cameraShotType, std::string& burstKey, int64_t timestamp)
-{
-    const int MAX_RETRIES = 7;
-    int32_t tempPid = getpid();
-    int32_t tempTid = gettid();
-    std::unordered_map<std::string, std::string> mapPayload;
-    ConfigPayload(tempPid, tempTid, "camera_service", MAX_RETRIES, mapPayload);
-    OHOS::ResourceSchedule::ResSchedClient::GetInstance().ReportData(
-        OHOS::ResourceSchedule::ResType::RES_TYPE_THREAD_QOS_CHANGE, 0, mapPayload);
-
-    constexpr int32_t movingPhotoShotType = 2;
-    constexpr int32_t imageShotType = 0;
-    cameraShotType = isSetMotionPhoto_ ? movingPhotoShotType : imageShotType;
-    MessageParcel data;
-    photoProxy->WriteToParcel(data);
-    photoProxy->CameraFreeBufferHandle();
-    sptr<CameraServerPhotoProxy> cameraPhotoProxy = new CameraServerPhotoProxy();
-    cameraPhotoProxy->ReadFromParcel(data);
-    cameraPhotoProxy->SetDisplayName(CreateDisplayName());
-    int32_t captureId = cameraPhotoProxy->GetCaptureId();
-    bool isBursting = false;
-    CameraReportDfxUtils::GetInstance()->SetPrepareProxyEndInfo(captureId);
-    CameraReportDfxUtils::GetInstance()->SetAddProxyStartInfo(captureId);
-    SetCameraPhotoProxyInfo(cameraPhotoProxy, cameraShotType, isBursting, burstKey);
-    std::shared_ptr<Media::Picture> picturePtr(picture.release());
-    std::shared_ptr<PhotoAssetIntf> photoAssetProxy =
-        HCaptureSession::ProcessPhotoProxy(captureId, picturePtr, isBursting, cameraPhotoProxy, uri);
-    CHECK_ERROR_RETURN_RET_LOG(photoAssetProxy == nullptr, CAMERA_INVALID_ARG, "photoAssetProxy is null");
-    if (!isBursting && isSetMotionPhoto_ && taskManager_) {
-        MEDIA_INFO_LOG("CreateMediaLibrary captureId :%{public}d", captureId);
-        if (taskManager_) {
-            taskManager_->SetVideoFd(timestamp, photoAssetProxy, captureId);
-        }
-    } else {
-        photoAssetProxy.reset();
-    }
-    CameraReportDfxUtils::GetInstance()->SetAddProxyEndInfo(captureId);
-    return CAMERA_OK;
-}
-
 int32_t HCaptureSession::SetFeatureMode(int32_t featureMode)
 {
     MEDIA_INFO_LOG("SetFeatureMode is called!");
@@ -2144,263 +1212,6 @@ int32_t HCaptureSession::SetFeatureMode(int32_t featureMode)
     return CAMERA_OK;
 }
 
-int32_t HCaptureSession::OnCaptureStarted(int32_t captureId, const std::vector<int32_t>& streamIds)
-{
-    MEDIA_INFO_LOG("HCaptureSession::OnCaptureStarted captureId:%{public}d, streamIds:%{public}s", captureId,
-        Container2String(streamIds.begin(), streamIds.end()).c_str());
-    std::lock_guard<std::mutex> lock(cbMutex_);
-    for (auto& streamId : streamIds) {
-        sptr<HStreamCommon> curStream = GetHdiStreamByStreamID(streamId);
-        if (curStream == nullptr) {
-            MEDIA_ERR_LOG("HCaptureSession::OnCaptureStarted StreamId: %{public}d not found", streamId);
-            return CAMERA_INVALID_ARG;
-        } else if (curStream->GetStreamType() == StreamType::REPEAT) {
-            CastStream<HStreamRepeat>(curStream)->OnFrameStarted();
-            CameraReportUtils::GetInstance().SetOpenCamPerfEndInfo();
-            CameraReportUtils::GetInstance().SetModeChangePerfEndInfo();
-            CameraReportUtils::GetInstance().SetSwitchCamPerfEndInfo();
-        } else if (curStream->GetStreamType() == StreamType::CAPTURE) {
-            CastStream<HStreamCapture>(curStream)->OnCaptureStarted(captureId);
-        }
-    }
-    return CAMERA_OK;
-}
-
-void HCaptureSession::StartRecord(uint64_t timestamp, int32_t rotation, int32_t captureId)
-{
-    if (isSetMotionPhoto_) {
-        taskManager_->SubmitTask(
-            [this, timestamp, rotation, captureId]() { this->StartOnceRecord(timestamp, rotation, captureId); });
-    }
-}
-
-SessionDrainImageCallback::SessionDrainImageCallback(std::vector<sptr<FrameRecord>>& frameCacheList,
-    wptr<MovingPhotoListener> listener, wptr<MovingPhotoVideoCache> cache, uint64_t timestamp, int32_t rotation,
-    int32_t captureId)
-    : frameCacheList_(frameCacheList), listener_(listener), videoCache_(cache), timestamp_(timestamp),
-      rotation_(rotation), captureId_(captureId)
-{}
-
-SessionDrainImageCallback::~SessionDrainImageCallback()
-{
-    MEDIA_INFO_LOG("~SessionDrainImageCallback enter");
-}
-
-void SessionDrainImageCallback::OnDrainImage(sptr<FrameRecord> frame)
-{
-    MEDIA_INFO_LOG("OnDrainImage enter");
-    {
-        std::lock_guard<std::mutex> lock(mutex_);
-        frameCacheList_.push_back(frame);
-    }
-    auto videoCache = videoCache_.promote();
-    if (frame->IsIdle() && videoCache) {
-        videoCache->CacheFrame(frame);
-    } else if (frame->IsFinishCache() && videoCache) {
-        videoCache->OnImageEncoded(frame, frame->IsEncoded());
-    } else if (frame->IsReadyConvert()) {
-        MEDIA_DEBUG_LOG("frame is ready convert");
-    } else {
-        MEDIA_INFO_LOG("videoCache and frame is not useful");
-    }
-}
-
-void SessionDrainImageCallback::OnDrainImageFinish(bool isFinished)
-{
-    MEDIA_INFO_LOG("OnDrainImageFinish enter");
-    auto videoCache = videoCache_.promote();
-    if (videoCache) {
-        videoCache_->GetFrameCachedResult(
-            frameCacheList_,
-            [videoCache](const std::vector<sptr<FrameRecord>>& frameRecords, uint64_t timestamp, int32_t rotation,
-                int32_t captureId) { videoCache->DoMuxerVideo(frameRecords, timestamp, rotation, captureId); },
-            timestamp_, rotation_, captureId_);
-    }
-    auto listener = listener_.promote();
-    CHECK_EXECUTE(listener && isFinished, listener->RemoveDrainImageManager(this));
-}
-
-void HCaptureSession::StartOnceRecord(uint64_t timestamp, int32_t rotation, int32_t captureId)
-{
-    MEDIA_INFO_LOG("StartOnceRecord enter");
-    // frameCacheList only used by now thread
-    std::lock_guard<std::mutex> lock(movingPhotoStatusLock_);
-    std::vector<sptr<FrameRecord>> frameCacheList;
-    sptr<SessionDrainImageCallback> imageCallback =
-        new SessionDrainImageCallback(frameCacheList, livephotoListener_, videoCache_, timestamp, rotation, captureId);
-    livephotoListener_->ClearCache(timestamp);
-    livephotoListener_->DrainOutImage(imageCallback);
-    MEDIA_INFO_LOG("StartOnceRecord end");
-}
-
-int32_t HCaptureSession::OnCaptureStarted_V1_2(
-    int32_t captureId, const std::vector<OHOS::HDI::Camera::V1_2::CaptureStartedInfo>& infos)
-{
-    MEDIA_INFO_LOG("HCaptureSession::OnCaptureStarted_V1_2 captureId:%{public}d", captureId);
-    std::lock_guard<std::mutex> lock(cbMutex_);
-    for (auto& captureInfo : infos) {
-        sptr<HStreamCommon> curStream = GetHdiStreamByStreamID(captureInfo.streamId_);
-        if (curStream == nullptr) {
-            MEDIA_ERR_LOG("HCaptureSession::OnCaptureStarted_V1_2 StreamId: %{public}d not found."
-                          " exposureTime: %{public}u",
-                captureInfo.streamId_, captureInfo.exposureTime_);
-            return CAMERA_INVALID_ARG;
-        } else if (curStream->GetStreamType() == StreamType::CAPTURE) {
-            MEDIA_DEBUG_LOG("HCaptureSession::OnCaptureStarted_V1_2 StreamId: %{public}d."
-                            " exposureTime: %{public}u",
-                captureInfo.streamId_, captureInfo.exposureTime_);
-            CastStream<HStreamCapture>(curStream)->OnCaptureStarted(captureId, captureInfo.exposureTime_);
-        }
-    }
-    return CAMERA_OK;
-}
-
-int32_t HCaptureSession::OnCaptureEnded(int32_t captureId, const std::vector<CaptureEndedInfo>& infos)
-{
-    MEDIA_INFO_LOG("HCaptureSession::OnCaptureEnded");
-    std::lock_guard<std::mutex> lock(cbMutex_);
-    for (auto& captureInfo : infos) {
-        sptr<HStreamCommon> curStream = GetHdiStreamByStreamID(captureInfo.streamId_);
-        if (curStream == nullptr) {
-            MEDIA_ERR_LOG("HCaptureSession::OnCaptureEnded StreamId: %{public}d not found."
-                          " Framecount: %{public}d",
-                captureInfo.streamId_, captureInfo.frameCount_);
-            return CAMERA_INVALID_ARG;
-        } else if (curStream->GetStreamType() == StreamType::REPEAT) {
-            CastStream<HStreamRepeat>(curStream)->OnFrameEnded(captureInfo.frameCount_);
-        } else if (curStream->GetStreamType() == StreamType::CAPTURE) {
-            CastStream<HStreamCapture>(curStream)->OnCaptureEnded(captureId, captureInfo.frameCount_);
-        }
-    }
-    return CAMERA_OK;
-}
-
-int32_t HCaptureSession::OnCaptureEndedExt(
-    int32_t captureId, const std::vector<OHOS::HDI::Camera::V1_3::CaptureEndedInfoExt>& infos)
-{
-    MEDIA_INFO_LOG("HCaptureSession::OnCaptureEndedExt captureId:%{public}d", captureId);
-    std::lock_guard<std::mutex> lock(cbMutex_);
-    for (auto& captureInfo : infos) {
-        sptr<HStreamCommon> curStream = GetHdiStreamByStreamID(captureInfo.streamId_);
-        if (curStream == nullptr) {
-            MEDIA_ERR_LOG("HCaptureSession::OnCaptureEndedExt StreamId: %{public}d not found."
-                          " Framecount: %{public}d",
-                captureInfo.streamId_, captureInfo.frameCount_);
-            return CAMERA_INVALID_ARG;
-        } else if (curStream->GetStreamType() == StreamType::REPEAT) {
-            CastStream<HStreamRepeat>(curStream)->OnFrameEnded(captureInfo.frameCount_);
-            CaptureEndedInfoExt extInfo;
-            extInfo.streamId = captureInfo.streamId_;
-            extInfo.frameCount = captureInfo.frameCount_;
-            extInfo.isDeferredVideoEnhancementAvailable = captureInfo.isDeferredVideoEnhancementAvailable_;
-            extInfo.videoId = captureInfo.videoId_;
-            MEDIA_INFO_LOG("HCaptureSession::OnCaptureEndedExt captureId:%{public}d videoId:%{public}s "
-                           "isDeferredVideo:%{public}d",
-                captureId, extInfo.videoId.c_str(), extInfo.isDeferredVideoEnhancementAvailable);
-            CastStream<HStreamRepeat>(curStream)->OnDeferredVideoEnhancementInfo(extInfo);
-        }
-    }
-    return CAMERA_OK;
-}
-
-int32_t HCaptureSession::OnCaptureError(int32_t captureId, const std::vector<CaptureErrorInfo>& infos)
-{
-    MEDIA_INFO_LOG("HCaptureSession::OnCaptureError");
-    std::lock_guard<std::mutex> lock(cbMutex_);
-    for (auto& errInfo : infos) {
-        sptr<HStreamCommon> curStream = GetHdiStreamByStreamID(errInfo.streamId_);
-        if (curStream == nullptr) {
-            MEDIA_ERR_LOG("HCaptureSession::OnCaptureError StreamId: %{public}d not found."
-                          " Error: %{public}d",
-                errInfo.streamId_, errInfo.error_);
-            return CAMERA_INVALID_ARG;
-        } else if (curStream->GetStreamType() == StreamType::REPEAT) {
-            CastStream<HStreamRepeat>(curStream)->OnFrameError(errInfo.error_);
-        } else if (curStream->GetStreamType() == StreamType::CAPTURE) {
-            auto captureStream = CastStream<HStreamCapture>(curStream);
-            captureStream->rotationMap_.Erase(captureId);
-            captureStream->OnCaptureError(captureId, errInfo.error_);
-        }
-    }
-    return CAMERA_OK;
-}
-
-int32_t HCaptureSession::OnFrameShutter(
-    int32_t captureId, const std::vector<int32_t>& streamIds, uint64_t timestamp)
-{
-    MEDIA_INFO_LOG("HCaptureSession::OnFrameShutter ts is:%{public}" PRIu64, timestamp);
-    std::lock_guard<std::mutex> lock(cbMutex_);
-    for (auto& streamId : streamIds) {
-        sptr<HStreamCommon> curStream = GetHdiStreamByStreamID(streamId);
-        if ((curStream != nullptr) && (curStream->GetStreamType() == StreamType::CAPTURE)) {
-            auto captureStream = CastStream<HStreamCapture>(curStream);
-            int32_t rotation = 0;
-            captureStream->rotationMap_.Find(captureId, rotation);
-            StartMovingPhotoEncode(rotation, timestamp, captureStream->format_, captureId);
-            captureStream->OnFrameShutter(captureId, timestamp);
-        } else {
-            MEDIA_ERR_LOG("HCaptureSession::OnFrameShutter StreamId: %{public}d not found", streamId);
-            return CAMERA_INVALID_ARG;
-        }
-    }
-    return CAMERA_OK;
-}
-
-int32_t HCaptureSession::OnFrameShutterEnd(
-    int32_t captureId, const std::vector<int32_t>& streamIds, uint64_t timestamp)
-{
-    MEDIA_INFO_LOG("HCaptureSession::OnFrameShutterEnd ts is:%{public}" PRIu64, timestamp);
-    std::lock_guard<std::mutex> lock(cbMutex_);
-    for (auto& streamId : streamIds) {
-        sptr<HStreamCommon> curStream = GetHdiStreamByStreamID(streamId);
-        if ((curStream != nullptr) && (curStream->GetStreamType() == StreamType::CAPTURE)) {
-            auto captureStream = CastStream<HStreamCapture>(curStream);
-            captureStream->rotationMap_.Erase(captureId);
-            captureStream->OnFrameShutterEnd(captureId, timestamp);
-        } else {
-            MEDIA_ERR_LOG("HCaptureSession::OnFrameShutterEnd StreamId: %{public}d not found", streamId);
-            return CAMERA_INVALID_ARG;
-        }
-    }
-    return CAMERA_OK;
-}
-
-int32_t HCaptureSession::OnCaptureReady(
-    int32_t captureId, const std::vector<int32_t>& streamIds, uint64_t timestamp)
-{
-    MEDIA_DEBUG_LOG("HCaptureSession::OnCaptureReady");
-    std::lock_guard<std::mutex> lock(cbMutex_);
-    for (auto& streamId : streamIds) {
-        sptr<HStreamCommon> curStream = GetHdiStreamByStreamID(streamId);
-        if ((curStream != nullptr) && (curStream->GetStreamType() == StreamType::CAPTURE)) {
-            CastStream<HStreamCapture>(curStream)->OnCaptureReady(captureId, timestamp);
-        } else {
-            MEDIA_ERR_LOG("HCaptureSession::OnCaptureReady StreamId: %{public}d not found", streamId);
-            return CAMERA_INVALID_ARG;
-        }
-    }
-    return CAMERA_OK;
-}
-
-int32_t HCaptureSession::OnResult(int32_t streamId, const std::vector<uint8_t>& result)
-{
-    MEDIA_DEBUG_LOG("HCaptureSession::OnResult");
-    sptr<HStreamCommon> curStream;
-    const int32_t metaStreamId = -1;
-    if (streamId == metaStreamId) {
-        curStream = GetStreamByStreamID(streamId);
-    } else {
-        curStream = GetHdiStreamByStreamID(streamId);
-    }
-    if ((curStream != nullptr) && (curStream->GetStreamType() == StreamType::METADATA)) {
-        CastStream<HStreamMetadata>(curStream)->OnMetaResult(streamId, result);
-    } else {
-        MEDIA_ERR_LOG("HCaptureSession::OnResult StreamId: %{public}d is null or not Not adapted", streamId);
-        return CAMERA_INVALID_ARG;
-    }
-    return CAMERA_OK;
-}
-
 StateMachine::StateMachine()
 {
     stateTransferMap_[static_cast<uint32_t>(CaptureSessionState::SESSION_INIT)] = {
@@ -2441,235 +1252,5 @@ bool StateMachine::Transfer(CaptureSessionState targetState)
     }
     return false;
 }
-
-bool StreamContainer::AddStream(sptr<HStreamCommon> stream)
-{
-    std::lock_guard<std::mutex> lock(streamsLock_);
-    auto& list = streams_[stream->GetStreamType()];
-    auto it = std::find_if(list.begin(), list.end(), [stream](auto item) { return item == stream; });
-    if (it == list.end()) {
-        list.emplace_back(stream);
-        return true;
-    }
-    return false;
-}
-
-bool StreamContainer::RemoveStream(sptr<HStreamCommon> stream)
-{
-    std::lock_guard<std::mutex> lock(streamsLock_);
-    auto& list = streams_[stream->GetStreamType()];
-    auto it = std::find_if(list.begin(), list.end(), [stream](auto item) { return item == stream; });
-    CHECK_ERROR_RETURN_RET(it == list.end(), false);
-    list.erase(it);
-    return true;
-}
-
-sptr<HStreamCommon> StreamContainer::GetStream(int32_t streamId)